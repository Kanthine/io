{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人简介 学无止境！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/计算机组成篇/计算机概述篇.html":{"url":"计算机基础/计算机组成篇/计算机概述篇.html","title":"计算机概述篇","keywords":"","body":"计算机原理之概述篇 1、计算机的发展简史 1.1、电子管计算机 (1946~1957) 集成度小，空间占用大； 功耗高，运行速度慢； 操作复杂，更换程序需要接线； 1.2、晶体管计算机 (1957~1964) 1948 年贝尔实验室发明了晶体管，此后晶体管为计算机带来了革命性的进步！ 集成度相对较高，空间占用相对较小； 功耗相对较低，运行速度较快； 操作相对简单，交互更加方便； 1.3、集成电路计算机 (1964~1980) 德州仪器的工程师发明了集成电路(IC)！ 计算机变得更小； 功耗变得更低； 计算速度更快； 1.4、超大规模集成电路计算机 (1980~现在) 一个电路集成了上百万的晶体管； 速度更快，体积更小，价格更低，更能被大众接受； 用途丰富：文本处理、表格处理、高交互的游戏与应用； 1.5、微型计算机的发展历史 微型计算机主要受限于性能； 单核 CPU 1971~1973 500KHZ 频率的微型计算机（字长 8 位）； 1973~1978 高于 1 MHZ 频率的微型计算机（字长 8 位）； 1978~1985 高于 500 MHZ 频率的微型计算机（字长 16 位）； 1985~2000 高于 1 GHZ 频率的微型计算机（字长 32 位）； 2000~现在 高于 2 GHZ 频率的微型计算机（字长 64 位）； 摩尔定律：微型计算机的发展历史，集成电路的性能，每 18 ~ 24 个月就会提升一倍！ 多核 CPU 2005 年 Intel 奔腾系列双核 CPU、 AMD 速龙系列； 2006 年 Intel 酷睿四核 CPU； 现在 Intel 酷睿系列十六核 CPU； Intel 至强系列五十六核 CPU； 2、计算机的分类 2.1、超级计算机 功能最强、运算速度最快、存储容量最大的计算机； 多用于国家高科技领域和尖端技术研究； 运算速度单位 TFlop/s : 1 TFlop/s = 每秒一万亿次浮点计算； 2.2、大型计算机 又称大型机、大型主机、主机等； 具有高性能、可处理大量数据与复杂的计算； 在大型机市场领域， IBM 占据很大的市场份额； 由于IOE高维护费用的存储系统、不够灵活、伸缩性弱，阿里巴巴在 2008 年提出了去 IOE 行动： I : IBM 服务器提供商 O : Oracle 数据库软件提供商 E : EMC 存储设备提供商 2.3、迷你计算机（服务器） 普通服务器已经替代了传统的大型机，成为大规模企业计算的中枢 又称小型机、普通服务器； 不需要特殊的空调场所； 具备不错的运算力、可以完成较复杂的运算； 2.4、工作站 高端的通用微型计算机，提供比个人计算机更强大的性能； 类似于普通台式电脑、体积较大、性能强劲 适用于图片工作者、视频工作者 2.5、 微型计算机 又称个人计算机，是最普通的一类计算机； 台式机、笔记本、一体机 iMac 麻雀虽小，五脏俱全 3、计算机的体系与构成 3.1、冯诺依曼体系 冯诺依曼体系 “将程序指令和数据一起存储的计算机设计概念结构” 早期计算机仅含固定用途，如果想要改变用途，需要改变程序更改结构、重新设计电路！ 冯诺依曼：存储程序指令，设计通用电路！ 现代计算机本质上都是冯诺依曼机，冯诺依曼体系的几个关键要素： 必须有一个存储器：存储运行的程序以及运行所需的数据； 必须有一个控制器：控制程序的流转； 必须有一个运算器：负责运算的操作； 必须有输入设备 必须有输出设备 冯诺依曼体系： 能够把需要的程序和数据送至计算机中 (输入设备：鼠标、键盘)； 能够长期记忆程序、数据、中间结果以及最终运算结果的能力，通过记忆才能进行下一步的操作 (存储器)； 能够具备算术、逻辑运算和数据传送等数据加工处理的能力 (运算器、控制器)； 能够按照要求将处理结果输出给用户 (输出设备：显示器、打印机)； 冯诺依曼瓶颈 CPU 和存储器速率之间的问题无法调和：CPU 的读写速率很快，而存储器的读写速率没有 CPU 快；导致 CPU 经常空转等待数据的传输！ 只有把 CPU 跑满，才是充分利用计算机的表现！ 3.2、现代计算机的结构 现代计算机在冯诺依曼体系结构基础上进行修改；解决 CPU 与储存设备之间的性能差异问题！ 存储器：磁带、硬盘；更高速的设备，内存，CPU 的寄存器！ 4、计算机的层次与编程语言 4.1、程序翻译与程序解释 计算机执行的指令都是 0 和 1 （L0 程序）； 程序翻译生成新的 L0 程序；程序解释不生成新的 L0 程序； 解释过程，由 L0 编写的解释器去解释 L1 程序； 翻译+解释语言：Java / C# ； 4.1.1、程序翻译 计算机的世界中，只有 0 与 1 两种表达；与人类的语言不相同，因此需要将人类语言翻译为计算机理解的程序语言！ 常见语言：C / C++ / Objective-C / Golang ！ 4.1.2、程序解释 常见语言：Python / PHP / JavaScript ！ 4.2、计算机的层次与编程语言 硬件逻辑层：门、触发器等逻辑电路组成；属于电子工程的领域； 微程序机器层：编程语言为 微指令集；微指令所组成的微程序直接交由硬件执行； 传统机器层：编程语言是 CPU 指令集；编程语言直接和硬件相关；不同架构的 CPU 使用不同的指令集；指令集存储在 CPU 内部； 操作系统层：向上为用户提供了简易的操作界面；向下对接指令系统，管理硬件资源；是在软件和硬件之间的适配层； 汇编语言层：汇编语言可以翻译为直接执行的机器语言；完成翻译过程的程序就是汇编器； 高级语言层：C / C++ / Objective-C / Python / PHP / Java / JavaScript / Golang 等； 应用层：满足计算机针对某种用途而专门设计的程序； 5、计算机的计算单位 5.1、容量单位 比特位 bit：在物理层面，高低电平 0 / 1 记录信息； 字节 Byte ：1 Byte = 8 bits ; 千字节 KB : 1 KB = 1024 Byte ; 常用于 CPU 的寄存器； 兆字节 MB : 1 MB = 1024 KB ; 常用于高效缓存 吉字节 GB : 1 GB = 1024 MB ; 常用于内存/硬盘； 太字节 TB : 1 TB = 1024 GB ; 常用于硬盘； 拍字节 PB : 1 PB = 1024 TB ; 常用于云硬盘； 艾字节 EB : 1 EB = 1024 PB ; 常用于数据仓库； 疑问：为什么网上买的移动硬盘 500 G，格式化之后只剩下 465 G 了？ 答案：因为硬盘商的换算单位为 1000，而计算机的换算单位为 1024 ! 5.2、速度单位 5.2.1、网络速度 疑问：为什么电信拉的 100 M 光纤，测试峰值速度只有 12 M 每秒？ 答案：网络速度单位为 Mbps ，即电信拉的 100 Mbps 光纤 ！ 100 M/s = 100 Mbps = 100 Mbit/s = 100 / 8 MB/S = 12.5 M/S ! 5.2.2、CPU 频率 CPU 的速度一般体现为 CPU 的时钟频率； CPU 的时钟频率单位一般为赫兹 HZ ； 赫兹 HZ 就是秒分之一，它是每秒钟的周期性变动重复次数的计量； 主流 CPU 的时钟频率都在 2 GHZ 以上; 2 GHZ = 2 * 1000^3 HZ = 20 亿次/秒 ! 6、计算机的字符与编码集 6.1、字符编码集的历史 ASCII 码：使用 7 个比特位就可以完全表示 ASCII 码 ；包含 95 个可打印字符与33 个不可打印字符（控制字符）！ ASCII 码在很多应用和国家的符号都无法表示；如数学符号 等！ 扩展的ASCII 码，使用 8 个比特位表示，包含数学符号 等！ 字符编码集的国际化： 各个国家的语言多样性； 语言体系不一样，不以有限字符组合的语言； 中、日、韩等的语言最为复杂； 6.2、中文编码集 GB 2312 ： 收录了 6763 个汉字和 682 个其它字符 ，总计 7445 个字符； GBK ： 向下兼容GB 2312，向上支持国际标准 ISO ; 收录了 21003 个汉字，支持全部中日韩汉字 Unicode : 兼容全球的字符集，定义了世界通用的字符集！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/计算机组成篇/计算机组成篇.html":{"url":"计算机基础/计算机组成篇/计算机组成篇.html","title":"计算机组成篇","keywords":"","body":"计算机原理之组成篇 1、计算机的总线 1.1、总线的概述 1.1.1、总线是什么？有什么用？ 计算机的总线就像是计算机的 “高速公路”，是为了解决不同设备间的通信而存在的！ 总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。总线标准有利于各模块高效使用总线。如 USB、PCIe 等。 1.1.2、总线的分类 总线分为片内总线与系统总线！ 片内总线：芯片内部的总线，高集成度芯片内部的信息传输线；可以连接寄存器与寄存器；可以连接寄存器与控制器、运算器； 系统总线：分为数据总线、地址总线、控制总线等；是 CPU 、主内存、IO 设备、各组件之间的信息传输线； 1.2、总线的仲裁 为了解决不同设备使用总线的优先顺序的设备； 为了解决总线使用权的冲突问题，有三种仲裁方法： 1.2.1、链式查询 假设设备 2 需要使用总线： 那么设备 2 通过仲裁控制线向仲裁控制器发出“使用总线”的请求； 仲裁控制器收到请求后发出允许使用的的信号； 该信号通过链式查询的方式会先进入设备 1 ； 如果设备 1 不需要使用，那么该信号会来到设备 2 ，设备 2 拿到信号后就可以使用总线； 假设设备 1、设备 2 同时发出使用总线的请求：那么设备 1 将优先拿到总线的使用权； 1.2.2、计时器定时查询 仲裁控制器分别与设备1、设备2、设备3 连接；仲裁控制器有一个计数器，比如值为 1； 假设设备 2 需要使用总线，将通过仲裁控制线向仲裁控制器发出请求； 仲裁控制器会将当前的计数器值 1 发送给所有的设备； 设备 1 实际没有发出请求信号，所以仲裁控制器发出的计数器值 1 无用； 此时仲裁控制器会发出信号 2，此时设备 2 可以获得总线使用权； 2、计算机的输入与输出设备 2.1、常见的输入输出设备 2.2、输入输出接口的通用设计 2.3、CPU 与 IO 设备的通信 程序中断 在某一时刻，CPU 在执行主程序，打印机处于待机状态； 接着 CPU 发出了一个启动打印机的信号，发出信号后 CPU 继续执行主程序； 打印机在收到 启动 信号后，做一些准备工作来启动，准备工作完成后打印机向 CPU 发送一个中断信号； CPU 收到中断信号后，会响应中断信号（不是立即中断，可能延迟） 接着 CPU 发送数据给打印机，打印机接收数据； CPU 发送完数据，会 中断返回，继续执行中断前执行的主程序；同时打印机也会开始打印数据； DMA （直接内存存取） DMA (Direct Memory Access) ： 直接内存存取； 对于 主存 与 IO 设备 并没有直接的连接；而是通过 DMA 设备连接； 当主存与 IO 设备交换信息时，不需要中断 CPU ； DMA 可以处理主存与 IO 设备交换信息的操作； IO 设备不用打断 CPU 的工作，因此 DMA 可以提高 CPU 的效率； 比较：程序中断和 DMA 都是计算机 IO 和低速设备的交互方式，程序中断方式实现简单，DMA 方式效率更高。 3、存储器 常见的存储器有以下几种： 主存：主存储器，即常说的计算机内存条， 辅存：辅助存储器，即常说的磁盘、U 盘、光盘、磁带等， Cache（高速缓存）：即常说的 L1、L2、L3 缓存，CPU 寄存器等，一般位于 CPU 上 ！ RAM：随机存取存储器（Random Access Memory） ROM：只读存储器（Read Only Memory） 3.1、存储器的层次结构 存储器的层次结构可以简单划分为：缓存 - 主存 - 辅存 三个层次，缓存 - 主存 主要是为了解决主存速度不够的问题；主存 - 辅存 主要是为了解决主存容量不足的问题。 3.1.1、缓存-主存 的层次 原理：局部性原理，指 CPU 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的区域中； 实现：在 CPU 与主存之间增加一层速度快容量小的 Cache ； 目的：解决 CPU 与主存速度不匹配的问题！ 3.1.2、主存-辅存 的层次： 原理：局部性原理； 实现：在主存之外增加辅助存储器（磁盘、SD 卡、 U盘等） 目的： 为了解决主存容量不足的问题； 例子：针对 8G 的Mac 与 10 多G 的 Xcode，Xcode 是如何运行到仅仅 8 G 的内存的？由于局部性原理，可以将一些必要数据加载到内存中，对于不使用的数据放到辅存中！ 3.2、计算机的主存储器 主存储器 -> 内存 随机存取存储器 RAM （Random Access Memory） RAM 通过电容存储数据，必须隔一段时间刷新一次，刷新需要有电的存在； 如果掉电，那么一段时间后不能刷新，电容中的电子将丢失，即丢失所有数据； 3.2.1、主存储器如何与 CPU 的交互？ CPU 中的主存数据寄存器 MDR 通过数据总线与主存储器中的读写电路交互； CPU 中的主存地址寄存器 MAR 通过地址总线与内存连接； 因为数据总线与地址总线的存在，CPU 可以通过地址总线指定数据的位置，同时通过数据总线传输相关的数据； 3.2.2、主存储器与操作系统的位数有关系 主存储器与操作系统位数有一定的关系，不同的操作系统对内存的支持是不同的： 32 位系统：最多支持 4 GB 的内存（2^32 = 4 * 2^30 = 4 GB）；在 32 位系统中加装更多的内存也是无用的，因为它的地址总线只有 32 位，寻址范围只有 4 GB 的大小； 64 位系统：最多支持 2^34 GB 的内存（2^64 = 2^34 * 2^30 = 2^34 GB）；在 64 位系统中地址总线有 64 位，寻址范围有 2^34 GB 大小； 3.3、计算机的辅助存储器 - 磁盘 磁盘表面是可磁化的硬磁特性材料，通过移动磁头径向运动读取磁道信息！ 磁盘由两部分组成： 光滑的盘片：使用磁材料存储数据； 磁头（悬臂）：通过左右移动来读取特定地址的信息 磁头位置：当前磁头位于哪一个磁道； 磁头方向：磁头向里走或者向外走； 3.3.1、磁盘的调度算法 为方便计算，将最外层的磁道称为第 1 磁道，最里面的磁道称为第 n 磁道。 假设磁头位于磁道4，磁头方向由里向外，现在需要读取磁道 1、4、2、3、1、5 ！ 先来先服务算法：磁头的移动痕迹 4 -> 1 -> 4 -> 2 -> 3 -> 1 -> 5 ！ 最短寻道时间优先算法：磁头的移动痕迹 4 -> 5 -> 3 -> 2 -> 1 -> 1 ！ 扫描算法（电梯算法）：磁头的移动痕迹 4 -> 3 -> 2 -> 1 -> 1 -> 5 ！ 循环扫描算法 ：磁头的移动痕迹 4 -> 5 -> 1 -> 1 -> 2 -> 3 ！ 3.4、高速缓存的工作原理 3.4.1、字与字块 基本概念： 字：是指存放在一个存储单元中的二进制代码组合；是存储单元的最小单位；一个字可以表示一个数据、一个指令、 一个字符串； 字块：存储在 连续 的存储单元中而被看作是一个单元的 一组 字；字块包含了多个字 ！ 字的寻址 字的地址包括两个部分，分别由字块的部分（用来指示当前需要寻址的字是属于哪一个字块的 ）以及字的部分（用来寻找字块中哪一个字是这个地址所指定的字 ）组成！ demo 假设主存空间为 4 G，字块大小为 4 M，字长位 32 位，则对于字地址中的地址块 m 和块内地址 b 的位数，至少应该是多少？ 4 G = 4096 M; 字块数：4096 / 4 = 1024 /// 至少需要 10 位来表示 1024 个字块 字块地址 m ：log2(1024) = 10 /// 每个字块内有 1048576 个字 块内字数： 4 M / 32 bits = 1048576 /// 至少需要 20 的块内地址来表示块内所有的字 块内地址 b ： log2(1048576) = 20 因此：m >= 10 ; b >= 20; 3.4.2、高速缓存 主存的容量远远大于缓存的容量（主存的字块数远大于缓存的字块数）； 缓存存取的数据是对主存的某块数据的复制（缓存中的数据来自于主存）； 缓存是如何在 缓存-主存 的层次中工作的呢？ CPU 需要高速缓存有两种情况： CPU 需要的数据在缓存中，CPU 直接高效快速的从高速缓存中拿到数据； CPU 需要的数据不在缓存中；CPU 从主存中拿数据； 高速缓存的读取速度比主存快很多，CPU 从主存拿数据，大大降低了 CPU 的效率；因此需要 CPU 尽可能的从高速缓存中读取数据，而非主存中取数据！此时需要一个量化的指标来量化 CPU 从高速缓存中取数据成功的机率（缓存命中率）！ 缓存命中率是衡量缓存的重要性能指标；理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1（实际上永远不可能位 1）！ 假设访问主存 m 次，访问缓存 n 次，那么缓存命中率就是 h = n / (m + n) 假设访问主存时间为 Tm，访问缓存时间为 Tc，则访问 缓存-主存 系统的平均时间为 Ta = h * Tc + (1 - h) * Tm！那么访问效率 e = Tc / Ta = Tc / ( h * Tc + (1 - h) * Tm) ！ demo 假设 CPU 在执行某段程序时，共访问了Cache 命中了 2000 次，访问主存 50 次，已知缓存的存取时间为 50 ns，主存的存取时间为 200 ns，求 缓存-主存 系统的命中率、访问效率和平均访问时间？ 缓存命中率 h = 2000 / (2000 + 50) = 0.97; 平均访问时间 Ta= 0.97 * 50 + (1 - 0.97) * 200 = 54.5 ns; 访问效率 e = 50 / 54.5 = 91.7% ; 3.5、高速缓存的替换策略 为了使 CPU 的运行效率更高，需要缓存命中率越高越好，让 CPU 在每一次取数据时，都能从高速缓存中取数据，而不是从主存中取数据！此时我们需要一个良好的缓存替换策略，使得缓存中的数据都是 CPU 需要的数据！ 替换时机：当 CPU 需要的数据不在高速缓存中时，需要从主存中载入所需的数据，然后替换到高速缓存中！ 假设缓存 4 个字块，() 表示使用的字块，[] 表示淘汰的字块 最近最少使用算法（LRU） (1) 1 (2) 2、1 (4) 4、2、1 (7) 7、4、2、1 (5) 5、7、4、2 [1] (4) 4、5、7、2 (6) 6、4、5、7 [2] 4、计算机的指令系统 4.1、机器指令的形式 机器指令主要由 操作码、地址码 两部分组成；分为三地址指令、二地址指令和一地址指令！ 操作码：指明指令所要完成的操作；操作码的位数反映了机器的操作种类，比如操作码有 8 位，则有 2^8 = 256 种操作！ 地址码：直接给出操作数或者操作数的地址；因为机器指令本质上还是对数据进行操作，所以地址码实际上还是指定数据或者数据的地址，使得 CPU 能够根据数据或者数据的地址进行运算； /// 三地址指令 操作码OP | addr1 | addr2 | addr3 (addr1)OP(addr2) -> (addr3) 如加法操作 (1)+(2) -> (3) /// 二地址指令 操作码OP | addr1 | addr2 (addr1)OP(addr2) -> (addr1)或者(addr2) /// 把结果放到 addr1 或者 addr2 /// 一地址指令 操作码OP | addr1 (addr1)OP -> (addr1) /// 把结果放到 addr1 ，如自己对自己的操作 (addr1)OP(ACC) -> (addr1) /// 把结果放到 addr1 零地址指令，在机器指令中无地址码，空操作、停机操作、中断返回操作等！ 4.2、机器指令的操作类型 4.3、机器指令的寻址方式 顺序寻址：执行 101 指令、102 指令、103 指令、104 指令、105 指令； 跳跃寻址：105 指令指向102 指令，因此跳跃到 102 指令！ 数据寻址方式 优先 缺点 立即寻址 速度快（从机器指令直接拿到数据） 地址码位数 限制操作数表示范围 （数据存放在地址码中） 直接寻址 寻找操作数简单 地址码位数 限制操作数表示范围 间接寻址 操作数寻址范围大 速度较慢 5、计算机的控制器 计算机的控制器用于协调和控制计算机运行！ 程序计数器：用于存储下一条指令的地址；当 CPU 工作时程序计数器会循环不断的从计数器中拿出指令；当拿出一条指令后，会指向下一条指令；程序计数器 主要提供给其它控制单元当前指令执行的地址！ 时序发生器：属于电气工程领域，用于发送时序 脉冲，CPU 依据不同的时序脉冲有节奏的进行工作！ 指令译码器：是控制器的重要部件之一，计算机指令由操作码与地址码组成，指令译码器会将操作码翻译为对应的操作数据、将地址码翻译为控制传输地址对应的数据！ 指令寄存器：是 CPU 高效运转的重要部件之一，用于缓存从主存或者高速缓存取下来的计算机指令；当 CPU 需要执行相关指令时，就可以从指令寄存器取出相关的指令，而不需要从主存或者高速缓存去取！ 主存地址寄存器：保存当前 CPU 正要访问的内存单元的地址，通过地址总线与主存通信的！ 主存数据寄存器：保存当前 CPU 正要读、正要写的主存数据，通过数据总线与主存通信的！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 6、计算机的运算器 计算机的运算器主要用于数据的运算加工！ 数据缓冲器：分为 输入缓冲 与 输出缓冲；输入缓冲 用于暂时存放外设传送来的数据，如果 ALU 正在运算则下一个运算数据保存在该缓冲中； 输出缓冲 暂时存放往外设的数据，当数据运算完毕从 ALU 输出时保存在输出缓冲中、等待控制器下一步的命令将数据送到相应位置！ ALU（算数逻辑单元）：是运算器的主要组成，可以完成常见的位运算（左移、右移、或、与、非等），可以完成一些算术运算（加、减、乘、除等）！ 状态字寄存器：用于存放运算中的状态（条件码、进位、溢出、结果正负等）；存放运算控制信息（调试跟踪标记位、允许中断位等）！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 7、计算机指令的执行过程 7.1、指令的执行过程 指令执行的一般操作 : 取指令 -> 分析指令 -> 执行指令 ! 取指令：从指令缓存中取指令，送到指令寄存器； 分析指令：将指令从指令寄存器取出，送到指令译码器译码；指令译码器发送控制信号，同时程序计数器 +1； 执行指令：首先将数据装载到寄存器，接着ALU 处理数据，记录运算状态，最后送出运算结果！ 指令执行中涉及的设备：数据缓冲器、指令缓冲器、运算器（通用寄存器、数据寄存器、状态字寄存器）、程序计数器、指令译码器、时序发生器、指令寄存器； 运算器部分、控制器部分、高速缓存部分，通过片内总线连接起来； 执行指令时，首先发生数据缓存与指令缓存；将数据与指令缓存到 CPU 的高速缓存中； 接着程序计数器根据指令地址 101，程序计数器只知道指令的地址而不知道指令的具体内容，需要通过总线来到指令缓存中获取指令 MOV R0,R1； 通过片内总线来到指令寄存器，指令寄存器缓存具体内容 MOV R0,R1； 指令寄存器不知道相关内容，还需要将指令发送到指令译码器；同时程序计数器 +1 (102)； 指令译码器将指令译码，译码完成后理解指令的具体内容 (将 R0 的数据移到 R1 中)；指令译码器发出控制信号； 控制信号通过片内总线来到运算器，运算器通过控制信号知道自己要干什么； 运算器首先将 R0(100) 加载到 ALU 中，接着将 R0(100) 通过总线送到数据缓存器； 数据缓存器会将 R0(100) 覆盖到 R1，此时 R1 的数据为 R1(100)！ 完成该条指令后，CPU 又去执行下条指令！ 疑问：在上述 取指令 与 分析指令 的过程中，是由控制器工作的；执行指令时，由运算器工作！也就是说，运算器与控制器不能同时工作，这就导致 CPU 的综合利用率并不高 ！因此需要改进指令执行过程，提高CPU 的综合利用率！ 7.2、CPU 的流水线设计 CPU 的流水线设计类似于工厂的装配线，多个厂品可以同时被加工；在同一时刻，不同产品位于不同的加工阶段！ 每一个时间片，都有一条或多条指令在执行； 如对于第 2 个时间片，第1条指令在分析，第 2 条指令在取指令； CPU 的流水线设计大大提升了CPU 的综合利用率！ 假设取指令、分析指令、执行指令的时间开销都是 t： 串行执行 m 条指令： T1 = 3t * m ； 流水线执行 m 条指令： T2 = t * (m + 2) ； 流水线执行的效率 H = T2 / T1 = (t * (m + 2)) / (3t * m) ； 当 m 很大时 流水线执行效率是串行执行 的 3 倍！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/计算机组成篇/计算机计算篇.html":{"url":"计算机基础/计算机组成篇/计算机计算篇.html","title":"计算机计算篇","keywords":"","body":"计算机原理之计算篇 1、进制运算的基础 1.1、进制运算概述 1024 = 0b1000000000 (0b 表示二进制) = 0o2000 (0o 表示八进制) = 0x400 (0x 表示十六进制) 1.2、二进制运算的基础 整数进制转换 /// 整数二进制转十进制：按权展开法 N = 01100101 = 1 * 2^6 + 1 * 2^5 + 1 * 2^2 + 1 = 101 N = 11101101 = 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^3 + 1 * 2^2 + 1 = 237 /// 整数十进制转二进制：重复相除法 (01100101)(从下向上) 101 / 2 = 50 ··· 1 50 / 2 = 25 ··· 0 25 / 2 = 12 ··· 1 12 / 2 = 6 ··· 0 6 / 2 = 3 ··· 0 3 / 2 = 1 ··· 1 1 / 2 = 0 ··· 1 浮点数进制转换 /// 浮点数二进制转十进制：按权展开法 N = 0.11001 = 1 * 2^-1 + 1 * 2^-2 + 1 * 2^-5 = 0.78125 N = 0.01011 = 1 * 2^-2 + 1 * 2^-4 + 1 * 2^-5 = 0.34375 /// 浮点数十进制转二进制：重复相乘法（0.11001）(从上向下) 25/32 = 50/32 = 1 + 9/16 取 1 9/16 = 18/16 = 1 + 1/8 取 1 1/8 = 1/4 = 0 + 1/4 取 0 1/4 = 1/2 = 0 + 1/2 取 0 1/2 = 1/1 = 1 + 0 取 1 1.3、有符号数与无符号数 1.3.1、原码表示法 如何判断是数字位还是符号位？ 原码表示法 使用 0 表示正数，使用 1 表示负数，规定符号位位于数值第一位；表达简单明了，是人类最容易理解的表示法！ 在原码表示法之下，0 有两种结果：正 0 00 与负0 10 ！除此之外，原码表示法进行运算也非常复杂，特别是两个操作数符号不同的时候！ 1.3.2、补码表示法 补码表示法：使用正数代替负数！但仍然没有实现 使用加法操作代替减法操作 的预期！ /// n = 4, x = 13； 计算 x 的二进制原码和补码 原码 x = 0 1101 补码 x = 0 1101 /// y = -13； 计算 y 的二进制原码和补码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 1.3.3、反码表示法 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 反码 2^(n+1) - 1 + y = 2^(4 + 1) - 1 - 13 = 011111 - 1101 = 10010 反码 y = 1 0010 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 反码 2^(n+1)-1 + z = 2^(4 + 1) - 1 - 7 = 011111 - 0111 = 11000 反码 z = 1 1000 十进制 原码 补码 反码 13 0 1101 0 1101 0 1101 -13 1 1101 1 0011 1 0010 -7 1 0111 1 1001 1 1000 -1 1 0001 1 1111 1 1110 负数的反码等于原码（除符号位）按位取反 ！ 负数的补码等于其反码 + 1 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 反码 y = 1 0010 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码、补码、反码 原码 z = 1 0111 反码 z = 1 1000 补码 z = 1 1001 1.3.4、小数的补码 /// n = 4, x = 9/16； 计算 x 的二进制原码、补码、反码 原码 x = 0 0.1001 (重复相乘法) 反码 x = 0 0.1001 补码 x = 0 0.1001 /// y = -11/32； 计算 y 的二进制原码、补码、反码 原码 y = 1 0.01011 (重复相乘法) 反码 y = 1 1.10100 补码 y = 1 1.10101 2、定点数与浮点数 2.1、定点数的表示方法 小数点固定在某个位置的数称为定点数！ 数值 符号位 数值位 0.1011 0 1011 -0.1011 1 1011 1011 0 1011 -1011 1 1011 2.2、浮点数的表示方法 计算机处理的很大程度上不是纯小数或纯正数；数据范围很大，定点数难以表达；此时需要使用浮点数来表示！ 2.2.1、浮点数的表示格式 科学计数法 1 2345 0000 = 1.2345 * 10^8 /// 尾数 1.2345 /// 基数 10 /// 阶码 8 /// 科学计数法要求尾数的绝对值范围在 [1,10) 之间 浮点数在计算机存储中分为 4 个部分 (规格要求： 尾数使用纯小数，且尾数最高位必须是 1 ) ！ 浮点数的表示格式 N = S * r^j 11.0101 = 0.110101 * 2^10 11.0101 = 0.0110101 * 2^11 ///不符合要求：尾数最高位不是 1 11.0101 = 1.10101 * 2^1 /// 不符合要求：尾数不是纯小数 阶码符号位 阶码数值位 尾数符号位 尾数数值位（8位） 0 10 0 11010100 2.2.2、浮点数的表示范围 假设阶码数值取 m 位，尾数数值取 n 位，N = S * r^j ！ 阶码能够表示的最大值：2^m - 1 ；考虑有符号时 [-(2^m - 1), 2^m - 1] 尾数能够表示的最大值：1 - 2^-n；尾数全是 1 的时候是最大值； 尾数能够表示的最小值：2^-n；尾数全是 0 （除了最后一位是 1） 的时候是最小值； 尾数表示范围：[2^-n, 1 - 2^-n]；考虑有符号时[-(1 - 2^-n),-2^-n]， [2^-n, 1 - 2^-n]； 超出浮点数的表示，有可能导致数据溢出： 上溢：绝对值太大，导致没有办法表示这么大的数； 下溢：绝对值太小，导致没有办法表示这么小的数； 单精度浮点数 float ：使用 4 个字节 (32 位) 来表示浮点数; 双精度浮点数 double：使用 8 个字节 (64 位) 来表示浮点数; Demo 1 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 13/128 表示为二进制浮点数 原码=反码=补码 x = 0.0001101000 (重复相乘法) 浮点数规格化 x = 0.1101000 * 2^-11 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 1 0011 0 1101000000 Demo 2 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 -54 表示为二进制浮点数 原码 x = 1 110110 (重复相除法) 浮点数规格化 x = -0.110110 * 2^110 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 0 0110 1 0010100000 2.3、定点数与浮点数的对比 当定点数与浮点数位数相同时，浮点数表示的范围更大； 当浮点数的尾数为规格化的小数时，浮点数的精度更高； 浮点数的运算包含阶码和尾数，浮点数的运算更为复杂； 浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数； 浮点数在数的运算规则、运算速度、硬件成本等方面不如定点数； 2.4、定点数的加法与减法 2.4.1、定点数的加法计算 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 ： 整数加法： A[补] + B[补] = [A + B][补](mod2^(n+1)) 小数加法： A[补] + B[补] = [A + B][补](mod2) /// 例1： A = -110010, B = 001101, 求 A + B A[反] = 1 001101 A[补] = 1 001110 B[反] = 0 001101 B[补] = 0 001101 [A + B][补] = 1 011011 [A + B][反] = 1 011010 A + B = -100101 /// 例2： A = -0.1010010, B = 0.0110100, 求 A + B A[反] = 1 1.0101101 A[补] = 1 1.0101110 B[反] = 0 0.0110100 B[补] = 0 0.0110100 [A + B][补] = 1 1.1100010 [A + B][反] = 1 1.1100001 A + B = -0.0011110 /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 10100000 B[补] = 1 10110000 [A + B][补] = 1 00100000 [A + B][反] = 1 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 00100000 B[补] = 1 00110000 [A + B][补] = 0 10100000 [A + B][反] = 0 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 判断溢出的方法： 双符号位判断法：单符号位表示成双符号位，运算时双符号位产生的进位丢弃；如果结果的双符号位不同，则表示溢出！ /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 10100000 B[补] = 11 10110000 [A + B][补] = 11 00100000 [A + B][反] = 11 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 00100000 B[补] = 11 00110000 [A + B][补] = 10 10100000 [A + B][反] = 10 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 2.4.2、定点数的减法计算 将减法转为上述的加法操作： 整数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2^(n+1)) 小数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2) (-B)[补] 等于 B[补] 连同符号位按位取反，末位加一！ B[补] = 10010101 (-B)[补] = 01101011 2.4、浮点数的加法与减法 一般步骤：对阶 -> 尾数求和 -> 尾数规格化 -> 舍入 -> 溢出判断 ！ 对阶：保证两个浮点数的阶码一致，使得尾数可以进行计算！阶码按照小阶看齐大阶的原则； 尾数规格化：对补码进行规格化需要判断两种情况：S > 0 或 S ！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/操作系统篇/操作系统基础篇.html":{"url":"计算机基础/操作系统篇/操作系统基础篇.html","title":"操作系统基础篇","keywords":"","body":"操作系统基础篇 最早的计算机没有操作系统这一概念的，需要人工操作计算机；CPU 等待人工输入输出，当用户输入输出时，CPU 处于空闲状态！ 为了 解决计算机操作难度大、计算机资源利用效率低 等问题，人们发明了操作系统；经历了由早起的 批处理系统 到现在 分时系统 的演变！ 处理操作系统：批量输入任务、有效提升计算机资源利用率；计算机工作时，用户无法干预； 分时复用计算机资源的操作系统：可以多个用户使用一台计算机；多个程序分时共享计算机资源；现代主流的计算机系统！ 而不论是 批处理系统、还是 分时系统 ，都利用了 多道程序设计 的概念！ 多道程序设计：是指计算机内存中同时存放多个程序，并且这些程序互不干扰； 早起的 批处理系统 一次只能处理一个任务； 多道程序设计使得 批处理系统 可以一次处理多个任务； 多道程序在计算机的管理程序之下相互穿插运行； 因此，对多道程序的管理是操作系统的重要功能； 1、操作系统概览 1.1、什么是操作系统？为什么使用操作系统？ 操作系统是管理硬件、提供用户交互的软件系统！ 操作系统是管理计算机硬件和软件资源的 计算机程序； 通过管理配置内存、决定资源供需顺序、控制输入输出设备等方法管理硬件资源； 同时，操作系统也提供了让用户和系统交互的操作界面！ 操作系统的种类是多种多样的，不局限于计算机；从手机到超级计算机，都有操作系统的存在(Android 、iOS 、Windows 、Linux 、MacOS 等)！在不同的设备，操作系统既可以简单也可以复杂，向用户呈现多种操作手段（手机的触控操作）！ 为什么使用操作系统？ 我们不可能直接的操作计算机硬件（如要求 CPU 计算 1 + 1） 设备种类繁多复杂，需要操作系统为用户提供了统一的界面，屏蔽不同设备的差异； 解决计算机操作难度大的问题：操作系统的简易性使得更多的人可以使用计算机； 1.2、操作系统的基本功能 操作系统实现了对计算机资源的抽象，这里面的计算机资源主要有 存储资源 、网络资源、计算资源等。 基本功能一：操作系统统一管理着计算机资源 如用户需要操作某个文件，并不是直接操作该文件的地址，而是通过操作系统来访问！ 如存储器资源，在用户读取数据或者写入数据，并不是直接控制存储器的设备读写，而是通过操作系统去管理和读写的！ 如处理器资源，也不是直接告诉 CPU 需要计算的内容，而是由操作系统来翻译需要做的任务！ 基本功能二：用户无需面向硬件接口编程 操作系统的 IO 设备管理软件，提供读写接口； 文件管理软件，提供操作文件的接口； 操作系统实现了对计算机资源的抽象；通过管理软件来实现抽象！管理软件屏蔽了硬件设备，向上向用户提供了逻辑设备，使得每个用户都使用相同的逻辑！ 基本功能三：操作系统提供了用户和计算机之间的接口 操作系统提供了用户与计算机之间的接口，使得用户可以通过操作系统操作计算机，这个接口主要以下有几种形式： 图像窗口形式 命令形式； 系统调用形式； 应用程序形式； 1.3、操作系统的相关概念 我们需要了解关于操作系统的 并发性 、共享性 、 虚拟性 、 异步性 ！ 1.3.1、并发性 并发与并行: 并行是指两个或者多个事件可以在 同一时刻 发生 并发是指两个或者多个事件可以在 同一时间间隔 发生 多道程序设计是并行与并发的基础 在单核处理器上，程序主要是并发的执行：在某一时刻，只能由一个程序占用 CPU ；在一个时间间隔内，多道程序交替运行； 在多核处理器上，程序可以并行的执行：在某一时刻，每个核上可以单独处理一个程序；多核同时处理多个程序； 1.3.2、共享性 资源共享表现为操作系统中的资源可以被多个并发的进程共同使用；多个程序可以同时使用主存资源的性质就是共享性！ 根据属性划分分为 互斥共享形式 与 同时访问形式 ! 互斥共享形式 当资源被程序 A 占用时，其它想使用该资源的程序只能等待 只有进程 A 使用完以后，其它进程才可以使用该资源 如打印机被程序 A 使用，那么程序 B 只能等待 程序 A 打印完毕才能使用打印机 同时访问形式 某种资源在一段时间内 并发地 被多个程序访问 这种 同时 是宏观的，从宏观上看该资源可以被同时访问 如程序 A 与程序 B 都准备向硬盘写入数据，硬盘悬臂只有一个，程序 A 写数据时，程序 B 实际上是不能写的；但写数据是一件快速的事情，所以我们可能观察到程序 A与程序 B在一瞬间都写入了数据 1.3.3、虚拟性 操作系统的虚拟性是指操作系统可以把一个计算机的物理实体转变为若干个逻辑实体以提供多个用户、多道程序使用；物理实体是真实存在的，而逻辑实体是虚拟的！ 虚拟性的技术主要有 时分复用技术 、空分复用技术 ! 时分复用技术 时分复用技术相关概念： 资源在时间上进行复用，不同程序并发使用 多道程序分时使用计算机的硬件资源 提高资源的利用率 时分复用技术主要有 虚拟处理器技术 、虚拟设备技术 ! 虚拟处理器技术 借助多道程序设计技术 为每个程序建立进程 多个程序分时复用处理器来执行相关逻辑 虚拟设备技术 将一个物理设备虚拟为多个逻辑设备 每个程序占用一个逻辑设备 多个程序通过逻辑设备并发访问 空分复用技术 空分复用技术主要用来实现虚拟磁盘、虚拟内存等；使用空分复用技术可以提高资源的利用率、提高编程效率！ 空分复用技术主要有 虚拟磁盘技术 、虚拟内存技术 ! 虚拟磁盘技术 将一个物理磁盘虚拟为多个逻辑磁盘 如一个硬盘虚拟为 C 盘、D 盘、E盘等 使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量 使用比实际内存更大的容量 大大的提升编程效率 1.3.4、异步性 操作系统的异步性是指是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。 异步性主要体现在以下几点： 在多道程序环境下，允许多个程序并发执行； 进程在使用资源时可能需要等到或者放弃； 进程的执行并不是一气呵成的，而是以走走停停的形式推进； 1.4、操作系统是如何启动的？ 没有操作系统的计算机就像是一堆废铜烂铁，操作系统接管了很多工作，在很多方面大大节省了人们的操作成本。 那么软件与硬件的界限在哪里？计算机硬件通电后，操作系统如何被激活和启动呢？ 1.4.1、操作系统的自举 自举是计算机领域比较重要的概念，计算机必须具备自举能力将自己所有的元件激活，以便能完成加载操作系统这一目的，然后再由操作系统承担起那些单靠自举代码无法完成的更复杂的任务。 1.4.2、操作系统的上电自检 BIOS (Basic Input Output System ) 是 基本输入输出系统 ! 上电自检 POST（Power On Self Test）是指计算机系统，接通电源、BIOS 程序的行为；包括对 CPU、系统主板、基本内存、扩展内存、系统 ROM BIOS 等器件的测试。如发现错误，给操作者提示或警告。简化或加快该过程，可使系统能够快速启动。 2、进程管理之进程实体 2.1、为什么需要进程 在没有操作系统的年代，计算机只能运行一个程序，计算机资源属于当前运行的程序；有了操作系统之后，引入了多道设计的概念，通过合理的隔离资源、运行环境，提升资源利用率！ 进程是操作系统进行计算机资源分配和调度的基本单位； 进程作为独立运行的载体，保障用户的逻辑程序在操作系统中独立、正常的执行；(多个进程可能使用一个共同的设备，如存储器、CPU等) 进程的存在使得操作系统对资源的利用率大幅度提升； 2.2、进程的实体：主存中的进程形态 进程在计算机中表现为一片存储空间，包含进程状态、进程优先级、程序计数器、内存指针、上下文数据、IO 状态信息等一系列数据。 进程控制块 PCB (Process Control Block) 在主存中，进程也是一段连续存储的空间 (进程控制块)： 用于描述和控制进程运行的通用数据结构； 用于记录进程当前状态和控制进程运行的全部信息； PCB 是进程能够独立运行的基本单位；每个进程都依赖于进程控制块，被操作系统调度； PCB 是操作系统进行调度经常会被读取的信息； PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内； 有了 PCB，操作系统才可以控制进程的运行。 进程控制块 PCB 的一些关键构成元素 进程控制块元素 细节 标识符 唯一标记一个进程，用于区别其它进程（如进程 ID 就是唯一标识符） 状态 标记进程的状态，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态 程序计数器 进程即将被执行的下一条指令的地址 内存指针 程序代码、进程数据相关指针；可能有多个内存指针分别指向程序的逻辑代码 上下文数据 进程执行时处理器存储的数据 IO 状态信息 被进程 IO 操作所占用的文件列表 记账信息 存储进程使用处理器的时间、时钟数总和等； 优先级 ... ... 进程的实体由进程标识符、处理机状态、进程调度信息、进程控制信息 构成； 2.3、进程与线程 进程 Process：是操作系统进行资源分配和调度的基本单位； 线程 Thread ：是操作系统能够进行运算调度的最小单位； 线程被包含在进程之中，是进程中的实际运作单位；一个进程可以有多个线程； 操作系统对进程的调度，实质上是对进程中线程的调度； 一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发多个线程，每个线程执行不同的任务； 一个进程中的多个线程共享该进程资源； 对比 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 管理线程、分配资源，因此进程系统开销大 线程系统开销小 通信 进程 IPC 读写同一进程数据通信 3、进程管理之五状态模型 进程在系统中是有多个状态的，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态！ 就绪状态： 当进程被分配到除了 CPU 以外所有必要的资源后处于就绪状态； 此时只要再获得 CPU 的使用权，就可以立即执行； 包括 进程控制块，堆空间、栈空间等内存 的其它资源都已经准备好、只差 CPU 资源的状态为就绪状态； 在一个系统中处于就绪状态的多个进程通常排成一个队列（就绪队列）； 执行状态： 进程获得 CPU 的使用权，其程序正在执行的状态； 在单处理机中，在某个时刻只能有一个进程处于执行状态； 阻塞状态： 进程由于某些原因从而放弃 CPU 的状态称为阻塞状态 如进程需要获取某个设备，而对应的设备没有就绪导致进程无法继续执行； 如某个进程需要使用打印机，而打印机属于外围的 IO 设备、速度比较慢，进程在请求使用打印机后可能没有立刻得到反馈，这时候进程无法进行下一步工作，由于打印机的未就绪而处于阻塞状态； 阻塞队列：在操作系统中可能有一个或者多个阻塞进程； 创建状态：分配 PCB -> 插入就绪队列 创建进程时拥有 PCB ，但其它资源尚未就绪的状态称为创建状态； 操作系统提供了 fork() 函数接口供程序员手动创建进程； 终止状态；系统清理 -> 归还 PCB 进程结束由系统清理或者归还 PCB 的状态称为终止状态； 就绪 -> 执行状态：当就绪状态的进程发生 进程调度 时，就可以变为执行状态； 执行 -> 就绪状态：当执行状态的进程 CPU 资源（时间片）用完时，又会切换为 就绪状态，插入到就绪队列中去；时间片资源指分配给某个进程执行的 CPU 时间段； 执行 -> 阻塞状态：进程发生 IO 请求时，可能变为阻塞状态； 阻塞 -> 就绪状态： 当 IO 完成时，进程由阻塞状态切换为就绪； 4、进程管理之进程同步 4.1、为什么需要进程间同步？ question 1：生产者-消费者问题 有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费；生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的缓冲池；生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。 在现实的宏观生活中，上述的生产者-消费者模型没有任何问题，但是针对计算机的微观世界而言，是有一些问题的！ 单从生产者程序或者消费者程序去看是没有任何问题的； 但如果两者并发执行时，可能出错！ question 2：哲学家进餐问题 有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌子，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子，只有两支筷子都被拿到的时候才能进餐，进餐完毕后放下筷子左右思考！ 上述两个模型的根源问题是彼此之间没有互相通信，如果生产者通知消费者我已经完成了一件生产、或者哲学家向旁边的哲学家说我要进餐了你们别拿我的筷子！因此需要进程间的同步！ 进程间的同步可以对竞争资源在多进程间进行使用次序的协调；使得并发执行的多个进程之间可以有效使用资源和相互合作！ 4.2、进程同步的原则 临界资源 ：指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其它进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源！ 为了对临界资源更好的约束，提出了四条原则 空闲让进：如果临界资源没有被占用、操作系统应该允许某个进程使用该临界资源； 忙则等待：如果已经有进程占用临界资源，此时应该防止别的进程使用该资源；使请求进程等待该临界资源的释放； 有限等待：在忙则等待的基础上，如果临界资源被占用，需要保证在有限等待时间内别的等待进程能够使用到资源，以避免外部等待进程僵死； 让权等待：当外部进程等待时，等待进程需要让出 CPU（进程从执行状态转为阻塞状态），保证 CPU 可以高效利用； 进程间同步的方法有：信号量、共享内存、消息队列、Unix 域套接字等！ 4.3、线程同步 进程中的线程共享进程资源，当进程中的多线程并发的访问进程的资源时，可能发生数据竞态的问题；所以进程内多线程也需要同步！ 线程同步的方法有：互斥量、自旋锁、读写锁（应对多读少写、少读多写的情况使用）、条件变量的等方法。 5、Linux 的进程管理 5.1、Linux 进程的相关概念 进程的类型 前台进程：正在运行、并且占用终端和用户交互的进程； 后台进程：基本上不和用户交互、不占用终端的进程，优先级比前台进程低； 守护进程：一种特殊的后台进程；很多守护进程随系统引导而启动，一直运行直到系统关闭；如进程名字以 d 结尾的一般都是守护进程：crond 、httpd 、sshd 、mysqld ！ 进程的标记 进程 ID ：进程的唯一标记，每个进程拥有不同的 ID；是一个非负整数，最大值由操作系统限定； ID 为 0 的进程为 idle 进程，是系统创建的第一个进程； ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化； init 进程 是所有用户进程的祖先进程； /// 进程 ID 相关的关系：父子关系 进程A调用 fork() 函数创建进程B； 进程B调用 fork() 函数创建进程C； 进程A是进程B的父进程，进程B是进程A的子进程； /// 进程的父子关系可以通过 pstree 命令来查看 MacBook-Pro:~ $ pstree -+= 00001 root /sbin/launchd |--= 00064 root /usr/sbin/syslogd |--= 00065 root /usr/libexec/UserEventAgent (System) |-+= 00073 root /usr/sbin/systemstats --daemon |-+= 00075 root /usr/libexec/configd |--= 00077 root endpointsecurityd |--= 00081 root /usr/libexec/remoted |--= 00083 root /usr/libexec/logd |--= 00097 root /usr/libexec/kernelmanagerd |--= 00098 root /usr/libexec/diskarbitrationd |--= 00101 root /usr/libexec/coreduetd 进程的状态标记 状态说明 R TASK_RUNNING 进程处于运行状态 S TASK_INTERUPTIBLE 进程处于睡眠状态 D TASK_UNINTERUPTIBLE 进程处于 IO 等待的睡眠状态 T TASK_STOPPED 进程处于暂停状态 Z TASK_DEAD / EXIT_ZOMBIE 进程处于退出状态，或僵尸进程 5.2、操作 Linux 进程的相关命令 ps 命令：查看当前进程的相关信息；配合 aux 参数或 ef 参数和 grep 命令检索特定进程； 　 　 top 命令：查看一些使用内存等 kill 命令：发送特定信号给进程，kill -l 可以查看操作系统支持的信号；只有 kill 9 -0000 可以无条件终止进程，其它信号进程有权忽略； MacBook-Pro:~ $ ps PID TTY TIME CMD 21187 ttys001 0:00.01 -bash 6、作业管理之进程调度 6.1、进程调度概述 进程调度指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权！ 保存旧进程的运行信息，请出旧进程（收拾包袱） 选择新进程，准备运行环境并分配 CPU （新进驻） 就绪队列的排队机制：为了提高进程的效率，事先将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程； 选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它； 新老进程的上下文切换机制：如果需要把新的进程调度到 CPU 中，需要将旧的 CPU 中的进程备份出来，将新的进程切换到 CPU 中去；保存当前进程的上下文信息，装入被委派执行进程的运行上下文； 如果程序调度时，老进程还没有执行完会怎样呢？进程调度分为非抢占式调度、抢占式调度！ 非抢占式调度：处理器一旦分配给某个进程，就让该进程一直使用下去；调度器不以任何原因抢占正在被使用的处理器；直到进程完成工作或因为 IO 阻塞才会让出处理器； 抢占式调度：允许调度程序以一定的策略暂停当前运行的进程；保存好旧进程的上下文信息，分配处理器给新进程； 对比 抢占式调度 非抢占式调度 系统开销 频繁切换、开销大 切换次数少、开销小 公平性 相对公平 不公平 应用 通用系统 专用系统 6.2、进程调度算法 先来先服务算法：在就绪队列，按先来先服务原则，优先取出先进入队列的就绪进程； 短进程优先调度算法：调度程序优先选择就绪队列中估计运行时间最短的进程；不利于长作业进程的执行； 高优先权优先调度算法：进程附带优先权，调度程序优先选择权重高的进程；使得紧迫的任务可以优先处理；（前台进程高于后台进程，是因为前台进程与用户交互，需要保证用户的体验，不卡顿！） 时间片轮转调度算法：按照先来先服务的原则排列就绪进程；每次从队列头部取出待执行进程，分配一个时间片，时间片用完后不管进程是否执行完、都会将进程重新插入队列尾部，然后取出第二个队列；是相对公平的调度算法，但不保证及时响应用户； 7、作业管理之死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力作用，它们都将无法推进下去。此时称操作系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程！ 7.1、死锁的产生原因 死锁的产生是由于竞争资源、进程调度顺序不当导致的！ 竞争资源： 共享资源数量不满足各个进程需求； 各个进程之间发生资源竞争导致死锁； 自身占用资源不释放，而一直在等待请求的资源被释放； 假设进程 1 申请传真机为步骤 A、进程 2 申请打印机为步骤 B、进程 2 申请传真机为步骤 C、进程 1 申请打印机为步骤 D！ 按照 A -> B -> C -> D 的顺序调度，就会引起进程死锁；如果将进程调度顺序改为 A -> D -> B -> C 就不存在死锁的情况！ 7.2、死锁产生的四个必要条件 死锁的产生，必然同时满足以下四个条件，仅满足其中的某几个是不会产生死锁的！ 互斥条件：进程对资源的使用具有 排它性 ；某个资源仅能由一个进程使用，其它进程需要使用只能等待； 请求保持条件：进程至少保持一个资源，又提出了新的资源请求；但新资源被占用，导致请求被堵塞；同时被阻塞的进程又不释放自己保持的资源； 不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺；获得的资源只能由进程自身释放； 环路等待条件：发生死锁时，必然存在进程-资源环形链； 7.3、预防死锁的方法 破坏死锁产生的四个必要条件中的某一个或者某几个，就能有效预防死锁的产生！ 摒弃 请求保持条件 ：系统规定进程在运行之前，一次性申请所有需要的资源；在进程运行中，不会再去申请资源； 破坏 不可剥夺条件 ：当一个进程请求新的资源得不到满足时，必须释放其自身占有的资源；进程运行时占有的资源可以被释放，意味着可以被剥夺； 破坏 环路等待条件 ： 可用资源线性排序，申请必须按照需要递增申请；线性申请不再形成环路，从而摒弃了环路等待条件； 7.4、银行家算法 银行家算法是一个可操作的著名的避免死锁的算法、以银行借贷系统分配策略为基础的算法！ 银行家算法的策略基础： 假设客户申请的贷款是有限的，每次申请需声明最大资金量； 银行家在能够满足贷款时，都应该给用户贷款； 客户在使用完贷款后，能过及时归还贷款； 如上图所示，有初始状态的 所需资源表、已分配资源表；所需资源表减去已分配资源表得到的 还需分配资源表；还有 可分配资源表 ！ 所需资源表：P1 需要 0 个 A 资源、 6 个 B 资源、 5 个 C 资源、 6 个 D 资源； 已分配资源表：P1 已经拥有 0 个 A 资源、 0 个 B 资源、 1 个 C 资源、 4 个 D 资源； 还需分配资源表：P1 还需要 0 个 A 资源、 6 个 B 资源、 4 个 C 资源、 2 个 D 资源； 经过与 可分配资源表 对比后，发现不能满足 P1 、P3 、P4 的需求，仅仅能满足 P2 的需求； 因此先满足 P2 ，执行完 P2 后 P2 归还资源； 此时 可分配资源表 又可以分配资源给 P1 、P3 、P4 ！ 8、存储管理之内存分配与回收 早期的计算机编程并不需要过多的存储管理；随着计算机和程序越来越复杂，存储管理变为一件必要的事情！ 确保计算机有足够的内存来处理数据； 确保程序可以从可用内存中获取一部分内存使用； 确保程序可以归还使用后的内存以供其他程序使用！ 8.1、内存分配的过程 单一连续分配： 最简单的内存分配方式； 只能在单用户、单进程的操作系统中使用； 将主存分为系统区、用户区； 系统区指的是内存给操作系统所使用； 用户区指的是所有的用户区内存都给用户区程序所使用； 固定分区分配： 支持多道程序的内存分配方式； 将内存空间划分为若干个固定大小的区域； 每个分区只提供给一个程序使用，互不干扰； 动态分区分配： 根据进程实际需要、动态分配内存空间； 涉及到相关数据结构（如动态分区空闲表数据结构、动态分区空闲链数据结构等）、分配算法； 假设主存中有若个分区，并且一些分区已经使用、一些分区还没有使用；这时候就需要一个数据结构来标记某个分区是否已使用！ 动态分区分配算法： 首次适应算法（FF 算法）： 最佳适应算法（BF 算法）；将空闲区链表按照容量大小进行排序；在每一次需要分配时遍历链表找到最佳合适空闲区； 快速使用算法（QF 算法）；要求有多种空闲区链表；每种链表存储一种容量的空闲区； 8.2、内存回收的过程 内存回收过程分为四种情况： 情况1：需要回收的区域和空闲区连接在一起，并且位于空闲区后面； 回收1：不需要新建空闲链表节点；只需要把空闲区 1 的容量增大为包括回收区的空闲区即可； 情况2：需要回收的区域和空闲区连接在一起，并且位于空闲区前面； 回收2：将回收区和空闲区合并为一个新的节点，然后使用回收区的地址作为新的节点地址； 情况3：需要回收的区域和空闲区连接在一起，并且位于空闲区中间； 回收3：将空闲区1、回收区、空闲区2 合并为一个新的节点，然后使用空闲区1的地址作为新的节点地址； 情况4： 需要回收的区域和空闲区没有连接在一起，单一的回收区； 回收4：为回收区创建新的节点，然后将新的节点插入到相应的空闲区链表中即可； 9、存储管理之段页式存储管理 操作系统使用 段页式存储 管理进程的内存空间！ 段是指连续不等长的一块内存，页是指连续等长的一块内存；段页式存储管理是将用户程序分成若干个段，再把每个段分成若干个页的内存管理方式。 9.1、页式存储管理 前文提到的 字与字块 是相对于物理设备的定义，而此处的 页面 则是相对于逻辑空间的定义！ 将进程逻辑空间 等分 为若干个大小的页面； 相应的把物理内存空间分成与页面大小一样的物理块； 以页面为单位把进程空间加载到物理内存中分散的物理块上； 页面大小应该适中，过大难以分配，过小则内存碎片过多； 页面大小通常是 512B ～ 8 K ； 通过页式存储管理，可以把进程的逻辑空间的每个页面加载到内存中去！但是又如何知道进程的某个页面具体被分配到哪一个字块中去呢？这时候就需要了解 页表 的概念！ 页表 ： 页表是一个记录进程逻辑空间与物理空间的映射表； 在页式存储管理中，地址 分为 页号 与 页内偏移； 在现代计算机系统中，可以支持非常大的逻辑地址空间（2^32 ~ 2^64）；而这将导致页表变得越来越大，会占用非常大的内存空间。如具有 32 位逻辑地址空间的分页系统，规定页面大小为 4 KB ，则在每个进程页表中的页表项可达 1 M (2^20) 个，如果每个页表项占用 1 Byte，则每个进程仅仅页表就要占用 1 MB 的内存空间！ 32 位系统进程的寻址空间位 2^32 = 4 G 4 G / 4KB = 2^20 使用多级页表来解决页表内存占用高的问题！ 首先，多级页表有一个根页表； 根页表的每个字块都指向内存的一片地址空间，这块地址空间存储一个二级页表； 假设每个二级页表有 1024 项，每一项指向的字块才是进程实际使用的内存； 一个根页表可以指向二级页表，这样子大大的减少的进程的页表所占用的内存空间； 在运行时，只需要把根页表加载到内存中即可；如果调用某个字块，发现二级页表不在内存空间；此时只需要把二级页表加载到内存中，做到 按需加载，节省内存空间 ； 页式存储管理仍然有一个问题：假如有一段连续逻辑分布在多个页面中，将大大降低执行效率！此时提出了段式存储管理！ 9.2、段式存储管理 将进程逻辑空间 非等分地 划分为若干段； 段的长度由进程的连续逻辑长度决定； 如进程的逻辑有 主函数 MAIN 、子程序段 X、子函数 Y 等，此时按照每个函数的逻辑长度分配逻辑空间； 段表：段式存储管理也需要一个表来保存逻辑空间到物理空间的映射关系； 不管是段式存储管理、或者页式存储管理，都离散地管理了进程的逻辑空间；不同之处在于： 页是物理单位（从物理的角度划分），段是逻辑单位（从进程的逻辑划分）； 分页是为了合理的利用空间；分段是为了满足用户需求； 页大小由硬件确定；段长可动态变化； 页表信息是一维的，段表信息是二维的；段表中每一段的长度不同，因此需要把段的基址和长度都记录起来，所以段表信息是二维的！ 9.3、段页式存储管理 段页式存储管理: 将用户程序分成若干个段，再把每个段分成若干个页 ! 分页可以有效提高内存利用率（虽然存在页内碎片），而分段可以更好的满足用户需求（因为逻辑是用户写的）；将两者结合，形成了段页式存储管理！ 先将逻辑空间按段式管理分成若干段； 再把段内空间按页式管理分成若干页； 页地址分为页号和页内偏移； 段地址分为段号和段内偏移； 段页地址：段号、段内页号、页内地址 段号 段内页号 页内地址 指定进程逻辑空间的具体哪一段 段里面具体的某一页 某一页的具体哪个字 10、存储管理之虚拟内存 思考 ： 一个 Xcode 十几个 G，物理内存只有 8G ，那么这个程序是如何运行起来的呢？ 10.1、虚拟内存概述 为什么要使用虚拟内存？ 有些进程实际需要的内存很大，远超主存的容量； 基于多道程序设计，主存中可以运行多个进程，使得每个进程可用内存资源更加稀缺； 不可能无限增加主存，主存总有不够用的时候； 虚拟内存是操作系统内存管理的关键技术，使得多道程序运行和大程序运行成为现实。它的工作原理为： 虚拟内存技术使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）； 而实际上，虚拟内存技术把应用程序所使用的内存进行划分，分隔成多个物理内存碎片； 将部分暂时不使用的内存放到辅存中去；在需要时进行数据交换。 10.2、程序的局部性原理 局部性原理指 CPU 在访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中！ 局部性原理是虚拟内存技术可以实现的一个原因： 程序运行时，无需全部载入内存，加载部分即可； 如果程序在运行的时候，发现访问页不在内存中，则发出缺页中断，发起页面置换，将保存在辅存中的页面置换到内存中；置换之后，程序可以继续运行下去； 从用户层面看，程序拥有很大的空间，即是虚拟内存； 虚拟内存实质上是对物理内存的一个扩充，使得它的速度接近于内存，成本接近于辅存！ 10.3、虚拟内存的置换算法 先进先出算法（FIFO） 最不经常使用算法（LFU） 最近最少使用算法（LRU） 替换策略发生在 Cache-主存 层次、主存-辅存 层次； Cache-主存 层次的替换策略主要是为了解决 CPU 速度远远快于主存的问题； 主存-辅存 层次主要是为了解决主存容量不足的问题； 11、Linux 的存储管理 11.1、Buddy 内存管理算法 Buddy 指的是两片内存连续、大小一样的内存片段 Buddy 算法是经典的内存管理算法； 算法基于计算机处理二进制的优势具有极高的效率； 设计了伙伴系统，可以快速的合并回收区与空闲区； 算法主要是为了解决内存外碎片的问题；其实质是将内存外碎片问题转移为内存内碎片问题； 极大的提升了内存利用效率，因为 内存外碎片 会比 内存内碎片 要大； 页内碎片与页外碎片 页内碎片：已经被分配出去（能明确指出属于哪个进程）的内存空间大于进程请求 所需的内存空间，剩下的不能再被利用的内存空间就是内部碎片！ 页外碎片：还没有被分配出去（不属于任何进程），但由于太小而无法分配给申请内存空间的新进程的内存空闲块！ 基于计算机处理二进制的优势具有极高效率，Buddy 内存管理算法的目的是 努力的让内存分配与相邻内存合并能快速进行 ! Buddy 算法内存分配原则：内存分配时默认每一块内存都向上取整为 2 的幂次方 ； /// 如一个进程需要申请 70k 的内存，Buddy 算法会向上取整到 128k 的内存 (2 的幂次方) 70k -> 128k /// 如一个进程需要申请 129k 的内存，Buddy 算法会向上取整到 256k 的内存 (2 的幂次方) 129k -> 256k 伙伴系统 伙伴指的是一片内存中的伙伴； 一片连续内存的伙伴是相邻的另一个大小一样的连续内存； Buddy内存管理算法具体流程 Buddy内存管理算法 创建一系列空闲块链表，每一种空闲块链表的大小 都是 2 的幂！ 假设存储空间有 1M 大小，对于 Buddy 算法而言 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点；需要使用 Buddy 算法分配 100KB 内存！那么如何分配呢？ 1、 100KB 按照向上取整为 2 的幂次方的原则为 128KB； 2、接着查询空闲块链表是否有 128 KB 的空闲内存块？查询结果没有； 3、再次查询空闲块链表是否有 256KB 的空闲内存块？查询结果没有； 4、再次查询空闲块链表是否有 512KB 的空闲内存块？查询结果没有； 5、再次查询空闲块链表是否有 1MB 的空闲内存块？查到一个 1MB 的节点； 6、从空闲链表取下 1MB 的节点，将链表节点置为 NULL；判断 1MB 的空闲内存是否满足最小需求，发现没有满足； 7、接着将 1MB 内存拆为两个 512KB 的内存 ，一个 512KB 用于存放数据； 另一个多余的 512KB 的内存放在 512KB 的空闲链表上，此时512KB 的空闲链表有一个节点； 同时会判断 512KB 的空闲内存是否满足最小需求，发现没有满足； 8、接着将 512KB 内存拆为两个 256KB的内存，一个 256KB用于存放数据； 另一个多余的 256KB的内存放在 256KB 的空闲链表上，此时256KB 的空闲链表有一个节点； 同时会判断 256KB 的空闲内存是否满足最小需求，发现没有满足； 9、接着将 256KB 内存拆为两个 128KB的内存，一个 128KB用于存放数据； 另一个多余的 128KB 的内存放在 128KB 的空闲链表上，此时128KB 的空闲链表有一个节点； 同时会判断 128KB 的空闲内存是否满足最小需求，发现已经满足； 10、至此，内存分配结束； 11、128KB、 256KB、 512KB 的空闲链表上各增加一个节点；1MB 的空闲链表少一个节点； 注意 ：进程需要 100KB 的内存，而 Buddy 算法为其分配 128KB 的内存，那么多出的 28KB 不被利用，属于 页内碎片！ Buddy内存管理算法回收流程 1、判断刚才分配的内存伙伴是否在空闲链表上； 2、在！移除伙伴，与需要回收的内存一起合并为 256KB 空闲内存；判断 256KB内存的伙伴是否在空闲链表上； 3、在！移除伙伴，与需要回收的内存一起合并为 512KB 空闲内存；判断 512KB 内存的伙伴是否在空闲链表上； 4、在！移除伙伴，与需要回收的内存一起合并为 1MB 空闲内存；判断 1MB 内存的伙伴是否在空闲链表上； 5、不在！将 1MB 的空闲内存插入到 1MB 空闲链表，至此回收完成。 6、此时 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点。 11.2、Linux 交换空间 什么是 Linux 交换空间？ Linux 交换空间 Swap 实质是磁盘的一个分区； 当 Linux 主存被占满的时候，会把一部分数据交换至 Swap 空间，使得 Linux 主存有更多的空间去运行； 可以在系统初始化的时候配置 Swap 空间：安装系统时，会提示是否需要 Swap空间 、需要多大的 Swap 空间！ 交换空间 Swap 的作用： 冷启动的内存依赖：对于一些大型应用程序，在启动的时候需要使用大量内存空间，但很多数据仅仅只在启动时加载一次，后续运行时很少使用这些数据；有了交换空间，系统可以将这些使用次数很少的内存数据保存在 Swap 空间，从而释放更多的物理内存提供给系统使用！ 系统睡眠依赖：当 Linux 系统需要睡眠时，会将系统中所有需要保存的数据交换到 Swap 空间中；等下次唤醒系统时，将这些数据从 Swap 空间 加载至主存；这样可以加快系统的启动速度； 大进程空间依赖：某些进程确实需要使用很多的内存空间，但主存空间不够；此时需要把进程使用的内存数据暂时保存在 Swap 中，使得大的进程能够运行起来； 备注：虽然交换空间 Swap 可以将 Linux 的主存数据交换至辅存上，但不推荐使用 Swap 技术！因为 Swap 空间实质属于辅存，读写速度相对于 主存要慢很多；如果频繁的使用 Swap 将数据从主存置换到辅存，就会使得 Linux 系统运行的非常慢；所以应该注意避免使用 Swap 技术。 对比 Swap 空间 虚拟内存 位置 存在于磁盘 存在于磁盘 置换 与主存发生置换 与主存发生置换 服务 是 Linux 操作系统的概念 属于进程的概念 目的 解决了系统物理内存不足的问题 解决进程物理内存不足的问题 12、操作系统的文件管理 12.1、文件的逻辑结构 12.2、辅存的存储空间分配 12.2.1、辅存的分配方式 连续分配 如果一个文件的存储需要一系列的扇区；此时就会连续的将这些连续扇区分配给某个文件； 优点是读取文件内容非常容易、速度很快；只需要顺序地读取磁盘的扇区即可； 缺点是对存储要求比较高，存储文件时要有满足容量的连续存储空间； 隐式链接分配 隐式分配的 下一个链接指向 被存放在当前盘块内！假设某个文件需要使用下述五个盘块： 2 -> 9 -> 7 -> 18 -> 16 由于隐式链接存储在盘块中，在分配文件时： 盘块 2 中会有一块空间去记录下一个盘块的地址（9） 盘块 9 中会有一块空间去记录下一个盘块的地址（7） 盘块 7 中会有一块空间去记录下一个盘块的地址（18） 盘块18中会有一块空间去记录下一个盘块的地址（16） 随机访问的效率极其低下 ：不管访问哪一个盘块，都需要从第一个盘块开始： 隐式分配适合顺序访问，在顺序访问时只需要知道第一个盘块，即可顺序的查找其余盘块； 假如需要访问文件的第 18 盘块，由于只能从头部开始，先找到第 2 个盘块、第 9 个盘块、第 7 个盘块；最终找到第 18 盘块！ 可靠性差：任何一个链接出问题，都将影响到整个文件！ 基于 隐式链接分配 的缺点，提出了 显示链接分配 方式！ 显式链接分配 显式链接分配：下一个盘块的位置没有记录在上一个盘块中，而是使用一个 FAT 表来指定！(参考 FAT 文件系统) 缺点： 不支持直接高效的存储，因为 FAT 记录项非常多；磁盘越大，FAT 记录项越大； 如果在 FAT 文件系统存储一个非常大的数据，需要检索 FAT 表找到很多空闲的盘块号； 所以 FAT 文件系统不支持直接高效的存储； 检索时 FAT 表占用较大的存储空间，因为对某个文件读取时需要将整个 FAT 加载到内存，然后在内存中检索 FAT； 索引分配 把文件的所有盘块集中存储，存储盘块的位置称为索引； 当需要读取某个文件时，只需要将该文件的索引读取进内存即可； 上图中，索引分配使用一个额外的盘块 12 去记录该文件被分配到的所有盘块； 12 是该文件的索引，会指向 2 -> 9 -> 7 -> 18 -> 16； 索引分配很好的解决了 FAT 方式遇到的问题： 每个文件拥有一个索引块，记录被分配的盘块信息；在索引某个文件时，只需将索引块加载到内存即可，不需要将整个表加载到内存； 索引分配方式支持直接访问盘块；在索引块中可以直接找到文件对应的盘块； 文件较大时，索引分配方式具有明显优势； 主流的文件系统（如 Ext 文件系统） 都是使用索引分配来 进行磁盘分配； 12.2.2、辅存的存储空间管理 在辅存中，一般使用位示图、或者空闲表（少用）的数据结构来管理存储空间！ 12.3、目录管理 文件目录树使得任何一个文件或文件夹都有唯一的路径 13、Linux 文件基本操作 在 Linux 系统下，一切都是文件，进程也是一个文件！ 13.1、Linux 目录 /// 进入根目录 MacBook $ cd / /// 查看文件列表 MacBook:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var 目录 描述 /bin 存放二进制可执行文件 (ls、cat、mkdir等)，常用命令一般都在这里 /etc 存放系统管理与配置文件 /home 存放所有用户文件的根目录，是用户目录的基点；如用户 user 的主目录就是 /home/user /usr 存放系统应用程序，如常见的 usr/local （本地系统管理员软件安装目录） /dev 用于存放设备文件，如终端、键盘输入等 /opt 额外安装的可选应用程序包所放置的位置 /var 用于存放运行时需要改变数据的文件 /sbin 存放二进制可执行文件，只有 /root 才能访问 /root 超级用户（系统管理员）的主目录 /proc 虚拟文件系统目录，是系统内存的映射！可直接访问这个目录来获取系统信息； /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统 /boot 存放用于系统引导时所使用的各种文件 /lib 存放和文件系统中的程序运行所需要的共享库及内核模块 每一个文件或者文件夹，从根目录开始，都有一个唯一的路径来指向； 绝对路径：从根目录开始的路径； 相对路径：相对于当前的操作目录，它的文件位于哪一个目录；相对路径不固定，随着操作文件的路径变化而变化！ 文件描述信息包含 文件标识符、文件类型、文件权限、文件长度、文件状态、索引节点 等信息。 13.2、Linux 文件常用操作 目录/文件的创建、删除、读取、写入 /// touch 创建一个文件 MacBook-Pro:Desktop $ touch 1.txt /// 使用 vim 创建、编辑、查看一个文件 MacBook-Pro:Desktop $ vim 2.txt /// 查看一个文件的内容 MacBook-Pro:Desktop $ cat 2.txt Hello Word! /// 删除一个文件 MacBook-Pro:Desktop $ rm 1.txt /// mkdir 创建一个文件夹 MacBook-Pro:Desktop $ mkdir 1 /// 删除一个文件夹 MacBook-Pro:Desktop $ rm 1 rm: 1: is a directory (1 是一个文件夹，不能删除) /// 使用参数 -r 表示递归的删除文件夹中的数据 MacBook-Pro:Desktop $ rm -r 1 13.3、Linux 文件类型 Linux 文件有 套接字文件、普通文件、目录文件、符号链接文件、设备文件、FIFO 文件等多种文件类型。 - 开头表示文件 d 开头表示文件夹 c 开头表示字符设备文件 b 开头表示块符设备文件 l 开头表示链接文件 /// 分别创建一个文件、一个文件夹 MacBook-Pro:Desktop $ touch 1.txt MacBook-Pro:Desktop $ mkdir 2 /// 使用 ls -al 查看文件的一些信息 MacBook-Pro:Desktop $ ls -al total 24 -rw-r--r--@ 1 i7y staff 6148 8 16 09:59 .DS_Store -rw-r--r-- 1 i7y staff 0 7 23 13:56 .localized -rw-r--r-- 1 i7y staff 0 8 16 09:58 1.txt drwxr-xr-x 2 i7y staff 64 8 16 09:59 2 /// -rw-r--r-- : 一个文件 /// drwxr-xr-x : 一个文件夹 MacBook-Pro:Desktop $ cd / MacBook-Pro:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var MacBook-Pro:/ $ cd dev MacBook-Pro:dev $ ls -al total 9 dr-xr-xr-x 3 root wheel 4384 8 16 09:04 . drwxr-xr-x 20 root wheel 640 1 1 2020 .. crw-r--r-- 1 root wheel 10, 3 8 16 09:04 auditsessions crw------- 1 root wheel 31, 0 8 16 09:05 autofs brw-r----- 1 root operator 1, 6 8 16 09:04 disk1s4 lr-xr-xr-x 1 root wheel 0 8 16 09:04 stdout -> fd/1 /// crw : 一个字符设备文件 /// brw : 一个块符设备文件 /// lr : 链接文件 14、Linux 的文件系统 常见的文件系统有 FAT、 NTFS 、 EXT2/3/4 ！ FAT 全称 File Allocation Table ，FAT 16 与 FAT 32 是早期微软的 Dos/Windows 使用的文件系统； 主要使用一张表来保存盘块的信息（链接分配方式）！ NTFS 全称 New Technology File System ，是当今 Windows 系统常用的文件系统；NTFS 对 FAT 进行了改进，取代了旧的文件系统！ EXT ( Extended File System) 可扩展文件系统；主要用于 Linux 的文件系统，不支持 Windows 系统； 一个 EXT 格式 U 盘不能被 Windows 系统读取数据；因此 U 盘多格式化为 NTFS 格式！ 14.1、Ext 文件系统 Ext 文件系统使用索引分配方式分配辅存空间！可以将 Ext 文件系统看做是由一个 Boot Sector 和若干个 Block Group 组成： Boot Sector 启动扇区，安装开机管理程序 Block Group 块组，存储数据的实际位置；有多个块组 每个块组 Block Group 都由以下一些信息组成： Inode bitmap : Inode 的位示图，记录已分配和未分配的Inode；当一个文件系统初始化的时候， Inode 的输入已经固定，此时可以使用位示图来记录； Inode table : 存放 Inode 的地方，每一个文件(目录)都有一个 索引节点 Inode ；Ext 文件系统管理外存的方式为索引分配的方式！ Date Block : 存放文件内容的地方；每个Block都有一个唯一的编号，每一个文件的 Block 记录在文件的 Inode 上； Block bitmap : Block 的位示图；功能与 Inode bitmap 类似，记录 Date Block 的使用情况；当需要对一个文件进行外存分配时，通过查询 Block bitmap 来分配相应的 Date Block ！ SuperBlock：记录整个文件系统相关信息（Block 、 Inode 使用情况，时间信息，控制信息等等）的地方；时间信息包括文件系统所挂载的时间、最后一次写入、最后一次读取、最后一次校验的时间！一般是 1024 个字节的大小！ 每个文件或者文件夹都有一个 Inode，Inode 可以理解为是文件或文件夹的 身份证，存储着关键信息：如文件类型(目录文件、普通文件、套接字文件等)、文件权限、文件物理地址、文件长度、文件连接计数、文件存取时间（如最新修改文件的时间、创建文件的时间等）、索引的节点编号（每个文件的唯一标识符）、文件状态、访问计数（当前哪几个进程访问了该文件）、链接指针等等； 文件名不是存放在 Inode 节点上的，而是存放在目录的 Inode 节点； 列出目录文件时，无需家在文件的 Inode；列出目录文件的操作非常频繁，如果每次列出目录文件，都去加载所有文件的 Inode，将会耗时！ /// 查看 EXT 文件系统 MacBook-Pro $ df -t Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1s5s1 976490576 29943648 596646728 5% 553781 4881899099 0% / devfs 379 379 0 100% 656 0 100% /dev /dev/disk1s4 976490576 2097192 596646728 1% 3 4882452877 0% /System/Volumes/VM /dev/disk1s2 976490576 553472 596646728 1% 832 4882452048 0% /System/Volumes/Preboot /dev/disk1s6 976490576 840 596646728 1% 18 4882452862 0% /System/Volumes/Update /dev/disk1s1 976490576 345715896 596646728 37% 1923831 4880529049 0% /System/Volumes/Data map auto_home 0 0 0 100% 0 0 100% /System/Volumes/Data/home MacBook-Pro $ dumpe2fs /dev/disk1s4 -bash: dumpe2fs: command not found 15、操作系统的设备管理 15.1、广义的 IO 设备 对于计算机，输入输出设备有键盘、鼠标、触摸板等！ 对 CPU 而言，凡是对 CPU 进行数据输入的都是输入设备；凡是对 CPU 进行数据输出的都是输出设备！ 可以按照 使用特性 、 信息交换的单位 、 设备的共享属性 、 传输速率 等多个角度对广义的 IO 设备进行分类！ 15.2、IO 设备的缓冲区 针对 CPU 与 IO 设备的传输速率不匹配的问题，前文提出了使用 缓存-主存、主存-辅存的存储层次来解决；除此之外，还可以使用 IO 设备的缓冲区来解决！ 通过 IO 设备的缓冲区，可以减少 CPU 处理 IO 请求的频率，提高 CPU 与 IO 设备之间的并行性！ 专用缓冲区只适用于特定的 IO 进程，当这样的 IO 进程比较多时，对内存的消耗会很大；因此，操作系统划出了可供多个进程使用的公共缓冲区，称为缓冲池！ 进程与 IO 设备的交互，使用的不是进程专用的缓冲区，而是从缓冲池中取出一个缓冲区； 缓冲池中存在多个缓冲区，进程需要使用时从缓冲池取出某一个缓冲区使用，使用完之后再将缓冲区归还给缓冲池； 达到多个进程共同使用缓冲区、减小内存消耗的目的！ 15.3、SPOOLing 技术 SPOOLing 技术是一种关于慢速字符设备如何与计算机主机交换信息的一种技术；可以使用该技术解决 CPU 与 IO 设备的传输速率不匹配的问题！ 工作原理： SPOOLing 技术是一种虚拟设备技术，将一台低速的物理设备虚拟为高速独享设备； 使用该技术，操作系统在逻辑上为每一个进程都分配了一台独立的高速独享设备； 假设三个进程都需要使用打印机，由于打印机是一种读写速度很慢的设备: 多个进程都需要使用打印机，将会等待很久； 使用 SPOOLing 技术，不会直接将打印机分配给某个进程，而在共享设备（如共享磁盘）进行输出； SPOOLing 技术会在 共享磁盘 分配一个存储空间，进程的输出数据会以文件的形式保存在 SPOOLing 的存储空间上； 这些进程的数据输入输出会形成一个输出队列，然后由 SPOOLing 去控制打印机的进程、将输出队列中的文件依次打印出来！ SPOOLing 系统并没有将打印机设备分配给任何一个进程，而是在输入输出的存储空间为进程分为一个存储区，并建立一张 IO 表，将逻辑设备虚拟为共享设备！ 共享磁盘所用到的空间称为 输出井！ SPOOLing 技术将同步调用低速设备改为异步调用：如进程实际调用的不是打印机，而是将输出数据写入 输出井，再由 SPOOLing 技术将这些文件送到打印机打印，这样可以大大提升进程的工作效率！ SPOOLing 技术总结： 在输入、输出之间增加了排队转储环节（输入井、输出井） SPOOLing 技术负责输入井（输出井）与低速设备之间的调度； 在逻辑上，进程直接与高速设备交互，而不是与实际的物理设备交互，因此减少了进程的等待时间，提高了进程的工作效率； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/操作系统篇/操作系统提升篇.html":{"url":"计算机基础/操作系统篇/操作系统提升篇.html","title":"操作系统提升篇","keywords":"","body":"1、线程同步 1.1、线程同步之互斥量 有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 互斥量可以保证一个线程在操作临界资源的时候，阻止其它线程来访问该临界资源！ 上图引起线程同步问题的最根本原因是两个线程的指令交叉执行： 如先执行线程 1 的两个指令，接着 CPU 被抢夺走去执行线程 2 的三条指令； 最后又回到线程 1 去执行线程 1 的第三条指令； 线程1 与线程 2 的指令交叉执行，引发了线程同步的问题； 互斥量如何解决上述问题呢？互斥量可以保证两个线程的关键指令不会被交叉执行，而是以先后顺序来执行； 互斥量本质上保证了线程操作的 原子性！原子性是指一组操作不可被中断的特性；这一组操作要么全部执行完成，要么全部没有执行；不存在部分执行、部分未执行的情况！ 互斥量（也称为互斥锁）是最简单的线程同步的方法；互斥量是处于 解锁、加锁 两个状态之一的变量；两个状态保证资源访问的串行！一个资源被加了互斥锁，代表该资源正在被某个线程所使用；那么其它线程想要使用该资源，只能等待正在使用的线程解锁、释放掉该资源，这就形成了资源访问的串行！ 操作系统直接提供了互斥量的 API，开发者可以直接使用 API 完成资源的加锁、解锁操作！ /// API pthread_mutex_t pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥量 int num = 0; /// 临界资源 void *producer(void*) { /// 生产者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num += 1; /// 每循环一次，生产一件产品 pthread_mutex_unlock(&mutex); } } void *comsumer(void*){ /// 消费者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num -= 1; /// 每循环一次，消费一件产品 pthread_mutex_unlock(&mutex); } } int main(){ /// 执行函数 pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); /// 创建生产者线程 pthread_create(&thread2, NULL, &comsumer, NULL); /// 创建消费者线程 pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.2、线程同步之自旋锁 上图有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 在一个线程使用临界资源前，先加一个自旋锁，阻止其它线程来访问临界资源；当使用完临界资源后解锁，保证临界资源的串行访问！ 自旋锁的原理和互斥锁是一样的，那么自旋锁和互斥锁有什么不一样嘛？ 自旋锁也是一种线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用；如果不可用，自旋锁会一直循环反复的检查直到可用为止；自旋锁不会让出 CPU ，是一种忙等待的过程；自旋锁实质上就是一个死循环等待锁被释放！ 自旋锁的好处： 自旋锁避免了进程或者线程上下文切换的开销； 如果使用自旋锁占用的时间不是很长，那么使用自旋锁的代价很小； 操作系统内部很多地方使用的都是自旋锁； 自旋锁不适合在单核 CPU 使用（因为自旋锁在等待的过程中不会释放 CPU，而是死循环的等待；在单核 CPU 使用自旋锁，会导致其它的进程或者线程无法执行） /// API : pthread_spinlock_t #include #include #include #include #include pthread_spinlock_t spin_lock; /// 自旋锁 int num = 0; /// 临界资源 void *producer(void*){ /// 生产者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num += 1; pthread_spin_unlock(&spin_lock); } } void *comsumer(void*){ /// 消费者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num -= 1; sleep(10); pthread_spin_unlock(&spin_lock); } } int main() { pthread_spin_init(&spin_lock, 0); pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); pthread_create(&thread2, NULL, &comsumer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.3、线程同步之读写锁 读写锁在互斥锁、自旋锁的基础上做了改进，主要是从临界资源的多读少些的方面考虑！ 读写锁是一种特殊的自旋锁，允许多个读者同时访问资源以提高读性能；对于写操作则是互斥的！ 读写锁在多读少些的场景下，对性能的优化是很明显的！ #include #include #include #include #include int num = 0; /// 临界资源 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; ///读写锁 void* reader(void*) { int times = 10000000; while(times --){ pthread_rwlock_rdlock(&rwlock); /// 添加读锁 /// 读取临界资源 printf(\"print num in reader: num = %d\\n\", num); pthread_rwlock_unlock(&rwlock); /// 释放读锁 } } void *writer(void*){ int times = 10000000; while(times --){ pthread_rwlock_wrlock(&rwlock); /// 添加写锁 num += 1; /// 临界资源的改变 pthread_rwlock_unlock(&rwlock); /// 释放写锁 } } int main(){ pthread_t thread1, thread2, thread3; /// 两个读线程、一个写线程 pthread_create(&thread1, NULL, &reader, NULL); pthread_create(&thread2, NULL, &reader, NULL); pthread_create(&thread3, NULL, &writer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_join(thread3, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.4、线程同步之条件变量 条件变量是一种相对复杂的线程同步方法，不满足条件时允许线程休眠；当满足条件时，可以向该线程发送信号唤醒线程！ 在上图 生产者-消费者模型 中有两个不严谨的问题： 缓冲区小于等于 0 时，不允许消费者消费，消费者必须等待； 缓冲区满时，不允许生产者向缓冲区生产，生产者必须等待； 使用条件变量实现唤醒操作： 缓冲区等于 0 时：当生产者生产一个产品时，唤醒可能等待的消费者； 缓冲区满时：当消费者消费一个产品时，唤醒可能等待的生产者； 条件变量的工作过程： 对于条件变量，首先需要加锁保护条件变量或临界资源； 接着判断条件是否满足，如果不满足就等待（线程处于休眠状态），条件满足时被唤醒； 线程唤醒后，就可以对临界资源操作； 操作完成后解锁； #include #include #include #include #include #include #include int MAX_BUF = 100; /// 缓冲区最大数 int num = 0; /// 临界资源 /// 条件变量配合互斥量来使用 pthread_cond_t cond = PTHREAD_COND_INITIALIZER; ///条件变量 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥锁 void* producer(void*) { /// 生产者 while(true){ pthread_mutex_lock(&mutex); while (num >= MAX_BUF) { // 等待 printf(\"缓冲区满了, 等待消费者消费...\\n\"); pthread_cond_wait(&cond, &mutex); ///等待条件满足 } num += 1; printf(\"生产一个产品，当前产品数量为：%d\\n\", num); sleep(1); pthread_cond_signal(&cond); /// 唤醒 printf(\"通知消费者...\\n\"); pthread_mutex_unlock(&mutex); sleep(1); } } void* consumer(void*){ while(true){ pthread_mutex_lock(&mutex); while (num 1.5、线程同步方法总结 互斥锁、自旋锁、读写锁 对于临界资源的操作都是一样的： 首先为临界资源加锁；解锁成功后操作临界资源；操作完成后解锁； 加锁成功后其它线程不能访问临界资源；解锁后其它线程才可以访问临界资源； 发现需要访问的临界资源被加锁，就需要等待临界资源被解锁； 同步方法 描述 互斥锁 最简单的一种线程同步方法，会 堵塞线程 (让出 CPU) 自旋锁 避免切换的一种线程同步方法，属于忙等待 (不让出 CPU) 读写锁 为 读多写少 的资源设计的线程同步方法，可以显著提高性能 条件变量 相对复杂的一种线程同步方法，有更灵活的使用场景 2、进程同步 进程是计算机系统分配资源的最小单位（严格说来是线程）； 每个进程都有自己的一部分独立的系统资源，彼此是隔离的； 为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。 通常，使用进程间通信的两个应用可以被分为客户端和服务器（见主从式架构），客户端进程请求数据，服务端响应客户端的数据请求。 有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。 这些进程可以运行在同一计算机上或网络连接的不同计算机上。 进程间通信又称为 IPC，有：高级管道通信、有名管道通信、匿名管道通信、消息队列通信、信号量通信、信号通信、共享内存通信、套接字通信等！ 2.1、使用系统函数 fork() 创建进程 调用系统函数 fork() 创建进程： 进程有进程空间，包括内存以及一些内核态的东西；新创建进程的进程空间数据与父进程一摸一样！包括拥有的变量、逻辑空间等； fork() 创建的进程初始化状态与父进程一样； 系统会为 fork() 的进程分配新的资源，如内存资源、CPU资源等； fork() 调用没有参数； 调用一次 fork() 函数会有 两次 返回，分别返回子进程 id 和 0； 返回子进程id 的是父进程，返回 0 的是子进程； 为什么 fork() 函数会有 两次 返回？ 当调用 fork() 创建子进程的时候，子进程的初始化状态与父进程是一模一样的；父进程调用 fork() 创建完子进程的时候，子进程也拥有 fork() 函数的逻辑，因此 fork() 函数会返回两次！第一次由父进程返回被创建的子进程 id、第二次由子进程返回 0！ #include #include #include #include using namespace std; int main() { pid_t pid; int num = 888; pid = fork(); if(pid == 0) { cout 0){ cout 2.2、进程同步之共享内存 每一个进程都有一条或者多条线程，进程中的多条线程共享该进程资源； 线程之间需要通信、需要同步进程的一些资源状态，这就需要线程之间的信息同步； 一个操作系统中有一个或者多个进程，进程之间共享进算计资源，包括内存、磁盘等； 进程之间需要通信，如前文的生产者与消费者模型、哲学家进餐问题，这就需要进程之间的信息同步； 操作系统对进程内存的管理： 每一个进程都有自己的进程空间； 进程空间通过页表、段页式存储管理与实际的物理内存建立映射关系； 进程之间的进程空间是独立的、互不干扰的； 因此在某种程度上，多进程是共同使用物理内存的； 由于操作系统的进程管理，进程间的内存空间是独立的； 进程默认不能访问进程之外的内存空间，确保进程独立运行的安全性； 进程同步之共享内存： 共享存储允许不相关的进程访问同一片物理内存； 实现原理：将相同的物理内存分别映射到不同进程页表中，使得不同的进程可以通过页表来访问同样的一片物理内存； 共享内存是两个进程之间共享和传递数据最快的方式；实际中后台的很多高性能服务都是通过共享内存的来实现进程间通信； 但是共享内存没有提供同步机制，需要借助其它机制管理访问，以避免并发访问所带来的问题； 共享内存使用的四个步骤： 1、当前进程向操作系统申请一块共享内存 2、将共享内存连接到当前进程空间：只有连接到进程空间，进程才可以通过页表来访问共享内存； 3、当前进程使用共享内存，通过读、写来传递一些信息； 4、将共享内存脱离当前进程空间并删除； 2.2.1、操作系统提供了有关共享内存的 API #include /** 向操作系统申请一块共享内存 * @return 函数返回共享内存 id * 如果等于 -1 ，则申请失败 */ int shmget(key_t, size_t, int); /** 连接共享内存到当前进程空间 * @param1 申请的共享内存 id */ void* shmat(int, const void *, int); /** 断开共享内存到当前进程空间的连接 */ int shmdt(const void *); /** 断开共享内存到当前进程空间的连接 */ int shmctl(int, int, struct shmid_ds *); 2.2.2、使用 API 操作共享内存 定义一个共享内存的数据结构 #define TEXT_LEN 2048 // 共享内存的数据结构 struct ShmEntry{ // 是否可以读取共享内存，用于进程间同步 bool can_read; // 共享内存信息 char msg[2048]; }; 创建进程1 #include \"common.hpp\" #include #include #include #include #include #include int main() { // 共享内存的结构体 struct ShmEntry *entry; // 1. 申请共享内存 int shmid = shmget((key_t)1111, sizeof(struct ShmEntry), 0666|IPC_CREAT); if (shmid == -1){ std::cout can_read = 0; /// 锁定共享内存 while (true){ if (entry->can_read == 1){ std::cout msg can_read = 0; }else{ std::cout 创建进程2 #include \"common.hpp\" #include #include #include #include #include #include int main() { struct ShmEntry *entry; // 1. 申请共享内存 int shmid = shmget((key_t)1111, sizeof(struct ShmEntry), 0666|IPC_CREAT); if (shmid == -1){ std::cout can_read = 0; char buffer[TEXT_LEN]; while (true){ if (entry->can_read == 0){ std::cout >> \"; fgets(buffer, TEXT_LEN, stdin); strncpy(entry->msg, buffer, TEXT_LEN); std::cout msg can_read = 1; } } shmdt(entry); // 3. 脱离进程空间 shmctl(shmid, IPC_RMID, 0); // 4. 删除共享内存 return 0; } 执行程序 打开一个终端窗口 MacBook-Pro:process1 $ make g++ client.cpp -o client -g -lpthread MacBook-Pro:process1 $ ls Makefile client client.cpp client.dSYM MacBook-Pro:process1 $ ./client Input message>>> hello word Send message: hello word 再打开一个终端窗口 MacBook-Pro:process2 $ make g++ server.cpp -o server -g -lpthread MacBook-Pro:process2 $ ls Makefile server server.cpp server.dSYM MacBook-Pro:process2 $ ./server Entry can not read. Sleep 1s. Entry can not read. Sleep 1s. Received message: hellow word 我们在进程 1 向共享内存发送了 hellow word， 可以看到进程 2 接收到 进程 1 的 hellow word ! 2.3、进程同步之 Unix 域套接字 域套接字是一种高级的进程间通信的方法； Unix 域套接字可以用于同一机器多个进程间通信，不能跨机器使用； 套接字 socket 原是网络通信中使用的术语； Unix 系统提供的域套接字提供了网络套接字类似的功能，如可靠性； 前文提到的进程间共享内存需要额外的同步机制，同步多个进程间的通信； Unix 域套接字不需要额外机制来保证多个进程间的通信问题； 服务端有四个步骤： 1、创建套接字； 2、绑定 bind 套接字 3、监听 listen 套接字：监听是否有请求进来、或者监听是否有连接进来； 4、处理和接收信息 客户端不需要监听： 1、创建套接字； 2、连接套接字 3、发送信息 套接字 socket 提供了一种可靠的信息传递方式，相比于共享内存，不需要维护多个进程并发访问的机制！ 2.3.1、有关 socket 的 API /** 创建域套接字 * @param1 套接字类别 * @param2 套接字信息格式 * @return 返回套接字 id； 若是 -1 则创建失败； */ int socket(int, int, int); /** 绑定域套接字 * @param1 套接字 id * @param2 域套接字的文件路径 * 使用域套接字的话，将会在文件系统中创建一个连接客户端与服务端的文件 * @param3 域套接字的文件大小限制 */ int bind(int, const struct sockaddr *, socklen_t); /** 监听套接字 * @param1 套接字 id * @param2 最大所能监听的进程个数 */ int listen(int, int); /** 连接套接字 * @param1 套接字 id * @param2 服务端地址 * @param3 服务端大小 */ int connect(int, const struct sockaddr *, socklen_t); /** */ int accept(int, struct sockaddr * __restrict, socklen_t * __restrict) /** 发送信息 * @param1 套接字 id * @param2 发送的数据内容 */ ssize_t send(int, const void *, size_t, int); /** 接收套接字 * @param1 套接字 id */ ssize_t recv(int, void *, size_t, int); 2.3.2、测试用例 创建服务端 #include #include #include #include #include #include #include #include #include #include /// 使用域套接字的话，将会在文件系统中创建一个连接客户端与服务端的文件 /// 定义域套接字的文件路径 #define SOCKET_PATH \"./domainsocket\" #define MSG_SIZE 2048 int main() { int socket_fd, accept_fd; int ret = 0; socklen_t addr_len; char msg[MSG_SIZE]; struct sockaddr_un server_addr; // 1. 创建域套接字 socket_fd = socket(PF_UNIX,SOCK_STREAM,0); if(-1 == socket_fd) { std::cout ret){ std::cout 创建客户端 #include #include #include #include #include #include #include #include #include #include #define SOCKET_PATH \"./domainsocket\" #define MSG_SIZE 2048 int main() { int socket_fd; int ret = 0; char msg[MSG_SIZE]; struct sockaddr_un server_addr; // 1. 创建域套接字 socket_fd = socket(PF_UNIX, SOCK_STREAM, 0); if(-1 == socket_fd){ std::cout >> \"; fgets(msg, MSG_SIZE, stdin); /// 获取键盘输入信息 ret = send(socket_fd, msg, MSG_SIZE, 0); // 3. 发送信息 } close(socket_fd); return 0; } 执行程序 打开一个服务端窗口 MacBook-Pro:socket $ make g++ client.cpp -o client -g -lpthread g++ server.cpp -o server -g -lpthread MacBook-Pro:socket $ ls Makefile client.cpp server server.dSYM client client.dSYM server.cpp MacBook-Pro:socket $ ./server Binding socket... Listening socket... Waiting for new requests. Received message from remote: 你好 再打开一个客户端窗口 MacBook-Pro:socket $ ls Makefile client.cpp domainsocket server.cpp client client.dSYM server server.dSYM MacBook-Pro:socket $ ./client Input message>>> 你好 Input message>>> 我们在客户端发送了 你好， 可以看到服务端接收到 你好 ! 3、线程池 3.1、什么是线程池？ 线程池是存放多个线程的容器； 当 CPU 需要调度时从线程池取出线程调度，线程执行后不会销毁； 而是将线程放回线程池重复利用； 3.2、为什么需要线程池？ 线程属于稀缺资源，不应该频繁创建和销毁； 线程也有上下文，在创建线程和销毁线程的时候，需要额外的资源去控制； 架构解耦：线程创建和业务处理解耦，更加优雅；不应该在处理业务需要使用线程的时候才创建线程； 线程池是使用线程的最佳实践 3、操作系统的用户态与内核态 4、理解上下文切换 5、进程、线程、协程 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"计算机基础/计算机网络/网络概述篇.html":{"url":"计算机基础/计算机网络/网络概述篇.html","title":"第三部分 网络篇","keywords":"","body":"计算机网络篇 计算机网络主要由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据；并且可以支持广泛和日益增长的应用！ 计算机网络不仅仅是软件概念，还包含了硬件设备（网卡、网线、路由器）； 计算机网络不仅仅是信息通信，还可以支持广泛的应用； 分类 作用范围 区域 广域网 WAN 几十到几千公里 跨省、跨国 城域网 MAN 5KM ～ 50 KM 城市间 局域网 LAN 1 KM 以内 地区内 1、计算机网络的发展简史 1.1、互联网的发展历史 第一阶段：单个网络ARPANET 比较简单比较小的单个网络 是1969 年美国国防部创建的一个小型网络； 初衷是为了将附近的计算机连接起来； 主要由计算机和交换机构成，计算机直接通过交换机完成信息交互； 后来计算机进入了千家万户，小型网络已经不能满足人们的需求，计算机网络进入第二个阶段； 第二阶段：三级结构互联网 现代互联网的雏形； 主要由美国来使用该网络； 该阶段的网络可以将美国的大学、研究所、实验室连接起来； 随着计算机慢慢普及全球，互联网进入第三个层次 第三阶段：多层次 ISP 互联网 ISP (Internet Service Provider) 网络服务提供商，如中国的电信、联通、移动等； 此时、全球的计算机才连接起来，形成一个巨大的网络！ 现代国际互联网的主要线路；通过海底电缆连接不同的区域； 1.2、中国互联网的发展历史 第一阶段：1980 年开始互联网实验，由铁道部主导； 第二阶段：到了 1989 年第一个公共网络建立运行，包括公安、银行、军队等都建立了专用网络； 第三阶段：1994 年接入国际互联网，实现国际信息互通； 随着互联网的发展，中国也建立了多个计算机网络可以进行国际信息交换，有五个规模最大的： 中国电信互联网 CHINANET、中国联通互联网 UNINET、中国移动互联网 CMNET、中国教育与科研计算机网路 CERNET 、中国科学技术网 CSTNET ！ 2、计算机网络的层次结构 2.1、层次结构设计的基本原则 假如有计算机A 与计算机B 通过网络连接起来，那么计算机网络需要解决什么问题？ 保证数据通路顺畅；如果网络中断，那么数据将不能通信； 识别目的计算机状态：在互联网中有数量众多的计算机，那么计算机A 如何识别计算机B？计算机B又如何识别计算机A？ 查询目的计算机状态：如果 A 与 B 需要通信，那么计算机 A 需要通过网络知道计算机 B 是否在线、是否能够接收数据； 判断数据是否错误：在网络传输中由于各种原因导致数据丢失、错误，需要保证数据不会出错；出错后如何补救； 计算机网络需要解决繁多而复杂的问题！基于此，计算机网络采用分层设计、分层去解决不同问题、分层实现不同功能，以此来保证计算机网络的正常运行！ 一个简单的应用例子： 网络应用数据：顶层对于用户接触最多的数据，如视频、文件、游戏等； 数据可靠通信：用户不关心，但网络需要保证的；数据错误、重复； 物理网络接入：是通过网线、还是光纤连接到别的计算机；比较底层，涉及到光电等物理特性； 设计的基本原则： 各层之间是相互独立的：某一层并不需要知道上一层或者下一层是如何实现的；仅仅知道该层如何通过层级接口来提供服务；也就是说，每一层仅实现一个相对独立的功能，并且层与层的耦合度是非常低的； 每一层要有足够的灵活性：计算机网络是不断发展的，在设计每一层的时候就要求有足够的灵活性，以应对未来的变化； 各层之间完全解耦：某一层的上一层变化或者下一层变化，并不会影响到该层的稳定性；各层功能易于实现且方便维护、结构独立！ 2.2、OSI 七层模型 由国际标准定义的 OSI 七层模型，每一层完成不同的工作，并且层与层之间相互独立、互不干扰： 应用层：为计算机用户提供接口和服务；在使用计算机时，直接接触的是应用层； 表示层：数据处理（编码、解码、加密等）； 会话层：管理通信会话（建立、维护、重连）； 传输层：管理端到端的通信连接； 网络层：数据路由（决定数据在网络的路径）；数据从一个计算机到另一个计算机，路要怎么走，由网络层决定！ 数据链路层：管理相邻节点之间的数据通信； 物理层：数据通信的光电物理特性； 网络层管理数据在整个网络的路径，而数据链路层仅仅管理相邻节点之间的数据通信！ OSI 在制定之初，欲成为全球计算机网络都遵循的标准，促进全球计算机使用该标准互联、交换数据；但是 OSI 在市场化过程中困难重重，因为 TCP/IP 在全球范围内成功运行；因此 OSI 仅仅在理论方面获得一些成果，但市场化时没有成功推进，最终没有成为广为使用的标准模型！ OSI 不被市场接受的主要原因： OSI 的专家缺乏实际经验；仅仅基于理论而设计，缺乏实际的开发环境经验； OSI 标准制定周期过长，使得按 OSI 标准生产的设备无法及时进入市场； OSI 模型设计的并不合理，一些功能在多层中重复出现； 计算机网络更多的使用 TCP/IP 四层模型！ 2.3、TCP/IP 四层模型 应用层：HTTP、HTTPS、FTP、SMTP、POP3、DNS、Telnet、TFTP、DHCP 等协议； 传输层：TCP协议、UDP 协议； 网络层：IP协议 、ICMP 协议； 网络接口层：Ethernet、PPP 等 假设计算机 A 与计算机B 通过一个路由器连接在一起： 计算机A 首先通过 应用层 -> 传输层 -> 网络层 -> 网络接口层 与路由器通信； 计算机A 的数据通过 网络接口层 -> 网络层 来到路由器； 路由器根据网络层的数据进行数据转发，转发到计算机 B； 到达计算机 B 后，通过 网络接口层 -> 网络层 -> 传输层 -> 应用层 与用户交互； 2.4、一些常见的设备 路由器工作在计算机网络的物理层、数据链路层、网络层。 桥接器：桥接器有别于路由器。路由器允许多个网络之间的独立通信，但又保持区隔，而桥接器则是将两个独立的网络连接起来，就如同单一网络。如果所桥接的网络有一个以上的区段是无线网络，则该设备称为无线桥接器。 网卡，又称局域网接收器（LAN adapter），是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。 由于其拥有 MAC 地址，因此属于数据链路层；它使得用户可以通过电缆或无线相互连接。 每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号，它被写在卡上的一块 ROM 中。 在网络上的每一个计算机都必须拥有一个独一无二的 MAC 地址；没有任何两块被生产出来的网卡拥有同样的地址。 这是因为电气电子工程师协会（IEEE）负责为网络接口控制器销售商分配唯一的 MAC 地址。 交换机：交换机是一种多端口的网桥，在数据链路层使用 MAC 地址转发数据。 通过引入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。 集线器：（Ethernet hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备。集线器是运作在 OSI 模型中的物理层，可以让其链接的设备工作在同一网段。集线器上有多个 I/O 端口，信号从任意一个端口进入后，会从其他端口出现。 3、现代互联网的网络拓扑 3.1、边缘部分与核心部分 我们可以将现代互联网的网络拓扑分为边缘部分与核心部分！ 边缘部分指的是平时用户可以直接接触的部分，如家庭部分、企业部分、商场部分等！ 核心部分主要由地区 ISP、主干 ISP 、以及一些国际路由器组成！主干 ISP 相互连接，并通过国际路由器与其它地区、其它国家的主干 ISP 连接； 边缘部分之家庭 如家庭部分，由手机、电脑、平板、智能家电（扫地机器人）等终端机器组成； 这些终端机器通过有线或者无线，连接到家里的路由器；路由器与终端机器直接接触； 路由器与当地的网关连接；一个网关可以连接一个或者多个路由器； 网关连接到地区 ISP （网络服务提供商：如上海电信、北京联通等）； 边缘部分之企业 如边缘的企业部分 有数量众多的计算机等终端、路由器、内部网关； 内部网关之间互相连接，路由器在其中进行报文转发、连接中转等； 统一网关：收敛内部的众多网关，提供唯一一个对外出口，和地区 ISP 连接； 3.2、用户角度的互联网模式 从用户角度看待互联网，常见互联网模式有：客户服务器模式(C/S) 、对等连接模式(P2P)等 客户服务端模式(C/S) 由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式； 该模式表现为在互联网寻求服务，如发邮件、查找资料等； 客户端是服务的请求方，服务端是服务的提供方；双方通过互联网连接起来； 互联网中有很多设备相互连接；而不论是客户、服务器，都不需要感知互联网的具体细节； 需要使用某个服务的时候，客户直接从自己的计算机发起服务；该服务通过路由来到服务器，服务器收到请求后就会响应，然后客户的获得应答。 对等连接模式(P2P) 多个终端通过边缘部分连接到网络的核心部分； 不区分客户端和服务端；只要终端运行 P2P 程序，双方就可以进行平等的、对等连接通信； 对等的连接方式，可以支持大量的对等用户；如视频的下载、文件的下载，P2P 使得下载速度更快； 4、计算机网络的性能指标 了解计算机网络的性能指标，可以有助于我们去评估、判断网络的质量、速度等！ 4.1、网络时延 计算机的时延，可以细分为四个部分： 发送时延：本机发送网络数据时，在本地停留的时间 传播时延： 排队时延：数据包在网络设备中等待被处理的时间； 如某个数据由本机发送到路由器，路由器收到数据后并非马上处理； 路由器可能处理很多数据包，新来的数据包需要排队等待路由器来处理； 路由器处理完该数据包之后，才会发送到下一个节点； 处理时延：数据包到达设备或者目的机器被处理所需要的时间；如果数据包到达的服务器性能不好， 那么该服务器可能需要反应一段时间才能处理数据包。 发送时延 = (数据长度 bit) / (发送速率 (bit/s)); * 数据长度由用户决定：如发送 1G 的视频；100M 的文件等； * 发送速率受限于计算机网卡，如千兆网卡、万兆网卡等； 网卡性能越好，发送速率越快； 传播时延 = 传播路径距离 / (传播速率 (bit/s)); * 传播路径距离：从一个地区到另一个地区，如上海到北京； 如上海到纽约，还需要经过海底电缆，传输距离就很长； * 传播速率受限于传输介质：可以使用铜线、光纤等介质； 计算机的总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延; 4.2、往返时间 RTT 往返时间 RTT RTT (Route-Trip Time) 是评估网络质量的一项重要指标； RTT 表示的是数据报文在端到端通信中来回一次的时间； 如客户端对服务器的一条请求，请求报文从客户端到服务器、服务器再返回相应报文到客户端的时间！ 通常使用 ping 命令查看 RTT； MacBook-Pro $ ping 119.29.12.253 PING 119.29.12.253 (119.29.12.253): 56 data bytes 64 bytes from 119.29.12.253: icmp_seq=0 ttl=113 time=110.518 ms 64 bytes from 119.29.12.253: icmp_seq=1 ttl=113 time=158.723 ms 64 bytes from 119.29.12.253: icmp_seq=2 ttl=113 time=204.338 ms 64 bytes from 119.29.12.253: icmp_seq=3 ttl=113 time=447.768 ms 64 bytes from 119.29.12.253: icmp_seq=4 ttl=113 time=37.928 ms 64 bytes from 119.29.12.253: icmp_seq=5 ttl=113 time=40.197 ms Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:32:47 "},"计算机基础/计算机网络/计算机物理层.html":{"url":"计算机基础/计算机网络/计算机物理层.html","title":"计算机物理层","keywords":"","body":"计算机物理层 物理层属于 OSI 模型的最底层，TCP/IP 模型的数据接口层！ 简单的说，网络的物理层面确保原始的数据可在各种物理媒体上传输。物理层规定：为传输数据，需要物理链路与设备的创建、维持、拆除，并具有机械的、电子的、功能的、规范的特性。 1、物理层的作用 物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流。 连接不同的物理设备： 如主干 ISP 通过 海底电缆 连接起来、如路由器通过 网线 连接起来；海底电缆、网线均属于物理层； 传输比特流：0/1 的数字信号！ 不同的传输介质 双绞线 同轴电缆 光纤 比特流 比特流就是由 0/1 组成的数字信号，表现为高低电平。 物理特性 我们往往关注物理层的一些物理特性，如机械特性、电气特性、功能特性、过程特性！ 2、信道的基本概念 信道是往一个方向传送信息的媒体； 一个通信电路包含一个接收信道和一个发送信道； 一个通信电路中的接收信道、发送信道可能冲突嘛？设计上不会冲突： 单工通信信道：只能往一个方向通信，没有反方向的信道；只能发送或者接收数据； 如生活中常见的有线电视、无线收音机等只能接收，不能发送信息； 半双工通信信道：双方都可以发送和接收信息； 但双方不能同时发送或者同时接收；一方发送，另一方只能接收； 全双工通信信道：双方都可以同时发送和接收信息。 3、分用-复用技术 如果两个计算机需要通信，在它们之间需要有一条通信电路；通信电路中包含发送信道、接收信道； 如果有多台计算机需要通信，就需要多条通信电路； 但是在大部分时候，这些通信电路处于关机状态并不活跃； 导致信道利用效率并不高； 因此提出 分用-复用技术，提升信道利用率； 多个计算机连接复用器；多个计算机连接分用器； 通过复用器、分用器，共享一条通信电路，大大提升信道利用率； 但如果多台计算机的通信频率很高，又使用了复用器、分用器；这会导致信道的拥塞； 复用技术也可以分为时分复用、波分复用、码分复用、频分复用(按频率不同来进行信道复用) 等！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-28 18:32:16 "},"计算机基础/计算机网络/计算机数据链路层.html":{"url":"计算机基础/计算机网络/计算机数据链路层.html","title":"计算机数据链路层","keywords":"","body":"计算机数据链路层 数据链路层在 OSI 模型中位于物理层上层，数据链路层与物理层组成了 TCP/IP 模型的数据接口层！ 1、数据链路层的几个重要功能 数据链路层的三个重要功能分别是封装成帧、透明传输、差错检测！ 1.1、封装成帧 帧 是数据链路层的基本单位； 发送端的数据链路层接收到网络层的一段数据，会把数据前后添加特定标记，形成数据帧； 接收端接收到数据后，会根据前后特定标记识别出帧； 物理层不会关注 数据帧，仅仅是数据的传输； 在网络层，会把一些 IP 数据报传送到数据链路层； 数据链路层接收到数据后，会在数据前添加帧首部、在数据后添加帧尾部； 帧的长度：从帧的首部开头、到帧尾部的结尾； 帧首部、帧尾部都是特定的控制字符（特定比特流），如 SOH:00000001, EOF:00000100； 假如数据里面也包含这些比特流，该这么办呢？ 1.2、透明传输 透明 在计算机领域是一个非常重要的术语； 对于数据链路层来说，物理层的工作是透明的；物理层仅需提供一些 API 即可； 一种实际存在的事物，却又看起来不存在一样； 控制字符在帧数据中，但是要当作不存在一样，去处理； 上图的数据报中恰好有一个 EOT 的控制字符 如果没有进行透明传输，接收端很可能将该字符当作帧尾部，这就导致了一个错误的帧数据； 对数据中出现的特殊字符特殊处理：如果数据报文中包含 EOT，则在 EOT 字符前加一个转义字符 ESC； 接收端接收到数据，读取到 EOT 字符时会判断前面是否有转义字符 ESC； 如果有，则认为是数据报中的数据；如果没有，则是一个报文的结尾； 如果数据报中也出现转义字符该这么办呢？对转义字符再做一次转义。 编程语言中的 \\ 一般作为转义字符； \\n、 \\t 等控制字符； 1.3、差错监测 物理层只管传输比特流，无法控制是否出错； 如果物理层在传输数据时，出现了一些干扰导致数据丢失，物理层是无法察觉其出错的； 数据链路层负责 “差错监测”的工作； 1.3.1、奇偶校验码 一种简单的校验比特流是否传输错误的方法； 通过在比特流尾部添加一位比特位来检测比特流是否出错； 假设需要传输比特流 00110010； 使用奇偶校验码在其尾部增加一位比特位 1 （ 0 + 0 + 1 + 1 + 0 + 0 + 1 + 0 = 3 % 2 = 1）； 当接收端接收到比特流数据后，会根据尾部的比特位 1 来判断数据是否出错； 假设传输过程发生错误变为 00010010，接收端检验为 0 与尾部 1 不合； 假设传输过程发生错误变为 00000010，接收端检验为 1 与尾部 1 相合；此时无法发现传输的数据出错； 局限性：比特流在传输过程中出现两位错误，奇偶校验码检测不到错误！ 1.3.2、循环冗余校验码 CRC 循环冗余校验码 CRC 是一种广泛使用的差错监测的算法： 根据传输或保存数据而 产生固定位数检验码 的方法；产生的固定位数，可能是一位、或者多位； 可以检测数据传输或者保存后可能出现的错误； 与奇偶校验码的过程类似：生成一些数字然后附加到数据后面；接收端接收到数据后根据附件到后面的数据来判断接收的数据是否出错； 循环冗余校验码 CRC 步骤 选定一个用于校验的多项式 G(x) ，并在数据尾部添加 r 个 0； 将添加 r 个 0 后的数据，使用模 2 相除法除以多项式的位串； 得到的余数填充在原数据 r 个 0的位置得到可校验的位串； /// 例1：使用 CRC 计算 101001 的可校验位串 G(x) = 1 * x^3 + 1 * x^2 + 0 * x^1 + 1 * x^0 = x^3 + x^2 + 1 => 二进制位串为 1101，最高阶为 3 setp1：尾部添加 3 个 0 => 101001 000 _______________ 1101 | 101001 000 1101 ____ 循环冗余校验码 CRC 的检错能力与位串的阶数 r 有关； 阶数越多，检测的能力越强；如果 r = 1 ，就是一个奇偶校验算法； 数据链路层仅仅校验数据，而不纠正数据； 如果检测到数据出错，数据链路层简单粗暴地直接丢弃错误数据； CRC 多项式 G(x) 规范 常用 CRC（按照 ITU-IEEE 规范） 名称 多项式 表示法：正常或者翻转 CRC-1 x + 1 (用于数据链路层，也称为奇偶校验位) 0x1 or 0x1 (0x1) CRC-5-CCITT x5 + x3 + x + 1 , ITU G.704 标准 0x15 (0x??) CRC-5-USB x5 + x2 + 1 ，用于 USB 信令包 0x25 or 0x14 (0x9) CRC-7 x7 + x3 + 1 ，用于通信系统 0x09 or 0x48 (0x11) CRC-8-ATM x8 + x2 + x + 1 ，用于ATM HEC 0x07 or 0xE0 (0xC1) CRC-8-CCITT x8 + x7 + x3 + x2 + 1 ，用于 1-Wire 总线 CRC-8-Dallas/Maxim x8 + x5 + x4 + 1，用于 1-Wire bus 0x31 or 0x8C CRC-8 x8 + x7 + x6 + x4 + x2 + 1 0xEA(0x??) CRC-10 x10 + x9 + x5 + x4 + x + 1 0x233 (0x????) CRC-12 x12 + x11 + x3 + x2 + x + 1，用于通信系统 0x80F or 0xF01 (0xE03) CRC-16-Fletcher 参见 Fletcher's checksum，用于 Adler-32 A & B CRC CRC-16-CCITT x16 + x12 + x5 + 1，用于X25, V.41, Bluetooth, PPP, IrDA 0x1021 or 0x8408 (0x0811) CRC-16-IBM x16 +x15 + x2 + 1 0x8005 or 0xA001 (0x4003) CRC-16-BBS x16 + x15 + x10 + x3，用于 XMODEM 协议 0x8408 (0x????) CRC-32-Adler See Adler-32 ,参见 Adler-32 CRC-32-MPEG2 See IEEE 802.3, 参见 IEEE 802.3 CRC-32-IEEE 802.3 x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x+ 1 0x04C11DB7 or 0xEDB88320 (0xDB710641) CRC-32C (Castagnoli) x32 + x28 + x27 + x26 + x25 + x23 + x22 + x20 + x19 + x18 + x14 + x13 + x11+ x10 + x9 + x8 + x6 + 1 0x1EDC6F41 or 0x82F63B78 (0x05EC76F1) CRC-64-ISO x64 + x4 + x3 + x + 1，用于 ISO 3309 0x000000000000001B or 0xD800000000000000 (0xB000000000000001) CRC-64-ECMA-182 x64 + x62 + x57 + x55 + x54 + x53 + x52 + x47 + x46 + x45 + x40 + x39 + x38+ x37 + x35 + x33 + x32 + x31 + x29 + x27 + x24 + x23 + x22 + x21 + x19 + x17 + x13 + x12 + x10 +x9 + x7 + x4 + x + 1 0x42F0E1EBA9EA3693 or 0xC96C5795D7870F42 (0x92D8AF2BAF0E1E85) CRC-128 IEEE-ITU 标准。被 MD5 & SHA-1 取代 CRC-160 IEEE-ITU 标准。被 MD5 & SHA-1 取代 补充知识：模 2 除法 异或：两个比特位数据相同，则运算结果为 0；如果不同，运算结果为 1； 模 2 除法是二进制下的除法；与算术除法类似，但模 2 除法不错位，本质就是一个 异或 的位运算； 2、最大传输单元 MTU 最大传输单元 MTU 相关概念： 最大传输单元 MTU （Maximum Transmission Unit） 数据链路层传输的数据帧也不是无限大的，MTU 描述可以传输的最大数据帧； 数据帧过大、过小都会影响传输效率； 数据帧过大，则发送时延、排队时延、传播时延、处理时延都会增大；导致发送端与接收端数据处理信息的时间过长； 常见的以太网 MTU 一般为 1500 字节； 3、以太网协议 计算机A 通过网络拓扑，向计算机 C 发送数据！那么中转数据的路由器又如何知道该数据又谁接收呢？ 3.1、以太网协议概述 以太网协议是数据链路层广泛使用的的局域网技术； 使用该协议可以完成 相邻设备 的数据帧传输； 3.2、MAC 地址表 MAC 地址属于硬件地址，每一台设备都有唯一的 MAC 地址地址；可以将 MAC 地址当做设备的身份证号！MAC 地址共有 48 位，使用十六进制表示！ 3.3、数据传输中转过程 疑问：计算机A 通过网络拓扑，向计算机 C 发送数据！那么中转数据的路由器又如何知道该数据又谁接收呢？ 路由器拥有一张 Mac 地址表； A 通过网卡发出以太网数据帧； 数据帧到达路由器，路由器取出其前 6 个字节 （目的机器的 Mac 地址 ）； 路由器查询其 Mac 地址表， 找到对应的网络接口（ E3 ，我们知道是计算机 C）； 路由器向该网络接口发送数据帧；从而完成数据从 A 到 C 的发送与接收的过程； 在上述过程中，发挥重要作用的是路由器的 Mac 地址表；但如果 Mac 地址表并不知道计算机 C 的硬件接口是哪一个，那该怎么办呢？ 路由器查询其 Mac 地址表，没有发现计算机 C 的信息； 路由器将广播计算机 A 的数据包到除 A 以外的端口（计算机 B、C）； 路由器收到计算机 B、C 的回应，并将这些 Mac 地址记录下来； 此时，路由器根据 Mac 地址表知道数据包的目的机器是计算机 C；就可以向计算机 C 发送数据了。 Mac 地址表只能指定一个数据帧的下一个地址是什么；即Mac 地址表只能进行相邻物理节点传输！ 从计算机 A 发送数据到计算机D ，可以经路由器 E 来中转；但如果从计算机 A 发送出数据到计算机 C ，该怎么处理呢？ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-28 18:34:06 "},"计算机基础/计算机网络/计算机网络层.html":{"url":"计算机基础/计算机网络/计算机网络层.html","title":"计算机网络层","keywords":"","body":"计算机网络层 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-28 18:26:02 "},"计算机基础/计算机网络/计算机传输层.html":{"url":"计算机基础/计算机网络/计算机传输层.html","title":"计算机传输层","keywords":"","body":"计算机传输层 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-28 18:26:11 "},"计算机基础/计算机网络/计算机应用层.html":{"url":"计算机基础/计算机网络/计算机应用层.html","title":"计算机应用层","keywords":"","body":"计算机应用层 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-28 18:25:52 "},"C_C++篇/C++学习入门篇.html":{"url":"C_C++篇/C++学习入门篇.html","title":"C++学习入门篇","keywords":"","body":"C++ 学习入门篇 C++ 是 C 的超集，在 C 语言的基础上发展而来，因此 C 语言更加高效！ C++ 是一门面向对象的编程语言！ 1、基础篇 1.1、基本数据类型 C 基本数据类型： 基本类型 ：整型、浮点型、字符型 ； 构造类型 ：数组、结构、枚举、联合； 指针类型 ； 空类型 ； C++ 具有 C 语言的所有基本数据类型，并且多了一个布尔类型：bool:true、false; 1.2、新的初始化方法 C 语言提供的初始化方法 ： /// 复制初始化 int a = 10; C++ 语言提供的初始化方法 ： /// 复制初始化 int a = 10; /// 直接初始化 int a(10); 1.3、随用随定义 C 语言所有变量定义都必须位于函数体最前面 ： { int a = 10; int b = 20; a = a + 3; b = b + a; } C++ 中所有变量随用随定义 ： { int a = 10; a = a + 3; int b = 20; b = b + a; } 1.4、输入输出流 C 语言的 I/O 方式 : 输入过程 : 输入设备 -> 输入流 -> scanf -> 变量； 输出过程 : 变量 -> printf -> 输出流 -> 输出设备 ； C++ 语言的 I/O 方式 ： 输入过程 : 输入设备 -> 输入流 -> cin -> 变量 ； 输出过程 : 变量 -> cout -> 输出流 -> 输出设备 ; /// 输出语法： cout > x; cin >> x >> y; 与 C 语言相比，C++ 的cin与cout的便利： 不用关注占位符； 不用关注数据类型； *不容易出现问题； 1.5、命名空间namespace 命名空间namespace是 C++ 新引入的一个机制，主要是为了解决多个模块间命名冲突的问题，就像现实生活中两个人重名一个道理。 /// 使用命名空间 std using namespace std; C++ 需要用不同的名字区分不同的命名空间！通过不同的命名空间，可以区分具有相同名字的变量，可以区分具有相同名字的函数！ /// 定义命名空间 namespace YLProject { int chapter; void test(); } namespace WLProject { int chapter; void test(); } void demoTest(void) { YLProject::chapter = 10; WLProject::chapter = 20; YLProject::test(); WLProject::test(); } 2、特性篇 2.1、指针 VS 引用 引用即 变量的别名！ 引用不能单独存在，必须有对应的变量名！ 针对别名的操作就是对其本身的操作！ 基本数据类型的引用 { int a = 10; int &b = a; b = 3; } 结构体类型的引用 { Coordinate c1; Coordinate &c2 = c1; c2.latitude = 9.234; c1.longitude = 4.243256; } 指针类型的引用 指针类型的引用：类型 *&指针别名 = 指针； { int m = 90; int *p = &m; int *&q = p; *p = 80; *q = 70; } 引用作函数参数 /// C 语言交换两个变量的值 void quoteFuncCTest(int *a, int *b) { int c = 0; c = *a; *a = *b; *b = c; } /// C++ 使用引用交换两个变量的值 void quoteFuncTest(int &a, int &b) { int c = a; a = b; b = c; } ///测试代码段 { int k1(78),k2(87); quoteFuncCTest(&k1, &k2); quoteFuncTest(k1, k2); } 2.2、#define VS const 与#define相比，const修饰的变量是由类型的！在编译阶段，编译器可以检查const修饰的变量的类型错误，而不会去检查 #define 修饰的变量的类型错误！ 存储类别说明符 const 指明被修饰的变量为只读类型，用于防止变量值被篡改！ 一般而言，声明的一个变量既具有读权限、又具有写权限！ 而使用 const 修饰的变量，仅仅具有读权限！ 为数据安全考虑，编译器允许声明一个只读权限的变量指向一个具有读写权限的变量；而不会允许一个具有读写权限的变量指向一个只读权限的变量！ const与 基本数据类型 { int a = 3;/// 变量 const int b = 5;/// 常量 } 变量名|存储地址|存储内容 -|-|- a|&a|3 b|&b|5 const 与 指针类型 const修饰指针要特别注意，共有两种形式： 一种是用来限定指向空间的值不能修改； 另一种是限定指针不可更改。 { int a = 5, b = 10, c = 15; const int *p = &a; /// int const *p = &a; 两种写法完全等价，const 修饰的都是 *p，此时不能通过 *p 来赋值 p = &b; /// 正确，const 修饰的是 *p， *p = 1; // ❌ const 修饰的是 *p，因此 *p 不能修改 int *const k = &b; /// const 修饰 k，此时不能通过 k 来赋值 k = &c; // ❌ 此时 const 修饰 k *k = 100; /// 正确 /// 不能通过指针 m 来修改值，也不能将指针 m 指向它处！ int const *const m = &b; ///完全等价于 const int *const m = &b; } const 与 函数 const修饰函数参数，对参数起限定作用，防止其在函数内部被修改。所限定的函数参数可以是普通变量，也可以是指针变量。 int sum(const int a,const int b) { return a + b; } int max(const int &a,const int &b) { if (a > b) return a; return b; } const 与 引用 { int a = 5; const int &y = a; a = 10; /// 正确 y = 20; /// ❌ } const 小结 const int x = 3; x = 5; /// ❌ int x = 3; const int y = x; y = 5; /// ❌ int x = 3, z = 4; int *const y = &x; y = &z; /// ❌ const int x = 3; const int &y = x; y = 5; /// ❌ /// 注意：变量 x 具有读写权限，指针 y 只具有读权限，允许使用权限小的变量接收权限大的变量 int x = 3; const int *y = &x; *y = 5; /// ❌ /// 注意：变量 x 具有写权限，指针 y 只具有读写权限，不允许使用权限大的变量接收权限小的变量 const int x = 3; int *y = &x; /// ❌ 2.3、函数特性 2.3.1、函数参数默认值 函数参数默认值需要记住两条规则： 有默认值的参数必须在参数列表的最右端； 无实参则用默认值，否则实参覆盖默认值； void func(int a, int b = 10, int c = 15); /// 有默认值的参数必须在参数列表的最右端 void func(int a = 5, int b, int c); /// ❌ void func(int a, int b = 10, int c = 15) { /// 无实参则用默认值，否则实参覆盖默认值 cout 注意：函数默认值建议写在声明处，所有的编译器都可以通过；如果在函数定义处写默认值，部分编译器可能不通过！ 2.3.2、函数重载 函数重载需要满足下述条件： *在相同作用域下； *用同一函数名定义的多个函数； *参数个数和参数类型不同； int max(int a, int b); /// max_int_int int max(int a, int b, int c); /// max_int_int_int double max(double a, double b); /// max_double_double double max(double a, double b, double c); /// max_double_double_double 思考：编译器如何识别重载的函数呢？ 答：编译器会将函数编译为函数名称 + 参数的样子，来区别重载的函数；调用时，编译器根据入参的类型与个数，调用不同的函数！ 2.3.3、内联函数 调用普通函数的五大步骤： 1、调用func()； 2、跳转函数 func()的入口； 3、执行函数 func()； 4、回到主函数的调用处 ； *5、结束func()的调用； 与普通函数相比，在定义上，区别不大！但在调用上，内联函数更加的高效：在编译时将函数体代码和实参代替函数调用语句，少了跳转函数入口、回到主要函数的步骤！ 某些时候，执行函数 func()的消耗时间并不长，但是执行 ②、④ 两个步骤消耗了比较长的时间！此时使用内敛函数，更加高效！使用关键字inline声明一个内联函数！ /// 内敛函数仅是一种编译方式 inline int max(int a, int b){ if (a > b) return a; return b; } 思考: 为什么不把所有的函数声明为内联函数呢？ 内联函数是建议性的，由编译器决定； 逻辑简单，调用频繁的函数建议使用内联函数； *递归函数无法使用内联方式； 2.4、内存管理 内存的本质就是一种由操作系统掌管的内存资源；开发者被允许向系统申请内存资源，同时被要求使用完毕后归还这部分内存资源！ 在 C 语言中使用 void *malloc(size_t size) 函数申请内存资源，使用 void free(void *p)函数归还内存资源； 而 C++ 中使用运算符new申请内存资源，使用运算符delete归还内存资源； { /// 内存的申请与释放 int *p = new int(20); if (p != NULL) { cout 注意：申请内存需要判断是否申请成功；释放内存，需要将指针指向NULL； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"C_C++篇/C++学习封装篇.html":{"url":"C_C++篇/C++学习封装篇.html","title":"C++学习封装篇","keywords":"","body":"C++ 学习封装篇 1、类与对象 类是用户定义的数据类型规范，它详细的描述了如何表示信息以及可对数据执行的操作。 对象是根据类规范创建的实体，就像简单变量是根据类型描述创建的实体一样。 1.1、类的定义 与 实例化对象 1.1.1、 使用关键字 class 定义一个 People 类 class People { }; 1.1.2、数据的封装 C++ 作为一门面向对象的语言，通过 封装 将数据成员与成员函数封装在一个类中；通过 class 定义的类公布其接口。 /// 使用关键字 class 定义一个类 class People { /// 公有成员 public: std::String name; float height; void eat(std::String food); /// 受保护 protected: int age; /// 私有成员 private: float weight; }; 可以使用 访问限定符 public | protected | private 选择暴露或者隐藏某些类的信息！在类中，访问限定符可以使用一个、也可以使用多个！ public： 公有的；可以在外部访问，读写； protected： 受保护的；被修饰的成员不能在外部被访问；只能在类定义内部读写； private： 私有的；被修饰的成员不能在外部被访问；只能在类定义内部读写； 1.1.3、分别在栈中与堆中实例化 People 对象 { /// 栈中实例化对象 People zhangSan; People peos[10]; /// 堆中实例化对象 People *liSi = new People(); People *rens = new People[10]; /// 对象的成员访问 cout height eat(); delete liSi; liSi = NULL; } if (rens != NULL){ cout height 1.2、类内定义与类外定义 成员函数的函数体写在类的定义体之内、还是外面，是有区别的： 类内定义：函数体写在类的定义体之内； 类外定义：函数体写在类的定义体之外；类外定义的函数可以重载； 一般而言，将类的声明与实现分为两个文件： 同文件类外定义：类的定义、与成员函数的实现，都在一个文件中！ 分文件类外定义：类定义在 People.hpp 文件，而成员函数的实现，主要在 People.cpp 文件中！ /// 类外定义的格式 void People::eat(std::String food) { cout 不得不提：对于类内定义的函数体，编译器会优先使用 inline 的方式来编译这些函数；但对于复杂的函数，还是会编译为普通的函数！ 1.3、对象指针 对象指针指向一块堆内存（第一个成员的地址） 堆中内存 ：运算符 new 与函数 malloc() 的区别 : new 会调用默认构造函数; malloc() 仅仅开辟内存，不会初始化这段内存的数据； { ///对象指针 peo 指向一块堆内存 People *liSi = new People; /// new 一个类后面，不加 () 则调用默认构造函数 if (liSi != NULL){ cout name 1.4、this 指针 this 指针就是指向自身数据的指针！ 说的通俗点， this 指针指向其类实例对象的起始地址！ 参数与数据成员同名怎么办？ class People { public: /// 参数与数据成员同名怎么办？ setHeight(float height) { /// 注意：此时编译器无法识别两个 height 的含义 /// 导致无法达到预期的赋值结果 height = height; } private: float height; }; 上述代码中 参数与数据成员同名 ,导致赋值失败！碰见这种情况，我们应该使用this 指针指向自身的数据成员！ class People { public: setHeight(float height) { /// this 指针一般写在容易混淆的地方 this -> height = height; } private: float height; }; 成员函数如何访问到对应的数据成员？ 实例对象的变量存储在栈区或者堆区，而编译的类的二进制文件存储在代码区！当一个类创建多个对象时： 编译器是如何区分哪个对象调用了成员函数 setHeight() 呢？ 编译器是如何在成员函数 setHeight() 中为对应的对象赋值，而没有产生混乱呢？ class People { public: setHeight(T *this, float height) { /// 编译器自动的为每个成员函数的参数列表添加了一个 this 指针！ this -> height = height; } private: float height; }; 编译器自动的为每个成员函数的参数列表添加了一个 this 指针！因此当不同对象调用同一个成员函数时，不会混淆调用者！ this 指针添加到成员员函数的位置！ 添加到第一个位置？最后一个位置？ 打印自身 class People { public: setHeight(float height) { this -> height = height; } /// 通过引用的方式，打印自身 People &printfPeople(){ return *this; } /// 通过指针的方式，打印自身 People *printfPeople(){ return this; } private: float height; }; this 指针总结： this 指针无需用户定义，是编译器自动产生的！ 同一个类的多个对象的this 指针，指向其实例的内存地址！ 当成员函数的参数或临时变量与数据成员同名时，可以使用 this 指针区分同名的数据成员； this 指针也是指针类型，在 64 位编译器下占用 8 个字节的内存！ 2、构造函数与析构函数 内存分区 解释 栈区 int a = 5; int *p = NULL; 堆区 int *q = new int[10]; 全局区 存储全局变量及静态变量 常量区 String str = \"Hello\" 代码区 存储编译之后的二进制代码 2.1、构造函数 构造函数的规则和特点： 构造函数在对象实例化时被自动调用 构造函数与类名同名； 构造函数没有返回值； 构造函数可以有多个重载形式（遵循重载函数的规则）； 构造函数的参数列表，可以有默认值； 实例化一个对象时，仅仅用到一个构造函数； 当用户没有定义构造函数时，编译器自动生成一个构造函数； 2.1.1、无参构造函数 构造函数内部为一些成员变量赋值 class People { People(){ name = \"人类\"; } private: String name; } 2.1.2、有参构造函数 class People { People(String name); private: String name; } People::People(String name){ this -> name = name; } 2.1.3、重载构造函数 class People { People(); People(String name); People(int age, String name = \"狗蛋\"); /// 构造函数也可以有默认参数 public: String name; private: int age; } People::People(){ name = \"人类\"; age = 0; } People::People(String name){ this -> name = name; age = 0; } People::People(int age, String name){ this -> name = name; this -> age = age; } 2.1.4、默认构造函数 在实例化对象时，如果不使用任何参数，则调用的是默认构造函数！ 当构造函数没有参数时，被称为默认构造函数； 当构造函数有参数，但每个参数都有默认值时，也被称为默认构造函数； class People { People(); People(String name = \"狗蛋\"); public: String name; } People::People(){ name = \"人类\"; } People::People(String name){ this -> name = name; } 2.1.5、构造函数初始化列表 推荐使用初始化列表来完成对数据成员的初始化操作！ class People { People():name(\"狗蛋\"),age(10); public: String name; private: int age; } 初始化列表特性： 初始化列表先于构造函数执行； 初始化列表只能用于构造函数； 初始化列表可以同时初始化多个数据成员； 初始化列表存在的必要性 class People { People(){ species = \"人类\"}; /// ❌ const修饰，不能修改 People():species(\"人类\"); ///可以通过初始化列表完成 const 常量的修改 public: const String species; } 2.1.6、拷贝构造函数 定义格式： 类名(const 类名& 变量名) ! class People { People(const People &peo){}; public: }; 拷贝构造函数特性： 如果没有自定义的拷贝构造函数，则系统自动生成一个默认的拷贝构造函数； 当采用直接初始化或复制初始化实例化对象时，系统自动调用拷贝构造函数； 拷贝构造函数的参数时确定的，不能重载； 浅拷贝 class People { public: People(){ this -> age = 10; this -> name = new string(\"堆中申请内存\"); }; /// 浅拷贝 People(const People &peo){ this -> age = peo.age;/// 没毛病 /// 指针 name 指向同一块内存 /// name 时通过 new 运算符申请的块内存，需要在 析构函数 中释放该块内存 /// 两个对象释放同一块内存，会造成内存的过度释放，引起程序崩溃 this -> name = peo.name; }; ~People(){ delete name; } int age; string *name; }; string 的浅拷贝是让两个不同的指针指向同一块空间，而这在析构的时候会出现将一块空间释放两次，程序会崩溃! 因此需要进行深拷贝，即第二个指针开辟和第一个指针一样大小空间，然后将内容复制过去。 深拷贝 class People { public: People(){ this -> age = 10; this -> name = new string(\"堆中申请内存\"); }; People(const People_YL &peo){ this -> age = peo.age; this -> name = new string((*peo.name)); /// 深拷贝 }; ~People(){ delete name; } int age; string *name; }; 2.2、析构函数 对象的生命历程： 申请内存 -> 初始化列表 -> 构造函数 -> 参与运算 -> 析构函数 -> 释放内存！ 申请的内存，最终要归还 如果没有自定义析构函数，则系统自动生成； 析构函数在对象被销毁时，系统自动调用！ 析构函数没有返回值；不允许添加任何参数，也就不会重载！ 析构函数的唯一作用就是释放资源！ 定义格式：~类名() ！ class People { People():species(\"人类\"); ///可以通过初始化列表完成 const 常量的修改 ~People(){}; public: const String species; } 2.2.1、析构函数存在的必要性 class People { People(){ name = new char[20]}; ~People(){ delete []name; }; /// 释放掉堆中内存 public: char *name; } 3、对象数组 实例化对象数组时 每一个对象的构造函数都会被执行； 内存既可以从堆上分配、也可以从栈上分配； 销毁对象数组时 每一个对象的析构函数都会被执行； 堆中实例化的数组，需要手动销毁释放内存； 栈中实例化的数组，系统自动回收内存； class Coordinate { public: Coordinate():longitude(0.0),latitude(0.0){}; double longitude; double latitude; }; ///测试代码段 { Coordinate coor[3];///栈上实例化一个对象数组 coor[0].longitude = 9.12; coor[0].latitude = 105.72; Coordinate *p = new Coordinate[3];///堆上实例化一个对象数组 if (p != NULL) { p[0].longitude = 21.567; p[0].latitude = 56.32543; delete []p; p = NULL; } } 4、对象成员 对象成员：一个对象成为另一个类的数据成员！ 实例化一个对象 A 的时候，如果对象 A 有对象成员 B 、C，那么先执行对象成员 B 、C 的构造函数，再执行 A 的构造函数；销毁对象 A 时，先执行 A 的析构函数，再执行对象成员 C 、B 的析构函数！ /// 构造函数没有参数 /// 构造函数有参数 class Coordinate { public: Coordinate():x(0.0),y(0.0){}; /// 默认构造函数 Coordinate(double _x, double _y):x(_x),y(_y){}; /// 带有参数的构造函数 double x; double y; }; class Line { public: Line():start(10,20), end(40, 50){}; /// 默认构造函数 Line(double sx, double sy, double ex, double ey):start(sx,sy), end(ex, ey){}; /// 带有参数的构造函数 Coordinate start; Coordinate end; }; ///测试代码段 { Line a1; ///栈上实例化一个对象 /// 先实例化成员 start 、接着实例化成员 end， 最后实例化 Line 对象 /// 释放内存时：先销毁 Line 对象 、接着销毁 end， 最后销毁 start } 4.1、对象成员指针 对象成员指针：对象指针成为另一个类的数据成员！ class Line { public: Line():start(NULL), end(NULL){}; /// 默认构造函数 Line(double sx, double sy, double ex, double ey){ start = new Coordinate(sx, sy); end = new Coordinate(ex, ey); }; /// 带有参数的构造函数 ~Line(){ delete start; start = NULL; delete end; end = NULL; }; Coordinate *start; Coordinate *end; }; 类 Line 中仅有两个成员指针，一个指针在 64 位电脑上占 8 个字节内存，sizeof(Line) 理论上应该占 16 个字节内存！ 4.2、常对象成员与常成员函数 常对象成员 ：const 可以修饰对象成员！ 例子：一条线段一旦构造完毕，就不能再修改它的起始终点位置！ class Coordinate { public: Coordinate():x(0.0),y(0.0){}; Coordinate(double _x, double _y):x(_x),y(_y){}; double x; double y; }; class Line { public: /// 使用构造函数初始化列表为被 const 修饰的数据成员赋值！ Line():start(10,20), end(40, 50){}; Line(double sx, double sy, double ex, double ey):start(sx,sy), end(ex, ey){}; const Coordinate start; const Coordinate end; }; 4.3、常成员函数 常成员函数 ：const 修饰成员函数！ 常成员函数本质是对 this 指针的修饰； 常成员函数中不能修改数据成员的值； class Coordinate { public: Coordinate():x(0.0),y(0.0){}; Coordinate(double _x, double _y):x(_x),y(_y){}; double x; double y; /// 声明的地方写上 const void changeX(double _x) const; }; /// 实现的地方也需要写上 const void Coordinate::changeX(double _x) const { /// error : Cannot assign to non-static data member within const member function 'changeX' this -> x = _x; } 为什么不能在常成员函数中修改数据成员的值？编译器将上述常成员函数编译为下述函数： void Coordinate::changeX(const Coordinate *this, double _x) { /// 通过常指针修改该指针指向的数据，是不被允许的！ this -> x = _x; /// this 指针此时仅具有读权限，没有写权限！ } 4.3.2、重载 常成员函数可以与普通同名函数互为重载 class Coordinate { public: /// 下述函数互为重载 void changeX(double _x); void changeX(double _x) const; }; 当与普通函数互为重载时，什么情况下调用普通函数？什么情况下调用常成员函数？ 普通对象调用普通成员函数； 常对象调用常成员函数； { Coordinate coor; coor.changeX(10);/// 调用普通成员函数 ///在互为重载时：常对象将调用常成员函数 const Coordinate coor1; coor1.changeX(10); } 4.4、常指针与常引用 常对象只能调用常成员函数，不能调用普通成员函数； 普通对象能够调用普通成员函数，也能调用常成员函数； 常指针和常引用都只能调用对象的常成员函数； 一个对象可以有多个常引用！ 5、字符串类 String 字符串库 #include String 的初始化方式 代码 注释 String str str 为空字符串 String str1 = \"A\" 字符串 str1 初始化为 \"A\" String str2(\"B\") 字符串str2 初始化为 \"B\" String str3(str2) 字符串str3 初始化为 str2 的一个副本 String str4(n,'B') 字符串str4 初始化为字符 'B' 的 n 个副本，即 BBB...BBBB String 的常用操作 代码 注释 str.empty() 判 str 是否为空，为空返回 true str.size() 返回 str 中字符的个数 str[n] 返回 str 中位置为 n 的字符（索引从 0 开始） str1 + str2 将两个字符串拼接为新串，返回新串的地址！ str1 = str2 将 str1 的内容替换为 str2 的副本 str1 == str2 判断 str1 与 str2 是否相等 String 的拼接 String str1 = \"Hello\"; String str2 = \"Word\"; String str3 = str1 + str2; String str4 = \"Hello\" + str2; String str5 = \"Hello\" + str2 + \"Word\"; String str6 = \"Hello\" + \"Word\"; /// ❌ 非法操作 注意 : 并不是所有的字符串都可以通过 + 连接的；双引号的字符串之间通过 + 连接，是不合法的！ 对象复制与对象赋值 深拷贝与浅拷贝 对象数组与对象指针 this 指针 const + 对象 -> 常对象 const + 函数 -> 常成员函数 const + 对象成员 -> 常对象成员 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"C_C++篇/C++学习继承篇.html":{"url":"C_C++篇/C++学习继承篇.html","title":"C++学习继承篇","keywords":"","body":"C++ 学习继承篇 1、什么是继承？ 继承是面向对象软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。 /// 基类 class People { public: int age; string firstName; void sleep(void); void eatFood(string food); }; /// 派生类 class Worker : public People{ public: void work(void); int salary; }; *被继承的类叫做基类也叫做父类，从其他类继承而来的类叫做派生类也叫做子类； 子类中不仅继承了父类中的数据成员，也继承了父类的成员函数； 1.1、内存中的对象 子类的实例化，内存中既包含父类的成员变量，又包含自己特有的成员变量 { Worker *p = new Worker(); if (p != NULL) { p -> firstName = \"狗蛋\"; p -> age = 10; p -> eatFood(\"面包\"); cout firstName age 创建时先调用父类的构造函数初始化一些数据，接着再调用自身的构造函数！ 销毁时先调用自身的析构函数释放一些内存，接着再调用父类的析构函数！ 2、继承方式 基类到派生类的关系： 公有继承 class subclass : public superclass 私有继承 class subclass : private superclass 保护继承 class subclass : protected superclass 2.1、公有继承 在公有继承中： 子类可以访问父类的 public 成员函数，读写父类的 public 数据成员； 子类可以在 内部 访问父类的 protected 成员函数，读写父类的 protected 数据成员； 子类无法访问父类的 private 成员函数，不能读写父类的 private 数据成员；父类的私有数据成员与成员函数，对于子类来说，是 不可见 的！ 父类的私有成员函数不能被子类继承并使用； 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 public 无法访问（不可见） protected 成员 public protected public 成员 public public 2.2、保护继承 对于访问限定符 protected： 其修饰的数据成员与成员函数，只能在类内部访问与读写；在外部是不被允许使用的！ 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 protected 无法访问（不可见） protected 成员 protected protected public 成员 protected protected 在保护继承中： 父类的公共成员函数与数据成员，将成为子类的受保护成员函数与数据成员！ 父类的受保护成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的私有成员函数与数据成员，对于子类来说是不可见的！ 2.3、私有继承 对于访问限定符 private： 其修饰的数据成员与成员函数，只能在类内部访问与读写；在外部与子类中是不可见的！ 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 private 无法访问（不可见） protected 成员 private private public 成员 private private 在私有继承中： 父类的公共成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的受保护成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的私有成员函数与数据成员，对于子类来说是不可见的！ 3、覆盖与隐藏 继承关系中的 覆盖 与 隐藏： 隐藏：同名的成员变量、或者同名的成员函数 （父子关系、成员同名、隐藏） 3.1、隐藏 隐藏的特性主要提现在： 子类的实例对象只能访问自己的成员函数，而似乎无法访问父类的同名函数 子类修改的是自己的数据成员，而不能直接修改父类的同名数据成员 /// 父类 class People { protected: string food; public: void eatFood(string food){ this -> food = food; }; }; /// 子类 class Worker : public People{ protected: /// 同名的数据成员 string food; public: /// 子类的函数隐藏了父类的同名函数 void eatFood(string food){ this -> food = food; this -> People_YL::food = food;// 读写同名的父类数据成员 }; }; 但实际上，父类的同名函数确实被子类继承，可以通过特殊手段来访问父类的同名函数 { Worker_YL *p = new Worker_YL; p -> eatFood(\"工人在食堂吃饭\"); /// 通过特殊手段来访问父类的同名函数 p -> People_YL::eatFood(\"人类需要吃饭\"); } 注意： 在继承关系中，同名但参数不同的函数，无法形成重载，只能以隐藏的形式出现！ 即使子类已经继承了父类的函数，但函数同名，就会将父类函数隐藏，即使参数不同，也无法形成重载！ /// 父类 class People { public: void eatFood(); }; /// 子类 class Worker : public People{ public: /// 子类的函数隐藏了父类的同名函数 void eatFood(string food); }; /// 测试代码 { Worker_YL *p = new Worker_YL; p -> eatFood(\"工人在食堂吃饭\"); p -> eatFood(); /// ❌ 不允许这种调用 p -> People_YL::eatFood(); /// 要想调用该函数，只能通过父类来调用 } 4、 基类与派生类的关系： Is'a 与 Has'a 4.1、 Is-a 关系 Is-a 概念：派生类的实例对象也是一个基类的实例对象 父类指针无法访问子类的成员变量与成员函数 调用父类指针销毁子类的实例对象，只会销毁父类的那一部分；子类独有的成员变量，不会被释放 父类指针 new 一个子类对象时，构造函数会先调用父类的构造函数，接着调用子类的构造函数！ 而 delete 仅仅调用的是父类的构造函数 ； class People { public: int age; void eatFood(); }; class Worker : public People{ public: int salary; void work(void); }; 测试代码段 /// Is-a 概念：派生类的实例对象也是一个基类的实例对象 { People *p = new Worker(); /// 先调用 People 的构造函数，接着调用 Worker 的构造函数 std::cout age salary work() 思考：在 Is-a 关系中如何通过父类指针释放子类内存？ 4.1.1、虚析构函数 虚析构函数：当存在继承关系时，使用父类指针指向堆中的子类对象，并且向通过父类指针释放子类的内存，这种情况下就需要虚析构函数来解决了！ 虚析构函数 virtual ~People(); 当父类的析构函数被声明为虚析构函数时，编译器也会默认将子类的析构函数编译为虚析构函数！ class People { public: int age; void eatFood(); virtual ~People(); /// 声明为虚析构函数 }; class Worker : public People{ public: int salary; void work(void); ~Worker();/// 编译器也会默认将其编译为虚析构函数 }; 此时通过父类指针指向堆中的子类对象，并且使用父类指针释放子类的内存，将会先调用子类的析构函数，接着调用父类的析构函数！ 4.1.2、测试 测试在公有继承中，Is-a 在函数传递中的表现！ 继承关系 class People { public: string name; People(){ this -> name = \"人类\"; cout name name = \"工人\"; cout 测试函数 /// test1 函数的传值是一个对象 peo /// 因此调用函数传值时，系统会现在栈上创建一个临时的对象，函数调用结束后，将栈上的缓存释放 void test1(People peo) { peo.logName(); } void test2(People &peo) { peo.logName(); } void test3(People *peo) { peo -> logName(); } 对比 test1() 函数 ， test2()与 test3()不会产生临时变量，效率更高！ 测试代码 { People p; Worker w; test1(p); test1(w); test2(p); test2(w); test3(p); test3(w); } 上述三个 test 函数， 当传递 People 对象时，打印的是 People 对象的实例变量； 当传递 Worker 对象时，打印的是 Worker 对象的实例变量； Has a : 包含关系！ 5、多继承与多重继承 5.1、多重继承 当 B 类从 A 类派生而来，C 类从 B 类派生而来，此时称为多重继承！ class People { public: string name; }; class Worker : public People{ }; class BenchWorker : public Worker{ }; 实例化一个 BenchWorker ，构造函数的执行顺序：People() -> Worker() -> BenchWorker() ! 释放一个 BenchWorker ，析构函数的执行顺序：~BenchWorker() -> ~Worker() -> ~People() ! 一个子类的对象，可以作为参数，传入父类的函数中！ 不管继承的关系有多少层，只要存在继承关系，子类与父类就存在 isa 的关系：PeasantWorker isa People ；PeasantWorker isa Worker！ 5.2、多继承 多继承： 一个子类继承多个父类 对父类的个数没有限制，继承方式可以是公共继承、保护继承、私有继承； 继承时，如果没有生命继承方式，默认为私有继承； /// 工人 class Worker : public People{ }; /// 农民 class Peasant : public People{ }; /// 农民工 : 默认私有继承 class PeasantWorker : public Peasant, public Worker { public: PeasantWorker(){ ///编译❌ Non-static member 'name' found in multiple base-class subobjects of type 'People': this -> name = \"农民工\"; }; }; 实例化一个 BenchWorker ，依次调用父类的构造函数（初始化列表中的顺序）！析构函数的执行顺序正好与构造函数的执行顺序相反！ PeasantWorker isa Worker PeasantWorker isa Peasant 5.3、多继承与多重继承的陷阱 菱形继承：既有多继承、又有多重继承！如下所示 类 A 人类 类B 类C 农名类 工人类 类D 农民工类 类 D 继承类B，类B继承类A；类 D 继承类C，类C继承类A！ 此时类 D 将含有类 A 中两份完全相同的数据，这是不被允许的； 如何解决数据冗余的问题呢？使用虚继承 virtual ！ 5.4、虚继承 virtual /// 工人 class Worker : virtual public People{ }; /// 农民 class Peasant : virtual public People{ }; /// 农民工 : 默认私有继承 class PeasantWorker : public Peasant, public Worker { }; 此时PeasantWorker类仅含有People类中一份数据！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"C_C++篇/C++学习多态篇.html":{"url":"C_C++篇/C++学习多态篇.html","title":"C++学习多态篇","keywords":"","body":"C++学习多态篇 多态：指相同对象收到不同消息或不同对象收到相同消息时产生不同的动作！ 1、虚函数 1.1、静态多态 静态多态也称为早绑定！ class People { public: void eat(); void eat(string food); }; { People p; p.eat();///编译器能够准确识别调用哪个函数 p.eat(\"食物\"); } 调用互为重载的函数，程序在编译的时期已经决定调用哪些函数；这种情况称为早绑定，也称为静态多态！ 1.2、动态多态 动态多态也称为晚绑定！ 产生多态的基础是继承关系；没有继承与封装，就没有多态！ 动态多态至少需要一个基类，一个派生类！ 动态多态的核心是 virtual 关键字，必须使用 virtual 才能建立多态关系！ class Shape { public: double calcArea(){ cout radius = radius; }; double calcArea(); private: double radius; }; double Circle::calcArea() { return M_PI * radius * radius; } class Rect : public Shape { public: Rect(double width, double height){ this -> width = width; this -> height = height; }; double calcArea(); private: double width; double height; }; double Rect::calcArea() { return width * height; } 上述的代码，我们做一个测试： { Shape *s1 = new Circle(10); Shape *s2 = new Rect(5,6); s1 -> calcArea(); s2 -> calcArea(); } 可以发现，调用的都是父类的成员函数，而非具体到某个子类的函数！也就是没有实现多态的功能！ 要想调用到某个子类的成员函数；需要使用 virtual 修饰父类的成员函数，使其成为虚函数！ 1.3、虚函数 使用 virtual 修饰成员函数，使其成为虚函数！ class Shape { public: virtual double calcArea(){ cout 此时，调用上述 1.2 的测试代码，将执行子类的相关函数！也就实现了动态多态！ 虚函数使用virtual 关键字定义，但使用 virtual 关键字时，并非全部是虚函数； 虚函数特性可以被继承，当子类定义的函数与父类中虚函数的声明相同时，该函数也是虚函数； 关于 virtual 在函数中的使用限制： 不能修饰普通函数； 不能修饰全局函数，否则产生编译错误； 不能修饰静态成员函数； 不能修饰内联函数，否则计算机会忽略 inline 关键字； 不能修饰构造函数； 1.4、虚析构函数 父类指针指向子类对象，使用父类指针调用 delete 销毁子类对象时，可能存在内存泄漏 ! 在上述例子中： { Shape *s1 = new Circle(10); if(s1 != NULL) { /// 父类指针调用 delete ，仅执行父类的析构函数； /// 子类的一些成员无法被释放，由此导致内存泄漏 delete s1; } } 解决方法：使用 virtual 修饰析构函数： class Shape { public: virtual ~Shape(); }; 注意： 只有虚析构函数，没有虚构造函数！ 虚析构函数避免了使用父类指针释放子类对象时造成内存泄漏！ 1.5、如何实现虚函数与虚析构函数？ 函数的本质就是一段二进制代码，而函数指针就是指向这段代码开头地址的指针！ 1.5.1、测试：证明虚函数表的存在 对象的大小：在类实例化出的对象中，数据成员总计占据的内存大小，不包含成员函数！ 对象的地址：通过一个类实例化一个对象后，该对象会在内存中占据一定的内存单元；第一个内存单元就是该对象的地址！ 对象成员的地址：每个数据成员所占据的地址；不同类型的数据成员占据不同的内存大小； 虚函数表指针： 一个有声明虚函数的类，具有一个隐藏的数据成员 虚函数表指针 vftable_pr ！ 测试1 C++ 中的一个类实例，如果没有一个数据成员，将会标记一个内存单元 class Shape { public: int width; }; { /// 测试代码 cout width) 测试2 (证明了虚函数表的存在) class Shape { public: int width; virtual double calcArea(); }; { /// 测试代码 cout width) 通过上述两个测试用例，发现有虚函数的 Shape 类，其指针并非是第一个成员变量的地址！中间差距 8 个字节的内存单元！ 这 8 个字节的内存单元，主要用于存储 虚函数表指针！ 1.5.2、虚函数表 一个有声明虚函数的类，具有一个隐藏的数据成员：虚函数表指针 vftable_pr ！ 虚函数表指针指向一个虚函数表，与类的定义同时出现！ 虚函数表指针 占据一个对象的前 8 个字节的内存单元！ 虚函数表占用一定的内存空间 该类只有一个虚函数表，所有该类的实例对象，共同使用一个虚函数表； 定义其子类时，一个子类也维护一个虚函数表； 父类与子类的两张虚函数表中的函数指针，可能指向同一个函数； 父类调用虚函数步骤： 1、通过虚函数表指针 vftable_pr 找到虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 3、根据函数地址，执行对应的虚函数； 子类调用父类的虚函数步骤（前提是子类没有同名函数）： 1、通过虚函数表指针 vftable_pr 找到自身的虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 3、该虚函数的入口地址，就是父类中的虚函数入口地址； 4、根据函数地址，执行对应的虚函数； 子类调用自身实现的虚函数步骤： 1、通过虚函数表指针 vftable_pr 找到自身的虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 4、根据函数地址，执行对应的虚函数； 1.5.3、虚析构函数 理论前提：执行完子类的析构函数之后，系统将会自动执行父类的析构函数； 1.5.4、多态中的覆盖与隐藏 隐藏：子类与父类出现同名函数；在子类中，父类的同名函数将被隐藏； 覆盖：在子类的虚函数表中，同名函数的地址被覆盖为子类函数的入口地址； 2、 纯虚函数 只有函数声明，没有函数定义的虚函数称为 纯虚函数！ class Shape { public: int width; /// 虚函数 virtual double calcArea() { return 0; } /// 纯虚函数：声明后面 + '= 0' virtual double funcArea() = 0; }; 2.1、虚函数表中的纯虚函数 2.2、抽象类 含有纯虚函数的类，称其为抽象类！ C++ 不允许抽象类实例化一个对象 抽象类的一个子类，也可以是抽象类 { Shape *p = new Shape(); /// erroe : Allocating an object of abstract class type 'Shape'! } 3、 接口类 接口类：仅含有纯虚函数的类，不含有其它的成员函数；不含有任何数据成员！ class Shape { public: virtual double calcArea() = 0; ///计算面积 virtual double calcPerimeter() = 0; ///计算周长 }; 上面 Shape 类不包含任何数据成员，仅有两个成员函数还都是纯虚函数！此时 Shape 类被称为接口类！ 接口类仅需要 .hpp 文件来声明，不需要 .cpp 文件来实现！ 接口类也是抽象类，因此不能使用接口类来实例化一个对象！ 一个类可以继承多个接口类，同时也可以继承非接口类； 接口类更多的是表达一种能力或者一个协议 ! 3.1、Objective-C 中的协议 Objective-C 中的协议类似于 C++ 的接口类，就是一堆方法的声明，但没有实现！ 一个 Objective-C 类可以遵循一个或多个协议，任何类只要遵循了协议就相当于拥有了这个协议中所有的方法声明。 协议可以定义在一个类的头文件上部，并直接应用在该类中（如作为delegate功能使用时）；也可单独定义到一个类中，作为多个不同类来遵循并实现的接口。 @protocol HumanProtocol @required - (void)name; - (void)age; @optional // ... @end 协议可以用于存储方法声明，可以将多个类中的公有方法抽取出来，让这些类遵守协议即可！ 4、运行时类型识别 RTTI 什么是 RTTI ？ 通过父类指针，识别其所指向对象的真实数据类型！ 运行时类型识别必须建立在虚函数的基础上，否则无需 RTTI 技术！ typeid 注意事项: typeid 返回一个 type_info 对象的引用； 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数；否则只能返回定义时的数据类型； 只能获取对象的实际类型； dynamic_cast 注意事项: 只能应用于指针和引用转换； 要转换的类型中必须包含虚函数； 转换成功返回子类的地址，失败则返回 NULL； 4.1、 RTTI 用例 定义一个接口类 class Flyable { public: /// 纯虚函数 virtual void takeOff() = 0; ///起飞 virtual void land() = 0; ///降落 }; 继承接口类 /// 飞机类 class Plane : public Flyable{ public: Plane(); ~Plane(); void carry(); virtual void takeOff(); virtual void land(); }; /// 鸟类 class Bird : public Flyable{ public: Bird(); ~Bird(); virtual void takeOff(); virtual void land(); void foraging(); }; 测试函数 void doSomething(Flyable *fly) { std::cout takeOff(); if (typeid(*fly) == typeid(Bird)) { /// 类型强制转换 /// 转换成功返回子类的地址，失败则返回 NULL Bird *niao = dynamic_cast(fly); niao -> foraging(); } if (typeid(*fly) == typeid(Plane)) { Plane *ji = dynamic_cast(fly); ji -> carry(); } fly -> land(); } void PolymorphismDemo(void) { /// 分别将 Bird 类与 Plane 类实例传入上述函数 Bird niao; doSomething(&niao); Plane *ji = new Plane(); doSomething(ji); std::cout 5、异常处理 异常：程序在运行过程中出现的错误！ 异常处理：对有可能发生异常的地方做出预见性的安排！ 常见异常： 数组下标越界； 除数为 0； 内存不足； 5.1、如何异常处理？ 在 C++ 中通常 throw 抛出异常， 使用 try...catch 语法结构尝试捕获并处理异常！ void func1() { try { func2(); } catch (string &value) { ///捕获异常 /// 发生异常时，可以在此处处理一些异常 std::cout try...catch 可以是一对一的关系，也可以是一对多的关系！ catch (...) { /// 省略号，表示可以捕获所有异常 } 多态与异常处理的关系 : 定义一个接口类 Exception ，处理不同场景的异常! Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"iOS开发/CNCopyCurrentNetworkInfo内存泄漏.html":{"url":"iOS开发/CNCopyCurrentNetworkInfo内存泄漏.html","title":"CNCopyCurrentNetworkInfo() 引发的内存泄漏","keywords":"","body":"CNCopyCurrentNetworkInfo() 引发的内存泄漏 笔者在优化项目时，发现了两处相同原因导致的内存泄漏，在此记录一下！ 1、CNCopyCurrentNetworkInfo() 引发的内存泄漏 项目中某个业务，会尝试获取 Wifi 的名称（非必须选项），导致下述的内存泄漏！ 1.39 KB 2.1% 13 main 1.39 KB 2.1% 13 __73+[KDeviceAccessManager requestAccessForAudioAndVideoCompletionHandler:]_block_invoke 1.39 KB 2.1% 13 __42-[ZMkGotoClassroom requestClassroomAccess]_block_invoke 1.39 KB 2.1% 13 +[NetWorkTool checkNetWorkStatusWithEnterClassBlock:] 1.39 KB 2.1% 13 +[NetWorkTool beginCheckNetWorkWithEnterClassBlock:] 1.39 KB 2.1% 13 -[NetWorkStatusView initWithEnterBlock:] 1.39 KB 2.1% 13 -[NetWorkStatusView loadCurrentNetInfo] 1.39 KB 2.1% 13 -[NetWorkStatusView loadWifiName] CaptiveNetwork __CNCopyCurrentNetworkInfo 分析日志，是由于 CNCopyCurrentNetworkInfo() 函数导致的内存泄漏，但是这个函数不是系统提供的嘛？怎么会出现内存泄漏了呢？ 去 苹果官网问题反馈 也能发现有人提出相同的问题： 再来看一下 CNCopyCurrentNetworkInfo() 的官方解释： /** @discussion 应用至少满足下述一个条件时，函数才会返回有效的网卡信息： * 1、应用如果使用 CoreLocation API，则必须拥有用户访问位置的授权 * 2、应用使用 NEHotspotConfiguration API 来配置当前的 Wi-Fi 网络 * 3、正处于启用状态的 VPN 应用 * 4、应用开启 NEDNSSettingsManager 配置 * * @note 1、iOS 12.0 以上必须有\"com.apple.developer.networking.wifi-info\"授权 * @note 2、iOS 13.0 及以上的系统，如果不满足上述至少一条要求，该函数返回 NULL * @note 3、如果遇到错误，返回NULL；必须释放返回值； */ CFDictionaryRef __nullable CNCopyCurrentNetworkInfo(CFStringRef interfaceName) API_DEPRECATED_WITH_REPLACEMENT(\"[NEHotspotNetwork fetchCurrentWithCompletionHandler:]\", ios(4.1, API_TO_BE_DEPRECATED), macCatalyst(14.0, API_TO_BE_DEPRECATED)) 笔者猜测：在 iOS 13.0 以上的系统，当项目不满足上述4个条件任一一个时，该函数内部仍然执行了逻辑功能，仅仅是最后给我们返回了 NULL ；这就导致原本返回的 NetworkInfo 被这个函数内部劫持了，而苹果又没去释放 NetworkInfo ，而开发者没办法拿到也不能去释放，所以导致了内存泄漏！ 开发者唯一能做的，仅仅是首先判断上述 4 个条件，确定自己是否有权限获取 Wifi 信息，如果没有就不要去调用这个函数！ - (NSString *)loadWifiName{ if (@available(iOS 13.0,*)) { /// 注：在 iOS 13 以上的设备，如果没有权限获取网卡信息，即使返回 NULL。苹果也留了个扯淡的内存泄漏 /// 此处判断下用户是否开启定位权限（前提是你没有在开发者网站配置 NEHotspotConfiguration 或者 NEDNSSettingsManager，否则大可不必在此判断） if (CLLocationManager.locationServicesEnabled) { /// 定位权限 if ( !(CLLocationManager.authorizationStatus == kCLAuthorizationStatusAuthorizedAlways || CLLocationManager.authorizationStatus == kCLAuthorizationStatusAuthorizedWhenInUse) ) { return nil; } } } /// 所有支持的网卡列表 NSArray *interfaceNames = CFBridgingRelease(CNCopySupportedInterfaces()); NSDictionary *SSIDInfo; for (NSString *interfaceName in interfaceNames) { /// 拿到有效网卡的信息（SSID，BSSID） SSIDInfo = CFBridgingRelease(CNCopyCurrentNetworkInfo((__bridge CFStringRef)interfaceName)); BOOL isNotEmpty = (SSIDInfo.count > 0); if (isNotEmpty) { break; } } NSString *SSID = SSIDInfo[@\"SSID\"]; return SSID; } 2、友盟 SDK 中调用 CNCopyCurrentNetworkInfo() 引发的内存泄漏 使用 Instruments -> Leak 监测程序，发现友盟 SDK 出现内存泄漏，泄露信息如下所示： 2.25 KB 20.3% 22 __44-[UMWorkDispatch dispatchEvent:inComponent:]_block_invoke_2 2.25 KB 20.3% 22 -[UMEnvelopeBuild buildInternalData] 2.25 KB 20.3% 22 +[UMInternalUtil Value3] 2.25 KB 20.3% 22 +[UMInternalUtil getwinfoValue] 2.25 KB 20.3% 22 +[UMInternalUtil getwinfo] 1.39 KB 12.6% 13 +[UMInternalUtil getWifiSSID] 880 Bytes 7.7% 9 +[UMInternalUtil getWifiBSSID] +0xb8 bl \"DYLD-STUB$$CNCopyCurrentNetworkInfo\" 分析发现，友盟调用了 CNCopyCurrentNetworkInfo() 函数而引发的内存泄漏！ 关于 CNCopyCurrentNetworkInfo() 函数引发的内存泄漏，在上文已经遇见过，此处不多做分析！ 参考文章 苹果官网问题反馈 记 iOS13 CNCopyCurrentNetworkInfo一个哭笑不得的内存泄漏bug Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"iOS开发/iOS渲染机制初窥.html":{"url":"iOS开发/iOS渲染机制初窥.html","title":"iOS渲染机制初窥","keywords":"","body":"iOS渲染机制初窥 1、渲染与成像 1.1、CPU 与 GPU 处理器 对于现代计算机系统，简单来说可以大概视作三层架构：硬件、操作系统与进程。对于移动端来说，进程就是 App，而 CPU 与 GPU 是硬件层面的重要组成部分。CPU 与 GPU 提供了计算能力，通过操作系统被 App 调用。 区别 CPU Central Processing Unit GPU Graphics Processing Unit 名称 中央处理器，系统的运算核心、控制核心 图形处理器 工作范围 大都在软件层面，适用于串行计算 大都在硬件层面，适用于并行计算 设计目的 低时延，更多的高速缓存，更快速地处理逻辑分支 更强的计算能力，基于大吞吐量而设计 工作场景 需要很强的通用性来处理各种不同的类型数据，同时又要逻辑判断又会引入大量的分支跳转和中断处理 面对类型高度统一的、相互无依赖的大规模数据和不需要被打断纯净的计算环境 架构 CPU的内部结构异常复杂，拥有更多的缓存空间以及复杂的控制单元 GPU 基于大吞吐量而设计，拥有更多的计算单元 Arithmetic Logic Unit GPU 优秀的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。 1.2、CPU+GPU 渲染流水线 图像渲染流程粗粒度地大概分为下面这些步骤： 除了第一阶段 Application 由CPU负责，后续主要都由 GPU 负责： 一个简单的三角形绘制就需要大量的 GPU 资源来计算；针对更多更复杂的顶点、颜色、纹理信息，其计算量是难以想象的。这也是为什么 GPU 更适合于渲染。 详细分析渲染流水线中各个阶段的具体任务： Ⅰ、Application 应用处理阶段：得到图元 该阶段具体指的是图像在 App 中被处理的阶段，此时还处于 CPU 负责的时期。 在该阶段 App 会对图像进行一系列的操作或者改变，最终将新的图像信息传给下一阶段。 这部分信息被叫做图元，通常是三角形、线段、顶点等。 Ⅱ、Geometry 几何处理阶段：处理图元 这个阶段以及之后的阶段，主要由 GPU 负责。 此时 GPU 可以拿到 Application 阶段传递下来的图元信息、并对这部分图元进行处理，然后输出新的图元。 这一系列阶段包括： 顶点着色器 Vertex Shader：将图元中的顶点信息进行视角转换、添加光照信息、增加纹理等操作； 形状装配 Shape Assembly：图元中的三角形、线段、点分别对应三个顶点、两个顶点、一个顶点；这个阶段会将顶点连接成相应的形状； 几何着色器Geometry Shader：添加额外的顶点，将原始图元转换成新图元，以构建一个不一样的模型。简单来说就是基于三角形、线段和点构建更复杂的几何图形。 Ⅲ、Rasterization 光栅化阶段：图元转换为像素 光栅化的主要目的是将几何渲染之后的图元信息，转换为一系列的像素，以便后续显示在屏幕上。 这个阶段中会根据图元信息，计算出每个图元所覆盖的像素信息等，从而将像素划分成不同的部分。 一种简单的划分就是根据中心点：如果像素的中心点在图元内部，那么这个像素就属于这个图元。如上图所示，深蓝色的线就是图元信息所构建出的三角形；而通过是否覆盖中心点，可以遍历出所有属于该图元的所有像素，即浅蓝色部分。 Ⅳ、Pixel 像素处理阶段：处理像素，得到位图 经过光栅化阶段，可以得到图元所对应的像素；此时，需要给这些像素填充颜色和效果。所以最后这个阶段就是给像素填充正确的内容，最终显示在屏幕上。 这些经过处理、蕴含大量信息的像素点集合，被称作 位图 bitmap 。也就是说，Pixel 阶段最终输出的结果就是位图，过程具体包含： 片段着色器Fragment Shader：也叫做 Pixel Shader，这个阶段的目的是给每一个像素 Pixel 赋予正确的颜色。颜色的来源就是之前得到的顶点、纹理、光照等信息。由于需要处理纹理、光照等复杂信息，所以这通常是 整个系统的性能瓶颈。 测试与混合Tests and Blending：也叫做 Merging 阶段 ，这个阶段主要处理片段的前后位置以及透明度。这个阶段会检测各个着色片段的深度值 z 坐标，从而判断片段的前后位置，以及是否应该被舍弃。同时也会计算相应的透明度 alpha 值，从而进行片段的混合，得到最终的颜色。 这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。只要有足够多的不同色彩的像素，就可以制作出色彩丰富的图象，逼真地表现自然界的景象。缩放和旋转容易失真，同时文件容量较大。 1.3、屏幕成像 在图像渲染流程结束之后，接下来就需要将得到的 bitmap 信息显示在物理屏幕上了。 CPU 计算好显示内容提交至 GPU，GPU 渲染结束后将 bitmap 信息缓存在 帧缓冲区 Framebuffer 中； 显示控制器 VideoController 收到 VSync 信号后逐帧读取 Framebuffer 中的数据，经过 数模转换 传递给 显示器Monitor 进行显示。完整的流程如下图所示： 1.4、显示器原理 显示器的电子束从上到下逐行扫描，扫描完成后显示器就呈现一帧画面；然后电子束回到初始位置进行下一次扫描。 为了同步显示器的显示过程和系统的显示控制器，显示器会用硬件时钟产生一系列的定时信号： 水平同步信号horizonal synchronization，简称 HSync：当电子束换行进行扫描时，显示器会发出一个HSync信号； 垂直同步信号vertical synchronization，简称VSync： 当一帧画面绘制完成后，电子束回复到原位，准备画下一帧前，显示器会发出一个 VSync 信号； 电子束扫描的过程中，屏幕就能呈现出对应的结果，每次整个屏幕被电子束扫描完一次后，就相当于呈现了一帧完整的图像。屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。而这个屏幕刷新的频率，就是 帧率（Frame per Second，FPS）。由于人眼的视觉暂留效应，当屏幕刷新频率足够高时（FPS 通常是 50 到 60 左右），就能让画面看起来是连续而流畅的。对于 iOS 而言，App 应该尽量保证 60 FPS 才是最好的体验。 1.5、屏幕撕裂 Screen Tearing CPU+GPU 的渲染流程是一个非常耗时的过程。 在单一缓存的模式下，理想情况是：每次电子束从头开始新的一帧的扫描时，CPU+GPU 对于该帧的渲染流程已经结束，渲染好的 bitmap 已经放入Framebuffer中。但这种完美的情况是非常脆弱的，很容易产生屏幕撕裂： 如果在电子束开始扫描新的一帧时，bitmap 还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入Framebuffer中； 那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成 屏幕撕裂 。 1.6、垂直同步 Vsync + 双缓冲机制 Double Buffering iOS 设备会始终使用 Vsync + Double Buffering 的策略。 解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号 Vsync 与双缓冲机制 Double Buffering。 使用 Vsync信号给 Framebuffer 加锁：只有当显示控制器接收到 Vsync信号时，才会将Framebuffer中的bitmap更新为下一帧，这样就能保证每次显示的都是同一帧的画面，也就避免了屏幕撕裂。 这种情况下要求显示控制器在接受到 Vsync 信号后将下一帧的bitmap传入；这意味着整个 CPU+GPU 的渲染流程都要在一瞬间完成，这明显是不现实的。 使用 双缓冲机制 会增加一个新的 备用缓冲区 BackBuffer：渲染结果会预先保存在 BackBuffer 中；在接收到 Vsync 信号的时候，显示控制器会将 BackBuffer 中的内容置换到 Framebuffer 中，此时就能保证置换操作几乎在一瞬间完成（实际上是交换了内存地址）。 1.7、屏幕卡顿的本质：掉帧 Jank 屏幕刷新频率必须要足够高才能流畅 使用 Vsync 信号以及双缓冲机制之后，能够解决屏幕撕裂的问题，但是会引入新的问题：掉帧。 如果在接收到 Vsync 之时 CPU 和 GPU 还没有渲染好新的位图，显示控制器就不会去替换Framebuffer 中的bitmap；这时屏幕就会重新扫描呈现出上一帧的画面；两个周期显示同一 bitmap，这就是所谓 掉帧 的情况。 如图所示，A、B 代表两个Framebuffer，当 B 没有渲染完毕时就接收到了 Vsync 信号，所以屏幕只能再显示相同帧 A，这就发生了第一次的掉帧。 App 卡顿的直接原因：CPU 和 GPU 渲染流水线耗时过长，导致掉帧 。对于 iPhone 手机来说，屏幕最大的刷新频率是 60 FPS，一般只要保证 50 FPS 就已经是较好的体验了。如果掉帧过多，导致刷新频率过低，就会造成不流畅的使用体验。 1.8、三缓冲 Triple Buffering 在上述策略中发生掉帧的时候，CPU 和 GPU 有一段时间处于闲置状态：当 A 的内容正在被扫描显示在屏幕上，而 B 的内容已经被渲染好，此时 CPU 和 GPU 就处于闲置状态。 如果再增加一个帧缓冲区，就可以利用这段时间进行下一步的渲染，并将渲染结果暂存于新增的帧缓冲区。 如图所示，由于增加了新的帧缓冲区，可以一定程度上地利用掉帧的空档期，合理利用 CPU 和 GPU 性能，从而减少掉帧的次数。 在Android4.1系统开始，引入了三缓冲+垂直同步的机制。由于多加了一个 Buffer，实现了 CPU 跟 GPU 并行，便可以做到了只在开始掉一帧，后续却不掉帧。 缓冲机制 意义 Vsync 与双缓冲 强制同步屏幕刷新，以掉帧为代价解决屏幕撕裂问题 三缓冲 合理使用 CPU、GPU 渲染性能，减少掉帧次数 2、 iOS 的渲染 了解了计算机的大致渲染流程后，我们回到主题，iOS App 的渲染大致是一个怎样的过程呢？ 2.1、iOS 的渲染框架 iOS App 的图形渲染依然符合渲染流水线的基本架构；在硬件基础之上，使用了 CoreGraphics、CoreAnimation、CoreImage 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系；但都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。 UIKit ：是 iOS 开发者最常用的框架，通过设置 UIKit 组件的布局以及相关属性来绘制界面。 事实上， UIKit 并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件响应的传递大体是经过 视图树 逐层的遍历实现的。 GPU Driver：软件框架最终通过 OpenGL 连接到 GPU Driver，GPU Driver 是直接和 GPU 交流的代码块，直接与 GPU 连接。 OpenGL：是一个提供了 2D 和 3D 图形渲染的 API，它能和 GPU 密切的配合，高效利用 GPU 能力实现硬件加速渲染。OpenGL的高效实现（利用了图形加速硬件）一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。OpenGL 之上扩展出很多东西，如 CoreGraphics 等最终都依赖于 OpenGL，有些情况下为了更高的效率，比如游戏程序，甚至会直接调用 OpenGL 的接口。 Metal 类似于 OpenGL，也是一套第三方标准，具体实现由苹果实现。大多数开发者仅仅间接的使用 Metal。CoreAnimation、CoreImage、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。 CoreAnimation：源自于 LayerKit，是一个复合引擎，主要职责包含：渲染、构建和实现动画；可视内容可被分解成独立的图层CALayer，这些图层会被存储在一个叫做 图层树 的体系之中，这个树是 iOS 应用程序中所能在屏幕上看见的一切的基础。 CoreAnimation 是 AppKit 和 UIKit 完美的底层支持，是 App 界面渲染和构建的最基础架构。 CoreGraphics：基于 Quartz 高级绘图引擎，主要用于 运行时绘制图像，在运行时实时计算、绘制一系列图像帧来实现动画 ；是一个强大的二维图像绘制引擎，用来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。常用的 CGRect 就定义在这个框架下。 CoreImage： 一个高性能的图像处理分析的框架，它拥有一系列现成的图像滤镜，能对 已存在的图像 进行高效的处理。 CoreAnimation 动画 CoreAnimation 动画是基于事务的动画，是最常见的动画实现方式。动画执行者是专门负责渲染的渲染进程 Render Server，操作的是呈现树。 开发者应该尽量使用 CoreAnimation 来控制动画，因为 CoreAnimation 是充分优化过的；基于Layer的绘图过程中，CoreAnimation 通过硬件操作位图（变换、组合等），产生动画的速度比软件操作的方式快很多。 基于 View 的绘图过程中，view 被改动时会触发的 -drawRect: 方法来重新绘制位图，但是这种方式需要 CPU 在主线程执行，比较耗时。而 CoreAnimation 则尽可能的操作硬件中已缓存的位图，来实现相同的效果，从而减少了资源损耗。 非CoreAnimation 动画 非 CoreAnimation 动画执行者是当前进程，操作的是模型树；常见的有定时器动画和手势动画： 定时器动画是在定时周期触发时修改模型树的图层属性； 手势动画是手势事件触发时修改模型树的图层属性。 两者都能达到视图随着时间不断变化的效果，即实现了动画。 非 CoreAnimation 动画过程中实际上不断改动的是模型树，而呈现树仅仅成了模型树的复制品，状态与模型树保持一致。整个过程中，主要是CPU在主线程不断调整图层属性、布局计算、提交数据，没有充分利用到 CoreAnimation 强大的动画控制功能。 2.2、iOS App 的渲染流水线 App 本身并不负责渲染，渲染由一个独立的进程 Render Server负责。 App 使用 CPU 处理触摸事件、显示内容的前置计算；然后通过 进程间通信 将渲染任务及相关数据提交给 Render Server；Render Server 处理完数据后，再传递至 GPU；最后由 GPU 调用 iOS 的图像设备进行显示。 渲染流水线可以分为下述步骤： App 处理 Handle Events事件，如用户的点击操作；在此过程中 App 可能需要更新 视图树 ，相应地 图层树 也会被更新； App 的 Commit Transaction：App 通过 CPU 处理显示内容的前置计算，如：视图创建、布局计算、图片解码、文本绘制等任务；之后将计算好的图层打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。 解码 Decode：打包好的图层被传输到 Render Server 之后，首先会进行解码。注意完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。 Draw Calls：解码完成后，CoreAnimation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。 渲染阶段 Render：这一阶段主要由 GPU 在物理层上完成了对图像的渲染。 显示阶段 Display：需要等 render 结束的下一个 RunLoop 触发显示。 2.2.1、Commit Transaction 都做了那些工作？ 一般而言，开发者能接触并影响到的就是 Handle Events 和 Commit Transaction 这两个阶段。 Handle Events 就是处理触摸事件，而 Commit Transaction 主要进行的是：Layout、Display、Prepare、Commit 等四个具体的操作。 Ⅰ、 Layout：构建视图 这个阶段主要处理视图的构建和布局，具体步骤包括： 调用重载的 -layoutSubviews 方法； 创建视图，并通过 -addSubview: 方法添加子视图； 计算视图布局，即所有的 Layout Constraint； 由于这个阶段是在 CPU 中进行，通常是 CPU 限制或者 IO 限制，所以应尽量高效、轻量地操作，减少这部分的时间，比如减少非必要的视图创建、简化布局计算、减少视图层级等。 Ⅱ、Display：绘制视图 这个阶段主要是交给 CoreGraphics 进行视图的绘制，得到 图元 数据： 根据上一阶段 Layout 的结果创建得到图元信息； 如果重写了 -drawRect: 方法，那么会调用重载的 -drawRect: 方法，在该方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制； 注意正常情况下 Display 阶段只会得到图元信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 -drawRect: 方法，这个方法会直接调用 CoreGraphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap。 由于重写了 -drawRect: 方法，绘制过程从 GPU 转移到了 CPU，会导致一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。 Ⅲ、 Prepare：CoreAnimation 额外的工作 这一步主要是：图片解码和转换 Ⅳ、 Commit：打包并发送 这一步主要是：图层打包并发送到 Render Server。 注意 Commit 操作是依赖图层树递归执行的，所以如果图层树过于复杂，Commit 的开销就会很大。这也是开发者减少视图层级，从而降低图层树复杂度的原因。 2.3、 视图UIView 与 图层CALayer 2.3.1、图层 CALayer 图层 CALayer 是用户所能在屏幕上看见的一切的基础，用来存放 位图 Bitmap 。 CALayer 有这样一个属性 contents：保存了由设备渲染流水线渲染好的位图 bitmap（通常也被称为 backing store），而当设备屏幕进行刷新时，会从 CALayer 中读取生成好的 bitmap，进而呈现到屏幕上。 /** 该属性提供了图层 CALayer 的内容，是一个指针类型 * 在 iOS 中的类型就是 CGImageRef ；在 OS X 10.6 及更高版本上还可以是 NSImage * 默认值为 nil * @note contents 属性赋予任何值，App 均可以编译通过；但如果 content 的值不是 CGImageRef ，得到的图层将是空白； * 本质上，contents 指向一块缓存区域，称为 backing store，可以存放 bitmap 数据 **/ @property(nullable, strong) id contents; 图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成 纹理），也支持直接使用 纹理（图片） 进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 手动绘制；另一种是 使用图片: 使用图片contents image ： 赋值 CGImageRef 类型的图片； 手动绘制：custom drawing：使用 CoreGraphics 直接绘制 寄宿图；实际开发中，一般通过继承 UIView 并实现 -drawRect: 方法来自定义绘制； // 注意 CGImage 和 CGImageRef 的关系： // typedef struct CGImage CGImageRef; layer.contents = (__bridge id)image.CGImage;** 虽然 -drawRect: 是一个 UIView 方法，但事实上都是底层的 CALayer 完成了重绘工作并保存了产生的图片。下图所示为 -drawRect: 绘制定义寄宿图的基本原理 UIView 有一个关联图层，即 CALayer； CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate 协议。UIView 作为 CALayer 的代理实现了 CALayerDelegae 协议； 当需要重绘时，即调用 -drawRect:，CALayer 请求其代理给予一个寄宿图来显示； CALayer 首先会尝试调用 -displayLayer: 方法，此时代理可以直接设置 contents 属性。 如果代理没有实现 -displayLayer: 方法，CALayer 则会尝试调用 -drawLayer:inContext: 方法。在调用该方法前，CALayer 会创建一个空的寄宿图（尺寸由 bounds 和 contentScale 决定）和一个 CoreGraphics 的绘制上下文，为绘制寄宿图做准备，作为 context 参数传入。 最后，由 CoreGraphics 绘制生成的寄宿图会存入 backing store。 2.3.2、视图 UIView UIView 是 iOS App 中的基本组成结构，定义了一些统一的规范；它会负责内容的渲染、交互事件的处理。 Drawing and animation：绘制与动画 Layout and subview management：布局与子 view 的管理 Event handling：点击事件处理 2.3.3、 UIView 与 CALayer 的关系 CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现。 UIView的职责是 创建并管理 CALayer，以确保当子视图在层级关系中 添加或被移除 时，其关联的图层在图层树中也有相同的操作，即保证视图树和图层树在结构上的 一致性 。 相同的层级结构： UIView 层级拥有 视图树 的树形结构，由于每个 UIView 都对应 CALayer 负责页面的绘制，所以 CALayer 也具有相应的 图层树 的树形结构。 部分效果的设置： UIView 只对 CALayer 的部分功能进行了封装；而另一部分如圆角、阴影、边框等特效都需要通过调用 CALayer 属性来设置； 是否响应点击事件：CALayer 不负责点击事件，所以不响应点击事件，而 UIView 会响应； 不同继承关系：CALayer 继承自 NSObject，UIView 由于要负责交互事件，所以继承自 UIResponder； 2.3.4、为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？ 这样设计的主要原因就是为了 职责分离，拆分功能，方便代码的复用。 iOS 平台基于多点触控的用户界面 和 Mac OS X 平台基于鼠标键盘的交互有着本质的区别；这就是为什么 iOS 有 UIKit 和 UIView，对应 Mac OS X 有 AppKit 和 NSView 的原因；它们在功能上很相似，但是在实现上有着显著的区别。 通过 CoreAnimation 框架来负责可视内容的呈现，这样在 iOS 和 Mac OS X 上都可以使用 CoreAnimation 进行渲染。 3、离屏渲染 3.1、什么是离屏渲染？ 正常的渲染流程如下图所示： App 通过 CPU 与 GPU 的合作，不停地将内容渲染完成放入 Framebuffer 中，而显示器不断地从 Framebuffer 中获取内容，显示实时的内容。如果有时因为面临一些限制，无法把渲染结果直接写入Framebuffer，而是先暂存在另外的内存区域，之后再写入Framebuffer，那么这个过程被称之为离屏渲染。 离屏渲染需要先额外创建离屏渲染缓冲区 OffScreen Buffer，将提前渲染好的内容放入其中，等到合适的时机再将 OffScreen Buffer 中的内容进一步叠加、渲染，完成后将结果切换到 Framebuffer 中。 3.2、 CPU 离屏渲染？ 通过CPU渲染就是俗称的 软件渲染，而真正的离屏渲染发生在 GPU。 如果在 UIView 中实现了 -drawRect: 方法，就算它的函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作。 类似这种 新开一块 CGContext 来画图 的操作，称之为 CPU离屏渲染（因为像素数据是暂时存入了CGContext，而不是存入Framebuffer）。进一步来说，其实所有CPU进行的光栅化操作如文字渲染、图片解码等，都无法直接绘制到由GPU掌管的Framebuffer ，只能暂时先放在另一块内存之中，说起来都属于 离屏渲染 。 自然我们会认为，因为CPU不擅长做这件事，所以我们需要尽量避免它，就误以为这就是需要避免离屏渲染的原因。但是根据苹果工程师的说法，CPU渲染并非真正意义上的离屏渲染。另一个证据是，如果你的view实现了 -drawRect:，此时打开 Xcode 调试的 Color Off-Screen Rendered 开关，你会发现这片区域不会被标记为黄色，说明 Xcode 并不认为这属于离屏渲染。 3.3、 GPU 离屏渲染 画家算法：首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分！ 通常对于每一层layer，Render Server 会遵循 画家算法，按次序输出到Framebuffer，后一层覆盖前一层，就能得到最终的显示结果。 然而有些场景并没有那么简单。作为 画家 的GPU虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来 擦除/改变 其中的某个部分——因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着， 对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作 。 比如：cornerRadius+clipsToBounds！对于多层layer的绘制，上层的 sublayer 会覆盖下层的 sublayer，下层 sublayer 绘制完之后就可以抛弃了，从而节约空间提高效率；所有 layer 依次绘制完毕之后，整个绘制过程完成，就可以进行后续的呈现了。 设置 layer.masksToBounds=YES 之后，要求它的所有子图层裁剪圆角；这就意味着所有的 sublayer 在第一次被绘制完之后，并不能立刻被丢弃，而必须要被保存在 OffScreen buffer 中等待下一轮圆角裁剪，这也就诱发了离屏渲染，具体过程如下： 3.3.1、GPU 离屏渲染的效率问题 GPU的操作是高度流水线化的：本来所有计算工作都在有条不紊地正在向 FrameBuffer 输出，此时突然收到指令，需要输出到另一块内存 OffScreen Buffer， 那么流水线中正在进行的一切都不得不被丢弃，将某些渲染结果保存到 OffScreen Buffer； 等到完成以后再次清空，再回到向 FrameBuffer输出的正常流程； 上述两步关于 buffer 的切换代价都非常大： OffScreen Buffer 本身就需要额外的空间，大量的离屏渲染可能早能内存的过大压力； OffScreen Buffer 的总大小也有限，不能超过屏幕总像素的 2.5 倍； 可见离屏渲染的开销非常大，一旦需要离屏渲染的内容过多，很容易造成掉帧的问题。所以大部分情况下，我们都应该尽量避免离屏渲染。 eg：在 UITableView 或者 UICollectionView 中，滚动的每一帧变化都会触发每个 cell 的重新绘制，因此一旦存在离屏渲染，上面提到的上下文切换就会每秒发生 60 次，并且很可能每一帧有几十张的图片要求这么做，对于GPU的性能冲击可想而知（GPU非常擅长大规模并行计算，但频繁的上下文切换显然不在其设计考量之中） 3.3.2、善用离屏渲染：光栅化 虽然离屏渲染开销很大，但如果无法避免它的时候，可以想办法把性能影响降到最低。优化思路也很简单：将花费大量资源裁出圆角的图片缓存下来，那么下一帧渲染就可以复用该缓存，不需要再重新画一遍了。 /** 表示是否开启光栅化 * 开启光栅化后，会触发离屏渲染: * Render Server 会强制将 CALayer 的渲染位图 bitmap 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。 * 保存的 bitmap 包含 layer 的 subLayer、圆角、阴影、组透明度等 * 所以如果 layer 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。 */ @property BOOL shouldRasterize; 开启光栅化的时候需要注意以下几点： 如果 layer 不能被复用，则没有必要打开光栅化； 如果 layer 不是静态，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率； 离屏渲染缓存内容有时间限制，缓存内容 100ms 内如果没有被使用，那么就会被丢弃，无法进行复用； 离屏渲染缓存空间有限，超过 2.5 倍屏幕像素大小的话也会失效，无法复用； 3.3.3、iOS 开发中常见的离屏渲染 cornerRadius+clipsToBounds：上文提过； 设置阴影 shadow：虽然 layer 本身是一块矩形区域，但是 shadow 默认是作用在其中 非透明区域 的，而且需要显示在所有 layer 内容的下方，因此根据 画家算法 必须被渲染在先。但矛盾在于此时 shadow 的本体 layer 都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？这样一来又只能另外申请一块内存，把本体内容都先画好，再根据渲染结果的形状，添加阴影到 FrameBuffer，最后把内容画上去。 设置 allowsGroupOpacity：opacity 并不是分别应用在每一层 layer 之上，而是只有到整个 图层树 画完之后，再统一加上opacity，最后和底下其他 layer 的像素进行组合；显然也无法通过一次遍历就得到最终结果。 将一对蓝色和红色 layer 叠在一起，然后在父 layer上设置 opacity=0.5，并复制一份在旁边作对比。左边关闭 allowsGroupOpacity，右边保持默认，然后打开 Xcode 调试的 Color Off-Screen Rendered 开关，会发现右边的那一组确实是离屏渲染了。 注意：从iOS7开始，如果没有显式指定，allowsGroupOpacity会默认为 YES ！ 设置蒙版 mask：mask 是应用在layer和其所有子sublayer的组合之上的，而且可能带有透明度；最终的内容是由 多层渲染结果叠加 ，所以必须要利用额外的内存空间对中间的渲染结果进行保存，因此系统会默认触发离屏渲染。 设置模糊特效 UIBlurEffectView：首先渲染需要模糊的内容本身；接着对内容进行缩放；然后分别对上一步内容进行横纵方向的模糊操作，最后一步用模糊后的结果叠加合成，最终实现完整的模糊特效。这也会触发离屏渲染。 其他还有一些，类似绘制了文字的 layer (UILabel,CATextLayer,CoreText 等)。 注意 ： 重写 -drawRect: 方法触发 CPU 软件渲染，而非 GPU 离屏渲染。 3.3.4、一些引发离屏渲染的优化 引起离屏渲染的本质是 多层渲染结果叠加，导致对 layer 以及所有 sublayer 进行多次处理。为避免对 layer 的多次处理，可以提前预处理，绘制时仅一次处理完成渲染。 对于图片的圆角：不经由容器来做剪切，而是预先使用 CoreGraphics 为图片裁剪圆角； 对于视频的圆角：由于实时剪切非常消耗性能，提前创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果； 对于view的圆形边框：如果没有 backgroundColor，可以放心使用 cornerRadius 来做； 对于所有的阴影：使用 shadowPath 来规避离屏渲染； 对于特殊形状的view：使用 layer.mask 并打开 shouldRasterize来对渲染结果进行缓存； 对于模糊效果：不采用系统提供的 UIVisualEffect，而是另外实现模糊效果CIGaussianBlur，并手动管理渲染结果； 3.4、什么时候需要 CPU 渲染？ 渲染性能的调优，其实始终是在做一件事：平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作。 一般情况下，得益于GPU针对图形处理的优化，我们都会倾向于让GPU来完成渲染任务，而给CPU留出足够时间处理各种各样复杂的App逻辑。为此 Core Animation 做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如 layer composition，设置 backgroundColor等等）。 但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片 ImageIO 渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。 这里有几个需要注意的点： 渲染不是CPU的强项，调用CoreGraphics会消耗其相当一部分计算时间，并且也不能因此阻塞用户操作，因此一般来说CPU渲染都在后台线程完成，然后再回到主线程上，把渲染结果传回 CoreAnimation。这样一来，多线程间数据同步会增加一定的复杂度 ； 同样因为CPU渲染速度不够快，因此只适合渲染静态的元素，如文字、图片； 作为渲染结果的bitmap数据量较大（形式上一般为解码后的UIImage），消耗内存较多，所以应该在使用完及时释放，并在需要的时候重新生成，否则很容易导致内存用完； 如果选择使用CPU来做渲染，那么就没有理由再触发GPU的离屏渲染了，否则会同时存在两块内容相同的内存，而且CPU和GPU都会比较辛苦； 一定要使用 Instruments 的不同工具来测试性能，而不是仅凭猜测来做决定； 参考文章 iOS 渲染原理解析 关于iOS离屏渲染的深入研究 iOS下的图像渲染原理 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"Git体系/Git常用命令.html":{"url":"Git体系/Git常用命令.html","title":"Git常用命令","keywords":"","body":"Git常用命令 1、pull 命令 ///将与本地当前分支同名的远程分支 拉取到 本地当前分支上 git pull /// 将远程指定分支 拉取到 本地当前分支上 git pull origin /// 将远程指定分支 拉取到 本地指定分支上 git pull origin : 1.1、回退到 pull 之前 /// 查看提交记录 git reflog /// 回退到某一版本 git reset --hard 70973042 2、push 命令 /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 git push /// 将本地当前分支 推送到 远程指定分支上 git push origin : /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 git push origin 3、分支 查看分支 /// 查看本地分支 git branch ///查看远程分支 git branch -r /// 查看所有分支 git branch -a 创建分支 /// 新建一个本地分支 git checkout -b L2 /// 把新建的本地分支push到远程服务器 git push origin L2:L2 /// 新建本地分支，并切换到远程分支 git checkout -b local/2 origin/0.0.2 拉取远程分支 ///拉取远程某个分支 git clone -b 分支名 git仓库 切换分支 /// 切换本地分支 git checkout master 删除分支 /// 删除本地分支 git branch -D 0.0.2 /// 删除远程分支 git push origin --delete 0.0.2 合并分支 /// 将 分支 L2 合并到 分支 L1 上 $ git checkout L1 Switched to branch 'L1' $ git merge L2 Merge made by the 'recursive' strategy. 4、tag /// 列出所有标签 git tag /// 新建tag git tag 1.0.0 /// 推送tag到远程 git push origin 1.0.0 /// 本地删除 git tag -d 1.0.0 /// 远程删除 tag git push origin :refs/tags/1.0.0 5、Pull Request Github 的 Pull Request 功能，简写为 PR；适用于多人合作的项目！ 5.1、什么是 Pull Request Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。 Pull Request 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码。 注意：GitHub 的代码贡献，是请求别人 pull 你的代码，而不是请求别人接受你的 push。因为对应的 git 操作必须是 pull 而不能是 push，所以叫 pull request 而不是 push request。 5.2、 Pull Request 的流程 第一步，在 Git 仓库创建自己的分支！ 第二步，在修改后的分支上，按下 New pull request 按钮。 这时，会进入一个新页面，有 Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。 第三步，填写说明，帮助别人理解你的提交，然后按下 create pull request 按钮即可。 PR 创建提交后，管理者就要决定是否接受该 PR。 参考文章 Pull Request 的命令行管理 git: 为什么 pull request 不叫 push request ? Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"Git体系/Github和SSH密钥.html":{"url":"Git体系/Github和SSH密钥.html","title":"Github和SSH密钥","keywords":"","body":"Github和SSH密钥 SSH 密钥允许本地计算机和 Git 远程仓库之间建立安全连接。 我们在使用 Git 管控项目时，需要一个安全的通信通道来共享信息。可以使用 用户名与密码 的认证方式，但每次输入密码，太过麻烦；还可以使用 SSH 协议向 Git 远程服务器进行身份验证。 有关SSH协议如何工作的更详细说明，建议阅读教程 DigitalOcean 。 1、SSH密钥的类型 Git 支持RSA、DSA、ECDSA和ED25519密钥。它们的区别在于签名算法，其中一些具有其他优势。 本文重点关注ED25519和RSA等。 1.1、RSA 密钥 RSA密钥是最常见的密钥，经典且可靠，兼容 OpenSSH 6.5 之前的服务器版本。 RSA 密钥最小为1024位，默认为 2048；如果希望生成更强的RSA密钥对，需要使用 -b 指定位值。 /// -t rsa 表示使用 RSA 算法 /// -b 指定 RSA 密钥为 4096 位;默认 2048 位 /// 使用 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码 MacBook ~ % ssh-keygen -o -t rsa -b 4096 -C 123456@github.com SSH 私钥密钥的旧的默认密码编码不安全。从 OpenSSH 6.5 版开始，应该使用该 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码。 但 RSA 密钥性能不够理想；所以建议使用 ED25519， ED25519 的安全性在 RSA 2048 与 RSA 4096 之间，且性能在数十倍以上。 1.2、ED25519 密钥 ED25519 密钥是在 OpenSSH 6.5 中引入的，如果GitLab服务器不兼容 ED25519 键，可以使用RSA 密钥！ ED25519 密钥加密解密很快，生成时间短而且安全性更高！ 所以现在建议使用ED25519 密钥！ 注意： 一对密钥只对应一个 Git 服务：一对密钥通吃各 Git 服务不太安全。 2、ED25519 的使用 2.1、ED25519 的制作 在Linux 或 macOS上打开终端，生成新的 ED25519 SSH 密钥对: //生成一个新的ED25519 SSH密钥对 MacBook ~ % ssh-keygen -t ed25519 -C 123456@qq.com Generating public/private ed25519 key pair. Enter file in which to save the key (/Users/long/.ssh/id_ed25519): /Users/long/.ssh/Test Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/long/.ssh/Test. Your public key has been saved in /Users/long/.ssh/Test.pub. The key fingerprint is: SHA256:FC2Qz4gvekNv8m4BcvptmI+oPKA8eqrZdhNTp/7Hkb8 123456@qq.com The key's randomart image is: +--[ED25519 256]--+ | .o.. | | . ... | | . +.. | | . + o.+ | | + + oS . | |. . = + o | |+ + X . . o | |o*+.X.B o . | |O*=o.@+... E. | +----[SHA256]-----+ 注意： passphrase 是给私钥添加一个 解锁口令！私钥必须要有 passphrase：如果私钥文件遗失，没有 passphrase 也无法解锁，只能暴力破解；所以不要偷懒，passphrase 一定要设置。 此时，已经将密匙对保存在本地！我们可以去查看并获取密匙： /// 进入ssh默认路径 MacBook ~ % cd ~/.ssh /// 查看该文件夹下的文件 MacBook .ssh % ls Test Test.pub known_hosts /// 打印公匙 Test.pub MacBook .ssh % cat Test.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTEL7FM0x60p5/S3M6IaBLkyi3OroA 123456@github.com /// 或者直接将 Test.pub 复制到剪贴板 MacBook % pbcopy 我们需要将 ED25519 的公匙复制到剪贴板，并添加到 Git 仓库！ 2.2、添加 ED25519 的公匙到 Git 远程仓库 在 Git 远程仓库中，通过点击 个人中心 -> Settings -> SSH and GPG Keys ，然后添加！ 注意： 手动复制的 ED25519 公匙，请确保以 ssh-ed25519 开头并以电子邮件结尾。 2.3、测试是否正确设置 SSH 密钥 要测试是否正确添加了SSH密钥，可以在终端中运行以下命令（自己的服务器，替换 github.com 的域名）： 2.3.1 、Permission denied (publickey) ssh -T git@github.com git@github.com: Permission denied (publickey). ///权限被拒，添加失败 如果设置正确，应该受到类似于下述的 欢迎消息： Welcome to github, @123456! 如果未出现欢迎消息，可以替换 -T 为-vvvT 来运行 SSH 的详细模式，以了解错误的位置： ssh -vvvT git@github.com 不过一般情况下，可以使用下述两个操作，将 SSH 密钥添加到高效缓存中： /// 首先进入 ssh 文件夹 MacBook ~ % ~ % cd ~/.ssh /// 然后将 ，将 SSH 密钥添加到高效缓存中 MacBook .ssh ~ % ssh-agent -s MacBook .ssh ~ % ssh-add ~/.ssh/Test 2.3.2 、but GitHub does not provide shell access. MacBook :.ssh $ ssh -T git@github.com Hi K! You've successfully authenticated, but GitHub does not provide shell access. 查看该 Git 仓库提交方式： MacBook $ git remote -v origin https://github.com/xxx/x (fetch) origin https://github.com/xxx/x (push) 发现不是 ssh 方式，需要改为 ssh 方式 MacBook $ git remote set-url origin git@github.xxx/ix.git MacBook $ git remote -v /// 再次查看 origin git@github.com:xxx/x.git (fetch) origin git@github.com:xxx/x.git (push) 参考文章： github配置ssh key过程中为什么需要ssh-add这一步呢？ 使用 Ed25519 算法生成你的 SSH 密钥 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"其它/sdk_cocoapods.html":{"url":"其它/sdk_cocoapods.html","title":"iOS 使用 cocoapods 创建组件化库","keywords":"","body":"iOS 使用 cocoapods 创建组件化库 1、创建组件库 使用 cocoapods 创建组件化库 YLServices ： MacBook-Air Desktop % pod lib create YLServices 需要回答一些问题： What platform do you want to use?? [ iOS / macOS ] > iOS What language do you want to use?? [ Swift / ObjC ] > ObjC Would you like to include a demo application with your library? [ Yes / No ] > Yes Which testing frameworks will you use? [ Specta / Kiwi / None ] > Specta Would you like to do view based testing? [ Yes / No ] > Yes What is your class prefix? > YL Running pod install on your new library. Analyzing dependencies Downloading dependencies Installing Expecta (1.0.6) Installing Expecta+Snapshots (3.1.1) Installing FBSnapshotTestCase (2.1.4) Installing Specta (1.0.7) Installing YLServices (0.1.0) Generating Pods project Integrating client project [!] Please close any current Xcode sessions and use `YLServices.xcworkspace` for this project from now on. Pod installation complete! There are 5 dependencies from the Podfile and 5 total pods installed. Ace! you're ready to go! We will start you off by opening your project in Xcode open 'YLServices/Example/YLServices.xcworkspace' To learn more about the template see `https://github.com/CocoaPods/pod-template.git`. To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. MacBook-Air Desktop % 至此，已经在本地创建了组件化库！ 2、配置文件 .podspec 组件库的配置文件 YLServices.podspec ! 如果需要依赖三方库，需要配置 s.dependency s.dependency 'AFNetworking', '4.0.1' s.dependency 'SDWebImage', '4.3.3' s.dependency 'Bugly', '2.5.0' 如果模块间需要相互引用，同样需要配置 s.dependency， 如：组件库 YLRouter 需要引用 YLServices //********1、修改 YLRouter.podspec 文件 s.dependency 'YLServices' //********2、修改 YLRouter Podfile 文件 pod 'YLServices', :path => '../../YLServices' 配置 Git 仓库的主页与地址 /// 必须配置主页地址 s.homepage = 'https://github.com/name/YLServices' /// 必须配置 Git 仓库地址 s.source = { :git => 'https://github.com/name/YLServices.git', :tag => s.version.to_s } 3、在组件库添加文件 添加类 创建 PeopleModel 类添加至指定目录： 执行 pod install ,将 PeopleModel 更新至 pods 组件库中 MacBook-Air ~ % cd /Users/long/Desktop/YLServices/Example MacBook-Air Example % pod install 添加资源文件 添加资源到指定目录，如图片、json、bundle文件等: 注意：必须在配置文件 YLServices.podspec 设置资源路径，否则无法读取资源！ s.resource_bundles = { # 添加所有类型文件 'YLServices' => ['YLServices/Assets/*'], # 指定添加 png 图片 'YLServices' => ['YLServices/Assets/*.png'], # 指定添加 bundle 类型文件 'YLServices' => ['YLServices/Assets/*.bundle'] } 然后执行 pod install ,更新组件库 MacBook-Air Example % pod install 4、组件库上传至远程 Git 仓库 MacBook-Air YLServices % git add . MacBook-Air YLServices % git commit -m'init' MacBook-Air YLServices % git push 打 tag /// 新建tag git tag 1.0.0 /// 推送tag到远程 git push origin 1.0.0 验证 podspec 文件 ///只验证一个本地仓库 MacBook-Air YLServices % pod lib /// 同时验证本地仓库和远程仓库 MacBook-Air YLServices % pod spec lint MacBook-Air YLServices % pod spec lint -> YLServices (0.0.1) - WARN | url: The URL (https://github.com/774792381@qq.com/YLServices) is not reachable. - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/774792381@qq.com/YLServices.git /var/folders/s5/127zrd4j7kl4llwhcl4cz3_40000gn/T/d20210106-20600-1a4bg2o --template= --single-branch --depth 1 --branch 0.0.1 Cloning into '/var/folders/s5/127zrd4j7kl4llwhcl4cz3_40000gn/T/d20210106-20600-1a4bg2o'... fatal: unable to access 'https://github.com/774792381@qq.com/YLServices.git/': The requested URL returned error: 400 ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 1 error and 1 warning. 5、在工程中使用组件库 YLServices 新建工程 Demo，创建 Podfile 文件 MacBook-Air Demo % pod init 在 Podfile 文件中添加： pod 'YLServices', :git => 'https://github.com/name/YLServices',:tag => '0.0.1' 此时，就可以在 Demo 工程中使用 YLServices 组件库 了！！ 参考文章 YLServices 示例 iOS 组件化方案 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"Gitbook指导/":{"url":"Gitbook指导/","title":"GitBook 使用教程","keywords":"","body":"GitBook 是使用 GitHub / Git 和 Markdown（或 AsciiDoc ）构建漂亮书籍的命令行工具（和 Node.js 库）。 GitBook 创建和托管图书，可以将您的内容作为网站（可定制和可扩展）或电子书（PDF ，ePub 或 Mobi ）输出。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "},"Gitbook指导/gitbook教程.html":{"url":"Gitbook指导/gitbook教程.html","title":"GitBook 安装","keywords":"","body":"gitbook 使用教程 下载 gitbook /// gitbook 是个本地命令行工具 /// 通过 npm 安装 gitbook npm install gitbook-cli -g /// 查看 gitbook 信息、验证安装 gitbook -V /// 列出可以下载的 gitbook 版本 gitbook ls-remote /// 列出本地的 gitbook 版本 gitbook ls /// 卸载对应的 gitbook 版本 gitbook uninstall 3.2.3 /// 安装对应的 gitbook gitbook fetch 标签/版本号 /// 更新到 gitbook 的最新版本 gitbook update /// 帮助 gitbook help 使用 gitbook创建电子书 初始化一个电子书 /// 初始化一个书籍 MacBook-Pro:book $ gitbook init gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件: SUMMARY.md 是默认概括文件，主要是根据该文件内容生成相应的目录结构； README.md 是默认首页文件，用于电子书的简介/前言； gitbook init 报错 MacBook-Pro:book $ gitbook init warn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 问题原因：node.js 版本过高； 解决办法：卸载高版本 node.js ，重新安装稍低版本的 node.js MacBook-Pro:$ node -v v16.6.1 /// 卸载高版本 node MacBook-Pro $ brew uninstall node 去官网下载一个稳定的版本 MacBook-Pro $ node -v v14.17.5 MacBook-Pro $ npm -v 6.14.14 MacBook-Pro $ npm install --global vue-cli 本地预览电子书 启动本地服务，程序无报错则可以在 本地浏览器 预览电子书效果 MacBook-Pro:book $ gitbook serve 制作静态网页 MacBook-Pro:book $ gitbook build 制作 PDF 格式 MacBook-Pro:book $ gitbook pdf MacBook-Pro:book $ gitbook epub MacBook-Pro:book $ gitbook mobi 生成 PDF 格式需要下载 ebook-convert，并链接环境变量 sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 查看目录 MacBook-Pro:booktest $ tree . ├── README.md ├── SUMMARY.md ├── _book │ ├── assets │ │ └── 图1.png │ ├── gitbook │ │ ├── fonts │ │ │ └── fontawesome │ │ │ ├── FontAwesome.otf │ │ │ ├── fontawesome-webfont.eot │ │ │ ├── fontawesome-webfont.svg │ │ │ ├── fontawesome-webfont.ttf │ │ │ ├── fontawesome-webfont.woff │ │ │ └── fontawesome-webfont.woff2 │ │ ├── gitbook-plugin-fontsettings │ │ │ ├── fontsettings.js │ │ │ └── website.css │ │ ├── gitbook-plugin-highlight │ │ │ ├── ebook.css │ │ │ └── website.css │ │ ├── gitbook-plugin-livereload │ │ │ └── plugin.js │ │ ├── gitbook-plugin-lunr │ │ │ ├── lunr.min.js │ │ │ └── search-lunr.js │ │ ├── gitbook-plugin-search │ │ │ ├── lunr.min.js │ │ │ ├── search-engine.js │ │ │ ├── search.css │ │ │ └── search.js │ │ ├── gitbook-plugin-sharing │ │ │ └── buttons.js │ │ ├── gitbook.js │ │ ├── images │ │ │ ├── apple-touch-icon-precomposed-152.png │ │ │ └── favicon.ico │ │ ├── style.css │ │ └── theme.js │ ├── index.html │ └── search_index.json ├── assets │ └── 图1.png ├── book.pdf ├── 篇1.md ├── 篇2.md └── 篇3.md 13 directories, 38 files 配置文件 book.json book.json 是配置文件,用于个性化调整 gitbook 的相关配置！如定义电子书的标题，封面，作者等信息。虽然是手动创建但一般是必选的！ author: 书籍的作者 title: 书籍的标题 description: 书籍的简要描述 language: 支持语言 \"language\": \"zh-hans\", isbn: 国际标准书号 \"isbn\": \"978-0-13-601970-1\", direction: 阅读顺序，支持从右到左(rtl)或从左到右(ltr)；默认值取决于语言值； gitbook: 指定 gitbook 版本； root: 包含所有图书文件的根文件夹的路径， book.json 文件除外； plugins : 添加新插件之后需要运行 gitbook install 来安装新的插件 { \"author\": \"苏莫离\", \"title\": \"初次配置 GitBook 教程\", \"description\": \"初次配置 GitBook 教程，记录一些使用步骤！\", \"isbn\": \"书籍的国际标准书号\", \"language\": \"zh-hans\", \"direction\" : \"ltr\", \"gitbook\": \"3.2.3\", \"root\" : \"./docs\", \"pdf.pageNumbers\" : true, \"pdf.fontSize\" : 12 , \"pdf.fontFamily\" : \"Arial\", \"pdf.paperSize\" : \"a4\", \"pdf.margin.top\" : 10, \"pdf.margin.left\" : 10, \"pdf.margin.bottom\" : 10, \"pdf.margin.right\" : 10, \"plugins\": [ \"highlight\", \"search\", \"sharing\", \"font-settings\", \"livereload\", \"collapsible-menu\", \"anchor-navigation-ex\", \"tbfed-pagefooter\", \"disqus\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": true, /// 是否自定插入标题索引 \"showGoTop\": false }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &SuMoli\", \"modify_label\": \"修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"disqus\": { \"shortName\": \"gitbookuse\" } } } 插入图片 修改一些默认配置 使用 Gitbook 进行项目输出的时候，我们会发现生成 Table of Contents 、 Introduction 等字样！此时需要修改 Gitbook 的预模版 一般情况下 Gitbook 的安装文件会在我们的 Users 目录下的 .gitbook 目录中 其 .gitbook/versions 目录下会有对应的版本号文件夹 修改对应版本号文件夹下的指定文件 ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_i18n/en.json ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_layouts/website/summary.html ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_layouts/layouts.html 修改某些占位符！ 其它配置 要提供封面，需要将 cover.jpg 文件放在书本的根目录下。添加一个 cover_small.jpg 将指定一个较小版本的封面。封面应为 JPEG 文件。 好的封面应该遵守以下准则： cover.jpg 的尺寸为 1800x2360 像素，cover_small.jpg 为 200x262 没有边界 清晰可见的书名 任何重要的文字应该在小版本中可见 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 11:08:00 "},"Gitbook指导/gitbook语法.html":{"url":"Gitbook指导/gitbook语法.html","title":"GitBook 使用","keywords":"","body":" __Gitbook 语法__ 标题 要创建标题，请在标题之前加 1-6 个 #，使用 # 的多少决定字体的大小 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 锚点 跳转到锚点 跳转到锚点 [跳转到本文标题](#title) //需要给标题添加id， 跳转到简介界面 跳转到简介界面 [跳转到简介界面](README.md) 跳转到百度 跳转到百度 [跳转到百度](http://www.baidu.com \"百度\") // 鼠标移入显现title属性 图片 ![图片](assets/图1.png) /// 不支持大小写修改 /// 支持大小写修改 字体 这是蓝色字体 这是蓝色字体 文字居中 文字居中 引用1 引用2 引用3 > 引用1 >> 引用2 >>> 引用3 序号 科目 成绩 1 语文 123 2 数学 134 3 英语 145 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-29 10:43:33 "}}