{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人简介 暂无简介 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"计算机基础/计算机组成篇/计算机概述篇.html":{"url":"计算机基础/计算机组成篇/计算机概述篇.html","title":"计算机概述篇","keywords":"","body":"计算机原理之概述篇 1、计算机的发展简史 1.1、电子管计算机 (1946~1957) 集成度小，空间占用大； 功耗高，运行速度慢； 操作复杂，更换程序需要接线； 1.2、晶体管计算机 (1957~1964) 1948 年贝尔实验室发明了晶体管，此后晶体管为计算机带来了革命性的进步！ 集成度相对较高，空间占用相对较小； 功耗相对较低，运行速度较快； 操作相对简单，交互更加方便； 1.3、集成电路计算机 (1964~1980) 德州仪器的工程师发明了集成电路(IC)！ 计算机变得更小； 功耗变得更低； 计算速度更快； 1.4、超大规模集成电路计算机 (1980~现在) 一个电路集成了上百万的晶体管； 速度更快，体积更小，价格更低，更能被大众接受； 用途丰富：文本处理、表格处理、高交互的游戏与应用； 1.5、微型计算机的发展历史 微型计算机主要受限于性能； 单核 CPU 1971~1973 500KHZ 频率的微型计算机（字长 8 位）； 1973~1978 高于 1 MHZ 频率的微型计算机（字长 8 位）； 1978~1985 高于 500 MHZ 频率的微型计算机（字长 16 位）； 1985~2000 高于 1 GHZ 频率的微型计算机（字长 32 位）； 2000~现在 高于 2 GHZ 频率的微型计算机（字长 64 位）； 摩尔定律：微型计算机的发展历史，集成电路的性能，每 18 ~ 24 个月就会提升一倍！ 多核 CPU 2005 年 Intel 奔腾系列双核 CPU、 AMD 速龙系列； 2006 年 Intel 酷睿四核 CPU； 现在 Intel 酷睿系列十六核 CPU； Intel 至强系列五十六核 CPU； 2、计算机的分类 2.1、超级计算机 功能最强、运算速度最快、存储容量最大的计算机； 多用于国家高科技领域和尖端技术研究； 运算速度单位 TFlop/s : 1 TFlop/s = 每秒一万亿次浮点计算； 2.2、大型计算机 又称大型机、大型主机、主机等； 具有高性能、可处理大量数据与复杂的计算； 在大型机市场领域， IBM 占据很大的市场份额； 由于IOE高维护费用的存储系统、不够灵活、伸缩性弱，阿里巴巴在 2008 年提出了去 IOE 行动： I : IBM 服务器提供商 O : Oracle 数据库软件提供商 E : EMC 存储设备提供商 2.3、迷你计算机（服务器） 普通服务器已经替代了传统的大型机，成为大规模企业计算的中枢 又称小型机、普通服务器； 不需要特殊的空调场所； 具备不错的运算力、可以完成较复杂的运算； 2.4、工作站 高端的通用微型计算机，提供比个人计算机更强大的性能； 类似于普通台式电脑、体积较大、性能强劲 适用于图片工作者、视频工作者 2.5、 微型计算机 又称个人计算机，是最普通的一类计算机； 台式机、笔记本、一体机 iMac 麻雀虽小，五脏俱全 3、计算机的体系与构成 3.1、冯诺依曼体系 冯诺依曼体系 “将程序指令和数据一起存储的计算机设计概念结构” 早期计算机仅含固定用途，如果想要改变用途，需要改变程序更改结构、重新设计电路！ 冯诺依曼：存储程序指令，设计通用电路！ 现代计算机本质上都是冯诺依曼机，冯诺依曼体系的几个关键要素： 必须有一个存储器：存储运行的程序以及运行所需的数据； 必须有一个控制器：控制程序的流转； 必须有一个运算器：负责运算的操作； 必须有输入设备 必须有输出设备 冯诺依曼体系： 能够把需要的程序和数据送至计算机中 (输入设备：鼠标、键盘)； 能够长期记忆程序、数据、中间结果以及最终运算结果的能力，通过记忆才能进行下一步的操作 (存储器)； 能够具备算术、逻辑运算和数据传送等数据加工处理的能力 (运算器、控制器)； 能够按照要求将处理结果输出给用户 (输出设备：显示器、打印机)； 冯诺依曼瓶颈 CPU 和存储器速率之间的问题无法调和：CPU 的读写速率很快，而存储器的读写速率没有 CPU 快；导致 CPU 经常空转等待数据的传输！ 只有把 CPU 跑满，才是充分利用计算机的表现！ 3.2、现代计算机的结构 现代计算机在冯诺依曼体系结构基础上进行修改；解决 CPU 与储存设备之间的性能差异问题！ 存储器：磁带、硬盘；更高速的设备，内存，CPU 的寄存器！ 4、计算机的层次与编程语言 4.1、程序翻译与程序解释 计算机执行的指令都是 0 和 1 （L0 程序）； 程序翻译生成新的 L0 程序；程序解释不生成新的 L0 程序； 解释过程，由 L0 编写的解释器去解释 L1 程序； 翻译+解释语言：Java / C# ； 4.1.1、程序翻译 计算机的世界中，只有 0 与 1 两种表达；与人类的语言不相同，因此需要将人类语言翻译为计算机理解的程序语言！ 常见语言：C / C++ / Objective-C / Golang ； 4.1.2、程序解释 常见语言：Python / PHP / JavaScript ； 4.2、计算机的层次与编程语言 硬件逻辑层：门、触发器等逻辑电路组成；属于电子工程的领域； 微程序机器层：编程语言为 微指令集；微指令所组成的微程序直接交由硬件执行； 传统机器层：编程语言是 CPU 指令集；编程语言直接和硬件相关；不同架构的 CPU 使用不同的指令集；指令集存储在 CPU 内部； 操作系统层：向上为用户提供了简易的操作界面；向下对接指令系统，管理硬件资源；是在软件和硬件之间的适配层； 汇编语言层：汇编语言可以翻译为直接执行的机器语言；完成翻译过程的程序就是汇编器； 高级语言层：C / C++ / Objective-C / Python / PHP / Java / JavaScript / Golang 等； 应用层：满足计算机针对某种用途而专门设计的程序； 5、计算机的计算单位 5.1、容量单位 比特位 bit：在物理层面，高低电平 0 / 1 记录信息； 字节 Byte ：1 Byte = 8 bits ; 千字节 KB : 1 KB = 1024 Byte ; 常用于 CPU 的寄存器； 兆字节 MB : 1 MB = 1024 KB ; 常用于高效缓存 吉字节 GB : 1 GB = 1024 MB ; 常用于内存/硬盘； 太字节 TB : 1 TB = 1024 GB ; 常用于硬盘； 拍字节 PB : 1 PB = 1024 TB ; 常用于云硬盘； 艾字节 EB : 1 EB = 1024 PB ; 常用于数据仓库； 疑问：为什么网上买的移动硬盘 500 G，格式化之后只剩下 465 G 了？ 答案：因为硬盘商的换算单位为 1000，而计算机的换算单位为 1024 ! 5.2、速度单位 5.2.1、网络速度 疑问：为什么电信拉的 100 M 光纤，测试峰值速度只有 12 M 每秒？ 答案：网络速度单位为 Mbps ，即电信拉的 100 Mbps 光纤 ！ 100 M/s = 100 Mbps = 100 Mbit/s = 100 / 8 MB/S = 12.5 M/S ! 5.2.2、CPU 频率 *CPU 的速度一般体现为 CPU 的时钟频率； CPU 的时钟频率单位一般为赫兹 HZ ； 赫兹 HZ 就是秒分之一，它是每秒钟的周期性变动重复次数的计量； 主流 CPU 的时钟频率都在 2 GHZ 以上; 2 GHZ = 2 * 1000^3 HZ = 20 亿次/秒 ! 6、计算机的字符与编码集 6.1、字符编码集的历史 ASCII 码：使用 7 个比特位就可以完全表示 ASCII 码 ；包含 95 个可打印字符与33 个不可打印字符（控制字符）！ ASCII 码在很多应用和国家的符号都无法表示；如数学符号 等！ 扩展的ASCII 码，使用 8 个比特位表示，包含数学符号 等！ 字符编码集的国际化： 各个国家的语言多样性； 语言体系不一样，不以有限字符组合的语言； 中、日、韩等的语言最为复杂； 6.2、中文编码集 GB 2312 ： 收录了 6763 个汉字和 682 个其它字符 ，总计 7445 个字符； GBK ： 向下兼容GB 2312，向上支持国际标准 ISO ; 收录了 21003 个汉字，支持全部中日韩汉字 Unicode : 兼容全球的字符集，定义了世界通用的字符集！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"计算机基础/计算机组成篇/计算机组成篇.html":{"url":"计算机基础/计算机组成篇/计算机组成篇.html","title":"计算机组成篇","keywords":"","body":"计算机原理之组成篇 1、计算机的总线 1.1、总线的概述 1.1.1、总线是什么？有什么用？ 计算机的总线就像是计算机的 “高速公路”，是为了解决不同设备间的通信而存在的！ 总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。总线标准有利于各模块高效使用总线。如 USB、PCIe 等。 1.1.2、总线的分类 总线分为片内总线与系统总线！ 片内总线：芯片内部的总线，高集成度芯片内部的信息传输线；可以连接寄存器与寄存器；可以连接寄存器与控制器、运算器； 系统总线：分为数据总线、地址总线、控制总线等；是 CPU 、主内存、IO 设备、各组件之间的信息传输线； 1.2、总线的仲裁 为了解决不同设备使用总线的优先顺序的设备； 为了解决总线使用权的冲突问题，有三种仲裁方法： 1.2.1、链式查询 假设设备 2 需要使用总线： 那么设备 2 通过仲裁控制线向仲裁控制器发出“使用总线”的请求； 仲裁控制器收到请求后发出允许使用的的信号； 该信号通过链式查询的方式会先进入设备 1 ； 如果设备 1 不需要使用，那么该信号会来到设备 2 ，设备 2 拿到信号后就可以使用总线； 假设设备 1、设备 2 同时发出使用总线的请求：那么设备 1 将优先拿到总线的使用权； 1.2.2、计时器定时查询 仲裁控制器分别与设备1、设备2、设备3 连接；仲裁控制器有一个计数器，比如值为 1； 假设设备 2 需要使用总线，将通过仲裁控制线向仲裁控制器发出请求； 仲裁控制器会将当前的计数器值 1 发送给所有的设备； 设备 1 实际没有发出请求信号，所以仲裁控制器发出的计数器值 1 无用； 此时仲裁控制器会发出信号 2，此时设备 2 可以获得总线使用权； 2、计算机的输入与输出设备 2.1、常见的输入输出设备 2.2、输入输出接口的通用设计 2.3、CPU 与 IO 设备的通信 程序中断 在某一时刻，CPU 在执行主程序，打印机处于待机状态； 接着 CPU 发出了一个启动打印机的信号，发出信号后 CPU 继续执行主程序； 打印机在收到 启动 信号后，做一些准备工作来启动，准备工作完成后打印机向 CPU 发送一个中断信号； CPU 收到中断信号后，会响应中断信号（不是立即中断，可能延迟） 接着 CPU 发送数据给打印机，打印机接收数据； CPU 发送完数据，会 中断返回，继续执行中断前执行的主程序；同时打印机也会开始打印数据； DMA （直接内存存取） DMA (Direct Memory Access) ： 直接内存存取； 对于 主存 与 IO 设备 并没有直接的连接；而是通过 DMA 设备连接； 当主存与 IO 设备交换信息时，不需要中断 CPU ； DMA 可以处理主存与 IO 设备交换信息的操作； IO 设备不用打断 CPU 的工作，因此 DMA 可以提高 CPU 的效率； 比较：程序中断和 DMA 都是计算机 IO 和低速设备的交互方式，程序中断方式实现简单，DMA 方式效率更高。 3、存储器 常见的存储器有以下几种： 主存：主存储器，即常说的计算机内存条， 辅存：辅助存储器，即常说的磁盘、U 盘、光盘、磁带等， Cache（高速缓存）：即常说的 L1、L2、L3 缓存，CPU 寄存器等，一般位于 CPU 上 ！ RAM：随机存取存储器（Random Access Memory） ROM：只读存储器（Read Only Memory） 3.1、存储器的层次结构 存储器的层次结构可以简单划分为：缓存 - 主存 - 辅存 三个层次，缓存 - 主存 主要是为了解决主存速度不够的问题；主存 - 辅存 主要是为了解决主存容量不足的问题。 3.1.1、缓存-主存 的层次 原理：局部性原理，指 CPU 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的区域中； 实现：在 CPU 与主存之间增加一层速度快容量小的 Cache ； 目的：解决 CPU 与主存速度不匹配的问题！ 3.1.2、主存-辅存 的层次： 原理：局部性原理； 实现：在主存之外增加辅助存储器（磁盘、SD 卡、 U盘等） 目的： 为了解决主存容量不足的问题； 例子：针对 8G 的Mac 与 10 多G 的 Xcode，Xcode 是如何运行到仅仅 8 G 的内存的？由于局部性原理，可以将一些必要数据加载到内存中，对于不使用的数据放到辅存中！ 3.2、计算机的主存储器 主存储器 -> 内存 随机存取存储器 RAM （Random Access Memory） RAM 通过电容存储数据，必须隔一段时间刷新一次，刷新需要有电的存在； 如果掉电，那么一段时间后不能刷新，电容中的电子将丢失，即丢失所有数据； 3.2.1、主存储器如何与 CPU 的交互？ CPU 中的主存数据寄存器 MDR 通过数据总线与主存储器中的读写电路交互； CPU 中的主存地址寄存器 MAR 通过地址总线与内存连接； 因为数据总线与地址总线的存在，CPU 可以通过地址总线指定数据的位置，同时通过数据总线传输相关的数据； 3.2.2、主存储器与操作系统的位数有关系 主存储器与操作系统位数有一定的关系，不同的操作系统对内存的支持是不同的： 32 位系统：最多支持 4 GB 的内存（2^32 = 4 * 2^30 = 4 GB）；在 32 位系统中加装更多的内存也是无用的，因为它的地址总线只有 32 位，寻址范围只有 4 GB 的大小； 64 位系统：最多支持 2^34 GB 的内存（2^64 = 2^34 * 2^30 = 2^34 GB）；在 64 位系统中地址总线有 64 位，寻址范围有 2^34 GB 大小； 3.3、计算机的辅助存储器 - 磁盘 磁盘表面是可磁化的硬磁特性材料，通过移动磁头径向运动读取磁道信息！ 磁盘由两部分组成： 光滑的盘片：使用磁材料存储数据； 磁头（悬臂）：通过左右移动来读取特定地址的信息 磁头位置：当前磁头位于哪一个磁道； 磁头方向：磁头向里走或者向外走； 3.3.1、磁盘的调度算法 为方便计算，将最外层的磁道称为第 1 磁道，最里面的磁道称为第 n 磁道。 假设磁头位于磁道4，磁头方向由里向外，现在需要读取磁道 1、4、2、3、1、5 ！ 先来先服务算法：磁头的移动痕迹 4 -> 1 -> 4 -> 2 -> 3 -> 1 -> 5 ！ 最短寻道时间优先算法：磁头的移动痕迹 4 -> 5 -> 3 -> 2 -> 1 -> 1 ！ 扫描算法（电梯算法）：磁头的移动痕迹 4 -> 3 -> 2 -> 1 -> 1 -> 5 ！ 循环扫描算法 ：磁头的移动痕迹 4 -> 5 -> 1 -> 1 -> 2 -> 3 ！ 3.4、高速缓存的工作原理 3.4.1、字与字块 基本概念： 字：是指存放在一个存储单元中的二进制代码组合；是存储单元的最小单位；一个字可以表示一个数据、一个指令、 一个字符串； 字块：存储在 连续 的存储单元中而被看作是一个单元的 一组 字；字块包含了多个字 ！ 字的寻址 字的地址包括两个部分，分别由字块的部分（用来指示当前需要寻址的字是属于哪一个字块的 ）以及字的部分（用来寻找字块中哪一个字是这个地址所指定的字 ）组成！ demo 假设主存空间为 4 G，字块大小为 4 M，字长位 32 位，则对于字地址中的地址块 m 和块内地址 b 的位数，至少应该是多少？ 4 G = 4096 M; 字块数：4096 / 4 = 1024 /// 至少需要 10 位来表示 1024 个字块 字块地址 m ：log2(1024) = 10 /// 每个字块内有 1048576 个字 块内字数： 4 M / 32 bits = 1048576 /// 至少需要 20 的块内地址来表示块内所有的字 块内地址 b ： log2(1048576) = 20 因此：m >= 10 ; b >= 20; 3.4.2、高速缓存 主存的容量远远大于缓存的容量（主存的字块数远大于缓存的字块数）； 缓存存取的数据是对主存的某块数据的复制（缓存中的数据来自于主存）； 缓存是如何在 缓存-主存 的层次中工作的呢？ CPU 需要高速缓存有两种情况： CPU 需要的数据在缓存中，CPU 直接高效快速的从高速缓存中拿到数据； CPU 需要的数据不在缓存中；CPU 从主存中拿数据； 高速缓存的读取速度比主存快很多，CPU 从主存拿数据，大大降低了 CPU 的效率；因此需要 CPU 尽可能的从高速缓存中读取数据，而非主存中取数据！此时需要一个量化的指标来量化 CPU 从高速缓存中取数据成功的机率（缓存命中率）！ 缓存命中率是衡量缓存的重要性能指标；理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1（实际上永远不可能位 1）！ 假设访问主存 m 次，访问缓存 n 次，那么缓存命中率就是 h = n / (m + n) 假设访问主存时间为 Tm，访问缓存时间为 Tc，则访问 缓存-主存 系统的平均时间为 Ta = h * Tc + (1 - h) * Tm！那么访问效率 e = Tc / Ta = Tc / ( h * Tc + (1 - h) * Tm) ！ demo 假设 CPU 在执行某段程序时，共访问了Cache 命中了 2000 次，访问主存 50 次，已知缓存的存取时间为 50 ns，主存的存取时间为 200 ns，求 缓存-主存 系统的命中率、访问效率和平均访问时间？ 缓存命中率 h = 2000 / (2000 + 50) = 0.97; 平均访问时间 Ta= 0.97 * 50 + (1 - 0.97) * 200 = 54.5 ns; 访问效率 e = 50 / 54.5 = 91.7% ; 3.5、高速缓存的替换策略 为了使 CPU 的运行效率更高，需要缓存命中率越高越好，让 CPU 在每一次取数据时，都能从高速缓存中取数据，而不是从主存中取数据！此时我们需要一个良好的缓存替换策略，使得缓存中的数据都是 CPU 需要的数据！ 替换时机：当 CPU 需要的数据不在高速缓存中时，需要从主存中载入所需的数据，然后替换到高速缓存中！ 假设缓存 4 个字块，() 表示使用的字块，[] 表示淘汰的字块 最近最少使用算法（LRU） (1) 1 (2) 2、1 (4) 4、2、1 (7) 7、4、2、1 (5) 5、7、4、2 [1] (4) 4、5、7、2 (6) 6、4、5、7 [2] 4、计算机的指令系统 4.1、机器指令的形式 机器指令主要由 操作码、地址码 两部分组成；分为三地址指令、二地址指令和一地址指令！ 操作码：指明指令所要完成的操作；操作码的位数反映了机器的操作种类，比如操作码有 8 位，则有 2^8 = 256 种操作！ 地址码：直接给出操作数或者操作数的地址；因为机器指令本质上还是对数据进行操作，所以地址码实际上还是指定数据或者数据的地址，使得 CPU 能够根据数据或者数据的地址进行运算； /// 三地址指令 操作码OP | addr1 | addr2 | addr3 (addr1)OP(addr2) -> (addr3) 如加法操作 (1)+(2) -> (3) /// 二地址指令 操作码OP | addr1 | addr2 (addr1)OP(addr2) -> (addr1)或者(addr2) /// 把结果放到 addr1 或者 addr2 /// 一地址指令 操作码OP | addr1 (addr1)OP -> (addr1) /// 把结果放到 addr1 ，如自己对自己的操作 (addr1)OP(ACC) -> (addr1) /// 把结果放到 addr1 零地址指令，在机器指令中无地址码，空操作、停机操作、中断返回操作等！ 4.2、机器指令的操作类型 4.3、机器指令的寻址方式 顺序寻址：执行 101 指令、102 指令、103 指令、104 指令、105 指令； 跳跃寻址：105 指令指向102 指令，因此跳跃到 102 指令！ 数据寻址方式 优先 缺点 立即寻址 速度快（从机器指令直接拿到数据） 地址码位数 限制操作数表示范围 （数据存放在地址码中） 直接寻址 寻找操作数简单 地址码位数 限制操作数表示范围 间接寻址 操作数寻址范围大 速度较慢 5、计算机的控制器 计算机的控制器用于协调和控制计算机运行！ 程序计数器：用于存储下一条指令的地址；当 CPU 工作时程序计数器会循环不断的从计数器中拿出指令；当拿出一条指令后，会指向下一条指令；程序计数器 主要提供给其它控制单元当前指令执行的地址！ 时序发生器：属于电气工程领域，用于发送时序 脉冲，CPU 依据不同的时序脉冲有节奏的进行工作！ 指令译码器：是控制器的重要部件之一，计算机指令由操作码与地址码组成，指令译码器会将操作码翻译为对应的操作数据、将地址码翻译为控制传输地址对应的数据！ 指令寄存器：是 CPU 高效运转的重要部件之一，用于缓存从主存或者高速缓存取下来的计算机指令；当 CPU 需要执行相关指令时，就可以从指令寄存器取出相关的指令，而不需要从主存或者高速缓存去取！ 主存地址寄存器：保存当前 CPU 正要访问的内存单元的地址，通过地址总线与主存通信的！ 主存数据寄存器：保存当前 CPU 正要读、正要写的主存数据，通过数据总线与主存通信的！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 6、计算机的运算器 计算机的运算器主要用于数据的运算加工！ 数据缓冲器：分为 输入缓冲 与 输出缓冲；输入缓冲 用于暂时存放外设传送来的数据，如果 ALU 正在运算则下一个运算数据保存在该缓冲中； 输出缓冲 暂时存放往外设的数据，当数据运算完毕从 ALU 输出时保存在输出缓冲中、等待控制器下一步的命令将数据送到相应位置！ ALU（算数逻辑单元）：是运算器的主要组成，可以完成常见的位运算（左移、右移、或、与、非等），可以完成一些算术运算（加、减、乘、除等）！ 状态字寄存器：用于存放运算中的状态（条件码、进位、溢出、结果正负等）；存放运算控制信息（调试跟踪标记位、允许中断位等）！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 7、计算机指令的执行过程 7.1、指令的执行过程 指令执行的一般操作 : 取指令 -> 分析指令 -> 执行指令 ! 取指令：从指令缓存中取指令，送到指令寄存器； 分析指令：将指令从指令寄存器取出，送到指令译码器译码；指令译码器发送控制信号，同时程序计数器 +1； 执行指令：首先将数据装载到寄存器，接着ALU 处理数据，记录运算状态，最后送出运算结果！ 指令执行中涉及的设备：数据缓冲器、指令缓冲器、运算器（通用寄存器、数据寄存器、状态字寄存器）、程序计数器、指令译码器、时序发生器、指令寄存器； 运算器部分、控制器部分、高速缓存部分，通过片内总线连接起来； 执行指令时，首先发生数据缓存与指令缓存；将数据与指令缓存到 CPU 的高速缓存中； 接着程序计数器根据指令地址 101，程序计数器只知道指令的地址而不知道指令的具体内容，需要通过总线来到指令缓存中获取指令 MOV R0,R1； 通过片内总线来到指令寄存器，指令寄存器缓存具体内容 MOV R0,R1； 指令寄存器不知道相关内容，还需要将指令发送到指令译码器；同时程序计数器 +1 (102)； 指令译码器将指令译码，译码完成后理解指令的具体内容 (将 R0 的数据移到 R1 中)；指令译码器发出控制信号； 控制信号通过片内总线来到运算器，运算器通过控制信号知道自己要干什么； 运算器首先将 R0(100) 加载到 ALU 中，接着将 R0(100) 通过总线送到数据缓存器； 数据缓存器会将 R0(100) 覆盖到 R1，此时 R1 的数据为 R1(100)！ 完成该条指令后，CPU 又去执行下条指令！ 疑问：在上述 取指令 与 分析指令 的过程中，是由控制器工作的；执行指令时，由运算器工作！也就是说，运算器与控制器不能同时工作，这就导致 CPU 的综合利用率并不高 ！因此需要改进指令执行过程，提高CPU 的综合利用率！ 7.2、CPU 的流水线设计 CPU 的流水线设计类似于工厂的装配线，多个厂品可以同时被加工；在同一时刻，不同产品位于不同的加工阶段！ 每一个时间片，都有一条或多条指令在执行； 如对于第 2 个时间片，第1条指令在分析，第 2 条指令在取指令； CPU 的流水线设计大大提升了CPU 的综合利用率！ 假设取指令、分析指令、执行指令的时间开销都是 t： 串行执行 m 条指令： T1 = 3t * m ； 流水线执行 m 条指令： T2 = t * (m + 2) ； 流水线执行的效率 H = T2 / T1 = (t * (m + 2)) / (3t * m) ； 当 m 很大时 流水线执行效率是串行执行 的 3 倍！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"计算机基础/计算机组成篇/计算机计算篇.html":{"url":"计算机基础/计算机组成篇/计算机计算篇.html","title":"计算机计算篇","keywords":"","body":"计算机原理之计算篇 1、进制运算的基础 1.1、进制运算概述 1024 = 0b1000000000 (0b 表示二进制) = 0o2000 (0o 表示八进制) = 0x400 (0x 表示十六进制) 1.2、二进制运算的基础 整数进制转换 /// 整数二进制转十进制：按权展开法 N = 01100101 = 1 * 2^6 + 1 * 2^5 + 1 * 2^2 + 1 = 101 N = 11101101 = 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^3 + 1 * 2^2 + 1 = 237 /// 整数十进制转二进制：重复相除法 (01100101)(从下向上) 101 / 2 = 50 ··· 1 50 / 2 = 25 ··· 0 25 / 2 = 12 ··· 1 12 / 2 = 6 ··· 0 6 / 2 = 3 ··· 0 3 / 2 = 1 ··· 1 1 / 2 = 0 ··· 1 浮点数进制转换 /// 浮点数二进制转十进制：按权展开法 N = 0.11001 = 1 * 2^-1 + 1 * 2^-2 + 1 * 2^-5 = 0.78125 N = 0.01011 = 1 * 2^-2 + 1 * 2^-4 + 1 * 2^-5 = 0.34375 /// 浮点数十进制转二进制：重复相乘法（0.11001）(从上向下) 25/32 = 50/32 = 1 + 9/16 取 1 9/16 = 18/16 = 1 + 1/8 取 1 1/8 = 1/4 = 0 + 1/4 取 0 1/4 = 1/2 = 0 + 1/2 取 0 1/2 = 1/1 = 1 + 0 取 1 1.3、有符号数与无符号数 1.3.1、原码表示法 如何判断是数字位还是符号位？ 原码表示法 使用 0 表示正数，使用 1 表示负数，规定符号位位于数值第一位；表达简单明了，是人类最容易理解的表示法！ 在原码表示法之下，0 有两种结果：正 0 00 与负0 10 ！除此之外，原码表示法进行运算也非常复杂，特别是两个操作数符号不同的时候！ 1.3.2、补码表示法 补码表示法：使用正数代替负数！但仍然没有实现 使用加法操作代替减法操作 的预期！ /// n = 4, x = 13； 计算 x 的二进制原码和补码 原码 x = 0 1101 补码 x = 0 1101 /// y = -13； 计算 y 的二进制原码和补码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 1.3.3、反码表示法 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 反码 2^(n+1) - 1 + y = 2^(4 + 1) - 1 - 13 = 011111 - 1101 = 10010 反码 y = 1 0010 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 反码 2^(n+1)-1 + z = 2^(4 + 1) - 1 - 7 = 011111 - 0111 = 11000 反码 z = 1 1000 十进制 原码 补码 反码 13 0 1101 0 1101 0 1101 -13 1 1101 1 0011 1 0010 -7 1 0111 1 1001 1 1000 -1 1 0001 1 1111 1 1110 负数的反码等于原码（除符号位）按位取反 ！ 负数的补码等于其反码 + 1 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 反码 y = 1 0010 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码、补码、反码 原码 z = 1 0111 反码 z = 1 1000 补码 z = 1 1001 1.3.4、小数的补码 /// n = 4, x = 9/16； 计算 x 的二进制原码、补码、反码 原码 x = 0 0.1001 (重复相乘法) 反码 x = 0 0.1001 补码 x = 0 0.1001 /// y = -11/32； 计算 y 的二进制原码、补码、反码 原码 y = 1 0.01011 (重复相乘法) 反码 y = 1 1.10100 补码 y = 1 1.10101 2、定点数与浮点数 2.1、定点数的表示方法 小数点固定在某个位置的数称为定点数！ 数值 符号位 数值位 0.1011 0 1011 -0.1011 1 1011 1011 0 1011 -1011 1 1011 2.2、浮点数的表示方法 计算机处理的很大程度上不是纯小数或纯正数；数据范围很大，定点数难以表达；此时需要使用浮点数来表示！ 2.2.1、浮点数的表示格式 科学计数法 1 2345 0000 = 1.2345 * 10^8 /// 尾数 1.2345 /// 基数 10 /// 阶码 8 /// 科学计数法要求尾数的绝对值范围在 [1,10) 之间 浮点数在计算机存储中分为 4 个部分 (规格要求： 尾数使用纯小数，且尾数最高位必须是 1 ) ！ 浮点数的表示格式 N = S * r^j 11.0101 = 0.110101 * 2^10 11.0101 = 0.0110101 * 2^11 ///不符合要求：尾数最高位不是 1 11.0101 = 1.10101 * 2^1 /// 不符合要求：尾数不是纯小数 阶码符号位 阶码数值位 尾数符号位 尾数数值位（8位） 0 10 0 11010100 2.2.2、浮点数的表示范围 假设阶码数值取 m 位，尾数数值取 n 位，N = S * r^j ！ 阶码能够表示的最大值：2^m - 1 ；考虑有符号时 [-(2^m - 1), 2^m - 1] 尾数能够表示的最大值：1 - 2^-n；尾数全是 1 的时候是最大值； 尾数能够表示的最小值：2^-n；尾数全是 0 （除了最后一位是 1） 的时候是最小值； 尾数表示范围：[2^-n, 1 - 2^-n]；考虑有符号时[-(1 - 2^-n),-2^-n]， [2^-n, 1 - 2^-n]； 超出浮点数的表示，有可能导致数据溢出： 上溢：绝对值太大，导致没有办法表示这么大的数； 下溢：绝对值太小，导致没有办法表示这么小的数； 单精度浮点数 float ：使用 4 个字节 (32 位) 来表示浮点数; 双精度浮点数 double：使用 8 个字节 (64 位) 来表示浮点数; Demo 1 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 13/128 表示为二进制浮点数 原码=反码=补码 x = 0.0001101000 (重复相乘法) 浮点数规格化 x = 0.1101000 * 2^-11 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 1 0011 0 1101000000 Demo 2 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 -54 表示为二进制浮点数 原码 x = 1 110110 (重复相除法) 浮点数规格化 x = -0.110110 * 2^110 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 0 0110 1 0010100000 2.3、定点数与浮点数的对比 当定点数与浮点数位数相同时，浮点数表示的范围更大； 当浮点数的尾数为规格化的小数时，浮点数的精度更高； 浮点数的运算包含阶码和尾数，浮点数的运算更为复杂； 浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数； 浮点数在数的运算规则、运算速度、硬件成本等方面不如定点数； 2.4、定点数的加法与减法 2.4.1、定点数的加法计算 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 ： 整数加法： A[补] + B[补] = [A + B][补](mod2^(n+1)) 小数加法： A[补] + B[补] = [A + B][补](mod2) /// 例1： A = -110010, B = 001101, 求 A + B A[反] = 1 001101 A[补] = 1 001110 B[反] = 0 001101 B[补] = 0 001101 [A + B][补] = 1 011011 [A + B][反] = 1 011010 A + B = -100101 /// 例2： A = -0.1010010, B = 0.0110100, 求 A + B A[反] = 1 1.0101101 A[补] = 1 1.0101110 B[反] = 0 0.0110100 B[补] = 0 0.0110100 [A + B][补] = 1 1.1100010 [A + B][反] = 1 1.1100001 A + B = -0.0011110 /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 10100000 B[补] = 1 10110000 [A + B][补] = 1 00100000 [A + B][反] = 1 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 00100000 B[补] = 1 00110000 [A + B][补] = 0 10100000 [A + B][反] = 0 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 判断溢出的方法： 双符号位判断法：单符号位表示成双符号位，运算时双符号位产生的进位丢弃；如果结果的双符号位不同，则表示溢出！ /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 10100000 B[补] = 11 10110000 [A + B][补] = 11 00100000 [A + B][反] = 11 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 00100000 B[补] = 11 00110000 [A + B][补] = 10 10100000 [A + B][反] = 10 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 2.4.2、定点数的减法计算 将减法转为上述的加法操作： 整数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2^(n+1)) 小数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2) (-B)[补] 等于 B[补] 连同符号位按位取反，末位加一！ B[补] = 10010101 (-B)[补] = 01101011 2.4、浮点数的加法与减法 一般步骤：对阶 -> 尾数求和 -> 尾数规格化 -> 舍入 -> 溢出判断 ！ 对阶：保证两个浮点数的阶码一致，使得尾数可以进行计算！阶码按照小阶看齐大阶的原则； 尾数规格化：对补码进行规格化需要判断两种情况：S > 0 或 S ！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"计算机基础/操作系统篇/操作系统基础篇.html":{"url":"计算机基础/操作系统篇/操作系统基础篇.html","title":"操作系统基础篇","keywords":"","body":"操作系统基础篇 多道程序设计：是指计算机内存中同时存放多个程序，并且这些程序互不干扰； 早起的 批处理系统 一次只能处理一个任务； 多道程序设计使得 批处理系统 可以一次处理多个任务； 多道程序在计算机的管理程序之下相互穿插运行； 因此，对多道程序的管理是操作系统的重要功能； 1、操作系统概览 1.1、什么是操作系统？为什么使用操作系统？ 操作系统是管理硬件、提供用户交互的软件系统！ 操作系统是管理计算机硬件和软件资源的 计算机程序；通过管理配置内存、决定资源供需顺序、控制输入输出设备等方法管理硬件资源；同时，操作系统也提供了让用户和系统交互的操作界面！ 操作系统的种类是多种多样的，不局限于计算机；从手机到超级计算机，都有操作系统的存在(Android 、iOS 、Windows 、Linux 、MacOS 等)！在不同的设备，操作系统既可以简单也可以复杂，向用户呈现多种操作手段（手机的触控操作）！ 为什么使用操作系统？ 我们不可能直接的操作计算机硬件（如要求 CPU 计算 1 + 1） 设备种类繁多复杂，需要操作系统为用户提供了统一的界面，屏蔽不同设备的差异； 操作系统的简易性使得更多的人可以使用计算机； 1.2、操作系统的基本功能 基本功能一：操作系统统一管理着计算机资源 如用户需要操作某个文件，并不是直接操作该文件的地址，而是通过操作系统来访问！ 如存储器资源，在用户读取数据或者写入数据，并不是直接控制存储器的设备读写，而是通过操作系统去管理和读写的！ 如处理器资源，也不是直接告诉 CPU 需要计算的内容，而是由操作系统来翻译需要做的任务！ 基本功能二：用户无需面向硬件接口编程 操作系统的 IO 设备管理软件，提供读写接口； 文件管理软件，提供操作文件的接口； 操作系统实现了对计算机资源的抽象；通过管理软件来实现抽象！管理软件屏蔽了硬件设备，向上向用户提供了逻辑设备，使得每个用户都使用相同的逻辑！ 基本功能三：操作系统提供了用户和计算机之间的接口 图像窗口形式 命令形式 系统调用形式 1.3、操作系统的相关概念 我们需要了解关于操作系统的 并发性 、共享性 、 虚拟性 、 异步性 ！ 1.3.1、并发性 并发与并行: 并行是指两个或者多个事件可以在 同一时刻 发生 并发是指两个或者多个事件可以在 同一时间间隔 发生 多道程序设计是并行与并发的基础 在单核处理器上，程序主要是并发的执行：在某一时刻，只能由一个程序占用 CPU ；在一个时间间隔内，多道程序交替运行； 在多核处理器上，程序可以并行的执行：在某一时刻，每个核上可以单独处理一个程序；多核同时处理多个程序； 1.3.2、共享性 资源共享表现为操作系统中的资源可以被多个并发的进程共同使用；多个程序可以同时使用主存资源的性质就是共享性！ 根据属性划分分为 互斥共享形式 与 同时访问形式 ! 互斥共享形式 当资源被程序 A 占用时，其它想使用该资源的程序只能等待 只有进程 A 使用完以后，其它进程才可以使用该资源 如打印机被程序 A 使用，那么程序 B 只能等待 程序 A 打印完毕才能使用打印机 同时访问形式 某种资源在一段时间内 并发地 被多个程序访问 这种 同时 是宏观的，从宏观上看该资源可以被同时访问 如程序 A 与程序 B 都准备向硬盘写入数据，硬盘悬臂只有一个，程序 A 写数据时，程序 B 实际上是不能写的；但写数据是一件快速的事情，所以我们可能观察到程序 A与程序 B在一瞬间都写入了数据 1.3.3、虚拟性 虚拟性表现为把一个物理实体转变为若干个逻辑实体；物理实体是真实存在的，而逻辑实体是虚拟的！ 虚拟性的技术主要有 时分复用技术 、空分复用技术 ! 时分复用技术 时分复用技术相关概念： 资源在时间上进行复用，不同程序并发使用 多道程序分时使用计算机的硬件资源 提高资源的利用率 时分复用技术主要有 虚拟处理器技术 、虚拟设备技术 ! 虚拟处理器技术 借助多道程序设计技术 为每个程序建立进程 多个程序分时复用处理器来执行相关逻辑 虚拟设备技术 将一个物理设备虚拟为多个逻辑设备 每个程序占用一个逻辑设备 多个程序通过逻辑设备并发访问 空分复用技术 空分复用技术主要用来实现虚拟磁盘、虚拟内存等；使用空分复用技术可以提高资源的利用率、提高编程效率！ 空分复用技术主要有 虚拟磁盘技术 、虚拟内存技术 ! 虚拟磁盘技术 将一个物理磁盘虚拟为多个逻辑磁盘 如一个硬盘虚拟为 C 盘、D 盘、E盘等 使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量 使用比实际内存更大的容量 大大的提升编程效率 1.3.4、异步性 异步性主要体现在以下几点： 在多道程序环境下，允许多个程序并发执行 进程在使用资源时可能需要等到或者放弃 进程的执行并不是一气呵成的，而是以走走停停的形式推进 进程以不可预知的速度向前推进（何时执行、何时暂停、何时完成 均不知道） 2、进程管理之进程实体 2.1、为什么需要进程 在没有操作系统的年代，计算机只能运行一个程序，计算机资源属于当前运行的程序；有了操作系统之后，引入了多道设计的概念，通过合理的隔离资源、运行环境，提升资源利用率！ 进程是系统进行资源分配和调度的基本单位； 进程作为独立运行的载体，保障程序正常执行；(多个进程可能使用一个共同的设备，如存储器、CPU等) 进程的存在使得操作系统对资源的利用率大幅度提升； 2.2、进程的实体：主存中的进程形态 进程控制块 PCB 在主存中，进程也是一段连续存储的空间 (进程控制块)： 用于描述和控制进程运行的通用数据结构； 用于记录进程当前状态和控制进程运行的全部信息； PCB 是进程能够独立运行的基本单位；每个进程都依赖于进程控制块，被操作系统调度； PCB 是操作系统进行调度经常会被读取的信息； PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内； 进程控制块 PCB 的一些关键构成元素 进程控制块元素 细节 标识符 唯一标记一个进程，用于区别其它进程（如进程 ID 就是唯一标识符） 状态 标记进程的状态，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态 程序计数器 进程即将被执行的下一条指令的地址 内存指针 程序代码、进程数据相关指针；可能有多个内存指针分别指向程序的逻辑代码 上下文数据 进程执行时处理器存储的数据 IO 状态信息 被进程 IO 操作所占用的文件列表 记账信息 存储进程使用处理器的时间、时钟数总和等； 优先级 ... ... 进程的实体由进程标识符、处理机状态、进程调度信息、进程控制信息 构成； 2.3、进程与线程 进程 Process：是操作系统进行资源分配和调度的基本单位； 线程 Thread ：是操作系统进行调度的最小单位； 一个进程可以有多个线程； 操作系统对进程的调度，实质上是对进程中线程的调度； 线程包含在进程之中，是进程中实际运行工作的单位； 一个进程可以并发多个线程，每个线程执行不同的任务； 一个进程中的多个线程共享该进程资源； 对比 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 管理线程、分配资源，因此进程系统开销大 线程系统开销小 通信 进程 IPC 读写同一进程数据通信 3、进程管理之五状态模型 进程在系统中是有多个状态的，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态！ 就绪状态： 当进程被分配到除了 CPU 以外所有必要的资源后处于就绪状态； 此时只要再获得 CPU 的使用权，就可以立即执行； 包括 进程控制块，堆空间、栈空间等内存 的其它资源都已经准备好、只差 CPU 资源的状态为就绪状态； 在一个系统中处于就绪状态的多个进程通常排成一个队列（就绪队列）； 执行状态： 进程获得 CPU 的使用权，其程序正在执行的状态； 在单处理机中，在某个时刻只能有一个进程处于执行状态； 阻塞状态： 进程由于某些原因从而放弃 CPU 的状态称为阻塞状态 如进程需要获取某个设备，而对应的设备没有就绪导致进程无法继续执行； 如某个进程需要使用打印机，而打印机属于外围的 IO 设备、速度比较慢，进程在请求使用打印机后可能没有立刻得到反馈，这时候进程无法进行下一步工作，由于打印机的未就绪而处于阻塞状态； 阻塞队列：在操作系统中可能有一个或者多个阻塞进程； 创建状态：分配 PCB -> 插入就绪队列 创建进程时拥有 PCB ，但其它资源尚未就绪的状态称为创建状态； 操作系统提供了 fork() 函数接口供程序员手动创建进程； 终止状态；系统清理 -> 归还 PCB 进程结束由系统清理或者归还 PCB 的状态称为终止状态； 就绪 -> 执行状态：当就绪状态的进程发生 进程调度 时，就可以变为执行状态； 执行 -> 就绪状态：当执行状态的进程 CPU 资源（时间片）用完时，又会切换为 就绪状态，插入到就绪队列中去；时间片资源指分配给某个进程执行的 CPU 时间段； 执行 -> 阻塞状态：进程发生 IO 请求时，可能变为阻塞状态； 阻塞 -> 就绪状态： 当 IO 完成时，进程由阻塞状态切换为就绪； 4、进程管理之进程同步 4.1、为什么需要进程间同步？ question 1：生产者-消费者问题 有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费；生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的缓冲池；生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。 在现实的宏观生活中，上述的生产者-消费者模型没有任何问题，但是针对计算机的微观世界而言，是有一些问题的！ 单从生产者程序或者消费者程序去看是没有任何问题的； 但如果两者并发执行时，可能出错！ question 2：哲学家进餐问题 有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌子，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子，只有两支筷子都被拿到的时候才能进餐，进餐完毕后放下筷子左右思考！ 上述两个模型的根源问题是彼此之间没有互相通信，如果生产者通知消费者我已经完成了一件生产、或者哲学家向旁边的哲学家说我要进餐了你们别拿我的筷子！因此需要进程间的同步！ 进程间的同步可以对竞争资源在多进程间进行使用次序的协调；使得并发执行的多个进程之间可以有效使用资源和相互合作！ 4.2、进程同步的原则 临界资源 ：指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其它进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源！ 为了对临界资源更好的约束，提出了四条原则 空闲让进：如果临界资源没有被占用、操作系统应该允许某个进程使用该临界资源； 忙则等待：如果已经有进程占用临界资源，此时应该防止别的进程使用该资源；使请求进程等待该临界资源的释放； 有限等待：在忙则等待的基础上，如果临界资源被占用，需要保证在有限等待时间内别的等待进程能够使用到资源，以避免外部等待进程僵死； 让权等待：当外部进程等待时，等待进程需要让出 CPU（进程从执行状态转为阻塞状态），保证 CPU 可以高效利用； 进程间同步的方法有：消息队列、共享存储、信号量。 4.3、线程同步 进程中的线程共享进程资源，当进程中的多线程并发的访问进程的资源时，可能发生数据竞态的问题；所以进程内多线程也需要同步！ 线程同步的方法有： 互斥量： 读写锁：应对多读少写、少读多写的情况使用； 自旋锁： 条件变量： 5、Linux 的进程管理 5.1、Linux 进程的相关概念 进程的类型 前台进程：具有终端、可以和用户交互的进程； 后台进程：基本上不和用户交互，优先级比前台进程低； 守护进程：一种特殊的后台进程；很多守护进程在系统启动引导的时候启动，一直运行直到系统关闭；如进程名字以 d 结尾的一般都是守护进程：crond 、httpd 、sshd 、mysqld ！ 进程的标记 进程 ID ：进程的唯一标记，每个进程拥有不同的 ID；是一个非负整数，最大值由操作系统限定； ID 为 0 的进程为 idle 进程，是系统创建的第一个进程； ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化； init 进程 是所有用户进程的祖先进程； /// 进程 ID 相关的关系：父子关系 进程A调用 fork() 函数创建进程B； 进程B调用 fork() 函数创建进程C； 进程A是进程B的父进程，进程B是进程A的子进程； /// 进程的父子关系可以通过 pstree 命令来查看 MacBook-Pro:~ $ pstree -+= 00001 root /sbin/launchd |--= 00064 root /usr/sbin/syslogd |--= 00065 root /usr/libexec/UserEventAgent (System) |-+= 00073 root /usr/sbin/systemstats --daemon |-+= 00075 root /usr/libexec/configd |--= 00077 root endpointsecurityd |--= 00081 root /usr/libexec/remoted |--= 00083 root /usr/libexec/logd |--= 00097 root /usr/libexec/kernelmanagerd |--= 00098 root /usr/libexec/diskarbitrationd |--= 00101 root /usr/libexec/coreduetd 进程的状态标记 状态说明 R TASK_RUNNING 进程处于运行状态 S TASK_INTERUPTIBLE 进程处于睡眠状态 D TASK_UNINTERUPTIBLE 进程处于 IO 等待的睡眠状态 T TASK_STOPPED 进程处于暂停状态 Z TASK_DEAD / EXIT_ZOMBIE 进程处于退出状态，或僵尸进程 5.2、操作 Linux 进程的相关命令 ps 命令：查看当前进程的相关信息；配合 aux 参数或 ef 参数和 grep 命令检索特定进程； 　 　 top 命令：查看一些使用内存等 kill 命令：发送特定信号给进程，kill -l 可以查看操作系统支持的信号；只有 kill 9 -0000 可以无条件终止进程，其它信号进程有权忽略； MacBook-Pro:~ $ ps PID TTY TIME CMD 21187 ttys001 0:00.01 -bash 6、作业管理之进程调度 6.1、进程调度概述 进程调度指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权！ 保存旧进程的运行信息，请出旧进程（收拾包袱） 选择新进程，准备运行环境并分配 CPU （新进驻） 就绪队列的排队机制：为了提高进程的效率，事先将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程； 选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它； 新老进程的上下文切换机制：如果需要把新的进程调度到 CPU 中，需要将旧的 CPU 中的进程备份出来，将新的进程切换到 CPU 中去；保存当前进程的上下文信息，装入被委派执行进程的运行上下文； 如果程序调度时，老进程还没有执行完会怎样呢？进程调度分为非抢占式调度、抢占式调度！ 非抢占式调度：处理器一旦分配给某个进程，就让该进程一直使用下去；调度器不以任何原因抢占正在被使用的处理器；直到进程完成工作或因为 IO 阻塞才会让出处理器； 抢占式调度：允许调度程序以一定的策略暂停当前运行的进程；保存好旧进程的上下文信息，分配处理器给新进程； 对比 抢占式调度 非抢占式调度 系统开销 频繁切换、开销大 切换次数少、开销小 公平性 相对公平 不公平 应用 通用系统 专用系统 6.2、进程调度算法 先来先服务算法：在就绪队列，按先来先服务原则，优先取出先进入队列的就绪进程； 短进程优先调度算法：调度程序优先选择就绪队列中估计运行时间最短的进程；不利于长作业进程的执行； 高优先权优先调度算法：进程附带优先权，调度程序优先选择权重高的进程；使得紧迫的任务可以优先处理；（前台进程高于后台进程，是因为前台进程与用户交互，需要保证用户的体验，不卡顿！） 时间片轮转调度算法：按照先来先服务的原则排列就绪进程；每次从队列头部取出待执行进程，分配一个时间片，时间片用完后不管进程是否执行完、都会将进程重新插入队列尾部，然后取出第二个队列；是相对公平的调度算法，但不保证及时响应用户； 7、作业管理之死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力作用，它们都将无法推进下去。此时称操作系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程！ 7.1、死锁的产生原因 死锁的产生是由于竞争资源、进程调度顺序不当导致的！ 竞争资源： 共享资源数量不满足各个进程需求； 各个进程之间发生资源竞争导致死锁； 自身占用资源不释放，而一直在等待请求的资源被释放； 假设进程 1 申请传真机为步骤 A、进程 2 申请打印机为步骤 B、进程 2 申请传真机为步骤 C、进程 1 申请打印机为步骤 D！ 按照 A -> B -> C -> D 的顺序调度，就会引起进程死锁；如果将进程调度顺序改为 A -> D -> B -> C 就不存在死锁的情况！ 7.2、死锁产生的四个必要条件 死锁的产生，必然同时满足以下四个条件，仅满足其中的某几个是不会产生死锁的！ 互斥条件：进程对资源的使用具有 排它性 ；某个资源仅能由一个进程使用，其它进程需要使用只能等待； 请求保持条件：进程至少保持一个资源，又提出了新的资源请求；但新资源被占用，导致请求被堵塞；同时被阻塞的进程又不释放自己保持的资源； 不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺；获得的资源只能由进程自身释放； 环路等待条件：发生死锁时，必然存在进程-资源环形链； 7.3、预防死锁的方法 破坏死锁产生的四个必要条件中的某一个或者某几个，就能有效预防死锁的产生！ 摒弃 请求保持条件 ：系统规定进程在运行之前，一次性申请所有需要的资源；在进程运行中，不会再去申请资源； 破坏 不可剥夺条件 ：当一个进程请求新的资源得不到满足时，必须释放其自身占有的资源；进程运行时占有的资源可以被释放，意味着可以被剥夺； 破坏 环路等待条件 ： 可用资源线性排序，申请必须按照需要递增申请；线性申请不再形成环路，从而摒弃了环路等待条件； 7.4、银行家算法 银行家算法是一个可操作的著名的避免死锁的算法、以银行借贷系统分配策略为基础的算法！ 银行家算法的策略基础： 假设客户申请的贷款是有限的，每次申请需声明最大资金量； 银行家在能够满足贷款时，都应该给用户贷款； 客户在使用完贷款后，能过及时归还贷款； 如上图所示，有初始状态的 所需资源表、已分配资源表；所需资源表减去已分配资源表得到的 还需分配资源表；还有 可分配资源表 ！ 所需资源表：P1 需要 0 个 A 资源、 6 个 B 资源、 5 个 C 资源、 6 个 D 资源； 已分配资源表：P1 已经拥有 0 个 A 资源、 0 个 B 资源、 1 个 C 资源、 4 个 D 资源； 还需分配资源表：P1 还需要 0 个 A 资源、 6 个 B 资源、 4 个 C 资源、 2 个 D 资源； 经过与 可分配资源表 对比后，发现不能满足 P1 、P3 、P4 的需求，仅仅能满足 P2 的需求； 因此先满足 P2 ，执行完 P2 后 P2 归还资源； 此时 可分配资源表 又可以分配资源给 P1 、P3 、P4 ！ 8、存储管理之内存分配与回收 早期的计算机编程并不需要过多的存储管理；随着计算机和程序越来越复杂，存储管理称为一件必要的事情！ 确保计算机有足够的内存来处理数据； 确保程序可以从可用内存中获取一部分内存使用； 确保程序可以归还使用后的内存以供其他程序使用！ 8.1、内存分配的过程 单一连续分配： 最简单的内存分配方式； 只能在单用户、单进程的操作系统中使用； 将主存分为系统区、用户区； 系统区指的是内存给操作系统所使用； 用户区指的是所有的用户区内存都给用户区程序所使用； 固定分区分配： 支持多道程序的最简单存储分配方式； 将内存空间划分为若干个固定大小的区域； 每个分区只提供给一个程序使用，互不干扰； 动态分区分配： 根据进程实际需要、动态分配内存空间； 涉及到相关数据结构（如动态分区空闲表数据结构、动态分区空闲链数据结构等）、分配算法； 假设主存中有若个分区，并且一些分区已经使用、一些分配还没有使用；这时候就需要一个数据结构来存储某个分区是否已使用！ 动态分区分配算法： 首次适应算法（FF 算法）： 最佳适应算法（BF 算法）；将空闲区链表按照容量大小进行排序；在每一次需要分配时遍历链表找到最佳合适空闲区； 快速使用算法（QF 算法）；要求有多个空闲区链表；每个链表存储一种容量的空闲区； 8.2、内存回收的过程 内存回收过程分为四种情况： 情况1：需要回收的区域和空闲区连接在一起，并且位于空闲区后面； 回收1：不需要新建空闲链表节点；只需要把空闲区 1 的容量增大为包括回收区的空闲区即可； 情况2：需要回收的区域和空闲区连接在一起，并且位于空闲区前面； 回收2：将回收区和空闲区合并为一个新的节点，然后使用回收区的地址作为新的节点地址； 情况3：需要回收的区域和空闲区连接在一起，并且位于空闲区中间； 回收3：将空闲区1、回收区、空闲区2 合并为一个新的节点，然后使用空闲区1的地址作为新的节点地址； 情况4： 需要回收的区域和空闲区没有连接在一起，单一的回收区； 回收4：为回收区创建新的节点，然后将新的节点插入到相应的空闲区链表中即可； 9、存储管理之段页式存储管理 操作系统是如何管理进程的内存空间呢？ 9.1、页式存储管理 前文提到的 字与字块 是相对于物理设备的定义，而此处的 页面 则是相对于逻辑空间的定义！ 将进程逻辑空间 等分 为若干个大小的页面； 相应的把物理内存空间分成与页面大小一样的物理块； 以页面为单位把进程空间装进物理内存中分散的物理块； 页面大小应该适中，过大难以分配，过小则内存碎片过多； 页面大小通常是 512B ～ 8 K ； 通过页式存储管理，可以把进程的逻辑空间的每个页面放到内存的物理块中去！但是又如何知道进程的某个页面具体被分配到哪一个字块中去呢？这时候就需要了解 页表 的概念！ 页表 ： 页表是一个记录进程逻辑空间与物理空间的映射表； 在页式存储管理中，地址 分为 页号 与 页内偏移； 在现代计算机系统中，可以支持非常大的逻辑地址空间（2^32 ~ 2^64）；这样就会导致页表就变得非常大，要占用非常大的内存空间。如具有 32 位逻辑地址空间的分页系统，规定页面大小为 4 KB ，则在每个进程页表中的页表项可达 1 M (2^20) 个，如果每个页表项占用 1 Byte，则每个进程仅仅页表就要占用 1 MB 的内存空间！ 32 位系统进程的寻址空间位 2^32 = 4 G 4 G / 4KB = 2^20 使用多级页表可以解决页表占用高的问题！ 首先，多级页表有一个根页表； 根页表的每个字块都指向内存的一片地址空间，这歌地址空间存储一个二级页表； 假设每个二级页表有 1024 项，每一项指向的字块才是进程实际使用的内存； 一个根页表可以指向二级页表，这样子大大的减少的进程的页表所占用的内存空间； 在运行时，只需要把根页表加载到内存中即可；如果调用某个字块，发现二级页表不在内存空间；此时只需要把二级页表加载到内存中，做到按需加载，节省内存空间； 页式存储管理仍然有一个问题：假如有一段连续的逻辑分布在多个页面中，将大大降低执行效率！此时提出了段式存储管理！ 9.2、段式存储管理 将进程逻辑空间 非等分地 划分为若干段； 段的长度由进程的连续逻辑长度决定； 如进程的逻辑有 主函数 MAIN 、字程序段 X、字函数 Y 等，此时按照每个函数的逻辑长度分配逻辑空间； 段表：段式存储管理也需要一个表来保存逻辑空间到物理空间的映射关系； 不管是段式存储管理、或者页式存储管理，都离散地管理了进程的逻辑空间；不同之处在于： 页是物理单位（从物理的角度划分），段是逻辑单位（从进程的逻辑划分）； 分页是为了合理的利用空间；分段是为了满足用户需求； 页大小由硬件固定；段长可动态变化； 页表信息是一维的，段表信息是二维的；段表中每一段的长度不同，因此需要把段的基址和长度都记录起来，所以段表信息是二维的！ 9.3、段页式存储管理 分页可以有效提高内存利用率（虽然存在页内碎片），而分段可以更好的满足用户需求（因为逻辑是用户写的）；将两者结合，形成了段页式存储管理！ 先将逻辑空间按段式管理分成若干段； 再把段内空间按页式管理分成若干页； 页地址分为页号和页内偏移； 段地址分为段号和段内偏移； 段页地址：段号、段内页号、页内地址 段号 段内页号 页内地址 指定进程逻辑空间的具体哪一段 段里面具体的某一页 某一页的具体哪个字 10、存储管理之虚拟内存 思考 一个 Xcode 十几个 G，物理内存只有 8G ，那么这个游戏是如何运行起来的呢？ 10.1、虚拟内存概述 为什么要使用虚拟内存？ 有些进程实际需要的内存很大，远远超过物理内存的容量； 基于多道程序设计，物理内存中存在多个进程，使得每个进程可用物理内存更加稀缺； 不可能无限增加物理内存，物理内存总有不够用的时候； 虚拟内存概述： 虚拟内存是操作系统内存管理的关键技术； 使得多道程序运行和大程序运行成为现实； 把进程所使用的内存进行划分，将部分暂时不使用的内存放到辅存中去；使用辅存暂时保存该程序不适用的部分内存； 10.2、程序的局部性原理 局部性原理指 CPU 在访问存储期时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中！ 局部性原理是虚拟内存技术可以实现的一个原因： 程序运行时，无需全部载入内存，装载部分即可； 如果程序在运行的时候，发现访问页不在内存中，则发出缺页中断，发起页面置换，将保存在辅存中的页面置换到内存中；置换之后，程序可以继续运行下去； 从用户层面看，程序拥有很大的空间，即是虚拟内存； 虚拟内存实质上是对物理内存的一个扩充，使得它的速度接近于内存，成本接近于辅存！ 10.3、虚拟内存的置换算法 先进先出算法（FIFO） 最不经常使用算法（LFU） 最近最少使用算法（LRU） 替换策略发生在 Cache-主存层次、主存-辅存层次； Cache-主存层次的替换策略主要是为了解决 CPU 速度远远快于主存的问题； 主存-辅存层次主要是为了解决主存容量不足的问题； 11、Linux 的存储管理 11.1、Buddy 内存管理算法 Buddy 算法是经典的内存管理算法； 算法基于计算机处理二进制的优势具有极高的效率； 设计了伙伴系统，可以快速的合并回收区与空闲区； 算法主要是为了解决内存外碎片的问题；本质是将内存外碎片问题转移为内存内碎片问题； 大大的提升了内存利用效率，因为 内存外碎片 会比 内存内碎片 要大； 页内碎片与页外碎片 页内碎片是已经被分配出去（能明确指出属于哪个进程）的内存空间大于进程请求 所需的内存空间，剩下的不能再被利用的内存空间就是内部碎片！ 页外碎片是还没有被分配出去（不属于任何进程），但由于大小而无法分配给申请内存空间的新进程的内存空闲块！ 基于计算机处理二进制的优势具有极高的效率，Buddy 内存管理算法的目的是 努力的让内存分配与相邻内存合并能快速进行 ! Buddy 算法内存分配原则：内存分配时默认每一块内存都是向上取整为 2 的幂大小 ； /// 如一个进程需要申请 `70k` 的内存，`Buddy` 算法会向上取整到 `128k`的内存 (2 的幂次方) 70k -> 128k /// 如一个进程需要申请 `129k` 的内存，`Buddy` 算法会向上取整到 `256k`的内存 (2 的幂次方) 129k -> 256k 伙伴系统 伙伴指的是一片内存中的伙伴； 一片连续内存的伙伴是相邻的另一个大小一样的连续内存； Buddy内存管理算法具体流程 Buddy内存管理算法流程就是 创建一系列空闲块链表，每一种空闲块链表的大小 都是 2 的幂！ 假设存储空间有 1M 大小，对于 Buddy 算法而言 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点；需要使用 Buddy 算法分配 100KB 内存！那么如何分配呢？ 1、 100KB 按照向上取整为 2 的幂次方的原则为 128KB； 2、接着查询空闲块链表是否有 128 KB 的空闲内存块？ 3、查询结果没有；再次查询空闲块链表是否有 256KB 的空闲内存块？ 4、查询结果没有；再次查询空闲块链表是否有 512KB 的空闲内存块？ 5、查询结果没有；再次查询空闲块链表是否有 1MB 的空闲内存块？ 7、接着将 1MB 内存拆为两个 512KB的内存 ，一个 512KB用于存放数据； 另一个多余的 512KB的内存放在 512KB 的空闲链表上，此时512KB 的空闲链表有一个节点； 同时会判断 512KB 的空闲内存是否满足最小需求，发现没有满足； 8、接着将 512KB 内存拆为两个 256KB的内存，一个 256KB用于存放数据； 另一个多余的 256KB的内存放在 256KB 的空闲链表上，此时256KB 的空闲链表有一个节点； 同时会判断 256KB 的空闲内存是否满足最小需求，发现没有满足； 9、接着将 256KB 内存拆为两个 128KB的内存，一个 128KB用于存放数据； 另一个多余的 128KB的内存放在 128KB 的空闲链表上，此时128KB 的空闲链表有一个节点； 同时会判断 128KB 的空闲内存是否满足最小需求，发现已经满足； 10、至此，内存分配结束； 注意 ：进程使用 100KB 的内存，而 Buddy 算法分配了 128KB 的内存，多出的 28KB 属于内存内碎片。 Buddy内存管理算法回收流程 1、判断刚才分配的内存伙伴是否在空闲链表上； 2、在！移除伙伴，与需要回收的内存一起合并为 256KB 空闲内存；判断 256KB内存的伙伴是否在空闲链表上； 3、在！移除伙伴，与需要回收的内存一起合并为 512KB 空闲内存；判断 512KB 内存的伙伴是否在空闲链表上； 4、在！移除伙伴，与需要回收的内存一起合并为 1MB 空闲内存；判断 1MB 内存的伙伴是否在空闲链表上； 5、不在！将 1MB 的空闲内存插入到 1MB 空闲链表，至此回收完成！ 6、此时 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点 11.2、Linux 交换空间 什么是 Linux 交换空间？ Linux 交换空间 Swap 实质是磁盘的一个分区； 当 Linux 主存满的时候，会把一部分数据交换至 Swap 空间，使得 Linux 主存有更多的空间去运行； 交换空间 Swap在系统初始化的时候需要配置，在安装系统时，会提示是否需要交换空间 Swap 、需要多大的交换空间！ 交换空间 Swap 的作用： 冷启动的内存依赖：对于一些大型应用程序，在启动的时候需要使用大量的内存，但很多内存数据仅仅只在启动时使用一次，后续运行时很少使用这些数据；有了交换空间，系统可以将这些使用次数很少的内存数据保存在 交换空间 Swap，从而释放更多的物理内存提供给系统使用！ 系统睡眠依赖：当 Linux 系统需要睡眠时，会将系统中所有需要保存的数据放在 Swap 中；等下次唤醒系统时，将这些数据从 Swap 加载到主存中；这样可以加快系统的启动速度； 大进程空间依赖：某些进程确实需要使用很多的内存空间，但主存空间不够使用；此时需要把进程使用的内存数据暂时保存在 Swap 中，使得大的进程能够运行起来； 备注：虽然交换空间 Swap 可以将 Linux 的物理内存交换到 Swap 上，但还是不推荐使用 Swap 技术！因为 Swap 空间实质属于辅存，读写速度相对于 Linux 的物理内存 要慢很多；如果频繁的使用 Swap 交换空间，就会使得 Linux 系统运行的非常慢！所以应该注意避免使用 Swap 技术。 对比 Swap 空间 虚拟内存 位置 存在于磁盘 存在于磁盘 置换 与主存发生置换 与主存发生置换 服务 是 Linux 操作系统的概念 属于进程的概念 目的 解决了系统物理内存不足的问题 解决进程物理内存不足的问题 12、操作系统的文件管理 12.1、文件的逻辑结构 12.2、辅存的存储空间分配 12.2.1、辅存的分配方式 连续分配 如果一个文件的存储需要一系列的扇区；此时就会连续的将这些连续扇区分配给某个文件； 优点是读取文件内容非常容易、速度很快；只需要顺序地读取磁盘的扇区即可； 缺点是对存储要求比较高，存储文件需要满足容量的连续存储空间； 隐式链接分配 隐式分配的下一个链接指向存储在当前盘快内！假设某个文件需要使用下述五个盘块： 2 -> 9 -> 7 -> 18 -> 16 由于隐式链接存储在盘块中，在分配文件时： 第 2 个盘块中会有一个地方去存储下一个盘块的地址（9） 第 9 个盘块中会有一个地方去存储下一个盘块的地址（7） 第 7 个盘块中会有一个地方去存储下一个盘块的地址（18） 第 18 个盘块中会有一个地方去存储下一个盘块的地址（16） 随机访问的效率极其低下 ，不管访问哪一个盘块，都需要从第一个盘库开始： 隐式分配适合顺序访问，在顺序访问时只需要知道第一个盘块，即可顺序的查找其余盘块； 假如需要访问文件的第 18 盘块，由于只能从头部开始； 先找到第 2 个盘块、第 9 个盘块、第 7 个盘块；最终找到第 18 盘块！ 可靠性差，任何一个链接出问题，都将影响到整个文件！ 基于隐式链接分配的缺点，提出了显示链接分配方式！ 显式链接分配 显式链接分配：不采用在盘块中指定下一个盘块的位置，使用一个 FAT 表来指定！ 缺点： 不支持直接高效的存储，因为FAT 记录项非常多；磁盘越大，FAT 记录项越大； 如果在 FAT 系统存储一个非常大的数据，需要检索 FAT 表找到很多空闲的盘块号； 所以 FAT 文件系统不支持直接高效的存储； 检索时 FAT 表占用较大的存储空间，因为对某个文件读取时需要将整个 FAT 加载到内存，然后在内存中检索 FAT； 索引分配 把文件的所有盘块集中存储，存储盘块的位置称为索引 当需要读取某个文件时，只需要将某个文件的索引读取进内存即可 索引分配使用一个额外的盘块 12 去存储该文件所有的盘块； 12 是该文件的索引，会指向 2 -> 9 -> 7 -> 18 -> 16； 索引分配很好的解决了 FAT 的问题： 每个文件拥有一个索引块，记录所有盘块信息；在索引某个文件时，只需将索引块加载到内存即可，不需要将整个表加载到内存； 索引分配方式支持直接访问盘块；在索引块中可以直接的找到文件对应的盘块； 文件较大时，索引分配方式具有明显优势； 主流的文件系统 都是使用索引分配来 进行磁盘分配； 12.2.2、辅存的存储空间管理 12.3、目录管理 13、Linux 文件基本操作 在 Linux 系统下，一切都是文件，进程也是一个文件！ 13.1、Linux 目录 /// 进入根目录 MacBook $ cd / /// 查看文件列表 MacBook:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var 目录 描述 /bin 存放二进制可执行文件 (ls、cat、mkdir等)，常用命令一般都在这里 /etc 存放系统管理与配置文件 /home 存放所有用户文件的根目录，是用户目录的基点；如用户 user 的主目录就是 /home/user /usr 存放系统应用程序，如常见的 usr/local （本地系统管理员软件安装目录） /dev 用于存放设备文件，如终端、键盘输入等 /opt 额外安装的可选应用程序包所放置的位置 /var 用于存放运行时需要改变数据的文件 /sbin 存放二进制可执行文件，只有 /root 才能访问 /root 超级用户（系统管理员）的主目录 /proc 虚拟文件系统目录，是系统内存的映射！可直接访问这个目录来获取系统信息； /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统 /boot 存放用于系统引导时所使用的各种文件 /lib 存放和文件系统中的程序运行所需要的共享库及内核模块 每一个文件或者文件夹，从根目录开始，都有一个唯一的路径来指向； 绝对路径：从根目录开始的路径； 相对路径：相对于当前的操作目录，它的文件位于哪一个目录；相对路径不固定，随着操作文件的路径变化而变化！ 13.2、Linux 文件常用操作 目录/文件的创建、删除、读取、写入 /// touch 创建一个文件 MacBook-Pro:Desktop $ touch 1.txt /// 使用 vim 创建、编辑、查看一个文件 MacBook-Pro:Desktop $ vim 2.txt /// 查看一个文件的内容 MacBook-Pro:Desktop $ cat 2.txt Hello Word! /// 删除一个文件 MacBook-Pro:Desktop $ rm 1.txt /// mkdir 创建一个文件夹 MacBook-Pro:Desktop $ mkdir 1 /// 删除一个文件夹 MacBook-Pro:Desktop $ rm 1 rm: 1: is a directory (1 是一个文件夹，不能删除) /// 使用参数 -r 表示递归的删除文件夹中的数据 MacBook-Pro:Desktop $ rm -r 1 13.3、Linux 文件类型 - 开头表示文件 d 开头表示文件夹 c 开头表示字符设备文件 b 开头表示块符设备文件 l 开头表示链接文件 /// 分别创建一个文件、一个文件夹 MacBook-Pro:Desktop $ touch 1.txt MacBook-Pro:Desktop $ mkdir 2 /// 使用 ls -al 查看文件的一些信息 MacBook-Pro:Desktop $ ls -al total 24 -rw-r--r--@ 1 i7y staff 6148 8 16 09:59 .DS_Store -rw-r--r-- 1 i7y staff 0 7 23 13:56 .localized -rw-r--r-- 1 i7y staff 0 8 16 09:58 1.txt drwxr-xr-x 2 i7y staff 64 8 16 09:59 2 /// -rw-r--r-- : 一个文件 /// drwxr-xr-x : 一个文件夹 MacBook-Pro:Desktop $ cd / MacBook-Pro:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var MacBook-Pro:/ $ cd dev MacBook-Pro:dev $ ls -al total 9 dr-xr-xr-x 3 root wheel 4384 8 16 09:04 . drwxr-xr-x 20 root wheel 640 1 1 2020 .. crw-r--r-- 1 root wheel 10, 3 8 16 09:04 auditsessions crw------- 1 root wheel 31, 0 8 16 09:05 autofs brw-r----- 1 root operator 1, 6 8 16 09:04 disk1s4 lr-xr-xr-x 1 root wheel 0 8 16 09:04 stdout -> fd/1 /// crw : 一个字符设备文件 /// brw : 一个块符设备文件 /// lr : 链接文件 14、Linux 的文件系统 常见的文件系统有 FAT、 NTFS 、 EXT2/3/4 ！ FAT 全称 File Allocation Table ，FAT 16 与 FAT 32 是早期微软的 Dos/Windows 使用的文件系统； 主要使用一张表来保存盘块的信息！ NTFS 全称 New Technology File System ，是当今 Windows 系统常用的文件系统；NTFS 对 FAT 进行了改进，取代了旧的文件系统！ EXT ( Extended File System) 可扩展文件系统；主要用于 Linux 的文件系统，不支持 Windows 系统； 一个 EXT 格式 U 盘不能被 Windows 系统读取数据；因此 U 盘多格式化为 NTFS 格式！ 14.1、Ext 文件系统 Boot Sector 启动扇区，安装开机管理程序 Block Group 块组，存储数据的实际位置；有多个块组 每个块组都有以下一些信息： Inode bitmap : Inode 的位示图，记录已分配和未分配的Inode；当一个文件系统初始化的时候， Inode 的输入已经固定，此时可以使用位示图来记录； Inode table : 存放 Inode 的地方，每一个文件(目录)都有一个 索引节点 Inode ；Ext 文件系统管理外存的方式为索引分配的方式！ Date Block : 存放文件内容的地方；每个Block都有一个唯一的编号，每一个文件的 Block 记录在文件的 Inode 上； Block bitmap : Block 的位示图；功能与 Inode bitmap 类似，记录 Date Block 的使用情况；当需要对一个文件进行外存分配时，通过查询 Block bitmap 来分配相应的 Date Block ！ SuperBlock：记录整个文件系统相关信息（Block 、 Inode 使用情况，时间信息，控制信息等等）的地方；时间信息包括文件系统所挂载的时间、最后一次写入、最后一次读取、最后一次校验的时间！一般是 1024 个字节的大小！ 其中 Inode 存放每一个文件的元信息，如文件类型(目录文件、普通文件、套接字文件等)、文件权限、文件物理地址、文件长度、文件连接计数、文件存取时间（如最新修改文件的时间、创建文件的时间等）、索引的节点编号（每个文件的唯一标识符）、文件状态、访问计数（当前哪几个进程访问了该文件）、链接指针等等； 文件名不是存放在 Inode 节点上的，而是存放在目录的 Inode 节点； 列出目录文件时，无需家在文件的 Inode；列出目录文件的操作非常频繁，如果每次列出目录文件，都去加载所有文件的 Inode，将会耗时！ /// 查看 EXT 文件系统 MacBook-Pro $ df -t Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1s5s1 976490576 29943648 596646728 5% 553781 4881899099 0% / devfs 379 379 0 100% 656 0 100% /dev /dev/disk1s4 976490576 2097192 596646728 1% 3 4882452877 0% /System/Volumes/VM /dev/disk1s2 976490576 553472 596646728 1% 832 4882452048 0% /System/Volumes/Preboot /dev/disk1s6 976490576 840 596646728 1% 18 4882452862 0% /System/Volumes/Update /dev/disk1s1 976490576 345715896 596646728 37% 1923831 4880529049 0% /System/Volumes/Data map auto_home 0 0 0 100% 0 0 100% /System/Volumes/Data/home MacBook-Pro $ dumpe2fs /dev/disk1s4 -bash: dumpe2fs: command not found 15、操作系统的设备管理 15.1、广义的 IO 设备 对于计算机，输入输出设备有键盘、鼠标、触摸板等！ 对 CPU 而言，凡是对 CPU 进行数据输入的都是输入设备；凡是对 CPU 进行数据输出的都是输出设备！ 可以按照 使用特性 、 信息交换的单位 、 设备的共享属性 、 传输速率 等多个角度对广义的 IO 设备进行分类！ 15.2、IO 设备的缓冲区 针对 CPU 与 IO 设备的传输速率不匹配的问题，前文提出了使用 缓存-主存、主存-辅存的存储层次来解决；除此之外，还可以使用 IO 设备的缓冲区来解决！ 通过 IO 设备的缓冲区，可以减少 CPU 处理 IO 请求的频率，提高 CPU 与 IO 设备之间的并行性！ 专用缓冲区只适用于特定的 IO 进程，当这样的 IO 进程比较多时，对内存的消耗会很大；因此，操作系统划出了可供多个进程使用的公共缓冲区，称为缓冲池！ 进程与 IO 设备的交互，使用的不是进程专用的缓冲区，而是从缓冲池中取出一个缓冲区； 缓冲池中存在多个缓冲区，进程需要使用时从缓冲池取出某一个缓冲区使用，使用完之后再将缓冲区归还给缓冲池； 达到多个进程共同使用缓冲区、减小内存消耗的目的！ 15.3、SPOOLing 技术 SPOOLing 技术是一种关于慢速字符设备如何与计算机主机交换信息的一种技术；可以使用该技术解决 CPU 与 IO 设备的传输速率不匹配的问题！ SPOOLing 技术是虚拟设备技术，将一台低速的物理设备虚拟为多个独立共享的高速独享设备； 使用该技术，操作系统在逻辑上为每一个进程都分配了一台独立的高速独享设备； 假设三个进程都需要使用打印机，由于打印机是一种读写速度很慢的设备: 多个进程都需要使用打印机，将会等待很久； 使用 SPOOLing 技术，不会直接将打印机分配给某个进程，而在共享设备（如共享磁盘）进行输出； SPOOLing 技术会在 共享磁盘 分配一个存储空间，进程的输出数据会以文件的形式保存在 SPOOLing 的存储空间上； 这些进程的数据输入输出会形成一个输出队列，然后由 SPOOLing 去控制打印机的进程、将输出队列中的文件依次打印出来！ SPOOLing 系统并没有将打印机设备分配给任何一个进程，而是在输入输出的存储空间为进程分为一个存储区，并建立一张 IO 表，将逻辑设备虚拟为共享设备！ 共享磁盘所用到的空间称为 输出井！ SPOOLing 技术将同步调用低速设备改为异步调用：如进程实际调用的不是打印机，而是将输出数据写入 输出井，再由 SPOOLing 技术将这些文件送到打印机打印，这样可以大大提升进程的工作效率！ SPOOLing 技术总结： 在输入、输出之间增加了排队转储环节（输入井、输出井） SPOOLing 技术负责输入井（输出井）与低速设备之间的调度； 在逻辑上，进程直接与高速设备交互，而不是与实际的物理设备交互，因此减少了进程的等待时间，提高了进程的工作效率； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-18 15:29:39 "},"计算机基础/操作系统篇/操作系统提升篇.html":{"url":"计算机基础/操作系统篇/操作系统提升篇.html","title":"操作系统提升篇","keywords":"","body":"1、线程同步 1.1、线程同步之互斥量 有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 互斥量可以保证一个线程在操作临界资源的时候，阻止其它线程来访问该临界资源！ 上图引起线程同步问题的最根本原因是两个线程的指令交叉执行： 如先执行线程 1 的两个指令，接着 CPU 被抢夺走去执行线程 2 的三条指令； 最后又回到线程 1 去执行线程 1 的第三条指令； 线程1 与线程 2 的指令交叉执行，引发了线程同步的问题； 互斥量如何解决上述问题呢？互斥量可以保证两个线程的关键指令不会被交叉执行，而是以先后顺序来执行； 互斥量本质上保证了线程操作的 原子性！原子性是指一组操作不可被中断的特性；这一组操作要么全部执行完成，要么全部没有执行；不存在部分执行、部分未执行的情况！ 互斥量（也称为互斥锁）是最简单的线程同步的方法；互斥量是处于 解锁、加锁 两个状态之一的变量；两个状态保证资源访问的串行！一个资源被加了互斥锁，代表该资源正在被某个线程所使用；那么其它线程想要使用该资源，只能等待正在使用的线程解锁、释放掉该资源，这就导致了资源访问的串行！ 一般而言，操作系统直接提供了互斥量的 API，开发者可以直接使用 API 完成资源的加锁、解锁操作！ /// API pthread_mutex_t pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥量 int num = 0; /// 临界资源 void *producer(void*) { /// 生产者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num += 1; /// 每循环一次，生产一件产品 pthread_mutex_unlock(&mutex); } } void *comsumer(void*){ /// 消费者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num -= 1; /// 每循环一次，消费一件产品 pthread_mutex_unlock(&mutex); } } int main(){ /// 执行函数 pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); /// 创建生产者线程 pthread_create(&thread2, NULL, &comsumer, NULL); /// 创建消费者线程 pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.2、线程同步之自旋锁 上图有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 在一个线程使用临界资源前，先加一个自旋锁，阻止其它线程来访问临界资源；当使用完临界资源后解锁，保证临界资源的串行访问！ 自旋锁的原理和互斥锁是一样的，那么自旋锁和互斥锁有什么不一样嘛？ 自旋锁也是一种线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用；如果不可用，自旋锁会一直循环反复的检查直到可用为止；自旋锁不会让出 CPU ，是一种忙等待的过程；自旋锁实质上就是一个死循环等待锁被释放！ 自旋锁的好处： 自旋锁避免了进程或者线程上下文切换的开销； 如果使用自旋锁占用的时间不是很长，那么使用自旋锁的代价很小； 操作系统内部很多地方使用的都是自旋锁； 自旋锁不适合在单核 CPU 使用（因为自旋锁在等待的过程中不会释放 CPU，而是死循环的等待；在单核 CPU 使用自旋锁，会导致其它的进程或者线程无法执行） /// API : pthread_spinlock_t #include #include #include #include #include pthread_spinlock_t spin_lock; /// 自旋锁 int num = 0; /// 临界资源 void *producer(void*){ /// 生产者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num += 1; pthread_spin_unlock(&spin_lock); } } void *comsumer(void*){ /// 消费者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num -= 1; sleep(10); pthread_spin_unlock(&spin_lock); } } int main() { pthread_spin_init(&spin_lock, 0); pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); pthread_create(&thread2, NULL, &comsumer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.3、线程同步之读写锁 读写锁在互斥锁、自旋锁的基础上做了改进，主要是从临界资源的多读少些的方面考虑！ 读写锁是一种特殊的自旋锁，允许多个读者同时访问资源以提高读性能；对于写操作则是互斥的！ 读写锁在多读少些的场景下，对性能的优化是很明显的！ #include #include #include #include #include int num = 0; /// 临界资源 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; ///读写锁 void* reader(void*) { int times = 10000000; while(times --){ pthread_rwlock_rdlock(&rwlock); /// 添加读锁 /// 读取临界资源 printf(\"print num in reader: num = %d\\n\", num); pthread_rwlock_unlock(&rwlock); /// 释放读锁 } } void *writer(void*){ int times = 10000000; while(times --){ pthread_rwlock_wrlock(&rwlock); /// 添加写锁 num += 1; /// 临界资源的改变 pthread_rwlock_unlock(&rwlock); /// 释放写锁 } } int main(){ pthread_t thread1, thread2, thread3; /// 两个读线程、一个写线程 pthread_create(&thread1, NULL, &reader, NULL); pthread_create(&thread2, NULL, &reader, NULL); pthread_create(&thread3, NULL, &writer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_join(thread3, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.4、线程同步之条件变量 条件变量是一种相对复杂的线程同步方法，不满足条件时允许线程休眠；当满足条件时，可以向该线程发送信号唤醒线程！ 在上图 生产者-消费者模型 中有两个不严谨的问题： 缓冲区小于等于 0 时，不允许消费者消费，消费者必须等待； 缓冲区满时，不允许生产者向缓冲区生产，生产者必须等待； 使用条件变量实现唤醒操作： 缓冲区等于 0 时：当生产者生产一个产品时，唤醒可能等待的消费者； 缓冲区满时：当消费者消费一个产品时，唤醒可能等待的生产者； 条件变量的工作过程： 对于条件变量，首先需要加锁保护条件变量或临界资源； 接着判断条件是否满足，如果不满足就等待（线程处于休眠状态），条件满足时被唤醒； 线程唤醒后，就可以对临界资源操作； 操作完成后解锁； #include #include #include #include #include #include #include int MAX_BUF = 100; /// 缓冲区最大数 int num = 0; /// 临界资源 /// 条件变量配合互斥量来使用 pthread_cond_t cond = PTHREAD_COND_INITIALIZER; ///条件变量 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥锁 void* producer(void*) { /// 生产者 while(true){ pthread_mutex_lock(&mutex); while (num >= MAX_BUF) { // 等待 printf(\"缓冲区满了, 等待消费者消费...\\n\"); pthread_cond_wait(&cond, &mutex); ///等待条件满足 } num += 1; printf(\"生产一个产品，当前产品数量为：%d\\n\", num); sleep(1); pthread_cond_signal(&cond); /// 唤醒 printf(\"通知消费者...\\n\"); pthread_mutex_unlock(&mutex); sleep(1); } } void* consumer(void*){ while(true){ pthread_mutex_lock(&mutex); while (num 1.5、线程同步方法总结 互斥锁、自旋锁、读写锁 对于临界资源的操作都是一样的： 首先为临界资源加锁；解锁成功后操作临界资源；操作完成后解锁； 加锁成功后其它线程不能访问临界资源；解锁后其它线程才可以访问临界资源； 发现需要访问的临界资源被加锁，就需要等待临界资源被解锁； 同步方法 描述 互斥锁 最简单的一种线程同步方法，会 堵塞线程 (让出 CPU) 自旋锁 避免切换的一种线程同步方法，属于忙等待 (不让出 CPU) 读写锁 为 读多写少 的资源设计的线程同步方法，可以显著提高性能 条件变量 相对复杂的一种线程同步方法，有更灵活的使用场景 2、进程同步 2.1、使用系统函数 fork() 创建进程 调用系统函数 fork() 创建进程： 进程有进程空间，包括内存以及一些内核态的东西；新创建进程的内存数据与父进程一摸一样！包括拥有的变量等； fork() 创建的进程初始化状态与父进程一样； 系统会为 fork() 的进程分配新的资源，如内存资源； fork() 调用没有参数； 调用一次 fork() 函数会有两次返回，分别返回进程id 和 0； 返回子进程id 的是父进程，返回 0 的是子进程； #include #include #include #include using namespace std; int main() { pid_t pid; int num = 888; pid = fork(); if(pid == 0) { cout 0){ cout 2.2、进程同步之共享内存 每一个进程都有一条或者多条线程，进程中的多条线程共享该进程资源； 线程之间需要通信、需要同步进程的一些资源状态，这就需要线程之间的信息同步； 一个操作系统中有一个或者多个进程，进程之间共享进算计资源，包括内存、磁盘等； 进程之间需要通信，如前文的生产者与消费者模型，这就需要进程之间的信息同步； 操作系统对进程内存的管理： 每一个进程都有自己的进程空间； 进程空间通过页表和段页式存储管理和实际的物理内存建立映射关系； 进程之间的进程空间是独立的，互不干扰的； 因此在某种程度上，多进程是共同使用物理内存的； 由于操作系统的进程管理，进程间的内存空间是独立的； 进程默认不能访问进程之外的内存空间； 进程同步之共享内存： 共享存储允许不相关的进程访问同一片物理内存 共享内存是两个进程之间共享和传递数据最快的方式； 共享内存没有提供同步机制，需要借助其它机制管理访问； 共享内存是高性能后台开发中最常用的进程同步方式； 2.3、进程同步之 Unix 域套接字 域套接字是一种高级的进程间通信的方法； Unix 域套接字可以用于同一机器进程间通信，不能跨机器使用； 套接字 socket 原是网络通信中使用的术语； Unix 系统提供的域套接字提供了网络套接字类似的功能； 3、操作系统的用户态与内核态 4、理解上下文切换 5、进程、线程、协程 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:26:46 "},"Git体系/Git常用命令.html":{"url":"Git体系/Git常用命令.html","title":"Git常用命令","keywords":"","body":"Git常用命令 1、pull 命令 ///将与本地当前分支同名的远程分支 拉取到 本地当前分支上 git pull /// 将远程指定分支 拉取到 本地当前分支上 git pull origin /// 将远程指定分支 拉取到 本地指定分支上 git pull origin : 1.1、回退到 pull 之前 /// 查看提交记录 git reflog /// 回退到某一版本 git reset --hard 70973042 2、push 命令 /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 git push /// 将本地当前分支 推送到 远程指定分支上 git push origin : /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 git push origin 3、分支 查看分支 /// 查看本地分支 git branch ///查看远程分支 git branch -r /// 查看所有分支 git branch -a 创建分支 /// 新建一个本地分支 git checkout -b L2 /// 把新建的本地分支push到远程服务器 git push origin L2:L2 /// 新建本地分支，并切换到远程分支 git checkout -b local/2 origin/0.0.2 拉取远程分支 ///拉取远程某个分支 git clone -b 分支名 git仓库 切换分支 /// 切换本地分支 git checkout master 删除分支 /// 删除本地分支 git branch -D 0.0.2 /// 删除远程分支 git push origin --delete 0.0.2 合并分支 /// 将 分支 L2 合并到 分支 L1 上 $ git checkout L1 Switched to branch 'L1' $ git merge L2 Merge made by the 'recursive' strategy. 4、tag /// 列出所有标签 git tag /// 新建tag git tag 1.0.0 /// 推送tag到远程 git push origin 1.0.0 /// 本地删除 git tag -d 1.0.0 /// 远程删除 tag git push origin :refs/tags/1.0.0 5、Pull Request Github 的 Pull Request 功能，简写为 PR；适用于多人合作的项目！ 5.1、什么是 Pull Request Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。 Pull Request 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码。 注意：GitHub 的代码贡献，是请求别人 pull 你的代码，而不是请求别人接受你的 push。因为对应的 git 操作必须是 pull 而不能是 push，所以叫 pull request 而不是 push request。 5.2、 Pull Request 的流程 第一步，在 Git 仓库创建自己的分支！ 第二步，在修改后的分支上，按下 New pull request 按钮。 这时，会进入一个新页面，有 Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。 第三步，填写说明，帮助别人理解你的提交，然后按下 create pull request 按钮即可。 PR 创建提交后，管理者就要决定是否接受该 PR。 参考文章 Pull Request 的命令行管理 git: 为什么 pull request 不叫 push request ? Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:43:19 "},"Git体系/Github和SSH密钥.html":{"url":"Git体系/Github和SSH密钥.html","title":"Github和SSH密钥","keywords":"","body":"Github和SSH密钥 SSH 密钥允许本地计算机和 Git 远程仓库之间建立安全连接。 我们在使用 Git 管控项目时，需要一个安全的通信通道来共享信息。可以使用 用户名与密码 的认证方式，但每次输入密码，太过麻烦；还可以使用 SSH 协议向 Git 远程服务器进行身份验证。 有关SSH协议如何工作的更详细说明，建议阅读教程 DigitalOcean 。 1、SSH密钥的类型 Git 支持RSA、DSA、ECDSA和ED25519密钥。它们的区别在于签名算法，其中一些具有其他优势。 本文重点关注ED25519和RSA等。 1.1、RSA 密钥 RSA密钥是最常见的密钥，经典且可靠，兼容 OpenSSH 6.5 之前的服务器版本。 RSA 密钥最小为1024位，默认为 2048；如果希望生成更强的RSA密钥对，需要使用 -b 指定位值。 /// -t rsa 表示使用 RSA 算法 /// -b 指定 RSA 密钥为 4096 位;默认 2048 位 /// 使用 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码 MacBook ~ % ssh-keygen -o -t rsa -b 4096 -C 123456@github.com SSH 私钥密钥的旧的默认密码编码不安全。从 OpenSSH 6.5 版开始，应该使用该 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码。 但 RSA 密钥性能不够理想；所以建议使用 ED25519， ED25519 的安全性在 RSA 2048 与 RSA 4096 之间，且性能在数十倍以上。 1.2、ED25519 密钥 ED25519 密钥是在 OpenSSH 6.5 中引入的，如果GitLab服务器不兼容 ED25519 键，可以使用RSA 密钥！ ED25519 密钥加密解密很快，生成时间短而且安全性更高！ 所以现在建议使用ED25519 密钥！ 注意： 一对密钥只对应一个 Git 服务：一对密钥通吃各 Git 服务不太安全。 2、ED25519 的使用 2.1、ED25519 的制作 在Linux 或 macOS上打开终端，生成新的 ED25519 SSH 密钥对: //生成一个新的ED25519 SSH密钥对 MacBook ~ % ssh-keygen -t ed25519 -C 123456@qq.com Generating public/private ed25519 key pair. Enter file in which to save the key (/Users/long/.ssh/id_ed25519): /Users/long/.ssh/Test Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/long/.ssh/Test. Your public key has been saved in /Users/long/.ssh/Test.pub. The key fingerprint is: SHA256:FC2Qz4gvekNv8m4BcvptmI+oPKA8eqrZdhNTp/7Hkb8 123456@qq.com The key's randomart image is: +--[ED25519 256]--+ | .o.. | | . ... | | . +.. | | . + o.+ | | + + oS . | |. . = + o | |+ + X . . o | |o*+.X.B o . | |O*=o.@+... E. | +----[SHA256]-----+ 注意： passphrase 是给私钥添加一个 解锁口令！私钥必须要有 passphrase：如果私钥文件遗失，没有 passphrase 也无法解锁，只能暴力破解；所以不要偷懒，passphrase 一定要设置。 此时，已经将密匙对保存在本地！我们可以去查看并获取密匙： /// 进入ssh默认路径 MacBook ~ % cd ~/.ssh /// 查看该文件夹下的文件 MacBook .ssh % ls Test Test.pub known_hosts /// 打印公匙 Test.pub MacBook .ssh % cat Test.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTEL7FM0x60p5/S3M6IaBLkyi3OroA 123456@github.com /// 或者直接将 Test.pub 复制到剪贴板 MacBook % pbcopy 我们需要将 ED25519 的公匙复制到剪贴板，并添加到 Git 仓库！ 2.2、添加 ED25519 的公匙到 Git 远程仓库 在 Git 远程仓库中，通过点击 个人中心 -> Settings -> SSH and GPG Keys ，然后添加！ 注意： 手动复制的 ED25519 公匙，请确保以 ssh-ed25519 开头并以电子邮件结尾。 2.3、测试是否正确设置 SSH 密钥 要测试是否正确添加了SSH密钥，可以在终端中运行以下命令（自己的服务器，替换 github.com 的域名）： 2.3.1 、Permission denied (publickey) ssh -T git@github.com git@github.com: Permission denied (publickey). ///权限被拒，添加失败 如果设置正确，应该受到类似于下述的 欢迎消息： Welcome to github, @123456! 如果未出现欢迎消息，可以替换 -T 为-vvvT 来运行 SSH 的详细模式，以了解错误的位置： ssh -vvvT git@github.com 不过一般情况下，可以使用下述两个操作，将 SSH 密钥添加到高效缓存中： /// 首先进入 ssh 文件夹 MacBook ~ % ~ % cd ~/.ssh /// 然后将 ，将 SSH 密钥添加到高效缓存中 MacBook .ssh ~ % ssh-agent -s MacBook .ssh ~ % ssh-add ~/.ssh/Test 2.3.2 、but GitHub does not provide shell access. MacBook :.ssh $ ssh -T git@github.com Hi K! You've successfully authenticated, but GitHub does not provide shell access. 查看该 Git 仓库提交方式： MacBook $ git remote -v origin https://github.com/xxx/x (fetch) origin https://github.com/xxx/x (push) 发现不是 ssh 方式，需要改为 ssh 方式 MacBook $ git remote set-url origin git@github.xxx/ix.git MacBook $ git remote -v /// 再次查看 origin git@github.com:xxx/x.git (fetch) origin git@github.com:xxx/x.git (push) 参考文章： github配置ssh key过程中为什么需要ssh-add这一步呢？ 使用 Ed25519 算法生成你的 SSH 密钥 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:47:03 "},"Gitbook指导/":{"url":"Gitbook指导/","title":"GitBook 简介","keywords":"","body":"GitBook 是使用 GitHub / Git 和 Markdown（或 AsciiDoc ）构建漂亮书籍的命令行工具（和 Node.js 库）。 GitBook 创建和托管图书，可以将您的内容作为网站（可定制和可扩展）或电子书（PDF ，ePub 或 Mobi ）输出。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"Gitbook指导/gitbook教程.html":{"url":"Gitbook指导/gitbook教程.html","title":"GitBook 安装","keywords":"","body":"gitbook 使用教程 下载 gitbook /// gitbook 是个本地命令行工具 /// 通过 npm 安装 gitbook npm install gitbook-cli -g /// 查看 gitbook 信息、验证安装 gitbook -V /// 列出可以下载的 gitbook 版本 gitbook ls-remote /// 列出本地的 gitbook 版本 gitbook ls /// 卸载对应的 gitbook 版本 gitbook uninstall 3.2.3 /// 安装对应的 gitbook gitbook fetch 标签/版本号 /// 更新到 gitbook 的最新版本 gitbook update /// 帮助 gitbook help 使用 gitbook创建电子书 初始化一个电子书 /// 初始化一个书籍 MacBook-Pro:book $ gitbook init gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件: SUMMARY.md 是默认概括文件，主要是根据该文件内容生成相应的目录结构； README.md 是默认首页文件，用于电子书的简介/前言； gitbook init 报错 MacBook-Pro:book $ gitbook init warn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 问题原因：node.js 版本过高； 解决办法：卸载高版本 node.js ，重新安装稍低版本的 node.js MacBook-Pro:$ node -v v16.6.1 /// 卸载高版本 node MacBook-Pro $ brew uninstall node 去官网下载一个稳定的版本 MacBook-Pro $ node -v v14.17.5 MacBook-Pro $ npm -v 6.14.14 MacBook-Pro $ npm install --global vue-cli 本地预览电子书 启动本地服务，程序无报错则可以在 本地浏览器 预览电子书效果 MacBook-Pro:book $ gitbook serve 制作静态网页 MacBook-Pro:book $ gitbook build 制作 PDF 格式 MacBook-Pro:book $ gitbook pdf MacBook-Pro:book $ gitbook epub MacBook-Pro:book $ gitbook mobi 生成 PDF 格式需要下载 ebook-convert，并链接环境变量 sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 查看目录 MacBook-Pro:booktest $ tree . ├── README.md ├── SUMMARY.md ├── _book │ ├── assets │ │ └── 图1.png │ ├── gitbook │ │ ├── fonts │ │ │ └── fontawesome │ │ │ ├── FontAwesome.otf │ │ │ ├── fontawesome-webfont.eot │ │ │ ├── fontawesome-webfont.svg │ │ │ ├── fontawesome-webfont.ttf │ │ │ ├── fontawesome-webfont.woff │ │ │ └── fontawesome-webfont.woff2 │ │ ├── gitbook-plugin-fontsettings │ │ │ ├── fontsettings.js │ │ │ └── website.css │ │ ├── gitbook-plugin-highlight │ │ │ ├── ebook.css │ │ │ └── website.css │ │ ├── gitbook-plugin-livereload │ │ │ └── plugin.js │ │ ├── gitbook-plugin-lunr │ │ │ ├── lunr.min.js │ │ │ └── search-lunr.js │ │ ├── gitbook-plugin-search │ │ │ ├── lunr.min.js │ │ │ ├── search-engine.js │ │ │ ├── search.css │ │ │ └── search.js │ │ ├── gitbook-plugin-sharing │ │ │ └── buttons.js │ │ ├── gitbook.js │ │ ├── images │ │ │ ├── apple-touch-icon-precomposed-152.png │ │ │ └── favicon.ico │ │ ├── style.css │ │ └── theme.js │ ├── index.html │ └── search_index.json ├── assets │ └── 图1.png ├── book.pdf ├── 篇1.md ├── 篇2.md └── 篇3.md 13 directories, 38 files 配置文件 book.json book.json 是配置文件,用于个性化调整 gitbook 的相关配置！如定义电子书的标题，封面，作者等信息。虽然是手动创建但一般是必选的！ author: 书籍的作者 title: 书籍的标题 description: 书籍的简要描述 language: 支持语言 \"language\": \"zh-hans\", isbn: 国际标准书号 \"isbn\": \"978-0-13-601970-1\", direction: 阅读顺序，支持从右到左(rtl)或从左到右(ltr)；默认值取决于语言值； gitbook: 指定 gitbook 版本； root: 包含所有图书文件的根文件夹的路径， book.json 文件除外； plugins : 添加新插件之后需要运行 gitbook install 来安装新的插件 { \"author\": \"苏莫离\", \"title\": \"初次配置 GitBook 教程\", \"description\": \"初次配置 GitBook 教程，记录一些使用步骤！\", \"isbn\": \"书籍的国际标准书号\", \"language\": \"zh-hans\", \"direction\" : \"ltr\", \"gitbook\": \"3.2.3\", \"root\" : \"./docs\", \"pdf.pageNumbers\" : true, \"pdf.fontSize\" : 12 , \"pdf.fontFamily\" : \"Arial\", \"pdf.paperSize\" : \"a4\", \"pdf.margin.top\" : 10, \"pdf.margin.left\" : 10, \"pdf.margin.bottom\" : 10, \"pdf.margin.right\" : 10, \"plugins\": [ \"highlight\", \"search\", \"sharing\", \"font-settings\", \"livereload\", \"collapsible-menu\", \"anchor-navigation-ex\", \"tbfed-pagefooter\", \"disqus\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": true, /// 是否自定插入标题索引 \"showGoTop\": false }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &SuMoli\", \"modify_label\": \"修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"disqus\": { \"shortName\": \"gitbookuse\" } } } 插入图片 其它配置 要提供封面，需要将 cover.jpg 文件放在书本的根目录下。添加一个 cover_small.jpg 将指定一个较小版本的封面。封面应为 JPEG 文件。 好的封面应该遵守以下准则： cover.jpg 的尺寸为 1800x2360 像素，cover_small.jpg 为 200x262 没有边界 清晰可见的书名 任何重要的文字应该在小版本中可见 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "},"Gitbook指导/gitbook语法.html":{"url":"Gitbook指导/gitbook语法.html","title":"GitBook 使用","keywords":"","body":" __Gitbook 语法__ 标题 要创建标题，请在标题之前加 1-6 个 #，使用 # 的多少决定字体的大小 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 锚点 跳转到锚点 跳转到锚点 [跳转到本文标题](#title) //需要给标题添加id， 跳转到简介界面 跳转到简介界面 [跳转到简介界面](README.md) 跳转到百度 跳转到百度 [跳转到百度](http://www.baidu.com \"百度\") // 鼠标移入显现title属性 图片 ![图片](assets/图1.PNG) /// 不支持大小写修改 /// 支持大小写修改 字体 这是蓝色字体 这是蓝色字体 文字居中 文字居中 引用1 引用2 引用3 > 引用1 >> 引用2 >>> 引用3 序号 科目 成绩 1 语文 123 2 数学 134 3 英语 145 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2021-08-19 10:34:11 "}}