{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人简介 学无止境！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/计算机基础.html":{"url":"计算机基础/计算机基础.html","title":"计算机基础","keywords":"","body":"计算机基础知识 致知在格物，物格而后知至！ 作为一名从事互联网行业的工程师，不论细化为哪个职业，对于计算机的一些基础知识，都应该有一个全面彻底的认知！ 计算机的基础知识，应该包括计算机的硬件组成、操作系统、计算机网络、数据结构与算法、汇编等！ 万丈高楼平地起！如果不了解计算机的基础知识，又谈何优化程序？从计算机的设计、操作系统的构建、互联网络的通信，既可以增加我们的知识储备量，也可以让我们在面对问题时，尽可能显的从容些！同时也可以借鉴吸收其中的优秀思想，也可以提升自己的编程能力！ 笔者作为多年的软件工程师，深感基础不扎实，特写下此学习笔记，以备随时查阅！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机组成篇/计算机概述篇.html":{"url":"计算机基础/计算机组成篇/计算机概述篇.html","title":"第一部分 计算机的组成","keywords":"","body":"计算机组成原理 1、计算机发展简史 计算机于 1946 年问世，有人说是由于战争的需要而产生的，我们认为计算机产生的根本动力是人们为创造更多的物质财富，是为了把人的大脑延伸，让人的潜力得到更大的发展。正如汽车的发明是使人的双腿延伸一样，计算机的发明事实上是对人脑智力的继承和延伸。近10年来，计算机的应用日益深入到社会的各个领域，如管理、办公自动化等。由于计算机的日益向智能化发展，于是人们干脆把微型计算机称之为“电脑”了。 计算机产生的动力是人们想发明一种能进行科学计算的机器，因此称之为计算机。它一诞生，就立即成了先进生产力的代表，掀开自工业革命后的又一场新的科学技术革命。 计算机的发展，可以简单的划分为四个阶段： 1.1、第一代电子管计算机 (1946~1956) 在第二次世界大战中，美国政府寻求计算机以开发潜在的战略价值，这促进了计算机的研究与发展。 1944年霍华德.艾肯研制出全电子计算器，为美国海军绘制弹道图。这台简称 Mark I 的机器有半个足球场大，内含 500 英里的电线，使用电磁信号来移动机械部件，速度很慢 (3-5秒一次计算)并且 适应性很差 只用于专门领域，但是，它既可以执行基本算术运算也可以运算复杂的等式。 到了40年代中期，冯.诺依曼 参加了宾夕法尼亚大学的小组，1945年设计电子离散可变自动计算机EDVAC，将程序和数据以相同的格式一起储存在存储器中。 这使得计算机可以在任意点暂停或继续工作，机器结构的关键部分是中央处理器，它使计算机所有功能通过单一的资源统一起来。 1946年，由美国政府和宾夕法尼亚大学合作开发，美国物理学家莫奇利任总设计师，研制成功世界上第一台电子管计算机ENIAC。 ENIAC代表了计算机发展史上的里程碑，它通过不同部分之间的重新接线编程，还拥有并行计算能力。使用了18800个电子管，70000个电阻器，有5百万个焊接点，耗电160千瓦，其运算速度比Mark I 快1000倍，ENIAC是第一台普通用途计算机。 电子管计算机主要有以下特点： 使用真空电子管和磁鼓储存数据，集成度小，空间占用大； 真空管的损耗率相当高，运行速度慢； 每种机器有各自不同的机器语言；操作指令是为特定任务而编制，操作复杂，更换程序需要接线； 1.2、第二代晶体管计算机 (1957~1964) 1948 年贝尔实验室发明了点触型晶体管，1950年又发明了面结型晶体管；相比真空电子管，晶体管体积小、重量轻、寿命长、发热少、功耗低。晶体管的发展为计算机带来了革命性的进步，电子线路的结构大大改观，运算速度大幅度提高。 晶体管 和 磁芯存储器 在电脑领域引的应用，使得计算机大步跨进了第二代的门槛。 晶体管计算机的特点： 集成度相对较高，空间占用相对较小； 功耗相对较低，运行速度较快； 操作相对简单，交互更加方便； 第二代晶体管计算机已经涉及现代计算机的一些雏形： 打印机、磁带、磁盘、内存、操作系统等。 计算机中存储的程序使得计算机有很好的适应性，可以更有效地用于商业用途，在这一时期出现了更高级的 COBOL 和 FORTRAN 等语言，以单词、语句和数学公式代替了二进制机器码，使计算机编程更容易。 1.3、第三代集成电路计算机 (1964~1980) 虽然晶体管比起电子管是一个明显的进步，但晶体管还是产生大量的热量，这会损害计算机内部的敏感部分。 1958年发明了集成电路(IC)，将三种电子元件结合到一片小小的硅片上；科学家使更多的元件集成到单一的半导体芯片上。于是，计算机变得更小，功耗更低，速度更快。 集成电路计算机的显著特点： 计算机变得更小； 功耗变得更低； 计算速度更快； 在该阶段还诞生了 操作系统，使得计算机在中心程序的控制协调下可以同时运行许多不同的程序。 1.4、超大规模集成电路计算机 (1980~现在) 出现集成电路后，唯一的发展方向是扩大规模。大规模集成电路(LSI)可以在一个芯片上容纳几百个元件。 到了80年代，超大规模集成电路(VLSI)在芯片上容纳了几十万个元件，后来的ULSI将数字扩充到百万级。可以在硬币大小的芯片上容纳如此数量的元件使得计算机的体积和价格不断下降，而功能和可靠性不断增强。 一个电路集成了上百万的晶体管； 速度更快，体积更小，价格更低，更能被大众接受； 用途丰富：文本处理、表格处理、高交互的游戏与应用； 1.5、微型计算机的发展历史 微型计算机主要受限于性能； 早期的微型计算机使用单核 CPU ： 1971~1973 500KHZ 频率的微型计算机（字长 8 位）； 1973~1978 高于 1 MHZ 频率的微型计算机（字长 8 位）； 1978~1985 高于 500 MHZ 频率的微型计算机（字长 16 位）； 1985~2000 高于 1 GHZ 频率的微型计算机（字长 32 位）； 2000~现在 高于 2 GHZ 频率的微型计算机（字长 64 位）； 关于 CPU 性能有一个著名的定律 摩尔定律：集成电路的性能，每 18 ~ 24 个月就会提升一倍！ 随着芯片的发展，芯片内部的电路越来越复杂、越来越密集，热损耗越来越高， 摩尔定律在 21 世纪慢慢失效！ 正是由于单核 CPU 的发展进入瓶颈期，所以提出了 多核 CPU ： 2005 年 Intel 奔腾系列双核 CPU、 AMD 速龙系列； 2006 年 Intel 酷睿四核 CPU； 现在 Intel 酷睿系列十六核 CPU； Intel 至强系列五十六核 CPU； 2、计算机的分类 2.1、超级计算机 功能最强、运算速度最快、存储容量最大的计算机； 能够完成个人计算机无法处理的数据与运算； 本质上组成元件与个人计算机相差不大； 多用于国家高科技领域和尖端技术研究；如天气预报、海洋监测等、生物制药、科学计算等； 运算速度单位 TFlop/s : 1 TFlop/s = 每秒一万亿次浮点计算； 2.2、大型计算机 又称大型机、大型主机、主机等； 虽然在功能上不如超级计算机，但同样拥有许多高速 CPU； 具有高性能、可处理大量数据与复杂的计算； 用于银行数据、证券交易所数据、人口普查、企业资源规划等大量数据的计算； 在大型机市场领域， IBM 占据很大的市场份额； 从软件到硬件的企业级数据库系统 IOE ： I : IBM 服务器提供商 O : Oracle 数据库软件提供商 E : EMC 存储设备提供商 由这三驾马车提供的数据库系统占据了大量市场份额！ 由于 IOE 代表了高成本、高维护费用的商业数据存储系统，并且不够灵活、伸缩性弱；阿里巴巴在 2008 年提出了去 IOE 行动，这间接的导致了在 2009 年阿里云的诞生！ 2.3、迷你计算机（服务器） 普通服务器已经替代了传统的大型机，成为大规模企业计算的中枢 又称小型机、普通服务器； 不需要特殊的空调场所； 具备不错的运算力、可以完成较复杂的运算； 联想、华为等很多公司都可以制造普通服务器； 云服务也是构建于普通服务器之上的； 去 IOE 行动就是将大型机替换为普通服务器； 普通服务器已经替代了传统的大型机，成为大规模企业计算的中枢。如阿里云、腾讯云等！ 2.4、工作站 高端的通用微型计算机，提供比个人计算机更强大的性能； 类似于普通台式电脑，但体积较大、性能强劲； 适用于图片工作者、视频工作者等专业用户； 2.5、微型计算机 又称个人计算机，是最普通的一类计算机； 台式机、笔记本、一体机 iMac 麻雀虽小，五脏俱全； 从构成的本质来看，个人计算机与其它计算机无差异，都包含一些必备硬件 3、计算机的体系结构 虽然计算机的形态千差万别，但本质还是一致的，都基于 冯诺依曼体系！ 3.1、冯诺依曼体系 冯诺依曼体系 “将程序指令和数据一起存储的计算机设计概念结构” 早期计算机仅含固定用途，如果想要改变用途，需要改变程序更改结构、重新设计电路！ 冯诺依曼：存储程序指令，设计通用电路！ 现代计算机本质上都是冯诺依曼机，冯诺依曼体系的几个关键要素： 必须有一个存储器：存储运行的程序以及运行所需的数据； 必须有一个控制器：控制程序的流转； 必须有一个运算器：负责运算的操作； 必须有输入设备 必须有输出设备 冯诺依曼体系： 能够把需要的程序和数据送至计算机中 (输入设备：鼠标、键盘)； 能够长期记忆程序、数据、中间结果以及最终运算结果的能力，通过记忆才能进行下一步的操作 (存储器)； 能够具备算术、逻辑运算和数据传送等数据加工处理的能力 (运算器、控制器)； 能够按照要求将处理结果输出给用户 (输出设备：显示器、打印机)； 冯诺依曼瓶颈 CPU 和存储器速率之间的问题无法调和：CPU 的读写速率很快，而存储器的读写速率没有 CPU 快；导致 CPU 经常空转等待数据的传输！ 只有把 CPU 跑满，才是充分利用计算机的表现！ 3.2、现代计算机的结构 现代计算机在冯诺依曼体系结构基础上进行修改；解决 CPU 与储存设备之间的性能差异问题！ 存储器：磁带、硬盘；更高速的设备，内存，CPU 的寄存器！ 4、计算机的层次与编程语言 4.1、程序翻译与程序解释 计算机执行的指令都是 0 和 1 （L0 程序）； 程序翻译生成新的 L0 程序；程序解释不生成新的 L0 程序； 解释过程，由 L0 编写的解释器去解释 L1 程序； 翻译+解释语言：Java / C# ； 4.1.1、程序翻译 计算机的世界中，只有 0 与 1 两种表达；与人类的语言不相同，因此需要将人类语言翻译为计算机理解的程序语言！ 常见语言：C / C++ / Objective-C / Golang ！ 4.1.2、程序解释 常见语言：Python / PHP / JavaScript ！ 4.2、计算机的层次与编程语言 为了更容易、更好地理解计算机的内部，人们将计算机划分为多个层次！ 硬件逻辑层：门、触发器等逻辑电路组成；属于电子工程的领域； 微程序机器层：编程语言为 微指令集；微指令所组成的微程序直接交由硬件执行； 传统机器层：编程语言是 CPU 指令集；编程语言直接和硬件相关；不同架构的 CPU 使用不同的指令集；指令集存储在 CPU 内部； 操作系统层：向上为用户提供了简易的操作界面；向下对接指令系统，管理硬件资源；是在软件和硬件之间的适配层； 汇编语言层：汇编语言可以翻译为直接执行的机器语言；完成翻译过程的程序就是汇编器； 高级语言层：C / C++ / Objective-C / Python / PHP / Java / JavaScript / Golang 等； 应用层：满足计算机针对某种用途而专门设计的程序； 5、计算机的计算单位 5.1、容量单位 比特位 bit：在物理层面，高低电平 0 / 1 记录信息； 字节 Byte ：1 Byte = 8 bits ; 千字节 KB : 1 KB = 1024 Byte ; 常用于 CPU 的寄存器； 兆字节 MB : 1 MB = 1024 KB ; 常用于高效缓存 吉字节 GB : 1 GB = 1024 MB ; 常用于内存/硬盘； 太字节 TB : 1 TB = 1024 GB ; 常用于硬盘； 拍字节 PB : 1 PB = 1024 TB ; 常用于云硬盘； 艾字节 EB : 1 EB = 1024 PB ; 常用于数据仓库； 疑问：为什么网上买的移动硬盘 500 G，格式化之后只剩下 465 G 了？ 答案：因为硬盘商的换算单位为 1000，而计算机的换算单位为 1024 ! 5.2、速度单位 5.2.1、网络速度 疑问：为什么电信拉的 100 M 光纤，测试峰值速度只有 12 M 每秒？ 答案：网络速度单位为 Mbps ，即电信拉的 100 Mbps 光纤 ！ 100 M/s = 100 Mbps = 100 Mbit/s = 100 / 8 MB/S = 12.5 M/S ! 5.2.2、CPU 频率 CPU 的速度一般体现为 CPU 的时钟频率； CPU 的时钟频率单位一般为赫兹 HZ ； 赫兹 HZ 就是秒分之一，它是每秒钟的周期性变动重复次数的计量； 主流 CPU 的时钟频率都在 2 GHZ 以上; 2 GHZ = 2 * 1000^3 HZ = 20 亿次/秒 ! 6、计算机的字符与编码集 6.1、字符编码集的历史 ASCII 码：使用 7 个比特位就可以完全表示 ASCII 码 ；包含 95 个可打印字符与33 个不可打印字符（控制字符）！ ASCII 码在很多应用和国家的符号都无法表示；如数学符号 等！ 扩展的ASCII 码，使用 8 个比特位表示，包含数学符号 等！ 字符编码集的国际化： 各个国家的语言多样性； 语言体系不一样，不以有限字符组合的语言； 中、日、韩等的语言最为复杂； 6.2、中文编码集 GB 2312 ： 收录了 6763 个汉字和 682 个其它字符 ，总计 7445 个字符； GBK ： 向下兼容GB 2312，向上支持国际标准 ISO ; 收录了 21003 个汉字，支持全部中日韩汉字 Unicode : 兼容全球的字符集，定义了世界通用的字符集！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机组成篇/计算机组成篇.html":{"url":"计算机基础/计算机组成篇/计算机组成篇.html","title":"计算机组成篇","keywords":"","body":"计算机原理之组成篇 1、计算机的总线 1.1、总线的概述 1.1.1、总线是什么？有什么用？ 计算机的总线就像是计算机的 “高速公路”，是为了解决不同设备间的通信而存在的！ 总线标准是系统与各模块、模块与模块之间的一个互连的标准界面。总线标准有利于各模块高效使用总线。如 USB、PCIe 等。 1.1.2、总线的分类 总线分为片内总线与系统总线！ 片内总线：芯片内部的总线，高集成度芯片内部的信息传输线；可以连接寄存器与寄存器；可以连接寄存器与控制器、运算器； 系统总线：分为数据总线、地址总线、控制总线等；是 CPU 、主内存、IO 设备、各组件之间的信息传输线； 1.2、总线的仲裁 为了解决不同设备使用总线的优先顺序的设备； 为了解决总线使用权的冲突问题，有三种仲裁方法： 1.2.1、链式查询 假设设备 2 需要使用总线： 那么设备 2 通过仲裁控制线向仲裁控制器发出“使用总线”的请求； 仲裁控制器收到请求后发出允许使用的的信号； 该信号通过链式查询的方式会先进入设备 1 ； 如果设备 1 不需要使用，那么该信号会来到设备 2 ，设备 2 拿到信号后就可以使用总线； 假设设备 1、设备 2 同时发出使用总线的请求：那么设备 1 将优先拿到总线的使用权； 1.2.2、计时器定时查询 仲裁控制器分别与设备1、设备2、设备3 连接；仲裁控制器有一个计数器，比如值为 1； 假设设备 2 需要使用总线，将通过仲裁控制线向仲裁控制器发出请求； 仲裁控制器会将当前的计数器值 1 发送给所有的设备； 设备 1 实际没有发出请求信号，所以仲裁控制器发出的计数器值 1 无用； 此时仲裁控制器会发出信号 2，此时设备 2 可以获得总线使用权； 2、计算机的输入与输出设备 2.1、常见的输入输出设备 2.2、输入输出接口的通用设计 2.3、CPU 与 IO 设备的通信 程序中断 在某一时刻，CPU 在执行主程序，打印机处于待机状态； 接着 CPU 发出了一个启动打印机的信号，发出信号后 CPU 继续执行主程序； 打印机在收到 启动 信号后，做一些准备工作来启动，准备工作完成后打印机向 CPU 发送一个中断信号； CPU 收到中断信号后，会响应中断信号（不是立即中断，可能延迟） 接着 CPU 发送数据给打印机，打印机接收数据； CPU 发送完数据，会 中断返回，继续执行中断前执行的主程序；同时打印机也会开始打印数据； DMA （直接内存存取） DMA (Direct Memory Access) ： 直接内存存取； 对于 主存 与 IO 设备 并没有直接的连接；而是通过 DMA 设备连接； 当主存与 IO 设备交换信息时，不需要中断 CPU ； DMA 可以处理主存与 IO 设备交换信息的操作； IO 设备不用打断 CPU 的工作，因此 DMA 可以提高 CPU 的效率； 比较：程序中断和 DMA 都是计算机 IO 和低速设备的交互方式，程序中断方式实现简单，DMA 方式效率更高。 3、存储器 常见的存储器有以下几种： 主存：主存储器，即常说的计算机内存条， 辅存：辅助存储器，即常说的磁盘、U 盘、光盘、磁带等， Cache（高速缓存）：即常说的 L1、L2、L3 缓存，CPU 寄存器等，一般位于 CPU 上 ！ RAM：随机存取存储器（Random Access Memory） ROM：只读存储器（Read Only Memory） 3.1、存储器的层次结构 存储器的层次结构可以简单划分为：缓存 - 主存 - 辅存 三个层次，缓存 - 主存 主要是为了解决主存速度不够的问题；主存 - 辅存 主要是为了解决主存容量不足的问题。 3.1.1、缓存-主存 的层次 原理：局部性原理，指 CPU 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的区域中； 实现：在 CPU 与主存之间增加一层速度快容量小的 Cache ； 目的：解决 CPU 与主存速度不匹配的问题！ 3.1.2、主存-辅存 的层次： 原理：局部性原理； 实现：在主存之外增加辅助存储器（磁盘、SD 卡、 U盘等） 目的： 为了解决主存容量不足的问题； 例子：针对 8G 的Mac 与 10 多G 的 Xcode，Xcode 是如何运行到仅仅 8 G 的内存的？由于局部性原理，可以将一些必要数据加载到内存中，对于不使用的数据放到辅存中！ 3.2、计算机的主存储器 主存储器 -> 内存 随机存取存储器 RAM （Random Access Memory） RAM 通过电容存储数据，必须隔一段时间刷新一次，刷新需要有电的存在； 如果掉电，那么一段时间后不能刷新，电容中的电子将丢失，即丢失所有数据； 3.2.1、主存储器如何与 CPU 的交互？ CPU 中的主存数据寄存器 MDR 通过数据总线与主存储器中的读写电路交互； CPU 中的主存地址寄存器 MAR 通过地址总线与内存连接； 因为数据总线与地址总线的存在，CPU 可以通过地址总线指定数据的位置，同时通过数据总线传输相关的数据； 3.2.2、主存储器与操作系统的位数有关系 主存储器与操作系统位数有一定的关系，不同的操作系统对内存的支持是不同的： 32 位系统：最多支持 4 GB 的内存（2^32 = 4 * 2^30 = 4 GB）；在 32 位系统中加装更多的内存也是无用的，因为它的地址总线只有 32 位，寻址范围只有 4 GB 的大小； 64 位系统：最多支持 2^34 GB 的内存（2^64 = 2^34 * 2^30 = 2^34 GB）；在 64 位系统中地址总线有 64 位，寻址范围有 2^34 GB 大小； 3.3、计算机的辅助存储器 - 磁盘 磁盘表面是可磁化的硬磁特性材料，通过移动磁头径向运动读取磁道信息！ 磁盘由两部分组成： 光滑的盘片：使用磁材料存储数据； 磁头（悬臂）：通过左右移动来读取特定地址的信息 磁头位置：当前磁头位于哪一个磁道； 磁头方向：磁头向里走或者向外走； 3.3.1、磁盘的调度算法 为方便计算，将最外层的磁道称为第 1 磁道，最里面的磁道称为第 n 磁道。 假设磁头位于磁道4，磁头方向由里向外，现在需要读取磁道 1、4、2、3、1、5 ！ 先来先服务算法：磁头的移动痕迹 4 -> 1 -> 4 -> 2 -> 3 -> 1 -> 5 ！ 最短寻道时间优先算法：磁头的移动痕迹 4 -> 5 -> 3 -> 2 -> 1 -> 1 ！ 扫描算法（电梯算法）：磁头的移动痕迹 4 -> 3 -> 2 -> 1 -> 1 -> 5 ！ 循环扫描算法 ：磁头的移动痕迹 4 -> 5 -> 1 -> 1 -> 2 -> 3 ！ 3.4、高速缓存的工作原理 3.4.1、字与字块 基本概念： 字：是指存放在一个存储单元中的二进制代码组合；是存储单元的最小单位；一个字可以表示一个数据、一个指令、 一个字符串； 字块：存储在 连续 的存储单元中而被看作是一个单元的 一组 字；字块包含了多个字 ！ 字的寻址 字的地址包括两个部分，分别由字块的部分（用来指示当前需要寻址的字是属于哪一个字块的 ）以及字的部分（用来寻找字块中哪一个字是这个地址所指定的字 ）组成！ demo 假设主存空间为 4 G，字块大小为 4 M，字长位 32 位，则对于字地址中的地址块 m 和块内地址 b 的位数，至少应该是多少？ 4 G = 4096 M; 字块数：4096 / 4 = 1024 /// 至少需要 10 位来表示 1024 个字块 字块地址 m ：log2(1024) = 10 /// 每个字块内有 1048576 个字 块内字数： 4 M / 32 bits = 1048576 /// 至少需要 20 的块内地址来表示块内所有的字 块内地址 b ： log2(1048576) = 20 因此：m >= 10 ; b >= 20; 3.4.2、高速缓存 主存的容量远远大于缓存的容量（主存的字块数远大于缓存的字块数）； 缓存存取的数据是对主存的某块数据的复制（缓存中的数据来自于主存）； 缓存是如何在 缓存-主存 的层次中工作的呢？ CPU 需要高速缓存有两种情况： CPU 需要的数据在缓存中，CPU 直接高效快速的从高速缓存中拿到数据； CPU 需要的数据不在缓存中；CPU 从主存中拿数据； 高速缓存的读取速度比主存快很多，CPU 从主存拿数据，大大降低了 CPU 的效率；因此需要 CPU 尽可能的从高速缓存中读取数据，而非主存中取数据！此时需要一个量化的指标来量化 CPU 从高速缓存中取数据成功的机率（缓存命中率）！ 缓存命中率是衡量缓存的重要性能指标；理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1（实际上永远不可能位 1）！ 假设访问主存 m 次，访问缓存 n 次，那么缓存命中率就是 h = n / (m + n) 假设访问主存时间为 Tm，访问缓存时间为 Tc，则访问 缓存-主存 系统的平均时间为 Ta = h * Tc + (1 - h) * Tm！那么访问效率 e = Tc / Ta = Tc / ( h * Tc + (1 - h) * Tm) ！ demo 假设 CPU 在执行某段程序时，共访问了Cache 命中了 2000 次，访问主存 50 次，已知缓存的存取时间为 50 ns，主存的存取时间为 200 ns，求 缓存-主存 系统的命中率、访问效率和平均访问时间？ 缓存命中率 h = 2000 / (2000 + 50) = 0.97; 平均访问时间 Ta= 0.97 * 50 + (1 - 0.97) * 200 = 54.5 ns; 访问效率 e = 50 / 54.5 = 91.7% ; 3.5、高速缓存的替换策略 为了使 CPU 的运行效率更高，需要缓存命中率越高越好，让 CPU 在每一次取数据时，都能从高速缓存中取数据，而不是从主存中取数据！此时我们需要一个良好的缓存替换策略，使得缓存中的数据都是 CPU 需要的数据！ 替换时机：当 CPU 需要的数据不在高速缓存中时，需要从主存中载入所需的数据，然后替换到高速缓存中！ 假设缓存 4 个字块，() 表示使用的字块，[] 表示淘汰的字块 最近最少使用算法（LRU） (1) 1 (2) 2、1 (4) 4、2、1 (7) 7、4、2、1 (5) 5、7、4、2 [1] (4) 4、5、7、2 (6) 6、4、5、7 [2] 4、计算机的指令系统 4.1、机器指令的形式 机器指令主要由 操作码、地址码 两部分组成；分为三地址指令、二地址指令和一地址指令！ 操作码：指明指令所要完成的操作；操作码的位数反映了机器的操作种类，比如操作码有 8 位，则有 2^8 = 256 种操作！ 地址码：直接给出操作数或者操作数的地址；因为机器指令本质上还是对数据进行操作，所以地址码实际上还是指定数据或者数据的地址，使得 CPU 能够根据数据或者数据的地址进行运算； /// 三地址指令 操作码OP | addr1 | addr2 | addr3 (addr1)OP(addr2) -> (addr3) 如加法操作 (1)+(2) -> (3) /// 二地址指令 操作码OP | addr1 | addr2 (addr1)OP(addr2) -> (addr1)或者(addr2) /// 把结果放到 addr1 或者 addr2 /// 一地址指令 操作码OP | addr1 (addr1)OP -> (addr1) /// 把结果放到 addr1 ，如自己对自己的操作 (addr1)OP(ACC) -> (addr1) /// 把结果放到 addr1 零地址指令，在机器指令中无地址码，空操作、停机操作、中断返回操作等！ 4.2、机器指令的操作类型 4.3、机器指令的寻址方式 顺序寻址：执行 101 指令、102 指令、103 指令、104 指令、105 指令； 跳跃寻址：105 指令指向102 指令，因此跳跃到 102 指令！ 数据寻址方式 优先 缺点 立即寻址 速度快（从机器指令直接拿到数据） 地址码位数 限制操作数表示范围 （数据存放在地址码中） 直接寻址 寻找操作数简单 地址码位数 限制操作数表示范围 间接寻址 操作数寻址范围大 速度较慢 5、计算机的控制器 计算机的控制器用于协调和控制计算机运行！ 程序计数器：用于存储下一条指令的地址；当 CPU 工作时程序计数器会循环不断的从计数器中拿出指令；当拿出一条指令后，会指向下一条指令；程序计数器 主要提供给其它控制单元当前指令执行的地址！ 时序发生器：属于电气工程领域，用于发送时序 脉冲，CPU 依据不同的时序脉冲有节奏的进行工作！ 指令译码器：是控制器的重要部件之一，计算机指令由操作码与地址码组成，指令译码器会将操作码翻译为对应的操作数据、将地址码翻译为控制传输地址对应的数据！ 指令寄存器：是 CPU 高效运转的重要部件之一，用于缓存从主存或者高速缓存取下来的计算机指令；当 CPU 需要执行相关指令时，就可以从指令寄存器取出相关的指令，而不需要从主存或者高速缓存去取！ 主存地址寄存器：保存当前 CPU 正要访问的内存单元的地址，通过地址总线与主存通信的！ 主存数据寄存器：保存当前 CPU 正要读、正要写的主存数据，通过数据总线与主存通信的！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 6、计算机的运算器 计算机的运算器主要用于数据的运算加工！ 数据缓冲器：分为 输入缓冲 与 输出缓冲；输入缓冲 用于暂时存放外设传送来的数据，如果 ALU 正在运算则下一个运算数据保存在该缓冲中； 输出缓冲 暂时存放往外设的数据，当数据运算完毕从 ALU 输出时保存在输出缓冲中、等待控制器下一步的命令将数据送到相应位置！ ALU（算数逻辑单元）：是运算器的主要组成，可以完成常见的位运算（左移、右移、或、与、非等），可以完成一些算术运算（加、减、乘、除等）！ 状态字寄存器：用于存放运算中的状态（条件码、进位、溢出、结果正负等）；存放运算控制信息（调试跟踪标记位、允许中断位等）！ 通用寄存器：用于暂时存放或传送 数据与指令；也可以保存 ALU 的运算中间结果；容量比一般专用寄存器要大！ 7、计算机指令的执行过程 7.1、指令的执行过程 指令执行的一般操作 : 取指令 -> 分析指令 -> 执行指令 ! 取指令：从指令缓存中取指令，送到指令寄存器； 分析指令：将指令从指令寄存器取出，送到指令译码器译码；指令译码器发送控制信号，同时程序计数器 +1； 执行指令：首先将数据装载到寄存器，接着ALU 处理数据，记录运算状态，最后送出运算结果！ 指令执行中涉及的设备：数据缓冲器、指令缓冲器、运算器（通用寄存器、数据寄存器、状态字寄存器）、程序计数器、指令译码器、时序发生器、指令寄存器； 运算器部分、控制器部分、高速缓存部分，通过片内总线连接起来； 执行指令时，首先发生数据缓存与指令缓存；将数据与指令缓存到 CPU 的高速缓存中； 接着程序计数器根据指令地址 101，程序计数器只知道指令的地址而不知道指令的具体内容，需要通过总线来到指令缓存中获取指令 MOV R0,R1； 通过片内总线来到指令寄存器，指令寄存器缓存具体内容 MOV R0,R1； 指令寄存器不知道相关内容，还需要将指令发送到指令译码器；同时程序计数器 +1 (102)； 指令译码器将指令译码，译码完成后理解指令的具体内容 (将 R0 的数据移到 R1 中)；指令译码器发出控制信号； 控制信号通过片内总线来到运算器，运算器通过控制信号知道自己要干什么； 运算器首先将 R0(100) 加载到 ALU 中，接着将 R0(100) 通过总线送到数据缓存器； 数据缓存器会将 R0(100) 覆盖到 R1，此时 R1 的数据为 R1(100)！ 完成该条指令后，CPU 又去执行下条指令！ 疑问：在上述 取指令 与 分析指令 的过程中，是由控制器工作的；执行指令时，由运算器工作！也就是说，运算器与控制器不能同时工作，这就导致 CPU 的综合利用率并不高 ！因此需要改进指令执行过程，提高CPU 的综合利用率！ 7.2、CPU 的流水线设计 CPU 的流水线设计类似于工厂的装配线，多个厂品可以同时被加工；在同一时刻，不同产品位于不同的加工阶段！ 每一个时间片，都有一条或多条指令在执行； 如对于第 2 个时间片，第1条指令在分析，第 2 条指令在取指令； CPU 的流水线设计大大提升了CPU 的综合利用率！ 假设取指令、分析指令、执行指令的时间开销都是 t： 串行执行 m 条指令： T1 = 3t * m ； 流水线执行 m 条指令： T2 = t * (m + 2) ； 流水线执行的效率 H = T2 / T1 = (t * (m + 2)) / (3t * m) ； 当 m 很大时 流水线执行效率是串行执行 的 3 倍！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机组成篇/计算机计算篇.html":{"url":"计算机基础/计算机组成篇/计算机计算篇.html","title":"计算机计算篇","keywords":"","body":"计算机原理之计算篇 1、进制运算的基础 1.1、进制运算概述 1024 = 0b1000000000 (0b 表示二进制) = 0o2000 (0o 表示八进制) = 0x400 (0x 表示十六进制) 1.2、二进制运算的基础 整数进制转换 /// 整数二进制转十进制：按权展开法 N = 01100101 = 1 * 2^6 + 1 * 2^5 + 1 * 2^2 + 1 = 101 N = 11101101 = 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^3 + 1 * 2^2 + 1 = 237 /// 整数十进制转二进制：重复相除法 (01100101)(从下向上) 101 / 2 = 50 ··· 1 50 / 2 = 25 ··· 0 25 / 2 = 12 ··· 1 12 / 2 = 6 ··· 0 6 / 2 = 3 ··· 0 3 / 2 = 1 ··· 1 1 / 2 = 0 ··· 1 浮点数进制转换 /// 浮点数二进制转十进制：按权展开法 N = 0.11001 = 1 * 2^-1 + 1 * 2^-2 + 1 * 2^-5 = 0.78125 N = 0.01011 = 1 * 2^-2 + 1 * 2^-4 + 1 * 2^-5 = 0.34375 /// 浮点数十进制转二进制：重复相乘法（0.11001）(从上向下) 25/32 = 50/32 = 1 + 9/16 取 1 9/16 = 18/16 = 1 + 1/8 取 1 1/8 = 1/4 = 0 + 1/4 取 0 1/4 = 1/2 = 0 + 1/2 取 0 1/2 = 1/1 = 1 + 0 取 1 1.3、有符号数与无符号数 1.3.1、原码表示法 如何判断是数字位还是符号位？ 原码表示法 使用 0 表示正数，使用 1 表示负数，规定符号位位于数值第一位；表达简单明了，是人类最容易理解的表示法！ 在原码表示法之下，0 有两种结果：正 0 00 与负0 10 ！除此之外，原码表示法进行运算也非常复杂，特别是两个操作数符号不同的时候！ 1.3.2、补码表示法 补码表示法：使用正数代替负数！但仍然没有实现 使用加法操作代替减法操作 的预期！ /// n = 4, x = 13； 计算 x 的二进制原码和补码 原码 x = 0 1101 补码 x = 0 1101 /// y = -13； 计算 y 的二进制原码和补码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 1.3.3、反码表示法 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 补码 2^(n+1) + y = 2^(4 + 1) - 13 = 10 0000 - 1101 = 10011 补码 y = 1 0011 反码 2^(n+1) - 1 + y = 2^(4 + 1) - 1 - 13 = 011111 - 1101 = 10010 反码 y = 1 0010 /// z = -7； 计算 z 的二进制原码和补码 原码 z = 1 0111 补码 2^(n+1) + z = 2^(4 + 1) - 7 = 10 0000 - 0111 = 11001 补码 z = 1 1001 反码 2^(n+1)-1 + z = 2^(4 + 1) - 1 - 7 = 011111 - 0111 = 11000 反码 z = 1 1000 十进制 原码 补码 反码 13 0 1101 0 1101 0 1101 -13 1 1101 1 0011 1 0010 -7 1 0111 1 1001 1 1000 -1 1 0001 1 1111 1 1110 负数的反码等于原码（除符号位）按位取反 ！ 负数的补码等于其反码 + 1 /// n = 4, y = -13； 计算 y 的二进制原码、补码、反码 原码 y = 1 1101 反码 y = 1 0010 补码 y = 1 0011 /// z = -7； 计算 z 的二进制原码、补码、反码 原码 z = 1 0111 反码 z = 1 1000 补码 z = 1 1001 1.3.4、小数的补码 /// n = 4, x = 9/16； 计算 x 的二进制原码、补码、反码 原码 x = 0 0.1001 (重复相乘法) 反码 x = 0 0.1001 补码 x = 0 0.1001 /// y = -11/32； 计算 y 的二进制原码、补码、反码 原码 y = 1 0.01011 (重复相乘法) 反码 y = 1 1.10100 补码 y = 1 1.10101 2、定点数与浮点数 2.1、定点数的表示方法 小数点固定在某个位置的数称为定点数！ 数值 符号位 数值位 0.1011 0 1011 -0.1011 1 1011 1011 0 1011 -1011 1 1011 2.2、浮点数的表示方法 计算机处理的很大程度上不是纯小数或纯正数；数据范围很大，定点数难以表达；此时需要使用浮点数来表示！ 2.2.1、浮点数的表示格式 科学计数法 1 2345 0000 = 1.2345 * 10^8 /// 尾数 1.2345 /// 基数 10 /// 阶码 8 /// 科学计数法要求尾数的绝对值范围在 [1,10) 之间 浮点数在计算机存储中分为 4 个部分 (规格要求： 尾数使用纯小数，且尾数最高位必须是 1 ) ！ 浮点数的表示格式 N = S * r^j 11.0101 = 0.110101 * 2^10 11.0101 = 0.0110101 * 2^11 ///不符合要求：尾数最高位不是 1 11.0101 = 1.10101 * 2^1 /// 不符合要求：尾数不是纯小数 阶码符号位 阶码数值位 尾数符号位 尾数数值位（8位） 0 10 0 11010100 2.2.2、浮点数的表示范围 假设阶码数值取 m 位，尾数数值取 n 位，N = S * r^j ！ 阶码能够表示的最大值：2^m - 1 ；考虑有符号时 [-(2^m - 1), 2^m - 1] 尾数能够表示的最大值：1 - 2^-n；尾数全是 1 的时候是最大值； 尾数能够表示的最小值：2^-n；尾数全是 0 （除了最后一位是 1） 的时候是最小值； 尾数表示范围：[2^-n, 1 - 2^-n]；考虑有符号时[-(1 - 2^-n),-2^-n]， [2^-n, 1 - 2^-n]； 超出浮点数的表示，有可能导致数据溢出： 上溢：绝对值太大，导致没有办法表示这么大的数； 下溢：绝对值太小，导致没有办法表示这么小的数； 单精度浮点数 float ：使用 4 个字节 (32 位) 来表示浮点数; 双精度浮点数 double：使用 8 个字节 (64 位) 来表示浮点数; Demo 1 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 13/128 表示为二进制浮点数 原码=反码=补码 x = 0.0001101000 (重复相乘法) 浮点数规格化 x = 0.1101000 * 2^-11 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 1 0011 0 1101000000 Demo 2 ：假设浮点数字长位 16 位，阶码为 5 位，尾数为 11 位，将十进制数 -54 表示为二进制浮点数 原码 x = 1 110110 (重复相除法) 浮点数规格化 x = -0.110110 * 2^110 阶码符号位 阶码数值位 尾数符号位 尾数数值位（11位） 0 0110 1 0010100000 2.3、定点数与浮点数的对比 当定点数与浮点数位数相同时，浮点数表示的范围更大； 当浮点数的尾数为规格化的小数时，浮点数的精度更高； 浮点数的运算包含阶码和尾数，浮点数的运算更为复杂； 浮点数在数的表示范围、精度、溢出处理、编程等方面均优于定点数； 浮点数在数的运算规则、运算速度、硬件成本等方面不如定点数； 2.4、定点数的加法与减法 2.4.1、定点数的加法计算 数值位与符号位一同运算，并将符号位产生的进位自然丢掉 ： 整数加法： A[补] + B[补] = [A + B][补](mod2^(n+1)) 小数加法： A[补] + B[补] = [A + B][补](mod2) /// 例1： A = -110010, B = 001101, 求 A + B A[反] = 1 001101 A[补] = 1 001110 B[反] = 0 001101 B[补] = 0 001101 [A + B][补] = 1 011011 [A + B][反] = 1 011010 A + B = -100101 /// 例2： A = -0.1010010, B = 0.0110100, 求 A + B A[反] = 1 1.0101101 A[补] = 1 1.0101110 B[反] = 0 0.0110100 B[补] = 0 0.0110100 [A + B][补] = 1 1.1100010 [A + B][反] = 1 1.1100001 A + B = -0.0011110 /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 10100000 B[补] = 1 10110000 [A + B][补] = 1 00100000 [A + B][反] = 1 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 1 01100000 A[补] = 1 01110000 B[反] = 1 00100000 B[补] = 1 00110000 [A + B][补] = 0 10100000 [A + B][反] = 0 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 判断溢出的方法： 双符号位判断法：单符号位表示成双符号位，运算时双符号位产生的进位丢弃；如果结果的双符号位不同，则表示溢出！ /// 例3： A = -10010000 （-144）, B = -01010000 （-80）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 10100000 B[补] = 11 10110000 [A + B][补] = 11 00100000 [A + B][反] = 11 00010000 A + B = - 11100000 （-224） /// 例4： A = -10010000 （-144）, B = -11010000 （-208）, 求 A + B A[反] = 11 01100000 A[补] = 11 01110000 B[反] = 11 00100000 B[补] = 11 00110000 [A + B][补] = 10 10100000 [A + B][反] = 10 10100000 A + B = 10100000 （160） /// ？？ 发生了溢出操作： A + B 使用 8 位不够存储 2.4.2、定点数的减法计算 将减法转为上述的加法操作： 整数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2^(n+1)) 小数减法： A[补] - B[补] = A[补] + (-B)[补] = [A + B][补](mod2) (-B)[补] 等于 B[补] 连同符号位按位取反，末位加一！ B[补] = 10010101 (-B)[补] = 01101011 2.4、浮点数的加法与减法 一般步骤：对阶 -> 尾数求和 -> 尾数规格化 -> 舍入 -> 溢出判断 ！ 对阶：保证两个浮点数的阶码一致，使得尾数可以进行计算！阶码按照小阶看齐大阶的原则； 尾数规格化：对补码进行规格化需要判断两种情况：S > 0 或 S ！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/操作系统篇/操作系统基础篇.html":{"url":"计算机基础/操作系统篇/操作系统基础篇.html","title":"第二部分 操作系统篇","keywords":"","body":"操作系统篇 最早的计算机没有操作系统这一概念的，需要人工操作计算机；CPU 等待人工输入输出，当用户输入输出时，CPU 处于空闲状态！ 为了 解决计算机操作难度大、计算机资源利用效率低 等问题，人们发明了操作系统；经历了由早起的 批处理系统 到现在 分时系统 的演变！ 处理操作系统：批量输入任务、有效提升计算机资源利用率；计算机工作时，用户无法干预； 分时复用计算机资源的操作系统：可以多个用户使用一台计算机；多个程序分时共享计算机资源；现代主流的计算机系统！ 而不论是 批处理系统、还是 分时系统 ，都利用了 多道程序设计 的概念！ 多道程序设计：是指计算机内存中同时存放多个程序，并且这些程序互不干扰； 早起的 批处理系统 一次只能处理一个任务； 多道程序设计使得 批处理系统 可以一次处理多个任务； 多道程序在计算机的管理程序之下相互穿插运行； 因此，对多道程序的管理是操作系统的重要功能； 1、什么是操作系统？为什么使用操作系统？ 操作系统是管理硬件、提供用户交互的软件系统！ 操作系统是管理计算机硬件和软件资源的 计算机程序； 通过管理配置内存、决定资源供需顺序、控制输入输出设备等方法管理硬件资源； 同时，操作系统也提供了让用户和系统交互的操作界面！ 操作系统的种类是多种多样的，不局限于计算机；从手机到超级计算机，都有操作系统的存在(Android 、iOS 、Windows 、Linux 、MacOS 等)！在不同的设备，操作系统既可以简单也可以复杂，向用户呈现多种操作手段（手机的触控操作）！ 为什么使用操作系统？ 我们不可能直接的操作计算机硬件（如要求 CPU 计算 1 + 1） 设备种类繁多复杂，需要操作系统为用户提供了统一的界面，屏蔽不同设备的差异； 解决计算机操作难度大的问题：操作系统的简易性使得更多的人可以使用计算机； 2、操作系统的基本功能 操作系统实现了对计算机资源的抽象，这里面的计算机资源主要有 存储资源 、网络资源、计算资源等。 基本功能一：操作系统统一管理着计算机资源 如用户需要操作某个文件，并不是直接操作该文件的地址，而是通过操作系统来访问！ 如存储器资源，在用户读取数据或者写入数据，并不是直接控制存储器的设备读写，而是通过操作系统去管理和读写的！ 如处理器资源，也不是直接告诉 CPU 需要计算的内容，而是由操作系统来翻译需要做的任务！ 基本功能二：用户无需面向硬件接口编程 操作系统的 IO 设备管理软件，提供读写接口； 文件管理软件，提供操作文件的接口； 操作系统实现了对计算机资源的抽象；通过管理软件来实现抽象！管理软件屏蔽了硬件设备，向上向用户提供了逻辑设备，使得每个用户都使用相同的逻辑！ 基本功能三：操作系统提供了用户和计算机之间的接口 操作系统提供了用户与计算机之间的接口，使得用户可以通过操作系统操作计算机，这个接口主要以下有几种形式： 图像窗口形式 命令形式； 系统调用形式； 应用程序形式； 3、操作系统的相关概念 我们需要了解关于操作系统的 并发性 、共享性 、 虚拟性 、 异步性 ！ 3.1、并发性 并发与并行: 并行是指两个或者多个事件可以在 同一时刻 发生 并发是指两个或者多个事件可以在 同一时间间隔 发生 多道程序设计是并行与并发的基础 在单核处理器上，程序主要是并发的执行：在某一时刻，只能由一个程序占用 CPU ；在一个时间间隔内，多道程序交替运行； 在多核处理器上，程序可以并行的执行：在某一时刻，每个核上可以单独处理一个程序；多核同时处理多个程序； 3.2、共享性 资源共享表现为操作系统中的资源可以被多个并发的进程共同使用；多个程序可以同时使用主存资源的性质就是共享性！ 根据属性划分分为 互斥共享形式 与 同时访问形式 ! 互斥共享形式 当资源被程序 A 占用时，其它想使用该资源的程序只能等待 只有进程 A 使用完以后，其它进程才可以使用该资源 如打印机被程序 A 使用，那么程序 B 只能等待 程序 A 打印完毕才能使用打印机 同时访问形式 某种资源在一段时间内 并发地 被多个程序访问 这种 同时 是宏观的，从宏观上看该资源可以被同时访问 如程序 A 与程序 B 都准备向硬盘写入数据，硬盘悬臂只有一个，程序 A 写数据时，程序 B 实际上是不能写的；但写数据是一件快速的事情，所以我们可能观察到程序 A与程序 B在一瞬间都写入了数据 3.3、虚拟性 操作系统的虚拟性是指操作系统可以把一个计算机的物理实体转变为若干个逻辑实体以提供多个用户、多道程序使用；物理实体是真实存在的，而逻辑实体是虚拟的！ 虚拟性的技术主要有 时分复用技术 、空分复用技术 ! 时分复用技术 时分复用技术相关概念： 资源在时间上进行复用，不同程序并发使用 多道程序分时使用计算机的硬件资源 提高资源的利用率 时分复用技术主要有 虚拟处理器技术 、虚拟设备技术 ! 虚拟处理器技术 借助多道程序设计技术 为每个程序建立进程 多个程序分时复用处理器来执行相关逻辑 虚拟设备技术 将一个物理设备虚拟为多个逻辑设备 每个程序占用一个逻辑设备 多个程序通过逻辑设备并发访问 空分复用技术 空分复用技术主要用来实现虚拟磁盘、虚拟内存等；使用空分复用技术可以提高资源的利用率、提高编程效率！ 空分复用技术主要有 虚拟磁盘技术 、虚拟内存技术 ! 虚拟磁盘技术 将一个物理磁盘虚拟为多个逻辑磁盘 如一个硬盘虚拟为 C 盘、D 盘、E盘等 使用起来更加安全、方便 虚拟内存技术 在逻辑上扩大程序的存储容量 使用比实际内存更大的容量 大大的提升编程效率 3.4、异步性 操作系统的异步性是指是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。 异步性主要体现在以下几点： 在多道程序环境下，允许多个程序并发执行； 进程在使用资源时可能需要等到或者放弃； 进程的执行并不是一气呵成的，而是以走走停停的形式推进； 4、操作系统是如何启动的？ 没有操作系统的计算机就像是一堆废铜烂铁，操作系统接管了很多工作，在很多方面大大节省了人们的操作成本。 那么软件与硬件的界限在哪里？计算机硬件通电后，操作系统如何被激活和启动呢？ 4.1、操作系统的自举 自举是计算机领域比较重要的概念，计算机必须具备自举能力将自己所有的元件激活，以便能完成加载操作系统这一目的，然后再由操作系统承担起那些单靠自举代码无法完成的更复杂的任务。 4.2、操作系统的上电自检 BIOS (Basic Input Output System ) 是 基本输入输出系统 ! 上电自检 POST（Power On Self Test）是指计算机系统，接通电源、BIOS 程序的行为；包括对 CPU、系统主板、基本内存、扩展内存、系统 ROM BIOS 等器件的测试。如发现错误，给操作者提示或警告。简化或加快该过程，可使系统能够快速启动。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/操作系统篇/进程管理篇.html":{"url":"计算机基础/操作系统篇/进程管理篇.html","title":"进程管理篇","keywords":"","body":"进程管理篇 1、为什么需要进程？ 在没有操作系统的年代，计算机只能运行一个程序，计算机资源属于当前运行的程序；有了操作系统之后，引入了多道设计的概念，通过合理的隔离资源、运行环境，提升资源利用率！ 进程是操作系统进行计算机资源分配和调度的基本单位； 进程作为独立运行的载体，保障用户的逻辑程序在操作系统中独立、正常的执行；(多个进程可能使用一个共同的设备，如存储器、CPU等) 进程的存在使得操作系统对资源的利用率大幅度提升； 2、进程实体 2.1、进程的实体：主存中的进程形态 进程在计算机中表现为一片存储空间，包含进程状态、进程优先级、程序计数器、内存指针、上下文数据、IO 状态信息等一系列数据。 进程控制块 PCB (Process Control Block) 在主存中，进程也是一段连续存储的空间 (进程控制块)： 用于描述和控制进程运行的通用数据结构； 用于记录进程当前状态和控制进程运行的全部信息； PCB 是进程能够独立运行的基本单位；每个进程都依赖于进程控制块，被操作系统调度； PCB 是操作系统进行调度经常会被读取的信息； PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内； 有了 PCB，操作系统才可以控制进程的运行。 进程控制块 PCB 的一些关键构成元素 进程控制块元素 细节 标识符 唯一标记一个进程，用于区别其它进程（如进程 ID 就是唯一标识符） 状态 标记进程的状态，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态 程序计数器 进程即将被执行的下一条指令的地址 内存指针 程序代码、进程数据相关指针；可能有多个内存指针分别指向程序的逻辑代码 上下文数据 进程执行时处理器存储的数据 IO 状态信息 被进程 IO 操作所占用的文件列表 记账信息 存储进程使用处理器的时间、时钟数总和等； 优先级 ... ... 进程的实体由进程标识符、处理机状态、进程调度信息、进程控制信息 构成； 2.2、进程与线程 进程 Process：是操作系统进行资源分配和调度的基本单位； 线程 Thread ：是操作系统能够进行运算调度的最小单位； 线程被包含在进程之中，是进程中的实际运作单位；一个进程可以有多个线程； 操作系统对进程的调度，实质上是对进程中线程的调度； 一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发多个线程，每个线程执行不同的任务； 一个进程中的多个线程共享该进程资源； 对比 进程 线程 资源 资源分配的基本单位 不拥有资源 调度 独立调度的基本单位 独立调度的最小单位 系统开销 管理线程、分配资源，因此进程系统开销大 线程系统开销小 通信 进程 IPC 读写同一进程数据通信 3、进程状态 进程在系统中是有多个状态的，主要有 就绪 、 阻塞 、执行 、 创建 、终止 五个状态！ 就绪状态： 当进程被分配到除了 CPU 以外所有必要的资源后处于就绪状态； 此时只要再获得 CPU 的使用权，就可以立即执行； 包括 进程控制块，堆空间、栈空间等内存 的其它资源都已经准备好、只差 CPU 资源的状态为就绪状态； 在一个系统中处于就绪状态的多个进程通常排成一个队列（就绪队列）； 执行状态： 进程获得 CPU 的使用权，其程序正在执行的状态； 在单处理机中，在某个时刻只能有一个进程处于执行状态； 阻塞状态： 进程由于某些原因从而放弃 CPU 的状态称为阻塞状态 如进程需要获取某个设备，而对应的设备没有就绪导致进程无法继续执行； 如某个进程需要使用打印机，而打印机属于外围的 IO 设备、速度比较慢，进程在请求使用打印机后可能没有立刻得到反馈，这时候进程无法进行下一步工作，由于打印机的未就绪而处于阻塞状态； 阻塞队列：在操作系统中可能有一个或者多个阻塞进程； 创建状态：分配 PCB -> 插入就绪队列 创建进程时拥有 PCB ，但其它资源尚未就绪的状态称为创建状态； 操作系统提供了 fork() 函数接口供程序员手动创建进程； 终止状态；系统清理 -> 归还 PCB 进程结束由系统清理或者归还 PCB 的状态称为终止状态； 就绪 -> 执行状态：当就绪状态的进程发生 进程调度 时，就可以变为执行状态； 执行 -> 就绪状态：当执行状态的进程 CPU 资源（时间片）用完时，又会切换为 就绪状态，插入到就绪队列中去；时间片资源指分配给某个进程执行的 CPU 时间段； 执行 -> 阻塞状态：进程发生 IO 请求时，可能变为阻塞状态； 阻塞 -> 就绪状态： 当 IO 完成时，进程由阻塞状态切换为就绪； 4、进程间同步 4.1、为什么需要进程间同步？ question 1：生产者-消费者问题 有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费；生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的缓冲池；生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。 在现实的宏观生活中，上述的生产者-消费者模型没有任何问题，但是针对计算机的微观世界而言，是有一些问题的！ 单从生产者程序或者消费者程序去看是没有任何问题的； 但如果两者并发执行时，可能出错！ question 2：哲学家进餐问题 有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌子，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子，只有两支筷子都被拿到的时候才能进餐，进餐完毕后放下筷子左右思考！ 上述两个模型的根源问题是彼此之间没有互相通信，如果生产者通知消费者我已经完成了一件生产、或者哲学家向旁边的哲学家说我要进餐了你们别拿我的筷子！因此需要进程间的同步！ 进程间的同步可以对竞争资源在多进程间进行使用次序的协调；使得并发执行的多个进程之间可以有效使用资源和相互合作！ 4.2、进程同步的原则 临界资源 ：指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其它进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源！ 为了对临界资源更好的约束，提出了四条原则 空闲让进：如果临界资源没有被占用、操作系统应该允许某个进程使用该临界资源； 忙则等待：如果已经有进程占用临界资源，此时应该防止别的进程使用该资源；使请求进程等待该临界资源的释放； 有限等待：在忙则等待的基础上，如果临界资源被占用，需要保证在有限等待时间内别的等待进程能够使用到资源，以避免外部等待进程僵死； 让权等待：当外部进程等待时，等待进程需要让出 CPU（进程从执行状态转为阻塞状态），保证 CPU 可以高效利用； 进程间同步的方法有：信号量、共享内存、消息队列、Unix 域套接字等！ 4.3、线程同步 进程中的线程共享进程资源，当进程中的多线程并发的访问进程的资源时，可能发生数据竞态的问题；所以进程内多线程也需要同步！ 线程同步的方法有：互斥量、自旋锁、读写锁（应对多读少写、少读多写的情况使用）、条件变量的等方法。 5、Linux 的进程管理 5.1、Linux 进程的相关概念 进程的类型 前台进程：正在运行、并且占用终端和用户交互的进程； 后台进程：基本上不和用户交互、不占用终端的进程，优先级比前台进程低； 守护进程：一种特殊的后台进程；很多守护进程随系统引导而启动，一直运行直到系统关闭；如进程名字以 d 结尾的一般都是守护进程：crond 、httpd 、sshd 、mysqld ！ 进程的标记 进程 ID ：进程的唯一标记，每个进程拥有不同的 ID；是一个非负整数，最大值由操作系统限定； ID 为 0 的进程为 idle 进程，是系统创建的第一个进程； ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化； init 进程 是所有用户进程的祖先进程； /// 进程 ID 相关的关系：父子关系 进程A调用 fork() 函数创建进程B； 进程B调用 fork() 函数创建进程C； 进程A是进程B的父进程，进程B是进程A的子进程； /// 进程的父子关系可以通过 pstree 命令来查看 MacBook-Pro:~ $ pstree -+= 00001 root /sbin/launchd |--= 00064 root /usr/sbin/syslogd |--= 00065 root /usr/libexec/UserEventAgent (System) |-+= 00073 root /usr/sbin/systemstats --daemon |-+= 00075 root /usr/libexec/configd |--= 00077 root endpointsecurityd |--= 00081 root /usr/libexec/remoted |--= 00083 root /usr/libexec/logd |--= 00097 root /usr/libexec/kernelmanagerd |--= 00098 root /usr/libexec/diskarbitrationd |--= 00101 root /usr/libexec/coreduetd 进程的状态标记 状态说明 R TASK_RUNNING 进程处于运行状态 S TASK_INTERUPTIBLE 进程处于睡眠状态 D TASK_UNINTERUPTIBLE 进程处于 IO 等待的睡眠状态 T TASK_STOPPED 进程处于暂停状态 Z TASK_DEAD / EXIT_ZOMBIE 进程处于退出状态，或僵尸进程 5.2、操作 Linux 进程的相关命令 ps 命令：查看当前进程的相关信息；配合 aux 参数或 ef 参数和 grep 命令检索特定进程； 　 　 top 命令：查看一些使用内存等 kill 命令：发送特定信号给进程，kill -l 可以查看操作系统支持的信号；只有 kill 9 -0000 可以无条件终止进程，其它信号进程有权忽略； MacBook-Pro:~ $ ps PID TTY TIME CMD 21187 ttys001 0:00.01 -bash 6、作业管理之进程调度 6.1、进程调度概述 进程调度指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权！ 保存旧进程的运行信息，请出旧进程（收拾包袱） 选择新进程，准备运行环境并分配 CPU （新进驻） 就绪队列的排队机制：为了提高进程的效率，事先将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程； 选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它； 新老进程的上下文切换机制：如果需要把新的进程调度到 CPU 中，需要将旧的 CPU 中的进程备份出来，将新的进程切换到 CPU 中去；保存当前进程的上下文信息，装入被委派执行进程的运行上下文； 如果程序调度时，老进程还没有执行完会怎样呢？进程调度分为非抢占式调度、抢占式调度！ 非抢占式调度：处理器一旦分配给某个进程，就让该进程一直使用下去；调度器不以任何原因抢占正在被使用的处理器；直到进程完成工作或因为 IO 阻塞才会让出处理器； 抢占式调度：允许调度程序以一定的策略暂停当前运行的进程；保存好旧进程的上下文信息，分配处理器给新进程； 对比 抢占式调度 非抢占式调度 系统开销 频繁切换、开销大 切换次数少、开销小 公平性 相对公平 不公平 应用 通用系统 专用系统 6.2、进程调度算法 先来先服务算法：在就绪队列，按先来先服务原则，优先取出先进入队列的就绪进程； 短进程优先调度算法：调度程序优先选择就绪队列中估计运行时间最短的进程；不利于长作业进程的执行； 高优先权优先调度算法：进程附带优先权，调度程序优先选择权重高的进程；使得紧迫的任务可以优先处理；（前台进程高于后台进程，是因为前台进程与用户交互，需要保证用户的体验，不卡顿！） 时间片轮转调度算法：按照先来先服务的原则排列就绪进程；每次从队列头部取出待执行进程，分配一个时间片，时间片用完后不管进程是否执行完、都会将进程重新插入队列尾部，然后取出第二个队列；是相对公平的调度算法，但不保证及时响应用户； 7、作业管理之死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力作用，它们都将无法推进下去。此时称操作系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程！ 7.1、死锁的产生原因 死锁的产生是由于竞争资源、进程调度顺序不当导致的！ 竞争资源： 共享资源数量不满足各个进程需求； 各个进程之间发生资源竞争导致死锁； 自身占用资源不释放，而一直在等待请求的资源被释放； 假设进程 1 申请传真机为步骤 A、进程 2 申请打印机为步骤 B、进程 2 申请传真机为步骤 C、进程 1 申请打印机为步骤 D！ 按照 A -> B -> C -> D 的顺序调度，就会引起进程死锁；如果将进程调度顺序改为 A -> D -> B -> C 就不存在死锁的情况！ 7.2、死锁产生的四个必要条件 死锁的产生，必然同时满足以下四个条件，仅满足其中的某几个是不会产生死锁的！ 互斥条件：进程对资源的使用具有 排它性 ；某个资源仅能由一个进程使用，其它进程需要使用只能等待； 请求保持条件：进程至少保持一个资源，又提出了新的资源请求；但新资源被占用，导致请求被堵塞；同时被阻塞的进程又不释放自己保持的资源； 不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺；获得的资源只能由进程自身释放； 环路等待条件：发生死锁时，必然存在进程-资源环形链； 7.3、预防死锁的方法 破坏死锁产生的四个必要条件中的某一个或者某几个，就能有效预防死锁的产生！ 摒弃 请求保持条件 ：系统规定进程在运行之前，一次性申请所有需要的资源；在进程运行中，不会再去申请资源； 破坏 不可剥夺条件 ：当一个进程请求新的资源得不到满足时，必须释放其自身占有的资源；进程运行时占有的资源可以被释放，意味着可以被剥夺； 破坏 环路等待条件 ： 可用资源线性排序，申请必须按照需要递增申请；线性申请不再形成环路，从而摒弃了环路等待条件； 7.4、银行家算法 银行家算法是一个可操作的著名的避免死锁的算法、以银行借贷系统分配策略为基础的算法！ 银行家算法的策略基础： 假设客户申请的贷款是有限的，每次申请需声明最大资金量； 银行家在能够满足贷款时，都应该给用户贷款； 客户在使用完贷款后，能过及时归还贷款； 如上图所示，有初始状态的 所需资源表、已分配资源表；所需资源表减去已分配资源表得到的 还需分配资源表；还有 可分配资源表 ！ 所需资源表：P1 需要 0 个 A 资源、 6 个 B 资源、 5 个 C 资源、 6 个 D 资源； 已分配资源表：P1 已经拥有 0 个 A 资源、 0 个 B 资源、 1 个 C 资源、 4 个 D 资源； 还需分配资源表：P1 还需要 0 个 A 资源、 6 个 B 资源、 4 个 C 资源、 2 个 D 资源； 经过与 可分配资源表 对比后，发现不能满足 P1 、P3 、P4 的需求，仅仅能满足 P2 的需求； 因此先满足 P2 ，执行完 P2 后 P2 归还资源； 此时 可分配资源表 又可以分配资源给 P1 、P3 、P4 ！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/操作系统篇/内存管理篇.html":{"url":"计算机基础/操作系统篇/内存管理篇.html","title":"内存管理篇","keywords":"","body":"内存管理篇 1、内存分配与回收 早期的计算机编程并不需要过多的存储管理；随着计算机和程序越来越复杂，存储管理变为一件必要的事情！ 确保计算机有足够的内存来处理数据； 确保程序可以从可用内存中获取一部分内存使用； 确保程序可以归还使用后的内存以供其他程序使用！ 1.1、内存分配的过程 单一连续分配： 最简单的内存分配方式； 只能在单用户、单进程的操作系统中使用； 将主存分为系统区、用户区； 系统区指的是内存给操作系统所使用； 用户区指的是所有的用户区内存都给用户区程序所使用； 固定分区分配： 支持多道程序的内存分配方式； 将内存空间划分为若干个固定大小的区域； 每个分区只提供给一个程序使用，互不干扰； 动态分区分配： 根据进程实际需要、动态分配内存空间； 涉及到相关数据结构（如动态分区空闲表数据结构、动态分区空闲链数据结构等）、分配算法； 假设主存中有若个分区，并且一些分区已经使用、一些分区还没有使用；这时候就需要一个数据结构来标记某个分区是否已使用！ 动态分区分配算法： 首次适应算法（FF 算法）： 最佳适应算法（BF 算法）；将空闲区链表按照容量大小进行排序；在每一次需要分配时遍历链表找到最佳合适空闲区； 快速使用算法（QF 算法）；要求有多种空闲区链表；每种链表存储一种容量的空闲区； 1.2、内存回收的过程 内存回收过程分为四种情况： 情况1：需要回收的区域和空闲区连接在一起，并且位于空闲区后面； 回收1：不需要新建空闲链表节点；只需要把空闲区 1 的容量增大为包括回收区的空闲区即可； 情况2：需要回收的区域和空闲区连接在一起，并且位于空闲区前面； 回收2：将回收区和空闲区合并为一个新的节点，然后使用回收区的地址作为新的节点地址； 情况3：需要回收的区域和空闲区连接在一起，并且位于空闲区中间； 回收3：将空闲区1、回收区、空闲区2 合并为一个新的节点，然后使用空闲区1的地址作为新的节点地址； 情况4： 需要回收的区域和空闲区没有连接在一起，单一的回收区； 回收4：为回收区创建新的节点，然后将新的节点插入到相应的空闲区链表中即可； 2、段页式存储管理 操作系统使用 段页式存储 管理进程的内存空间！ 段是指连续不等长的一块内存，页是指连续等长的一块内存；段页式存储管理是将用户程序分成若干个段，再把每个段分成若干个页的内存管理方式。 2.1、页式存储管理 前文提到的 字与字块 是相对于物理设备的定义，而此处的 页面 则是相对于逻辑空间的定义！ 将进程逻辑空间 等分 为若干个大小的页面； 相应的把物理内存空间分成与页面大小一样的物理块； 以页面为单位把进程空间加载到物理内存中分散的物理块上； 页面大小应该适中，过大难以分配，过小则内存碎片过多； 页面大小通常是 512B ～ 8 K ； 通过页式存储管理，可以把进程的逻辑空间的每个页面加载到内存中去！但是又如何知道进程的某个页面具体被分配到哪一个字块中去呢？这时候就需要了解 页表 的概念！ 页表 ： 页表是一个记录进程逻辑空间与物理空间的映射表； 在页式存储管理中，地址 分为 页号 与 页内偏移； 在现代计算机系统中，可以支持非常大的逻辑地址空间（2^32 ~ 2^64）；而这将导致页表变得越来越大，会占用非常大的内存空间。如具有 32 位逻辑地址空间的分页系统，规定页面大小为 4 KB ，则在每个进程页表中的页表项可达 1 M (2^20) 个，如果每个页表项占用 1 Byte，则每个进程仅仅页表就要占用 1 MB 的内存空间！ 32 位系统进程的寻址空间位 2^32 = 4 G 4 G / 4KB = 2^20 使用多级页表来解决页表内存占用高的问题！ 首先，多级页表有一个根页表； 根页表的每个字块都指向内存的一片地址空间，这块地址空间存储一个二级页表； 假设每个二级页表有 1024 项，每一项指向的字块才是进程实际使用的内存； 一个根页表可以指向二级页表，这样子大大的减少的进程的页表所占用的内存空间； 在运行时，只需要把根页表加载到内存中即可；如果调用某个字块，发现二级页表不在内存空间；此时只需要把二级页表加载到内存中，做到 按需加载，节省内存空间 ； 页式存储管理仍然有一个问题：假如有一段连续逻辑分布在多个页面中，将大大降低执行效率！此时提出了段式存储管理！ 2.2、段式存储管理 将进程逻辑空间 非等分地 划分为若干段； 段的长度由进程的连续逻辑长度决定； 如进程的逻辑有 主函数 MAIN 、子程序段 X、子函数 Y 等，此时按照每个函数的逻辑长度分配逻辑空间； 段表：段式存储管理也需要一个表来保存逻辑空间到物理空间的映射关系； 不管是段式存储管理、或者页式存储管理，都离散地管理了进程的逻辑空间；不同之处在于： 页是物理单位（从物理的角度划分），段是逻辑单位（从进程的逻辑划分）； 分页是为了合理的利用空间；分段是为了满足用户需求； 页大小由硬件确定；段长可动态变化； 页表信息是一维的，段表信息是二维的；段表中每一段的长度不同，因此需要把段的基址和长度都记录起来，所以段表信息是二维的！ 2.3、段页式存储管理 段页式存储管理: 将用户程序分成若干个段，再把每个段分成若干个页 ! 分页可以有效提高内存利用率（虽然存在页内碎片），而分段可以更好的满足用户需求（因为逻辑是用户写的）；将两者结合，形成了段页式存储管理！ 先将逻辑空间按段式管理分成若干段； 再把段内空间按页式管理分成若干页； 页地址分为页号和页内偏移； 段地址分为段号和段内偏移； 段页地址：段号、段内页号、页内地址 段号 段内页号 页内地址 指定进程逻辑空间的具体哪一段 段里面具体的某一页 某一页的具体哪个字 3、虚拟内存 思考 ： 一个 Xcode 十几个 G，物理内存只有 8G ，那么这个程序是如何运行起来的呢？ 3.1、虚拟内存概述 为什么要使用虚拟内存？ 有些进程实际需要的内存很大，远超主存的容量； 基于多道程序设计，主存中可以运行多个进程，使得每个进程可用内存资源更加稀缺； 不可能无限增加主存，主存总有不够用的时候； 虚拟内存是操作系统内存管理的关键技术，使得多道程序运行和大程序运行成为现实。它的工作原理为： 虚拟内存技术使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）； 而实际上，虚拟内存技术把应用程序所使用的内存进行划分，分隔成多个物理内存碎片； 将部分暂时不使用的内存放到辅存中去；在需要时进行数据交换。 3.2、程序的局部性原理 局部性原理指 CPU 在访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中！ 局部性原理是虚拟内存技术可以实现的一个原因： 程序运行时，无需全部载入内存，加载部分即可； 如果程序在运行的时候，发现访问页不在内存中，则发出缺页中断，发起页面置换，将保存在辅存中的页面置换到内存中；置换之后，程序可以继续运行下去； 从用户层面看，程序拥有很大的空间，即是虚拟内存； 虚拟内存实质上是对物理内存的一个扩充，使得它的速度接近于内存，成本接近于辅存！ 3.3、虚拟内存的置换算法 先进先出算法（FIFO） 最不经常使用算法（LFU） 最近最少使用算法（LRU） 替换策略发生在 Cache-主存 层次、主存-辅存 层次； Cache-主存 层次的替换策略主要是为了解决 CPU 速度远远快于主存的问题； 主存-辅存 层次主要是为了解决主存容量不足的问题； 4、Linux 的存储管理 4.1、Buddy 内存管理算法 Buddy 指的是两片内存连续、大小一样的内存片段 Buddy 算法是经典的内存管理算法； 算法基于计算机处理二进制的优势具有极高的效率； 设计了伙伴系统，可以快速的合并回收区与空闲区； 算法主要是为了解决内存外碎片的问题；其实质是将内存外碎片问题转移为内存内碎片问题； 极大的提升了内存利用效率，因为 内存外碎片 会比 内存内碎片 要大； 页内碎片与页外碎片 页内碎片：已经被分配出去（能明确指出属于哪个进程）的内存空间大于进程请求 所需的内存空间，剩下的不能再被利用的内存空间就是内部碎片！ 页外碎片：还没有被分配出去（不属于任何进程），但由于太小而无法分配给申请内存空间的新进程的内存空闲块！ 基于计算机处理二进制的优势具有极高效率，Buddy 内存管理算法的目的是 努力的让内存分配与相邻内存合并能快速进行 ! Buddy 算法内存分配原则：内存分配时默认每一块内存都向上取整为 2 的幂次方 ； /// 如一个进程需要申请 70k 的内存，Buddy 算法会向上取整到 128k 的内存 (2 的幂次方) 70k -> 128k /// 如一个进程需要申请 129k 的内存，Buddy 算法会向上取整到 256k 的内存 (2 的幂次方) 129k -> 256k 伙伴系统 伙伴指的是一片内存中的伙伴； 一片连续内存的伙伴是相邻的另一个大小一样的连续内存； Buddy内存管理算法具体流程 Buddy内存管理算法 创建一系列空闲块链表，每一种空闲块链表的大小 都是 2 的幂！ 假设存储空间有 1M 大小，对于 Buddy 算法而言 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点；需要使用 Buddy 算法分配 100KB 内存！那么如何分配呢？ 1、 100KB 按照向上取整为 2 的幂次方的原则为 128KB； 2、接着查询空闲块链表是否有 128 KB 的空闲内存块？查询结果没有； 3、再次查询空闲块链表是否有 256KB 的空闲内存块？查询结果没有； 4、再次查询空闲块链表是否有 512KB 的空闲内存块？查询结果没有； 5、再次查询空闲块链表是否有 1MB 的空闲内存块？查到一个 1MB 的节点； 6、从空闲链表取下 1MB 的节点，将链表节点置为 NULL；判断 1MB 的空闲内存是否满足最小需求，发现没有满足； 7、接着将 1MB 内存拆为两个 512KB 的内存 ，一个 512KB 用于存放数据； 另一个多余的 512KB 的内存放在 512KB 的空闲链表上，此时512KB 的空闲链表有一个节点； 同时会判断 512KB 的空闲内存是否满足最小需求，发现没有满足； 8、接着将 512KB 内存拆为两个 256KB的内存，一个 256KB用于存放数据； 另一个多余的 256KB的内存放在 256KB 的空闲链表上，此时256KB 的空闲链表有一个节点； 同时会判断 256KB 的空闲内存是否满足最小需求，发现没有满足； 9、接着将 256KB 内存拆为两个 128KB的内存，一个 128KB用于存放数据； 另一个多余的 128KB 的内存放在 128KB 的空闲链表上，此时128KB 的空闲链表有一个节点； 同时会判断 128KB 的空闲内存是否满足最小需求，发现已经满足； 10、至此，内存分配结束； 11、128KB、 256KB、 512KB 的空闲链表上各增加一个节点；1MB 的空闲链表少一个节点； 注意 ：进程需要 100KB 的内存，而 Buddy 算法为其分配 128KB 的内存，那么多出的 28KB 不被利用，属于 页内碎片！ Buddy内存管理算法回收流程 1、判断刚才分配的内存伙伴是否在空闲链表上； 2、在！移除伙伴，与需要回收的内存一起合并为 256KB 空闲内存；判断 256KB内存的伙伴是否在空闲链表上； 3、在！移除伙伴，与需要回收的内存一起合并为 512KB 空闲内存；判断 512KB 内存的伙伴是否在空闲链表上； 4、在！移除伙伴，与需要回收的内存一起合并为 1MB 空闲内存；判断 1MB 内存的伙伴是否在空闲链表上； 5、不在！将 1MB 的空闲内存插入到 1MB 空闲链表，至此回收完成。 6、此时 1KB、2KB、4KB... 512KB 的链表节点都是 NULL，只有 1MB 的空闲链表有一个节点。 4.2、Linux 交换空间 什么是 Linux 交换空间？ Linux 交换空间 Swap 实质是磁盘的一个分区； 当 Linux 主存被占满的时候，会把一部分数据交换至 Swap 空间，使得 Linux 主存有更多的空间去运行； 可以在系统初始化的时候配置 Swap 空间：安装系统时，会提示是否需要 Swap空间 、需要多大的 Swap 空间！ 交换空间 Swap 的作用： 冷启动的内存依赖：对于一些大型应用程序，在启动的时候需要使用大量内存空间，但很多数据仅仅只在启动时加载一次，后续运行时很少使用这些数据；有了交换空间，系统可以将这些使用次数很少的内存数据保存在 Swap 空间，从而释放更多的物理内存提供给系统使用！ 系统睡眠依赖：当 Linux 系统需要睡眠时，会将系统中所有需要保存的数据交换到 Swap 空间中；等下次唤醒系统时，将这些数据从 Swap 空间 加载至主存；这样可以加快系统的启动速度； 大进程空间依赖：某些进程确实需要使用很多的内存空间，但主存空间不够；此时需要把进程使用的内存数据暂时保存在 Swap 中，使得大的进程能够运行起来； 备注：虽然交换空间 Swap 可以将 Linux 的主存数据交换至辅存上，但不推荐使用 Swap 技术！因为 Swap 空间实质属于辅存，读写速度相对于 主存要慢很多；如果频繁的使用 Swap 将数据从主存置换到辅存，就会使得 Linux 系统运行的非常慢；所以应该注意避免使用 Swap 技术。 对比 Swap 空间 虚拟内存 位置 存在于磁盘 存在于磁盘 置换 与主存发生置换 与主存发生置换 服务 是 Linux 操作系统的概念 属于进程的概念 目的 解决了系统物理内存不足的问题 解决进程物理内存不足的问题 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/操作系统篇/文件系统篇.html":{"url":"计算机基础/操作系统篇/文件系统篇.html","title":"文件系统篇","keywords":"","body":"文件系统篇 1、操作系统的文件管理 1.1、文件的逻辑结构 1.2、辅存的存储空间分配 1.2.1、辅存的分配方式 连续分配 如果一个文件的存储需要一系列的扇区；此时就会连续的将这些连续扇区分配给某个文件； 优点是读取文件内容非常容易、速度很快；只需要顺序地读取磁盘的扇区即可； 缺点是对存储要求比较高，存储文件时要有满足容量的连续存储空间； 隐式链接分配 隐式分配的 下一个链接指向 被存放在当前盘块内！假设某个文件需要使用下述五个盘块： 2 -> 9 -> 7 -> 18 -> 16 由于隐式链接存储在盘块中，在分配文件时： 盘块 2 中会有一块空间去记录下一个盘块的地址（9） 盘块 9 中会有一块空间去记录下一个盘块的地址（7） 盘块 7 中会有一块空间去记录下一个盘块的地址（18） 盘块18中会有一块空间去记录下一个盘块的地址（16） 随机访问的效率极其低下 ：不管访问哪一个盘块，都需要从第一个盘块开始： 隐式分配适合顺序访问，在顺序访问时只需要知道第一个盘块，即可顺序的查找其余盘块； 假如需要访问文件的第 18 盘块，由于只能从头部开始，先找到第 2 个盘块、第 9 个盘块、第 7 个盘块；最终找到第 18 盘块！ 可靠性差：任何一个链接出问题，都将影响到整个文件！ 基于 隐式链接分配 的缺点，提出了 显示链接分配 方式！ 显式链接分配 显式链接分配：下一个盘块的位置没有记录在上一个盘块中，而是使用一个 FAT 表来指定！(参考 FAT 文件系统) 缺点： 不支持直接高效的存储，因为 FAT 记录项非常多；磁盘越大，FAT 记录项越大； 如果在 FAT 文件系统存储一个非常大的数据，需要检索 FAT 表找到很多空闲的盘块号； 所以 FAT 文件系统不支持直接高效的存储； 检索时 FAT 表占用较大的存储空间，因为对某个文件读取时需要将整个 FAT 加载到内存，然后在内存中检索 FAT； 索引分配 把文件的所有盘块集中存储，存储盘块的位置称为索引； 当需要读取某个文件时，只需要将该文件的索引读取进内存即可； 上图中，索引分配使用一个额外的盘块 12 去记录该文件被分配到的所有盘块； 12 是该文件的索引，会指向 2 -> 9 -> 7 -> 18 -> 16； 索引分配很好的解决了 FAT 方式遇到的问题： 每个文件拥有一个索引块，记录被分配的盘块信息；在索引某个文件时，只需将索引块加载到内存即可，不需要将整个表加载到内存； 索引分配方式支持直接访问盘块；在索引块中可以直接找到文件对应的盘块； 文件较大时，索引分配方式具有明显优势； 主流的文件系统（如 Ext 文件系统） 都是使用索引分配来 进行磁盘分配； 1.2.2、辅存的存储空间管理 在辅存中，一般使用位示图、或者空闲表（少用）的数据结构来管理存储空间！ 1.3、目录管理 文件目录树使得任何一个文件或文件夹都有唯一的路径 2、Linux 文件基本操作 在 Linux 系统下，一切都是文件，进程也是一个文件！ 2.1、Linux 目录 /// 进入根目录 MacBook $ cd / /// 查看文件列表 MacBook:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var 目录 描述 /bin 存放二进制可执行文件 (ls、cat、mkdir等)，常用命令一般都在这里 /etc 存放系统管理与配置文件 /home 存放所有用户文件的根目录，是用户目录的基点；如用户 user 的主目录就是 /home/user /usr 存放系统应用程序，如常见的 usr/local （本地系统管理员软件安装目录） /dev 用于存放设备文件，如终端、键盘输入等 /opt 额外安装的可选应用程序包所放置的位置 /var 用于存放运行时需要改变数据的文件 /sbin 存放二进制可执行文件，只有 /root 才能访问 /root 超级用户（系统管理员）的主目录 /proc 虚拟文件系统目录，是系统内存的映射！可直接访问这个目录来获取系统信息； /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其它的文件系统 /boot 存放用于系统引导时所使用的各种文件 /lib 存放和文件系统中的程序运行所需要的共享库及内核模块 每一个文件或者文件夹，从根目录开始，都有一个唯一的路径来指向； 绝对路径：从根目录开始的路径； 相对路径：相对于当前的操作目录，它的文件位于哪一个目录；相对路径不固定，随着操作文件的路径变化而变化！ 文件描述信息包含 文件标识符、文件类型、文件权限、文件长度、文件状态、索引节点 等信息。 2.2、Linux 文件常用操作 目录/文件的创建、删除、读取、写入 /// touch 创建一个文件 MacBook-Pro:Desktop $ touch 1.txt /// 使用 vim 创建、编辑、查看一个文件 MacBook-Pro:Desktop $ vim 2.txt /// 查看一个文件的内容 MacBook-Pro:Desktop $ cat 2.txt Hello Word! /// 删除一个文件 MacBook-Pro:Desktop $ rm 1.txt /// mkdir 创建一个文件夹 MacBook-Pro:Desktop $ mkdir 1 /// 删除一个文件夹 MacBook-Pro:Desktop $ rm 1 rm: 1: is a directory (1 是一个文件夹，不能删除) /// 使用参数 -r 表示递归的删除文件夹中的数据 MacBook-Pro:Desktop $ rm -r 1 2.3、Linux 文件类型 Linux 文件有 套接字文件、普通文件、目录文件、符号链接文件、设备文件、FIFO 文件等多种文件类型。 - 开头表示文件 d 开头表示文件夹 c 开头表示字符设备文件 b 开头表示块符设备文件 l 开头表示链接文件 /// 分别创建一个文件、一个文件夹 MacBook-Pro:Desktop $ touch 1.txt MacBook-Pro:Desktop $ mkdir 2 /// 使用 ls -al 查看文件的一些信息 MacBook-Pro:Desktop $ ls -al total 24 -rw-r--r--@ 1 i7y staff 6148 8 16 09:59 .DS_Store -rw-r--r-- 1 i7y staff 0 7 23 13:56 .localized -rw-r--r-- 1 i7y staff 0 8 16 09:58 1.txt drwxr-xr-x 2 i7y staff 64 8 16 09:59 2 /// -rw-r--r-- : 一个文件 /// drwxr-xr-x : 一个文件夹 MacBook-Pro:Desktop $ cd / MacBook-Pro:/ $ ls Applications Volumes etc sbin Library bin home tmp System cores opt usr Users dev private var MacBook-Pro:/ $ cd dev MacBook-Pro:dev $ ls -al total 9 dr-xr-xr-x 3 root wheel 4384 8 16 09:04 . drwxr-xr-x 20 root wheel 640 1 1 2020 .. crw-r--r-- 1 root wheel 10, 3 8 16 09:04 auditsessions crw------- 1 root wheel 31, 0 8 16 09:05 autofs brw-r----- 1 root operator 1, 6 8 16 09:04 disk1s4 lr-xr-xr-x 1 root wheel 0 8 16 09:04 stdout -> fd/1 /// crw : 一个字符设备文件 /// brw : 一个块符设备文件 /// lr : 链接文件 3、Linux 的文件系统 常见的文件系统有 FAT、 NTFS 、 EXT2/3/4 ！ FAT 全称 File Allocation Table ，FAT 16 与 FAT 32 是早期微软的 Dos/Windows 使用的文件系统； 主要使用一张表来保存盘块的信息（链接分配方式）！ NTFS 全称 New Technology File System ，是当今 Windows 系统常用的文件系统；NTFS 对 FAT 进行了改进，取代了旧的文件系统！ EXT ( Extended File System) 可扩展文件系统；主要用于 Linux 的文件系统，不支持 Windows 系统； 一个 EXT 格式 U 盘不能被 Windows 系统读取数据；因此 U 盘多格式化为 NTFS 格式！ 3.1、Ext 文件系统 Ext 文件系统使用索引分配方式分配辅存空间！可以将 Ext 文件系统看做是由一个 Boot Sector 和若干个 Block Group 组成： Boot Sector 启动扇区，安装开机管理程序 Block Group 块组，存储数据的实际位置；有多个块组 每个块组 Block Group 都由以下一些信息组成： Inode bitmap : Inode 的位示图，记录已分配和未分配的Inode；当一个文件系统初始化的时候， Inode 的输入已经固定，此时可以使用位示图来记录； Inode table : 存放 Inode 的地方，每一个文件(目录)都有一个 索引节点 Inode ；Ext 文件系统管理外存的方式为索引分配的方式！ Date Block : 存放文件内容的地方；每个Block都有一个唯一的编号，每一个文件的 Block 记录在文件的 Inode 上； Block bitmap : Block 的位示图；功能与 Inode bitmap 类似，记录 Date Block 的使用情况；当需要对一个文件进行外存分配时，通过查询 Block bitmap 来分配相应的 Date Block ！ SuperBlock：记录整个文件系统相关信息（Block 、 Inode 使用情况，时间信息，控制信息等等）的地方；时间信息包括文件系统所挂载的时间、最后一次写入、最后一次读取、最后一次校验的时间！一般是 1024 个字节的大小！ 每个文件或者文件夹都有一个 Inode，Inode 可以理解为是文件或文件夹的 身份证，存储着关键信息：如文件类型(目录文件、普通文件、套接字文件等)、文件权限、文件物理地址、文件长度、文件连接计数、文件存取时间（如最新修改文件的时间、创建文件的时间等）、索引的节点编号（每个文件的唯一标识符）、文件状态、访问计数（当前哪几个进程访问了该文件）、链接指针等等； 文件名不是存放在 Inode 节点上的，而是存放在目录的 Inode 节点； 列出目录文件时，无需家在文件的 Inode；列出目录文件的操作非常频繁，如果每次列出目录文件，都去加载所有文件的 Inode，将会耗时！ /// 查看 EXT 文件系统 MacBook-Pro $ df -t Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1s5s1 976490576 29943648 596646728 5% 553781 4881899099 0% / devfs 379 379 0 100% 656 0 100% /dev /dev/disk1s4 976490576 2097192 596646728 1% 3 4882452877 0% /System/Volumes/VM /dev/disk1s2 976490576 553472 596646728 1% 832 4882452048 0% /System/Volumes/Preboot /dev/disk1s6 976490576 840 596646728 1% 18 4882452862 0% /System/Volumes/Update /dev/disk1s1 976490576 345715896 596646728 37% 1923831 4880529049 0% /System/Volumes/Data map auto_home 0 0 0 100% 0 0 100% /System/Volumes/Data/home MacBook-Pro $ dumpe2fs /dev/disk1s4 -bash: dumpe2fs: command not found 4、操作系统的设备管理 4.1、广义的 IO 设备 对于计算机，输入输出设备有键盘、鼠标、触摸板等！ 对 CPU 而言，凡是对 CPU 进行数据输入的都是输入设备；凡是对 CPU 进行数据输出的都是输出设备！ 可以按照 使用特性 、 信息交换的单位 、 设备的共享属性 、 传输速率 等多个角度对广义的 IO 设备进行分类！ 4.2、IO 设备的缓冲区 针对 CPU 与 IO 设备的传输速率不匹配的问题，前文提出了使用 缓存-主存、主存-辅存的存储层次来解决；除此之外，还可以使用 IO 设备的缓冲区来解决！ 通过 IO 设备的缓冲区，可以减少 CPU 处理 IO 请求的频率，提高 CPU 与 IO 设备之间的并行性！ 专用缓冲区只适用于特定的 IO 进程，当这样的 IO 进程比较多时，对内存的消耗会很大；因此，操作系统划出了可供多个进程使用的公共缓冲区，称为缓冲池！ 进程与 IO 设备的交互，使用的不是进程专用的缓冲区，而是从缓冲池中取出一个缓冲区； 缓冲池中存在多个缓冲区，进程需要使用时从缓冲池取出某一个缓冲区使用，使用完之后再将缓冲区归还给缓冲池； 达到多个进程共同使用缓冲区、减小内存消耗的目的！ 4.3、SPOOLing 技术 SPOOLing 技术是一种关于慢速字符设备如何与计算机主机交换信息的一种技术；可以使用该技术解决 CPU 与 IO 设备的传输速率不匹配的问题！ 工作原理： SPOOLing 技术是一种虚拟设备技术，将一台低速的物理设备虚拟为高速独享设备； 使用该技术，操作系统在逻辑上为每一个进程都分配了一台独立的高速独享设备； 假设三个进程都需要使用打印机，由于打印机是一种读写速度很慢的设备: 多个进程都需要使用打印机，将会等待很久； 使用 SPOOLing 技术，不会直接将打印机分配给某个进程，而在共享设备（如共享磁盘）进行输出； SPOOLing 技术会在 共享磁盘 分配一个存储空间，进程的输出数据会以文件的形式保存在 SPOOLing 的存储空间上； 这些进程的数据输入输出会形成一个输出队列，然后由 SPOOLing 去控制打印机的进程、将输出队列中的文件依次打印出来！ SPOOLing 系统并没有将打印机设备分配给任何一个进程，而是在输入输出的存储空间为进程分为一个存储区，并建立一张 IO 表，将逻辑设备虚拟为共享设备！ 共享磁盘所用到的空间称为 输出井！ SPOOLing 技术将同步调用低速设备改为异步调用：如进程实际调用的不是打印机，而是将输出数据写入 输出井，再由 SPOOLing 技术将这些文件送到打印机打印，这样可以大大提升进程的工作效率！ SPOOLing 技术总结： 在输入、输出之间增加了排队转储环节（输入井、输出井） SPOOLing 技术负责输入井（输出井）与低速设备之间的调度； 在逻辑上，进程直接与高速设备交互，而不是与实际的物理设备交互，因此减少了进程的等待时间，提高了进程的工作效率； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/操作系统篇/操作系统提升篇.html":{"url":"计算机基础/操作系统篇/操作系统提升篇.html","title":"操作系统提升篇","keywords":"","body":"1、线程同步 1.1、线程同步之互斥量 有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 互斥量可以保证一个线程在操作临界资源的时候，阻止其它线程来访问该临界资源！ 上图引起线程同步问题的最根本原因是两个线程的指令交叉执行： 如先执行线程 1 的两个指令，接着 CPU 被抢夺走去执行线程 2 的三条指令； 最后又回到线程 1 去执行线程 1 的第三条指令； 线程1 与线程 2 的指令交叉执行，引发了线程同步的问题； 互斥量如何解决上述问题呢？互斥量可以保证两个线程的关键指令不会被交叉执行，而是以先后顺序来执行； 互斥量本质上保证了线程操作的 原子性！原子性是指一组操作不可被中断的特性；这一组操作要么全部执行完成，要么全部没有执行；不存在部分执行、部分未执行的情况！ 互斥量（也称为互斥锁）是最简单的线程同步的方法；互斥量是处于 解锁、加锁 两个状态之一的变量；两个状态保证资源访问的串行！一个资源被加了互斥锁，代表该资源正在被某个线程所使用；那么其它线程想要使用该资源，只能等待正在使用的线程解锁、释放掉该资源，这就形成了资源访问的串行！ 操作系统直接提供了互斥量的 API，开发者可以直接使用 API 完成资源的加锁、解锁操作！ /// API pthread_mutex_t pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥量 int num = 0; /// 临界资源 void *producer(void*) { /// 生产者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num += 1; /// 每循环一次，生产一件产品 pthread_mutex_unlock(&mutex); } } void *comsumer(void*){ /// 消费者 int times = 100000000; while(times--){ pthread_mutex_lock(&mutex); num -= 1; /// 每循环一次，消费一件产品 pthread_mutex_unlock(&mutex); } } int main(){ /// 执行函数 pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); /// 创建生产者线程 pthread_create(&thread2, NULL, &comsumer, NULL); /// 创建消费者线程 pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.2、线程同步之自旋锁 上图有两个线程分别充当生产者与消费者的角色，这两个线程可能会同时操作临界资源，从而引起线程同步的问题！ 在一个线程使用临界资源前，先加一个自旋锁，阻止其它线程来访问临界资源；当使用完临界资源后解锁，保证临界资源的串行访问！ 自旋锁的原理和互斥锁是一样的，那么自旋锁和互斥锁有什么不一样嘛？ 自旋锁也是一种线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用；如果不可用，自旋锁会一直循环反复的检查直到可用为止；自旋锁不会让出 CPU ，是一种忙等待的过程；自旋锁实质上就是一个死循环等待锁被释放！ 自旋锁的好处： 自旋锁避免了进程或者线程上下文切换的开销； 如果使用自旋锁占用的时间不是很长，那么使用自旋锁的代价很小； 操作系统内部很多地方使用的都是自旋锁； 自旋锁不适合在单核 CPU 使用（因为自旋锁在等待的过程中不会释放 CPU，而是死循环的等待；在单核 CPU 使用自旋锁，会导致其它的进程或者线程无法执行） /// API : pthread_spinlock_t #include #include #include #include #include pthread_spinlock_t spin_lock; /// 自旋锁 int num = 0; /// 临界资源 void *producer(void*){ /// 生产者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num += 1; pthread_spin_unlock(&spin_lock); } } void *comsumer(void*){ /// 消费者 int times = 10000000; while(times --){ pthread_spin_lock(&spin_lock); num -= 1; sleep(10); pthread_spin_unlock(&spin_lock); } } int main() { pthread_spin_init(&spin_lock, 0); pthread_t thread1, thread2; pthread_create(&thread1, NULL, &producer, NULL); pthread_create(&thread2, NULL, &comsumer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.3、线程同步之读写锁 读写锁在互斥锁、自旋锁的基础上做了改进，主要是从临界资源的多读少些的方面考虑！ 读写锁是一种特殊的自旋锁，允许多个读者同时访问资源以提高读性能；对于写操作则是互斥的！ 读写锁在多读少些的场景下，对性能的优化是很明显的！ #include #include #include #include #include int num = 0; /// 临界资源 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; ///读写锁 void* reader(void*) { int times = 10000000; while(times --){ pthread_rwlock_rdlock(&rwlock); /// 添加读锁 /// 读取临界资源 printf(\"print num in reader: num = %d\\n\", num); pthread_rwlock_unlock(&rwlock); /// 释放读锁 } } void *writer(void*){ int times = 10000000; while(times --){ pthread_rwlock_wrlock(&rwlock); /// 添加写锁 num += 1; /// 临界资源的改变 pthread_rwlock_unlock(&rwlock); /// 释放写锁 } } int main(){ pthread_t thread1, thread2, thread3; /// 两个读线程、一个写线程 pthread_create(&thread1, NULL, &reader, NULL); pthread_create(&thread2, NULL, &reader, NULL); pthread_create(&thread3, NULL, &writer, NULL); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_join(thread3, NULL); printf(\"Print in main function: num = %d\\n\", num); return 0; } 1.4、线程同步之条件变量 条件变量是一种相对复杂的线程同步方法，不满足条件时允许线程休眠；当满足条件时，可以向该线程发送信号唤醒线程！ 在上图 生产者-消费者模型 中有两个不严谨的问题： 缓冲区小于等于 0 时，不允许消费者消费，消费者必须等待； 缓冲区满时，不允许生产者向缓冲区生产，生产者必须等待； 使用条件变量实现唤醒操作： 缓冲区等于 0 时：当生产者生产一个产品时，唤醒可能等待的消费者； 缓冲区满时：当消费者消费一个产品时，唤醒可能等待的生产者； 条件变量的工作过程： 对于条件变量，首先需要加锁保护条件变量或临界资源； 接着判断条件是否满足，如果不满足就等待（线程处于休眠状态），条件满足时被唤醒； 线程唤醒后，就可以对临界资源操作； 操作完成后解锁； #include #include #include #include #include #include #include int MAX_BUF = 100; /// 缓冲区最大数 int num = 0; /// 临界资源 /// 条件变量配合互斥量来使用 pthread_cond_t cond = PTHREAD_COND_INITIALIZER; ///条件变量 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; /// 互斥锁 void* producer(void*) { /// 生产者 while(true){ pthread_mutex_lock(&mutex); while (num >= MAX_BUF) { // 等待 printf(\"缓冲区满了, 等待消费者消费...\\n\"); pthread_cond_wait(&cond, &mutex); ///等待条件满足 } num += 1; printf(\"生产一个产品，当前产品数量为：%d\\n\", num); sleep(1); pthread_cond_signal(&cond); /// 唤醒 printf(\"通知消费者...\\n\"); pthread_mutex_unlock(&mutex); sleep(1); } } void* consumer(void*){ while(true){ pthread_mutex_lock(&mutex); while (num 1.5、线程同步方法总结 互斥锁、自旋锁、读写锁 对于临界资源的操作都是一样的： 首先为临界资源加锁；解锁成功后操作临界资源；操作完成后解锁； 加锁成功后其它线程不能访问临界资源；解锁后其它线程才可以访问临界资源； 发现需要访问的临界资源被加锁，就需要等待临界资源被解锁； 同步方法 描述 互斥锁 最简单的一种线程同步方法，会 堵塞线程 (让出 CPU) 自旋锁 避免切换的一种线程同步方法，属于忙等待 (不让出 CPU) 读写锁 为 读多写少 的资源设计的线程同步方法，可以显著提高性能 条件变量 相对复杂的一种线程同步方法，有更灵活的使用场景 2、进程同步 进程是计算机系统分配资源的最小单位（严格说来是线程）； 每个进程都有自己的一部分独立的系统资源，彼此是隔离的； 为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。 通常，使用进程间通信的两个应用可以被分为客户端和服务器（见主从式架构），客户端进程请求数据，服务端响应客户端的数据请求。 有一些应用本身既是服务器又是客户端，这在分布式计算中，时常可以见到。 这些进程可以运行在同一计算机上或网络连接的不同计算机上。 进程间通信又称为 IPC，有：高级管道通信、有名管道通信、匿名管道通信、消息队列通信、信号量通信、信号通信、共享内存通信、套接字通信等！ 2.1、使用系统函数 fork() 创建进程 调用系统函数 fork() 创建进程： 进程有进程空间，包括内存以及一些内核态的东西；新创建进程的进程空间数据与父进程一摸一样！包括拥有的变量、逻辑空间等； fork() 创建的进程初始化状态与父进程一样； 系统会为 fork() 的进程分配新的资源，如内存资源、CPU资源等； fork() 调用没有参数； 调用一次 fork() 函数会有 两次 返回，分别返回子进程 id 和 0； 返回子进程id 的是父进程，返回 0 的是子进程； 为什么 fork() 函数会有 两次 返回？ 当调用 fork() 创建子进程的时候，子进程的初始化状态与父进程是一模一样的；父进程调用 fork() 创建完子进程的时候，子进程也拥有 fork() 函数的逻辑，因此 fork() 函数会返回两次！第一次由父进程返回被创建的子进程 id、第二次由子进程返回 0！ #include #include #include #include using namespace std; int main() { pid_t pid; int num = 888; pid = fork(); if(pid == 0) { cout 0){ cout 2.2、进程同步之共享内存 每一个进程都有一条或者多条线程，进程中的多条线程共享该进程资源； 线程之间需要通信、需要同步进程的一些资源状态，这就需要线程之间的信息同步； 一个操作系统中有一个或者多个进程，进程之间共享进算计资源，包括内存、磁盘等； 进程之间需要通信，如前文的生产者与消费者模型、哲学家进餐问题，这就需要进程之间的信息同步； 操作系统对进程内存的管理： 每一个进程都有自己的进程空间； 进程空间通过页表、段页式存储管理与实际的物理内存建立映射关系； 进程之间的进程空间是独立的、互不干扰的； 因此在某种程度上，多进程是共同使用物理内存的； 由于操作系统的进程管理，进程间的内存空间是独立的； 进程默认不能访问进程之外的内存空间，确保进程独立运行的安全性； 进程同步之共享内存： 共享存储允许不相关的进程访问同一片物理内存； 实现原理：将相同的物理内存分别映射到不同进程页表中，使得不同的进程可以通过页表来访问同样的一片物理内存； 共享内存是两个进程之间共享和传递数据最快的方式；实际中后台的很多高性能服务都是通过共享内存的来实现进程间通信； 但是共享内存没有提供同步机制，需要借助其它机制管理访问，以避免并发访问所带来的问题； 共享内存使用的四个步骤： 1、当前进程向操作系统申请一块共享内存 2、将共享内存连接到当前进程空间：只有连接到进程空间，进程才可以通过页表来访问共享内存； 3、当前进程使用共享内存，通过读、写来传递一些信息； 4、将共享内存脱离当前进程空间并删除； 2.2.1、操作系统提供了有关共享内存的 API #include /** 向操作系统申请一块共享内存 * @return 函数返回共享内存 id * 如果等于 -1 ，则申请失败 */ int shmget(key_t, size_t, int); /** 连接共享内存到当前进程空间 * @param1 申请的共享内存 id */ void* shmat(int, const void *, int); /** 断开共享内存到当前进程空间的连接 */ int shmdt(const void *); /** 断开共享内存到当前进程空间的连接 */ int shmctl(int, int, struct shmid_ds *); 2.2.2、使用 API 操作共享内存 定义一个共享内存的数据结构 #define TEXT_LEN 2048 // 共享内存的数据结构 struct ShmEntry{ // 是否可以读取共享内存，用于进程间同步 bool can_read; // 共享内存信息 char msg[2048]; }; 创建进程1 #include \"common.hpp\" #include #include #include #include #include #include int main() { // 共享内存的结构体 struct ShmEntry *entry; // 1. 申请共享内存 int shmid = shmget((key_t)1111, sizeof(struct ShmEntry), 0666|IPC_CREAT); if (shmid == -1){ std::cout can_read = 0; /// 锁定共享内存 while (true){ if (entry->can_read == 1){ std::cout msg can_read = 0; }else{ std::cout 创建进程2 #include \"common.hpp\" #include #include #include #include #include #include int main() { struct ShmEntry *entry; // 1. 申请共享内存 int shmid = shmget((key_t)1111, sizeof(struct ShmEntry), 0666|IPC_CREAT); if (shmid == -1){ std::cout can_read = 0; char buffer[TEXT_LEN]; while (true){ if (entry->can_read == 0){ std::cout >> \"; fgets(buffer, TEXT_LEN, stdin); strncpy(entry->msg, buffer, TEXT_LEN); std::cout msg can_read = 1; } } shmdt(entry); // 3. 脱离进程空间 shmctl(shmid, IPC_RMID, 0); // 4. 删除共享内存 return 0; } 执行程序 打开一个终端窗口 MacBook-Pro:process1 $ make g++ client.cpp -o client -g -lpthread MacBook-Pro:process1 $ ls Makefile client client.cpp client.dSYM MacBook-Pro:process1 $ ./client Input message>>> hello word Send message: hello word 再打开一个终端窗口 MacBook-Pro:process2 $ make g++ server.cpp -o server -g -lpthread MacBook-Pro:process2 $ ls Makefile server server.cpp server.dSYM MacBook-Pro:process2 $ ./server Entry can not read. Sleep 1s. Entry can not read. Sleep 1s. Received message: hellow word 我们在进程 1 向共享内存发送了 hellow word， 可以看到进程 2 接收到 进程 1 的 hellow word ! 2.3、进程同步之 Unix 域套接字 域套接字是一种高级的进程间通信的方法； Unix 域套接字可以用于同一机器多个进程间通信，不能跨机器使用； 套接字 socket 原是网络通信中使用的术语； Unix 系统提供的域套接字提供了网络套接字类似的功能，如可靠性； 前文提到的进程间共享内存需要额外的同步机制，同步多个进程间的通信； Unix 域套接字不需要额外机制来保证多个进程间的通信问题； 服务端有四个步骤： 1、创建套接字； 2、绑定 bind 套接字 3、监听 listen 套接字：监听是否有请求进来、或者监听是否有连接进来； 4、处理和接收信息 客户端不需要监听： 1、创建套接字； 2、连接套接字 3、发送信息 套接字 socket 提供了一种可靠的信息传递方式，相比于共享内存，不需要维护多个进程并发访问的机制！ 2.3.1、有关 socket 的 API /** 创建域套接字 * @param1 套接字类别 * @param2 套接字信息格式 * @return 返回套接字 id； 若是 -1 则创建失败； */ int socket(int, int, int); /** 绑定域套接字 * @param1 套接字 id * @param2 域套接字的文件路径 * 使用域套接字的话，将会在文件系统中创建一个连接客户端与服务端的文件 * @param3 域套接字的文件大小限制 */ int bind(int, const struct sockaddr *, socklen_t); /** 监听套接字 * @param1 套接字 id * @param2 最大所能监听的进程个数 */ int listen(int, int); /** 连接套接字 * @param1 套接字 id * @param2 服务端地址 * @param3 服务端大小 */ int connect(int, const struct sockaddr *, socklen_t); /** */ int accept(int, struct sockaddr * __restrict, socklen_t * __restrict) /** 发送信息 * @param1 套接字 id * @param2 发送的数据内容 */ ssize_t send(int, const void *, size_t, int); /** 接收套接字 * @param1 套接字 id */ ssize_t recv(int, void *, size_t, int); 2.3.2、测试用例 创建服务端 #include #include #include #include #include #include #include #include #include #include /// 使用域套接字的话，将会在文件系统中创建一个连接客户端与服务端的文件 /// 定义域套接字的文件路径 #define SOCKET_PATH \"./domainsocket\" #define MSG_SIZE 2048 int main() { int socket_fd, accept_fd; int ret = 0; socklen_t addr_len; char msg[MSG_SIZE]; struct sockaddr_un server_addr; // 1. 创建域套接字 socket_fd = socket(PF_UNIX,SOCK_STREAM,0); if(-1 == socket_fd) { std::cout ret){ std::cout 创建客户端 #include #include #include #include #include #include #include #include #include #include #define SOCKET_PATH \"./domainsocket\" #define MSG_SIZE 2048 int main() { int socket_fd; int ret = 0; char msg[MSG_SIZE]; struct sockaddr_un server_addr; // 1. 创建域套接字 socket_fd = socket(PF_UNIX, SOCK_STREAM, 0); if(-1 == socket_fd){ std::cout >> \"; fgets(msg, MSG_SIZE, stdin); /// 获取键盘输入信息 ret = send(socket_fd, msg, MSG_SIZE, 0); // 3. 发送信息 } close(socket_fd); return 0; } 执行程序 打开一个服务端窗口 MacBook-Pro:socket $ make g++ client.cpp -o client -g -lpthread g++ server.cpp -o server -g -lpthread MacBook-Pro:socket $ ls Makefile client.cpp server server.dSYM client client.dSYM server.cpp MacBook-Pro:socket $ ./server Binding socket... Listening socket... Waiting for new requests. Received message from remote: 你好 再打开一个客户端窗口 MacBook-Pro:socket $ ls Makefile client.cpp domainsocket server.cpp client client.dSYM server server.dSYM MacBook-Pro:socket $ ./client Input message>>> 你好 Input message>>> 我们在客户端发送了 你好， 可以看到服务端接收到 你好 ! 3、线程池 3.1、什么是线程池？ 线程池是存放多个线程的容器； 当 CPU 需要调度时从线程池取出线程调度，线程执行后不会销毁； 而是将线程放回线程池重复利用； 3.2、为什么需要线程池？ 线程属于稀缺资源，不应该频繁创建和销毁； 线程也有上下文，在创建线程和销毁线程的时候，需要额外的资源去控制； 架构解耦：线程创建和业务处理解耦，更加优雅；不应该在处理业务需要使用线程的时候才创建线程； 线程池是使用线程的最佳实践 3、操作系统的用户态与内核态 4、理解上下文切换 5、进程、线程、协程 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/计算机网络/网络概述篇.html":{"url":"计算机基础/计算机网络/网络概述篇.html","title":"第三部分 网络篇","keywords":"","body":"计算机网络篇 计算机网络主要由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据；并且可以支持广泛和日益增长的应用！ 计算机网络不仅仅是软件概念，还包含了硬件设备（网卡、网线、路由器）； 计算机网络不仅仅是信息通信，还可以支持广泛的应用； 分类 作用范围 区域 广域网 WAN 几十到几千公里 跨省、跨国 城域网 MAN 5KM ～ 50 KM 城市间 局域网 LAN 1 KM 以内 地区内 1、计算机网络的发展简史 1.1、互联网的发展历史 第一阶段：单个网络ARPANET 简单、小型的单个网络 是1969 年美国国防部创建的一个微型网络； 初衷是为了将附近的计算机连接起来； 主要由计算机和交换机构成，计算机直接通过交换机完成信息交互； 后来计算机进入了众多的校园、科研机构，小型网络已经不能满足需求，计算机网络进入第二个阶段。 第二阶段：三级结构互联网 现代互联网的雏形； 主要由美国来使用该网络； 该阶段的网络可以将美国的大学、研究所、实验室连接起来； 随着计算机慢慢普及全球、计算机进入千家万户，计算机网络的发展进入第三个阶段。 第三阶段：多层次 ISP 互联网 ISP (Internet Service Provider) 网络服务提供商，如中国的电信、联通、移动等； 直到此阶段，全球的计算机才连接起来，形成一个巨大的网络！ 现代国际互联网的主要线路，通过海底电缆连接不同的区域。 1.2、中国互联网的发展历史 第一阶段：1980 年开始互联网实验，由铁道部主导； 第二阶段：到了 1989 年第一个公共网络建立运行，包括公安、银行、军队等也都建立了各自的专用网络； 第三阶段：1994 年接入国际互联网，实现国际信息互通； 随着互联网的发展，中国陆续建立了多个计算机网络进行国际信息交换，其中有五个规模最大的： 中国电信互联网 CHINANET、中国联通互联网 UNINET、中国移动互联网 CMNET、中国教育与科研计算机网路 CERNET 、中国科学技术网 CSTNET ！ 2、计算机网络的层次架构 2.1、层次架构设计的基本原则 数量众多的计算机通过互联网连接在一起，那么计算机网络需要解决什么问题？ 保证数据通路顺畅：如果网络中断，那么数据将不能通信； 识别目的计算机：在互联网中有数量众多的计算机，计算机 A 如何识别计算机 B ？计算机 B 又如何识别计算机 A？ 查询目的计算机状态：如果 A 与 B 需要通信，那么计算机 A 需要通过网络知道计算机 B 是否在线、能否接收数据； 判断数据是否错误：在网络传输中由于各种原因导致数据丢失、错误，需要保证数据不会出错；出错之后的补救策略； 计算机网络需要解决繁多而复杂的问题！基于此，计算机网络采用分层设计、分层实现不同功能、分层去解决不同问题，以此来保证计算机网络的正常运行！ 一个简单的应用例子： 网络应用数据：对于用户接触最多的顶层数据，如视频、文件、游戏等； 数据可靠通信：用户不关心，但网络需要保证的；数据错误、数据重复； 物理网络接入：是通过网线、还是光纤连接到别的计算机；比较底层，涉及到光电等物理特性； 网络层次设计的基本原则： 各层之间是相互独立的：某一层并不需要知道上一层或者下一层是如何实现的； 仅仅知道该层如何通过层级接口来提供服务； 也就是说，每一层仅实现一个相对独立的功能，并且层与层的耦合度是非常低的； 每一层要有足够的灵活性：计算机网络是不断发展的，在设计每一层的时候要有足够的灵活性，以应对未来的变化； 各层之间完全解耦：某一层的上一层变化或者下一层变化，并不会影响到该层的稳定性；各层功能易于实现且方便维护、结构独立！ 2.2、OSI 七层模型 由国际标准定义的 OSI 七层模型，每一层完成不同的工作，并且层与层之间相互独立、互不干扰： 应用层：提供接口和服务；用户在使用计算机时，直接接触的是应用层； 表示层：数据处理（如编码、解码、加密等）； 会话层：管理通信会话（建立、维护、重连）； 传输层：管理端到端的通信连接； 网络层：数据路由（决定数据在网络的路径）；数据从一台计算机传输到另一台计算机，路径如何由网络层决定！ 数据链路层：管理 相邻 节点之间的数据通信； 物理层：数据通信的光电物理特性； 网络层管理数据在整个网络的路径，而数据链路层仅仅管理相邻节点之间的数据通信！ OSI 在制定之初，欲成为全球计算机网络都遵循的标准，促进全球计算机使用该标准互联、交换数据；但是 OSI 在市场化过程中困难重重，因为 TCP/IP 在全球范围内成功运行；因此 OSI 仅仅在理论方面获得一些成果，但市场化时没有成功推进，最终没有成为广为使用的标准模型！ OSI 不被市场接受的主要原因： OSI 的专家缺乏实际经验；仅仅基于理论而设计，缺乏实际的开发环境经验； OSI 标准制定周期过长，使得按 OSI 标准生产的设备无法及时进入市场； OSI 模型设计的并不合理，一些功能在多层中重复出现； 计算机网络使用更多的还是 TCP/IP 四层模型！ 2.3、TCP/IP 四层模型 应用层：HTTP、HTTPS、FTP、SMTP、POP3、DNS、Telnet、TFTP、DHCP 等协议； 传输层：TCP协议、UDP 协议； 网络层：IP协议 、ICMP 协议； 网络接口层：Ethernet、PPP 等。 假设计算机 A 与计算机 B 通过一个路由器连接在一起： 计算机 A 首先通过 应用层 -> 传输层 -> 网络层 -> 网络接口层 与路由器通信； 计算机 A 的数据通过 网络接口层 -> 网络层 来到路由器； 路由器根据网络层的数据进行数据转发，转发到计算机 B； 到达计算机 B 后，通过 网络接口层 -> 网络层 -> 传输层 -> 应用层 与用户交互； 2.4、一些常见的设备 路由器：工作在计算机网络的物理层、数据链路层、网络层。 桥接器：区别于路由器，路由器允许多个网络之间的独立通信，但又保持区隔，而桥接器则是将两个独立的网络连接起来，就如同单一网络。如果所桥接的网络有一个以上的区段是无线网络，则该设备称为无线桥接器。 网卡：又称局域网接收器（LAN adapter），是一块支持计算机在互联网通讯的计算机硬件； 由于其拥有 MAC 地址，因此属于数据链路层；它使得计算机可以通过电缆或无线相互连接； 每一个网卡都拥有唯一的 MAC 地址，被写死在卡上的一块 ROM 中；没有任何两块被生产出来的网卡拥有同样的地址。 这是因为电气电子工程师协会 IEEE 负责为网络接口控制器销售商分配唯一的 MAC 地址。 交换机：一种多端口的网桥，在数据链路层使用 MAC 地址转发数据； 通过引入路由功能，一些交换机也可以在网络层转发数据，这种交换机一般被称为三层交换机或者多层交换机。 集线器：Ethernet hub 是指将多条光纤连接在同一段物理介质下的设备；集线器是运作在物理层，可以让其链接的设备工作在同一网段。集线器上有多个 I/O 端口，信号从任意一个端口进入后，会从其他端口发出。 3、现代互联网的网络拓扑 3.1、边缘部分与核心部分 我们可以将现代互联网的网络拓扑分为 边缘部分 与 核心部分！ 边缘部分指的是平时用户可以直接接触的部分，如家庭部分、企业部分、商场部分等！ 核心部分主要由地区 ISP、主干 ISP 、以及一些国际路由器组成！主干 ISP 相互连接，并通过国际路由器与其它地区、其它国家的主干 ISP 连接； 边缘部分之家庭 如家庭部分，由手机、电脑、平板、智能家电（扫地机器人）等终端机器组成； 这些终端机器通过有线或者无线，连接到家里的路由器；路由器与终端机器直接接触； 路由器与当地的网关连接；一个网关可以连接一个或者多个路由器； 网关连接到地区 ISP （网络服务提供商：如上海电信、北京联通等）； 边缘部分之企业 如边缘的企业部分 有数量众多的计算机等终端、路由器、内部网关； 内部网关之间互相连接，路由器在其中进行报文转发、连接中转等； 统一网关：收敛内部的众多网关，提供唯一一个对外出口，和地区 ISP 连接； 3.2、用户角度的互联网模式 从用户角度看待互联网，常见互联网模式有：客户服务器模式(C/S) 、对等连接模式(P2P)等。 客户服务端模式(C/S) 由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式； 该模式表现为在互联网寻求服务，如发邮件、查找资料等； 客户端是服务的请求方，服务端是服务的提供方；双方通过互联网连接起来； 互联网中有很多设备相互连接；而不论是客户、服务器，都不需要感知互联网的具体细节； 需要使用某个服务的时候，客户端直接发起服务；该服务通过路由来到服务端，服务端收到请求后就会响应，然后客户端获得应答。 对等连接模式(P2P) 多个终端通过边缘部分连接到网络的核心部分； 不区分客户端和服务端；只要终端运行 P2P 程序，双方就可以进行平等的、对等连接通信； 对等的连接方式，可以支持大量的对等用户；如视频的下载、文件的下载，P2P 使得下载速度更快； 4、计算机网络的性能指标 了解计算机网络的性能指标，可以有助于我们去评估、判断网络的质量、速度等！ 4.1、网络时延 计算机的时延，可以细分为四个部分： 发送时延：计算机发送网络数据时，在本地停留的时间； 传播时延：在光纤等介质传播的时间； 排队时延：数据包在网络设备中等待被处理的时间； 如某个数据由计算机发送到路由器，路由器收到数据后并非马上处理； 路由器可能处理很多数据包，新来的数据包需要排队等待路由器来处理； 路由器处理完该数据包之后，才会发送到下一个节点； 处理时延：数据包到达设备或者目的机器被处理所需要的时间；如果数据包到达的服务器性能不好， 那么该服务器可能需要反应一段时间才能处理数据包。 发送时延 = (数据长度 bit) / (发送速率 (bit/s)); * 数据长度由用户决定：如发送 1G 的视频；100M 的文件等； * 发送速率受限于计算机网卡，如千兆网卡、万兆网卡等； 网卡性能越好，发送速率越快； 传播时延 = 传播路径距离 / (传播速率 (bit/s)); * 传播路径距离：从一个地区到另一个地区，如上海到北京； 如上海到纽约，还需要经过海底电缆，传输距离就很长； * 传播速率受限于传输介质：可以使用铜线、光纤等介质； 计算机的总时延 = 发送时延 + 排队时延 + 传播时延 + 处理时延; 4.2、往返时间 RTT 往返时间 RTT (Route-Trip Time) 是评估网络质量的一项重要指标； RTT 表示的是数据报文在端到端通信中往返一次的时间； 如客户端对服务器的一条请求，请求报文从客户端到服务器、服务器再返回响应报文到客户端的时间！ 通常使用 ping 命令查看 RTT； MacBook-Pro $ ping 119.29.12.253 PING 119.29.12.253 (119.29.12.253): 56 data bytes 64 bytes from 119.29.12.253: icmp_seq=0 ttl=113 time=110.518 ms 64 bytes from 119.29.12.253: icmp_seq=1 ttl=113 time=158.723 ms 64 bytes from 119.29.12.253: icmp_seq=2 ttl=113 time=204.338 ms 64 bytes from 119.29.12.253: icmp_seq=3 ttl=113 time=447.768 ms 64 bytes from 119.29.12.253: icmp_seq=4 ttl=113 time=37.928 ms 64 bytes from 119.29.12.253: icmp_seq=5 ttl=113 time=40.197 ms Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/计算机物理层.html":{"url":"计算机基础/计算机网络/计算机物理层.html","title":"计算机物理层","keywords":"","body":"计算机物理层 物理层位于 OSI 模型的最底层，TCP/IP 模型的数据接口层！ 简单的说，网络的物理层面确保原始的数据可在各种物理媒介上传输。物理层规定：为传输数据，需要物理链路与设备的创建、维持、拆除，并具有机械的、电子的、功能的、规范的特性。 1、物理层的作用 物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流。 连接不同的物理设备： 如主干 ISP 通过 海底电缆 连接起来、路由器通过 网线 连接起来；海底电缆、网线均属于物理层； 传输比特流：0/1 的数字信号！ 不同的传输介质 双绞线 同轴电缆 光纤 比特流 比特流就是由 0/1 组成的数字信号，表现为高低电平。 物理特性 我们往往关注物理层的一些物理特性，如机械特性、电气特性、功能特性、过程特性！ 2、信道的基本概念 信道是往一个方向传送信息的媒体； 一条通信电路包含一个接收信道和一个发送信道； 一条通信电路中的接收信道、发送信道可能冲突嘛？设计上不允许它们冲突： 单工通信信道：只能往一个方向通信，没有反方向的信道；只能发送或者接收数据； 如生活中常见的有线电视、无线收音机等只能接收，不能发送信息； 半双工通信信道：双方都可以发送和接收信息； 但双方不能同时发送或者同时接收；一方发送，另一方只能接收； 全双工通信信道：双方都可以同时发送和接收信息。 3、分用-复用技术 在整个通信基础设施的投资成本中，由传输媒介所组成的通信线路占有相当大的比重： 对于有线的传输媒介来说，一方面由于资源有限，制造成本增加，即使说采用了原料丰富的光纤线路，但是线路铺设的费用依然也是在逐年增长； 对于无线传输媒介来说，有限的可用频率更是一种非常宝贵的通讯资源； 如果两个计算机需要通信，在它们之间需要有一条通信电路；通信电路中包含发送信道、接收信道； 如果有多台计算机需要通信，就需要多条通信电路；但是在大部分时候，这些通信电路处于关机状态并不活跃； 导致信道利用效率并不高； 因此如何提高通信线路的利用率是数据通信中的一个不可忽视的内容：这引出了 分用-复用技术！ 分用-复用技术是指 在一条通信线路上传输多路信号，以提高通信线路利用率的技术； 多个计算机连接复用器，多个计算机连接分用器； 通过复用器、分用器，共享一条通信电路，大大提升信道利用率； 但如果多台计算机的通信频率都很高，又使用了复用器、分用器；这会导致信道的拥塞； 复用技术也可以分为时分复用、波分复用、码分复用、频分复用(按频率不同来进行信道复用) 等！ 3.1、频分复用 一个信号一般只占据一个宽带有线的频率范围， 而在实际用中一个信道可以被利用的频率的范围比一路信号需要的频率要宽得多， 如果在这样的一个信道上只传输一路信号的话，就像在宽阔的马路上只有一个车道一样，显然太浪费！ 因而 以频率分割的方式把一条信道分成若干个子信道，从而实现多路复用，这就是频分复用的基本原理。 传统的多路载波电话系统就是一种典型的平分多路复用系统！ 上图信道按照频率的不同被分割成了四个子信道； 为了保证各子信道中所传输的信号互不干扰，相邻子信道的频谱之间留有一定的频率间隔； 每个子信道传输一路用户的信号，那么从总体上看，在这条信道中同时传输四个用户的信号； 复用器的作用就是把各路用户的信号进行频谱搬移，搬移到分配给它的频段范围； 分用器就相当于一个滤波器，把各种信号区别开来； 频分复用的所有用户在同样的时间内占据着不同的带宽资源。 目前频分复用技术在利用无线传输介质，比如无线电通信微波通信卫星通信中仍然在得到广泛的使用。 3.2、时分复用 采用时间分片的方式来实现传输信道的多路复用； 也就是说每一路信号传输都使用信道的全部带宽，但它只是使用其中的某个时间片； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/计算机数据链路层.html":{"url":"计算机基础/计算机网络/计算机数据链路层.html","title":"计算机数据链路层","keywords":"","body":"计算机数据链路层 数据链路层在 OSI 模型位于物理层上层，数据链路层与物理层组成了 TCP/IP 模型的网络接口层！ 1、数据链路层的几个重要功能 数据链路层的三个重要功能分别是封装成帧、透明传输、差错检测！ 1.1、封装成帧 帧 是数据链路层的基本单位； 发送端的计算机会将网络层的 IP 数据报文传送到数据链路层； 数据链路层接收到 IP 数据报文后，会在报文前添加帧首部、在报文后添加帧尾部，形成数据帧； 接收端接收到数据后，会根据前后特定标记识别出数据帧； 物理层不会关注 数据帧，仅仅是数据的传输； 帧的长度：从帧的首部开头、到帧尾部的结尾； 帧首部、帧尾部都是特定的控制字符（特定比特流），如 SOH:00000001, EOF:00000100； 假如数据里面也包含这些比特流，该这么办呢？ 1.2、透明传输 透明 在计算机领域是一个非常重要的术语； 对于数据链路层来说，物理层的工作是透明的，物理层仅需提供一些 API 即可； 一种实际存在的事物，却又看起来不存在一样； 控制字符在帧数据中，但是要当作不存在一样去处理； 上图的数据报中恰好有一个 EOT 的控制字符 如果没有进行透明传输，接收端很可能将该字符当作帧尾部，这就导致了一个错误的帧数据； 对数据中出现的特殊字符特殊处理：如果数据报文中包含 EOT，则在 EOT 字符前加一个转义字符 ESC； 接收端接收到数据，读取到 EOT 字符时会判断前面是否有转义字符 ESC； 如果有，则认为是数据报中的数据；如果没有，则是一个报文的结尾； 如果数据报中也出现转义字符该这么办呢？对转义字符再做一次转义。 编程语言中的 \\ 一般作为转义字符； \\n、 \\t 等控制字符； 1.3、差错监测 物理层只负责传输比特流，无法监测是否出错； 如果物理层在传输数据时，出现了一些信号干扰导致数据丢失，物理层是无法察觉其出错的； 数据链路层负责 差错监测 的工作； 1.3.1、奇偶校验码 一种简单的校验比特流是否传输错误的方法； 通过在比特流尾部添加一位比特位来检测比特流是否出错； 假设需要传输比特流 00110010； 使用奇偶校验码在其尾部增加一位比特位 1 （ 0 + 0 + 1 + 1 + 0 + 0 + 1 + 0 = 3 % 2 = 1）； 当接收端接收到比特流数据后，会根据尾部的比特位 1 来判断数据是否出错； 假设传输过程发生错误变为 00010010，接收端检验为 0 与尾部 1 不合； 假设传输过程发生错误变为 00000010，接收端检验为 1 与尾部 1 相合；此时无法发现传输的数据出错； 局限性：比特流在传输过程中出现两位错误，奇偶校验码检测不到错误！ 1.3.2、循环冗余校验码 CRC 循环冗余校验码 CRC 是一种广泛使用的差错监测的算法： 根据传输或保存数据而 产生固定位数检验码 的方法；产生的固定位数，可能是一位、或者多位； 可以检测数据传输或者保存后可能出现的错误； 与奇偶校验码的过程类似：生成一些数字然后附加到数据后面；接收端接收到数据后根据附件到后面的数据来判断接收的数据是否出错； 循环冗余校验码 CRC 步骤 选定一个用于校验的多项式 G(x) ，并在数据尾部添加 r 个 0； 将添加 r 个 0 后的数据，使用模 2 相除法除以多项式的位串； 得到的余数填充在原数据 r 个 0的位置得到可校验的位串； /// 例1：使用 CRC 计算 101001 的可校验位串 G(x) = 1 * x^3 + 1 * x^2 + 0 * x^1 + 1 * x^0 = x^3 + x^2 + 1 => 二进制位串为 1101，最高阶为 3 setp1：尾部添加 3 个 0 => 101001 000 _______________ 1101 | 101001 000 1101 ____ 循环冗余校验码 CRC 的检错能力与位串的阶数 r 有关； 阶数越多，检测的能力越强；如果 r = 1 ，就是一个奇偶校验算法； 数据链路层仅仅校验数据，而不纠正数据； 如果检测到数据出错，数据链路层简单粗暴地直接丢弃错误数据； CRC 多项式 G(x) 规范 常用 CRC（按照 ITU-IEEE 规范） 名称 多项式 表示法：正常或者翻转 CRC-1 x + 1 (用于数据链路层，也称为奇偶校验位) 0x1 or 0x1 (0x1) CRC-5-CCITT x5 + x3 + x + 1 , ITU G.704 标准 0x15 (0x??) CRC-5-USB x5 + x2 + 1 ，用于 USB 信令包 0x25 or 0x14 (0x9) CRC-7 x7 + x3 + 1 ，用于通信系统 0x09 or 0x48 (0x11) CRC-8-ATM x8 + x2 + x + 1 ，用于ATM HEC 0x07 or 0xE0 (0xC1) CRC-8-CCITT x8 + x7 + x3 + x2 + 1 ，用于 1-Wire 总线 CRC-8-Dallas/Maxim x8 + x5 + x4 + 1，用于 1-Wire bus 0x31 or 0x8C CRC-8 x8 + x7 + x6 + x4 + x2 + 1 0xEA(0x??) CRC-10 x10 + x9 + x5 + x4 + x + 1 0x233 (0x????) CRC-12 x12 + x11 + x3 + x2 + x + 1，用于通信系统 0x80F or 0xF01 (0xE03) CRC-16-Fletcher 参见 Fletcher's checksum，用于 Adler-32 A & B CRC CRC-16-CCITT x16 + x12 + x5 + 1，用于X25, V.41, Bluetooth, PPP, IrDA 0x1021 or 0x8408 (0x0811) CRC-16-IBM x16 +x15 + x2 + 1 0x8005 or 0xA001 (0x4003) CRC-16-BBS x16 + x15 + x10 + x3，用于 XMODEM 协议 0x8408 (0x????) CRC-32-Adler See Adler-32 ,参见 Adler-32 CRC-32-MPEG2 See IEEE 802.3, 参见 IEEE 802.3 CRC-32-IEEE 802.3 x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x+ 1 0x04C11DB7 or 0xEDB88320 (0xDB710641) CRC-32C (Castagnoli) x32 + x28 + x27 + x26 + x25 + x23 + x22 + x20 + x19 + x18 + x14 + x13 + x11+ x10 + x9 + x8 + x6 + 1 0x1EDC6F41 or 0x82F63B78 (0x05EC76F1) CRC-64-ISO x64 + x4 + x3 + x + 1，用于 ISO 3309 0x000000000000001B or 0xD800000000000000 (0xB000000000000001) CRC-64-ECMA-182 x64 + x62 + x57 + x55 + x54 + x53 + x52 + x47 + x46 + x45 + x40 + x39 + x38+ x37 + x35 + x33 + x32 + x31 + x29 + x27 + x24 + x23 + x22 + x21 + x19 + x17 + x13 + x12 + x10 +x9 + x7 + x4 + x + 1 0x42F0E1EBA9EA3693 or 0xC96C5795D7870F42 (0x92D8AF2BAF0E1E85) CRC-128 IEEE-ITU 标准。被 MD5 & SHA-1 取代 CRC-160 IEEE-ITU 标准。被 MD5 & SHA-1 取代 补充知识：模 2 除法 异或：两个比特位数据相同，则运算结果为 0；如果不同，运算结果为 1； 模 2 除法是二进制下的除法；与算术除法类似，但模 2 除法不错位，本质就是一个 异或 的位运算； 2、最大传输单元 MTU 最大传输单元 MTU 相关概念： 最大传输单元 MTU （Maximum Transmission Unit） 数据链路层传输的数据帧也不是无限大的，MTU 描述可以传输的最大数据帧； 数据帧过大、过小都会影响传输效率； 数据帧过大，则发送时延、排队时延、传播时延、处理时延都会增大；导致发送端与接收端数据处理信息的时间过长； 常见的以太网 MTU 一般为 1500 字节； 3、以太网协议 计算机A 通过网络拓扑，向计算机 C 发送数据！那么中转数据的路由器又如何知道该数据又谁接收呢？ 3.1、以太网协议概述 以太网协议是数据链路层广泛使用的的局域网技术； 使用该协议可以完成 相邻设备 的数据帧传输； 3.2、MAC 地址表 MAC 地址属于硬件地址，每一台设备都有唯一的 MAC 地址；可以将 MAC 地址当做设备的身份证号！MAC 地址共有 48 位，使用十六进制表示！ 3.3、数据传输中转过程 疑问：计算机 A 通过网络拓扑，向计算机 C 发送数据！那么中转数据的路由器又如何知道该数据由谁接收呢？ 路由器拥有一张 MAC 地址表； 计算机 A 通过网卡发出以太网数据帧； 数据帧到达路由器，路由器取出其前 6 个字节 （目的机器的 MAC 地址 ）； 路由器查询其 MAC 地址表， 找到对应的网络接口 E3（计算机 C）； 路由器向该网络接口发送数据帧；从而完成数据从 A 到 C 的发送与接收的过程； 在上述过程中，发挥重要作用的是路由器的 MAC 地址表；但如果 MAC 地址表并不知道计算机 C 的硬件接口是哪一个，那该怎么办呢？ 路由器查询其 MAC 地址表，没有发现计算机 C 的信息； 路由器将广播计算机 A 的数据包到除 A 以外的端口（计算机 B、C）； 路由器收到计算机 B、C 的回应，并将这些 MAC 地址记录下来； 此时，路由器根据 MAC 地址表知道数据包的目的机器是计算机 C；就可以向计算机 C 发送数据了。 MAC 地址表只能指定一个数据帧的下一个地址是什么；即MAC 地址表只能进行相邻物理节点传输！ 从计算机 A 发送数据到计算机D ，可以经路由器 E 来中转；但如果从计算机 A 发送出数据到计算机 C ，该怎么处理呢？ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/计算机网络层.html":{"url":"计算机基础/计算机网络/计算机网络层.html","title":"计算机网络层","keywords":"","body":"计算机网络层 计算机网络层在 OSI 模型中的第三层（位于物理层、数据链路层上层），在 TCP/IP 模型的第二层；网络层主要决定数据在网络的传输路径！ 1、网络层 IP 协议 1.1、IP 协议 1.1.1、虚拟互联网络 计算机 A 如何将数据传送到计算机 B 呢？根据拓扑图可以看到有很多条路径可以从计算机 A 到达计算机 B ： 如：A -> 中型网络 -> 大型网络 -> 中型网络 -> 小型网络 -> B ； 如：A -> 中型网络 -> 路由器 -> 小型网络 -> 路由器 -> 中型网络 -> 路由器 -> 小型网络 -> B； 主要由网络层来确定这条路径！ 虚拟互联网络： 现实中的网络环境错综复杂；可能连接不同的家庭、不同的地区、不同的国家、不同的大洲等； 不同的物理设备通过 IP 协议连接，屏蔽物理网络之间的差异； 当网络中的主机使用 IP 协议连接时，则无需关注网络细节； 将复杂的网络拓扑看作一个虚拟的互联网络，计算机 A 只需要将数据发送到虚拟的互联网中，网络可以解决数据传输问题；将数据准确的传输到计算机 B。 1.1.2、IP 协议 IP 地址 IP 地址唯一标记互联网中的计算机，使用点分十进制表示； IPV4 有 32 位共占用 4 个字节，0~255.0~255.0~255.0~255； IPV6 有 64 位共占用 8 个字节； IP 地址与 MAC 地址 IP 地址和 MAC 地址都是唯一标识符： MAC 地址标记网络硬件设备；MAC 地址不可改变，即使将网卡从一台机器移动到另一台机器，MAC 地址也不变、捆绑于网卡之上； 对于网络层而言，IP 地址是网络设备的唯一标识符；只要设备的网络环境发生变化，它的 IP 地址就可能会变跟着改变；将手机从家庭局域网换到公司的局域网，手机的 IP 地址就会变化； IP 协议 IP 协议将现实中复杂的网络变为一个虚拟互联网络； IP 协议使得网络层可以屏蔽底层细节而专注网络层的数据转发； IP 协议解决了 在虚拟网络中数据报传输路径 的问题； IP 报文由 IP 头部和 IP 数据两个部分组成，IP 头部一般占用 20 个字节。 IP 头部 每一行 32 位长度，4 个字节；对于IP 报文头部，至少需要 20 个字节长度； 版本： IP 协议的版本、如 IPV4 、IPV6，通信双方的版本必须一致； 首部长度：表示 IP 首部长度；4 个比特位最大数值 15，单位是 32位字(4 个字节)，因此首部最大长度位 60 字节（15 * 4）； 总长度：占 16 位最大数值 65535， 表示 IP 数据报总长度（IP 首部 + IP 数据）； 数据链路层的数据帧传输单元 MTU 一般为 1500 字节；而 IP报文最大长度为 65535 字节，远高于 MTU； 数据链路层会将 IP 报文分片，将一个较长的 IP 数据报拆分为多个数据帧来传输； 网络层接收数据时根据该字段界定区分一个 IP 报文的； 标志：标记 IP 报文是否分片； 片偏移：当一个 IP 报文被拆分为多个数据帧时，需要在 片偏移 中记录当前数据帧是第几个切片； TTL：占 8 位，表明 IP 数据报文在网络中的寿命，每经过一个设备 TTL 减 1；当 TTL = 0 时，网络设备将丢弃该报文； 设置 TTL 可以让 IP 数据在有限次传输之后到达目的机器或者丢弃掉；避免当 IP 报文在网络中找不到终点时一直传输，消耗带宽； 协议：占 8 位， 表明 IP 报文所携带的具体数据是什么协议的，如 TCP、UDP等； 首部校验和：占 16 位，校验 IP 首部是否出错；接收方在接收 IP 报文之后会进行 IP 首部校验，如果出错，直接丢弃掉； 源IP地址：占 32 位，发送 IP 数据报的计算机地址； 目的IP地址：占 32 位，IP 报文要到达的计算机地址； 协议名 字段值 ICMP 1 IGMP 2 IP 4 TCP 6 UDP 17 OSPF 89 ... ... 1.1.3、IP 协议的转发流程 计算机 A 如何将数据传送到计算机 B 呢？根据拓扑图可以看到有很多条路径可以从计算机 A 到达计算机 B ：如：A -> 中型网络 -> 大型网络 -> 中型网络 -> 小型网络 -> B ！ 路由表工作在网络层；计算机或者路由器都拥有路由表！ 路由表存储着目的地址和下一跳地址的映射关系，路由表是网络层可以正常工作的重要数据结构。 IP 协议的转发流程 计算机 A 需要跨设备将数据传输到计算机 C，仅仅是数据链路层无法完成这个任务： A 发出目的地为 C 的 IP 数据报，查询本地计算机的路由表发现下一跳为 E； A 将数据报发送给路由器 E； 路由器 E 查询自己本地的路由表发现下一跳为 F，将数据报发送给 F； 路由器 F 查询自己本地的路由表发现目的地 C 与自己直接连接，将数据报文发送给 C； 此时完成整个数据传输！ 数据链路层与网络层的共同作用 第一步：从计算机 A 传输到路由器 E： A 发出目的地为 C 的 IP 数据报，查询本地计算机的路由表发现下一跳的 IP 为 E； A 将数据报交给数据链路层，并告知目的地址 MAC 地址为 E； 数据链路层接收到 IP 数据报后，封装成数据帧并且填充源 MAC 地址 A 和目的 MAC 地址 E； 数据链路层通过物理层将数据帧发送给 E； 第二步：从路由器 E 传输到路由器 F 路由器 E 的数据链路层接收到数据帧后，将数据帧交给它的网络层； 路由器 E 的网络层查询路由表，发现下一跳的 IP 为 F； 路由器 E 的网络层将数据交给数据链路层，并告知目的 MAC 地址为 F； 路由器 E 的数据链路层会重新封装数据帧并且填充源 MAC 地址 E 和目的 MAC 地址 F； 接着，将数据帧发送给 F； 第三步：从路由器 F 传输到计算机 C 路由器 F 的数据链路层接收到数据帧后，将数据帧交给它的网络层； 路由器 F 的网络层查询路由表，发现下一跳的 IP 为 C； 路由器 F 的网络层将数据交给数据链路层，并告知目的 MAC 地址为 C； 路由器 F 的数据链路层会重新封装数据帧并且填充源 MAC 地址 F 和目的 MAC 地址 C； 接着，将数据帧发送给 C； 至此，整个传输链路完成！ 上述总结 数据帧 每一跳的MAC地址都在变化； IP 数据报 每一跳的 IP 地址始终不变； 1.2、子网划分 IP 地址长度为 32 位，使用点分十进制表示，分为四个 8 位 (0~255.0~255.0~255.0~255)； 32 位 IP 地址可以表示 42 亿之多的地址 (2^32 = 4294961296)； 如果没有一个合理的分配方案，直接对42 亿个 IP 地址分配；那么整个规划和分配将是十分麻烦的； 因此需要对 IP 地址进行合理的规划：子网划分！ 1.2.1、分类的 IP 地址 可以将 IP 地址分为两个部分：网络号 与 主机号。 根据网络号与主机号的长度不同，可以进一步细分为 A、B、C、D、E 五类: A类地址的第一位规定是 0，8位分配给网络号，24位分配给主机号；保留给政府机构； B类地址的前两位规定是 10，16位分配给网络号，16位分配给主机号；分配给中等规模的公司； C类地址的前三位规定是 110，24位分配给网络号，8位分配给主机号；分配给任何需要的人； D类地址的前四位规定是 1110；用于组播； E类地址的前五位规定是 11110；用于实验； A、B、C、D、E 五类可容纳的地址数目不同： 当分配给主机号的二进制位越多，则能标识的主机数就越多，相应地能标识的网络数就越少； 当分配给主机号的二进制位越少，则能标识的主机数就越少，相应地能标识的网络数就越多； 分类 A类 B类 C类 最小网络号 1 128.1 192.0.1 最大网络号 127 (01111111) 191.255 223.255.255 子网数量 2^7 - 2 2^14 - 1 2^21 - 1 最小主机号 0.0.1 0.1 1 最大主机号 255.255.254 255.254 254 主机数量 2^24 - 2 2^16 - 2 2^8 - 2 125.125.3.60 /// 取出前 8 位，转为二进制 01111101 属于 A 类地址 163.70.31.23 /// 取出前 8 位，转为二进制 10100011 属于 B 类地址 210.36.127.11 /// 取出前 8 位，转为二进制 11010010 属于 C 类地址 特殊的主机号 主机号全是 0 表示当前网络段，不可以被分配为特定主机； 主机号全是 1 表示广播地址，向当前网络段所有主机发送消息； A 类地址如 1.2.3.4 特殊的主机号 1.0.0.0 表示当前网络段的 IP 地址； 特殊的主机号 1.255.255.255 表示广播地址 特殊的网络号 A 类地址网络段全是 0 (00000000) 表示特殊网络； A 类地址网络段 127 (01111111) 表示回环地址； B 类地址网络段 128.0 (10000000.00000000) 是不可使用的； C 类地址网络段 192.0 是不可使用的； 回环地址 127.0.0.1 通常被称作本地回环地址，不属于A 类、B 类等任何一个有类别的地址； 它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口； 在 Windows 操作系统中也有类似定义，通常在安装网卡前就可以 ping 通这个本地回环地址； 一般用来检查本地网络协议、基本数据接口等是否正常； 1.2.2、划分子网 例1：某公司拥有 100 名员工，每人配备一台计算机，请问该公司应该申请哪种网络段？ 答： C 类网络段有 254 个 IP地址，申请 C 类网络段可以最大程度节约 IP 地址，因此申请 C 类网络段！ 例2：某公司拥有 256 名员工，每人配备一台计算机，请问该公司应该申请哪种网络段？ 答：C 类网络段有 254 个 IP地址，不够使用；因此只能使用 B 类地址； 而B类地址拥有 2^16 - 2 = 65534 个 IP 地址，仅仅使用了 256 个。 此时造成了很大的地址空间浪费！ IP 地址分类方法的初衷是为路由协议的设计提供便利，只从IP地址的首部特征位就可以判定属于哪一类网络。但是这种分类方法使得地址空间无法得到最大限度的利用，随着互联网的急剧膨胀，地址短缺的问题愈来愈突出。 为了更大限度的使用IP地址，可将一个网络划分为多个子网，IP地址的结构变为三部分：网络号、子网号和主机号。 网络号和子网号唯一标识一个网络； 子网的划分提高了IP地址的利用率，在一定程度上缓解了IP地址短缺的问题； /// 对C类网络进行子网划分 193.10.10.0 /// 第 25 位为 0 193.10.10.0 ~ 193.10.10.127 /// 第 25 位为 1 193.10.10.128 ~ 193.10.10.255 例1：某公司拥有 100 名员工，每人配备一台计算机，请问该公司应该申请哪种网络段？ 答：分配子网 193.10.10.128 ，该子网有 126 个IP地址，仅仅浪费了 26 个； 大大减少了 IP 的浪费，节约更多的 IP 资源！ 疑问：如果将 A类、B类、C类网络都进行了子网划分，将会产生很多的子网；这种情况下如何判断某个子网属于哪一个 IP 的网络号呢？使用子网掩码，可以快速判断某个子网所属的网络号！ 子网掩码 子网掩码相关概念： 子网掩码和 IP 地址一样，都是 32 位； 与IP地址不同：子网掩码由连续的 1 和连续的 0 组成； 某一个字网的子网掩码由 网络号位数个 连续的 1 组成； 使用子网掩码确定IP地址中哪些部分属于网络号和子网号，哪些部分属于主机号； 子网掩码为 1 的部分对应IP地址的网络号和子网号，为 0 的部分对应主机号！ A 类地址子网掩码为 255.0.0.0，由 8 个 1 ，24 个 0 组成 B 类地址子网掩码为 255.255.0.0 ，由 16 个 1 ，16 个 0 组成 C 类地址子网掩码为 255.255.255.0 ，由 24 个 1 ，8 个 0 组成 划分子网的子网掩码 如何通过子网掩码得到 IP 地址的网络号？ IP : 193.10.10.6 子网掩码 : 255.255.255.128 与运算 : 193.10.10.6 & 255.255.255.128 = 193.10.10.0 子网号 : 193.10.10.0 IP : 193.10.10.129 子网掩码 : 255.255.255.128 与运算 : 193.10.10.129 & 255.255.255.128 = 193.10.10.128 子网号 : 193.10.10.128 1.2.3、无分类编址 CIDR 上文中的 IP 划分、子网划分，过于繁杂！因此提出了无分类编址 CIDR： 无分类编址 CIDR 中没有 A、B、C 类网络号，没有子网的概念； CIDR 将网络前缀相同的 IP 地址称为一个 CIDR 地址块 ； 因此，CIDR 的IP 地址分为两个部分：网络前缀、主机号； 网络前缀与网络号最大的不同之处是：网络前缀是任意位数的；长度并不受限与某一类 IP 地址。 CIDR 前缀长度 掩码 地址数 /13 255.248.0.0 512K /14 255.252.0.0 256K /15 255.254.0.0 128K /16 255.255.0.0 64K /17 255.255.128.0 32K /18 255.255.192.0 16K /19 255.255.224.0 8K ... ... ... 使用 斜线记法 记录相关 IP 地址，如 193.10.10.129/25 表示网络前缀有 25 位，主机号有 7 位。 对于网络前缀为 13 位的 IP 地址，掩码为 255.248.0.0 ，有 512K 个 IP 地址 。 除了网络前缀与网络号的概念不同，子网掩码的使用、地址的计算、特殊的网络号、特殊的主机号、特殊的地址号都是通用的！ 无分类编址 CIDR 相比于子网划分，更加的灵活。现在更多的使用无分类编址 CIDR 规划 IP 地址！ 例1：某公司拥有 100 名员工，每人配备一台计算机，请问该公司应该申请哪种网络段？ 使用 CIDR 进行网络分配，只需要使用斜线记法，分配一个网络前缀为 25 位长度的 IP 网络号即可； 例2：该公司后期增加了 100 名员工，并且拆分为两个部门，又该如何规划 IP 呢？ 此时只需使用 CIDR 分配一个网络前缀为 24 位长度的 IP 网络号即可； 对于两个部门，每个部门分配一个网络前缀为 25 位长度的 IP 网络号； 对于城市使用 CIDR 进行 IP 地址规划： 为该城市分配一个网络前缀为 18 位长度的 IP 网络号； 为该城市的公司分配一个网络前缀为 20 位长度的 IP 网络号； 为该城市公司的某个部门分配一个网络前缀为 24 位长度的 IP 网络号； 1.3、网络地址转换 NAT 技术 为什么使用 NAT 技术？因为 IP 地址不够用了！IPV4 有 40 多亿个地址，但早期 IP 地址的不合理规划导致 IP 号浪费，现在的 IPV4 号已经不够分配。 NAT 技术相关概述 网络地址转换 NAT (Network Address Translation) ，用于多个主机通过一个公有 IP 访问互联网的私有网络中！ IP 地址也可以分为内网地址和外网地址： 内网地址供 内部机构 使用，避免与外网地址重复；如家庭：手机、平板、电脑等； 外网地址供 全球范围 使用，全球公网唯一； 内网地址也分为三类： 10.0.0.0 ~ 10.255.255.255 支持千万数量级设备; 172.16.0.0 ~ 173.31.255.255 支持百万数量级设备; 192.169.0.0 ~ 192.168.255.255 支持万数量级设备; 网络拓扑边缘部分的家庭、公司等，实质上都可以只有一个对外 IP 地址！由于内网地址供内部机构使用，因此 A 公司与 B 公司内部可能使用同样的 IP 地址， A 家庭与 B 家庭内部也可能使用同样的 IP 地址；不会引起冲突。 问题：内网多个设备使用同一外网请求的服务，外部这么知道是具体哪个设备在请求的呢？ NAT 技术的具体细节 端口 Port ：是每个进程进行网络请求的概念！ 一台电脑，一部手机通过一个路由器连接到外部网络： 假设电脑 192.168.2.11 的进程 6666 使用网络发出报文； 该报文来到路由器之后会被替换为新的地址与端口号 173.31.59.10:16666 ； 在目的计算机中识别的是新的源地址与端口号； 因此目的计算机处理完报文后，会把响应报文发送到 173.31.59.10:16666 ； 路由器收到响应报文后，又会将地址转换为 192.168.2.11:6666 ; 以上过程就是 NAT 技术的具体细节： 网络地址转换 NAT 发生在本地路由； 对外通信：将内网的地址与端口号转换为外网的地址与端口号； 接收到相关数据：再把外网地址与端口号映射为内网的地址与端口号； 这个映射的过程，就是网络地址转换的过程；映射的表称为 NAT 表； NAT 技术总结 NAT 技术的实现原理：NAT 技术在网络设备中通过维护一个映射表，通过映射表可以将外部地址转换为内部地址。 该技术在别的场景也广泛使用，如本地安装的虚拟机使用该技术对外通信；可以登录路由器查看 NAT 表。 NAT 技术减缓了 IP 地址的损耗，但是增加了网络通信的复杂度！ 2、网络层其它协议 2.1、ARP协议与RARP协议 ARP 协议与 RARP 协议是 TCP/IP 协议栈中最基础的协议；主要协调完成网络层与数据链路层的工作； ARP 协议与 RARP 协议的操作对于程序员是透明的，程序员并不接触这些协议； 但理解 ARP 协议与 RARP 协议有助于理解网络分层的细节； ARP 协议与 RARP 协议涉及到一个重要的表：ARP 缓存表 是 IP 地址到 MAC 地址的映射； ARP 协议可以将 IP 地址翻译成物理地址； 2.1.1、ARP 缓存表 ARP 缓存表相关概述： ARP 缓存表是 ARP 协议和 RARP 协议的关键； ARP 缓存表缓存了 IP 地址到 MAC 硬件地址之间的映射关系； ARP 缓存表中的记录并不是永久有效的，有一定的期限； 会随着 IP 地址的变化而更新； 在网络层进行数据转发的时候，会经过 ARP 协议将 IP 地址转化为 MAC 地址并告知数据链路层，然后数据链路层才可以进行数据的传输； ARP 缓存表的使用有两种情况： ARP 缓存表缓存有 IP 地址和 MAC 地址的映射关系； ARP 缓存表没有缓存 IP 地址和 MAC 地址的映射关系； case1、缓存映射关系 此时网络层可以直接告知数据链路层目的 MAC 地址。 case2、没有缓存映射关系 ARP 协议会广播某一 IP 协议的信息，收到这个广播的所有设备都会回应一个数据包，表示是不是要找的 IP 地址；如果是，广播的物理设备记录这个 IP 地址与对应的 MAC 地址。 查看本地的 ARP 缓存表 /// 查看 ARP 缓存表 ： IP 地址到 MAC 地址的映射 MacBook-Pro $ arp -a (10.4.152.157) at 88:46:4:a:8b:b0 on en0 ifscope [ethernet] (10.4.159.254) at 14:30:4:9a:79:c on en0 ifscope [ethernet] (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet] (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet] 2.1.2、ARP 协议 ARP 协议相关概述： ARP 协议全称为 地址解析协议 (Address Resloution Protocol) ； ARP 协议的主要作用是：将网络层 IP 的32位地址转化为数据链路层的 48 位 MAC 地址； 在地址转化中有一个重要的表：ARP 缓存表，是 IP 地址到 MAC 地址的映射； ARP 协议是网络层与数据链路层配合使用的重要协议； ARP 协议的具体报文信息，是封装在数据链路层的数据帧中的； 疑问：既然 ARP 协议封装在数据链路层的数据帧中，那为何属于网络层的协议呢？ 答：因为使用了 IP 地址。 2.1.3、RARP 协议 RARP 协议相关概述： RARP 协议全称为 逆地址解析协议 (Reverse Address Resloution Protocol) ； RARP 协议的主要作用是：将数据链路层的 48 位 MAC 地址转化为网络层的32位 IP 地址； 补充：ARP 协议与 RARP 协议在网络传输中的扮演角色 第一步：从计算机 A 传输到路由器 E： A 发出目的地为 C 的 IP 数据报，查询本地计算机的路由表发现下一跳的 IP 为 E； A 的网络层 根据 ARP 协议查寻 ARP 缓存表，查到目的 MAC 地址为 E ； A 将数据报交给数据链路层，并告知目的 MAC 地址为 E； 数据链路层接收到 IP 数据报后，封装成数据帧并且填充源 MAC 地址 A 和目的 MAC 地址 E； 数据链路层通过物理层将数据帧发送给 E； 第二步：从路由器 E 传输到路由器 F： 路由器 E 的数据链路层接收到数据帧后，将数据帧交给它的网络层； 路由器 E 的网络层查询路由表，发现下一跳的 IP 为 F； 路由器 E 的网络层 根据 ARP 协议查寻 ARP 缓存表，查到目的 MAC 地址为 F； 路由器 E 的网络层将数据交给数据链路层，并告知目的 MAC 地址为 F； 路由器 E 的数据链路层会重新封装数据帧并且填充源 MAC 地址 E 和目的 MAC 地址 F； 接着，将数据帧发送给 F； 第三步：从路由器 F 传输到计算机 C 路由器 F 的数据链路层接收到数据帧后，将数据帧交给它的网络层； 路由器 F 的网络层查询路由表，发现下一跳的 IP 地址为 C； 路由器 F 的网络层 根据 ARP 协议查寻 ARP 缓存表，查到目的 MAC 地址为 C ； 路由器 F 的网络层将数据交给数据链路层，并告知目的 MAC 地址为 C； 路由器 F 的数据链路层会重新封装数据帧并且填充源 MAC 地址 F 和目的 MAC 地址 C； 接着，将数据帧发送给 C； 至此，整个传输链路完成！ 2.2、ICMP 协议 网际控制报文协议 Internet Control Message Protocol ，主要用于辅助 IP 协议进行数据传输； ICMP 协议可以报告错误信息或异常情况； ICMP 是不能单独传输的，ICMP 报文需要传输时作为 IP 报文的数据进行传输。 ICMP 报文和 IP 报文一样，分为 ICMP 报文首部、ICMP 报文数据； ICMP 报文首部： 8 位类型：ICMP 报文的种类：差错报告报文、询问报文； 8 位代码：不同的 ICMP 报文种类的具体错误； 16 位校验和：校验报文在传输中是否发生错误； 2.2.1、差错报告报文与询问报文 差错报告的类型值主要有 3、5、11、12 等几种类型； 分别是终点不可达、重定向、传输超时、其它原因等； 网络不可达：IP 地址可以表示一个网络，当主机号全为 0 时表示一个网络，当整个网络不可达时，将报告类型为 3、具体代码为 0 的报文； 主机不可达：客户端需要通信，但服务端处于关闭状态； 对网络重定向：传输给主机的数据需要经过网络，当该网络不能走时，可能需要走别的网络，此时发出网络重定向； 对主机重定向：当报文到达某个主机，主机不能处理，要求重新发到另一个主机中； 询问报文 验证网络是否通畅：当计算机 A 与计算机 B 需要通信，A 会发送一条空的报文，如果计算机 B 收到就回应一下； 时间戳的请求或应答：对时间需要同步的时候，发出该报文！ 2.2.2、Ping 应用 Ping 使用 ICMP 的询问报文来实现！ 发送 Ping 请求时，首先组装一个 IP 数据报文； 在 IP 报文中组装一个 ICMP 的询问报文，并且封装到 IP 协议中去； 然后在数据链路层发出数据帧 MacBook-Pro $ ping www.baidu.com PING www.a.shifen.com (180.101.49.12): 56 data bytes 64 bytes from 180.101.49.12: icmp_seq=0 ttl=50 time=12.454 ms 64 bytes from 180.101.49.12: icmp_seq=1 ttl=50 time=25.224 ms 64 bytes from 180.101.49.12: icmp_seq=2 ttl=50 time=66.736 ms 64 bytes from 180.101.49.12: icmp_seq=3 ttl=50 time=120.979 ms 64 bytes from 180.101.49.12: icmp_seq=4 ttl=50 time=167.337 ms 64 bytes from 180.101.49.12: icmp_seq=5 ttl=50 time=206.755 ms 64 bytes from 180.101.49.12: icmp_seq=6 ttl=50 time=13.319 ms 64 bytes from 180.101.49.12: icmp_seq=7 ttl=50 time=14.916 ms 64 bytes : Ping 命令发出的 IP 报文长度有 64 个字节； time : 从请求到对方应答经历的时间； ttl : IP 报文头部的一个协议，表明 IP 数据报文在网络中的寿命，每经过一个设备 TTL 减 1；当 TTL = 0 时，网络设备必须丢弃该报文； 设置 TTL 可以让 IP 数据在有限次传输之后到达目的机器或者丢弃掉；避免当 IP 报文在网络中找不到终点时，该数据在网络中一直传输，消耗带宽； ttl = 50 表明该报文在网络中还剩下 50 跳； 使用 Ping 命令排查网络故障 首先 Ping 回环地址 127.0.0.1 ，一般都会得到返回； 如果没有得到返回，说明计算机的协议栈可能出现问题，需要重装系统或重装协议栈； 然后 Ping 网关地址，即路由器地址( 192.168.0.1 )； 如果 Ping 不通，说明 Wifi 或者网线连接有问题； 如果 Ping 通，说明本机到路由器的地址是通的； 最后 Ping 一个外部地址，如百度地址；如果 Ping 不通，说明从路由器到 ISP 的网络是有故障的，需要联系服务商来排查问题； 2.2.3、路由追踪技术 Traceroute Traceroute 应用可以探测 IP 数据报在网络中走过的路径！ IP 报文首部的 TTL：表明 IP 报文在网络中的寿命，每经过一个设备 TTL 减 1；当 TTL = 0 时，网络设备将丢弃该报文； ICMP 的差错报告报文会报告终点不可达； 原理：Traceroute 应用巧妙了利用了 TTL 与 ICMP 的差错报告报文，每次将 TTL 加 1直到到达对方的机器，过程中的每一台机器会被记录其地址信息，以此来记录 IP 数据走过的路径！ 具体原理过程 上图中数据报文从计算机 A 经过网络到达计算机 B；由于报文是一跳一跳的中转的：中型网络 -> 大型网络 -> 中型网络 -> 小型网络 -> 达计算机 B； Traceroute 利用了 ICMP 的终点不可达报文，探测数据报走过的路径： 首先封装一个 TTL = 1 的报文；计算机 A 发出该报文到达中型网络，此时 TTL = 0 中型网络会丢弃该报文并向计算机 A 发出一个 ICMP 的终点不可达报文，计算机 A 会将中型网络的地址记录下来； 接着封装一个 TTL = 2 的报文；计算机 A 发出该报文到达大型网络，此时 TTL = 0 大型网络会丢弃该报文并向计算机 A 发出一个 ICMP 的终点不可达报文，计算机 A 会将大型网络的地址记录下来； 接着封装一个 TTL = 3 的报文；计算机 A 发出该报文到达中型网络，此时 TTL = 0 中型网络会丢弃该报文并向计算机 A 发出一个 ICMP 的终点不可达报文，计算机 A 会将中型网络的地址记录下来； 然后封装一个 TTL = 4 的报文；计算机 A 发出该报文到达小型网络，此时 TTL = 0 小型网络会丢弃该报文并向计算机 A 发出一个 ICMP 的终点不可达报文，计算机 A 会将小型网络的地址记录下来； 最后封装一个 TTL = 5 的报文；计算机 A 发出该报文到计算机 B，计算机 B 会响应计算机 A “表明 B 收到 A 的报文”；此时计算机 A 已经记录了所有路径的地址，就可以输出 计算机 A -> 计算机 B 在网络的路径； 注意： IP 协议不保证每个数据包走的路径都一样。 应用 MacBook-Pro-2 $ Traceroute www.baidu.com Traceroute: Warning: www.baidu.com has multiple addresses; using 180.101.49.12 Traceroute to www.a.shifen.com (180.101.49.12), 64 hops max, 52 byte packets 1 202.97.74.150 (202.97.74.150) 10.884 ms 202.97.74.134 (202.97.74.134) 8.479 ms 202.97.66.54 (202.97.66.54) 12.769 ms 2 58.213.94.6 (58.213.94.6) 35.093 ms 58.213.95.2 (58.213.95.2) 18.573 ms 58.213.94.106 (58.213.94.106) 27.976 ms 3 * * * 4 58.213.96.118 (58.213.96.118) 113.623 ms 58.213.96.110 (58.213.96.110) 19.417 ms 58.213.96.122 (58.213.96.122) 16.972 ms 3、IP 的路由算法 3.1、路由的概述 路由表的下一跳地址如何来的？ 路由表的下一跳地址唯一嘛？ 路由表的下一跳地址是最佳路径嘛？ 路由器那么多，它们的路由表如何协同工作？ 将网络拓扑抽象成一张图，使用图论算法来解决上述问题！路由表仅仅是路由算法的一个数据结构！ 每一个顶点表示一个网络、路由器或计算机； 每一条边表示一条网络路径；从一个顶点到另一个顶点有多条路径； 路由算法实际上就是图论算法； 现实中的网络环境复杂，如网络的抖动、网络设备的故障等都会导致路由有图发生变化； 路由算法比图论算法复杂的多； 一个理想的路由算法： 算法需要是 正确 的、完整 的；依据该算法，数据可以顺利到达目的地，不至于走不到或者目的地就是错误的； 算法在计算上应该尽可能的 简单 ；在复杂庞大的互联网非常运行路由算法，算法越简单，越适合更多的设备来使用； 算法可以 适应网络中的变化 ；在每一刻，网络的状态都在变化； 算法必须是 稳定 和 公平 的； 即使一个设备或者网络发生故障，也不会影响到别的网络与设备； 算法对每个路由器、计算机都是公平的，不会因为设备的性能等硬件因素导致路径变化； 互联网的规模非常庞大、互联网的环境非常复杂；为了使路由算法尽可能的简单，也需要人为的对互联网做一些处理：互联网划分。 自制系统 自制系统 Autonomous System； 一个自制系统 AS 是处于一个管理结构下的网络设备群； 一个管理结构可以是一个国家、一个城市、一个企业等； AS 内部网络自行管理， AS 对外提供一个或者多个出入口；AS 外部设备不直接参与内部的管理； 路由算法的层次 网络是分层次的：主干 ISP、地区 ISP、公司、校园、家庭等； 每一个主干ISP 都可以理解成一个主干自制系统 AS； 每一个地区ISP 都可以理解成一个地区自制系统 AS； 每一个公司、校园、家庭等都可以理解成一个小的 AS； 可以将路由算法分为两个层次： 自制系统内部路由的协议称为：内部网关协议 ( RIP协议、OSPF协议 )； 自制系统外部路由的协议称为：外部网关协议 ( BGP协议 )； 3.2、内部网关的路由协议 3.2.1、内部网关的路由协议之 RIP 协议 3.2.1.1、距离矢量 DV 算法 距离矢量 DV 算法实际上运行在图中： 每一个节点使用两个向量 Dij 和 Sij ： 向量 Dij 描述的是节点 i 到节点 j 的距离，向量 Sij 描述的是节点 i 到节点 j 需要途径的下一个节点； 每一个节点都会与相邻的节点交换 Dij 和 Sij 的信息； 每一个节点根据交换的信息更新自己的节点信息； DV 算法示例 初始化路由信息 以节点 A 来还原 DV 算法的运行过程！ 疑问：为何 A -> B 的距离是11，B -> A 的距离是 9 ？ 可能因为距离矢量并非最新信息，如 A -> B = 11 是 A -> C -> B 的距离， B -> A = 9 是 B -> C -> D -> A 与节点 B 交换信息 初始化 Sa 都为空 (A 节点到达B、C、D、E、F节点需要途径的下一个节点是什么)； 首先假设节点 A 与节点 B 交换信息，A 得到了节点 B 的信息，会进行以下运算： A -> B = 6; /// A 拿到 B 的数据之后，A 通过节点 B 可以到下一个节点的距离 A -> B -> C = 6 + 11 = 17; A -> B -> D = 6 + 7 = 13; A -> B -> E = 6 + 17 = 23; A -> B -> F = 6 + 11 = 17; 运算出上述数据之后，A 会与自己的距离矢量比较；如果更小就会覆盖原有信息： A -> B （11 更新为 6） A -> F （17 更新为 17） 同时更新 Sa 的信息，将到达节点 B 与 F 的下一跳节点设置为 B 。 与节点 C 交换信息 节点 A 与节点 C 交换信息，A 得到了节点 C 的信息，会进行以下运算： /// A 通过节点 C 可以到下一个节点的距离 A -> C -> B = 9 + 9 = 18; A -> C = 9; A -> C -> D = 9 + 8 = 17; A -> C -> E = 9 + 11 = 20; A -> C -> F = 9 + 10 = 19; 运算出上述数据之后，A 会与自己的距离矢量比较；如果更小就会覆盖原有信息： A -> C （12 更新为 9） A -> E （21 更新为 20） 同时更新 Sa 的信息，将到达节点 C 与 E 的下一跳节点设置为 C 。 与节点 D 交换信息 节点 A 与节点 D 交换信息，A 得到了节点 D 的信息，会进行以下运算： /// A 通过节点 D 可以到下一个节点的距离 A -> D -> B = 8 + 8 = 16; A -> D -> C = 8 + 6 = 14; A -> D = 8; A -> D -> E = 8 + 11 = 19; A -> D -> F = 8 + 10 = 18; 运算出上述数据之后，A 会与自己的距离矢量比较；如果更小就会覆盖原有信息： A -> D （10 更新为 8） A -> E （20 更新为 19） 同时更新 Sa 的信息，将到达节点 D 与 E 的下一跳节点设置为 D 。 与节点 F 交换信息 节点 A 与节点 F 交换信息，A 得到了节点 F 的信息，会进行以下运算： /// A 通过节点 F 可以到下一个节点的距离 A -> F -> B = 7 + 15 = 22; A -> F -> C = 7 + 11 = 18; A -> F -> D = 7 + 10 = 17; A -> F -> E = 7 + 13 = 20; A -> F = 7; 运算出上述数据之后，A 会与自己的距离矢量比较；如果更小就会覆盖原有信息： A -> F （17 更新为 7） 同时更新 Sa 的信息，将到达节点 F 的下一跳节点设置为 F 。 3.2.1.2、RIP 协议 RIP 协议全称 Routing Information Protocol，路由信息协议； RIP 协议是使用 DV 算法的一种协议； RIP 协议会把网络的跳数 hop 作为 DV 算法的距离；跳数越多，距离也就越长； RIP 协议每隔 30 秒就会交换一次路由信息(包括 Di 与 Si)； RIP 协议默认跳数 > 15 的路由为不可达路由； 对于使用 RIP 协议的路由器： 1、路由器首先会初始化路由信息，包括 Di 和 Si ； 2、初始化之后，路由器会和相邻路由器进行信息的交换； 对相邻路由器 X 发过来的信息进行修改；修改两个部分，首先将下一跳地址设置为 X，其次所有的距离都加 1； 2.1、检索本地路由，某些路由信息可能是本机没有的，需要将这些信息插入到路由表里面； 2.2、检索本地路由，对于下一跳为 X 的，更新为修改后的信息； 2.3、检索本地路由，对比相同目的的距离，如果新信息的距离更小，则更新本地路由；（DV 算法过程） 3、如果 3 分钟没有收到相邻的路由信息，则把相邻路由设置为不可达（16 跳）； 3.2.1.3、RIP 协议的缺点 RIP 协议的致命缺点：故障信息传递慢 1、RIP 协议无条件相信隔壁路由节点信息；拿到隔壁路由信息，就更新自身的信息； 导致陷入循环，直到跳数达到 16 跳才发现原来 A 是不可达的； 2、自己不思考，视野不够；每一个路由器只看到相邻路由节点的信息，看不到更远的信息！ 假设有A、B、C 三个节点线性连接 B -> A = 1 、B -> C = 2 ： 某一时刻路由器 A 宕掉不可达了； B 发现路由器 A 宕掉后会去询问 C，发现 C 经过 2 跳可以到达 A，因此 B 会更新自己的路由表，设置下一跳为 C 并且 B -> A = 2 + 1 = 3； C 发现路由器 A 宕掉后会去询问 B，发现 B 经过 3 跳可以到达 A，所以 C 会更新自己的路由表，设置下一跳为 B 并且 C -> A = 3 + 1 = 4 ； ... B 与 C 一直循环下去，直到达到 16 跳才最终发现 A 不可达！ 该缺点是致命的：网络中经常发生故障，如果每发生一次故障就循环这么多次才收敛，将会导致整个网络的不可控！ 3.2.1.4、RIP 协议总结 RIP 协议： 优点：实现简单，开销很小 ； 缺点：限制了网络规模（达到了 15 跳之上的，被裁定为不可达；使得该协议只能在较小的网络中使用）； 缺点：坏消息传递慢，更新收敛时间过长；使得 RIP 协议整体性能较差 3.2.2、内部网关的路由协议之 OSPF 协议 3.2.2.1、迪杰斯特拉算法 Dijkstra 算法是著名的图算法； Dijkstra 算法使用广度优先搜索，解决有权图从一个节点到其它节点的最短路径问题； 广度优先搜索：以起点为中心，向外层层扩展； 将计算机的网络拓扑抽象为一张图，就是为了更加方便的去描述路由过程； 最短路径问题 计算 A 到 E 的最短路径： /// 首先将 A 到 E 的所有路径都描述出来 A -> B -> C -> E = 13 A -> C -> E = 11 A -> D -> C -> E = 13 A -> D -> E = 9 A -> F -> E = 10 /// 通过列举每一条路径，可以求出最短路径为 9 迪杰斯特拉算法规则 1、初始化两个集合 (S, U) ； 集合 S 的元素初始化为只有一个节点 A，待计算节点 A 到各节点的最短路径； U 为其它顶点集合； 2、如果 U 不为空，对集合 U 的顶点进行距离排序，并取出距离 A 最近的一个顶点 D； 2.1、将顶点 D 纳入 S 集合； 2.2、更新通过顶点 D 到达 U 集合所有点的距离（如果距离更小则更新，否则不更新） 2.3、重复步骤 2； 3、直到 U 集合为空，算法完成。 迪杰斯特拉算法使用 分别求取节点 A 到达节点 B、C、D、E、F 的最短路径： 对集合 U 排序，发现 A -> B = 6 最小，将节点 B 纳入集合 S ！ 3.2.2.2、OSPF 协议 3.2.2.2.1、链路状态 LS 协议 链路状态 LS 协议有几个特点： 特点1： 向所有的路由器发送消息 一传十、十传百 一个路由器产生一条信息，将会向相邻的所有路由器发送该条消息； 这些路由器收到消息后，又会向相邻的所有路由器发送该条消息； 一传十、十传百，将这条消息传到整个网络中去； RIP 协议只和相邻节点交换信息； 特点2：发送的消息会描述该路由器与相邻路由器的链路状态 链路状态指的是与相邻路由器的距离、时延、带宽等可以描述链路状态的指标； 这些指标可以客官的描述该路由器与相邻路由器的链路状态； 网络管理人员可以决定链路状态，使得链路状态更加符合需求； 通常将链路状态称为网络链接的代价，客观的描述一个路由器到另一个路由器的代价； RIP 协议交换的信息是跳数； 更加客观、更加先进; 特点3：只有链路状态发生变化时，才发送更新信息 RIP 协议每隔 30 秒交换一次路由信息，不管路由信息是否发生变化； 实际的运行中OSPF 协议比 RIP 协议 减少了数据的交换、更快收敛; 对比 RIP 协议 RIP 协议盲目的相信隔壁路由器发送的消息； LS 协议下的任意一个路由器都能收到来自该网络下的任何路由器的消息，并不会盲目信任隔壁路由器的消息； RIP 协议视野不够； LS 协议能够看到整个网络的消息；但是 OSPF 协议本身较为复杂，实现开销较大。 3.2.2.2.2、OSPF 协议的过程 OSPF 协议：Open Shortest Path First ，开放最短路径优先 OSPF 协议的核心算法是 Dijkstra 算法； OSPF 协议是链路状态协议的一种实现； 获取网络中所有路由器的消息 => 拿到网络的完整拓扑 => 每个路由器的消息都是完整的 => 也称为 \"链路状态数据库\"，保存网络中每一跳的网络状态 => 链路状态数据库是全网一致的，因为每个消息都会广播到网络中所有的路由器； => 每个路由器都拿到网络的完整拓扑，每个路由器都可以运行 Dijkstra 算法； => 通过 Dijkstra 算法，每个路由器都可以自己找到到达某个节点的最短路径； 3.2.2.2.5、OSPF 协议的五种消息类型 问候消息 Hello ，长度短，维护该路由器与相邻路由器的可达性； 在实际运行中，每个路由器都会发送问候消息给隔壁路由器，以此来确认两个路由器的可达性； 链路状态数据库的描述信息：向隔壁路由器发送自己的链路状态数据库的简单描述消息； 链路状态请求信息：向隔壁路由器请求链路状态数据库 链路状态更新信息：OSPF 协议中非常重要的一条消息，在网络中网络状态实时变化，每个路由器都有可能更新链路状态； 链路状态确认信息：用于对链路更新的一个确认； 3.2.2.2.6、OSPF 协议的完整过程 1、路由器接入网络； 2、向相邻路由器发出问候消息，确认可达性； 3、确认后，与邻居交流链路状态数据库； 3.1、首先发出数据库描述信息，向隔壁路由器介绍自己的链路状态的简要消息； 3.2、交流后，对不同的链路状态进行同步，达到信息一致的状态； 3.3、还需要与网络中的其它路由器达到一致的状态； 4、广播和更新未知路由的消息，以及接收更新消息；以此来更新本地的链路状态数据库 RIP 协议 OSPF 协议 从邻居看网络 整个网络的拓扑 跳数：在路由器之间累加距离 Dijkstra 算法计算最短路径 频繁、周期的更新，收敛很慢 状态变化才更新，收敛很快 路由间拷贝路由信息 路由间传递链路状态，自行计算路径 3.3、外部网关的路由协议 3.3.1、外部网关协议之 BGP 协议 BGP （Border Gateway Protocol） ：边际网关协议 BGP 协议运行在自制系统 AS 之间的一种协议 BGP 协议能够找到一条到达目的机器的 比较好 的路由（无法找到最好的路由） 为何在 AS 之间要使用 BGP 协议？ 互联网的规模宏大，使得在 AS 之间选择路由非常困难； 如果在 AS 之间使用链路状态协议，每个路由器需要存储庞大的链路状态数据，使用 Dijkstra 算法计算最短路径的效率也会变得很低下； AS 内部使用不同的路由协议，如公司甲使用 RIP 协议、公司乙使用 OSPF 协议； 使用不同路由协议的 AS 之间是无法通信的，公司甲的 RIP 协议中跳数才是关注指标、公司乙的 OSPF 协议考虑更多的是带宽、时延、距离等因素； 因此它们之间需要 BGP 协议来协调； AS 之间需要考虑除网络特性以外的一些因素，如政治、安全因素等；AS 之间可能是一个地区到另一个地区，也可能是一个国家到一个国家，地区之间可能法律不同，国家之间可能有一些军事冲突等； 上图中 AS1、AS2、AS3、AS4 在物理上是互相连接的，但由于政治、安全等因素，可能出现一些额外情况： 如 AS1 的网络不符合 AS2 地区的法律，AS2 有权拒绝 AS1 传递的信息、或者 AS1 不想将敏感信息传递到 AS2； 此时 AS1 需要通过 AS3 将数据传递到 AS4； BGP 发言人 speaker 在一个网络中有两个位于 AS 边界的路由器，将这两个路由器配置为 BGP 发言人 BGP 并不关心内部网络拓扑； AS 之间通过 BGP 发言人交换信息； 如某个 AS 增加路由、撤销路由、发生网络差错时，都是通过 BGP 发言人进行信息交换； BGP 发言人可以人为的配置策略；如是否允许某个 AS 经过自己的 AS、在 AS 配置过滤一些敏感信息使这部分信息无法进入； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/计算机传输层.html":{"url":"计算机基础/计算机网络/计算机传输层.html","title":"计算机传输层","keywords":"","body":"计算机传输层 传输层位于 OSI 模型的第四层，TCP/IP 模型的第三层； 为上层的应用层提供数据传输服务； 管理端到端的通信连接； 主要工作在终端设备（手机、计算机、笔记本、平板电脑等）上；而无需经过路由； 网络层提供了一个虚拟的互联网络，不同的终端设备可以连接到该网络进行数据通信；而传输层不再关心数据路由的相关问题，只需解决不同的终端设备的通信问题即可。 客户端通过虚拟的互联网络向服务端请求数据；不管是客户端，还是服务端，在计算机运行的实体就是一个进程； 因此客户端与服务端的通信可以看作是进程与进程间的通信；传输层主要解决这两个进程之间是如何通信的； 回忆操作系统的进程间通信：Unix 域套接字、共享内存等；主要用于单机间的进程通信，不能跨网络、不能跨机器； 而网络通信可以多机器之间通信，也可以跨网络、跨机器进行通信，因此网络通信是更广泛的进程间通信方法。 疑问：每个计算机可以运行多个进程，那么计算机与计算机之间如何识别是哪个进程通信的呢？ 使用端口 Port 来标记不同的网络进程； 端口 Port 使用 16 比特位来表示（0～65535） 常用进程 端口 FTP 21 HTTP 80 HTTPS 443 DNS 53 TELNET 23 UDP 主要提供多媒体纷发的功能，包括视频、语音、实时信息等； 因为多媒体纷发的数据即使丢了一秒数据也没关系，因为下一秒又有新的数据来展示； 如股票走势、视频数据等，一些数据的丢失不影响接下来的展示； 用户关注的是实时信息，过去数据丢失了用户也不关注； TCP 主要提供了数据的可靠性与完整性，所以 TCP 更多的进行可靠信息的传输；如金融交易不允许一丝的信息错误； 1、UDP 协议 UDP 协议全称 用户数据报协议（User Datagram Protocol），是一个非常简单的协议，不能保证可靠的交付数据。 数据报 是应用层传输过来的完整数据，针对该数据报 UDP 不做任何处理，既不拆分、也不合并。 UDP 协议直接将数据报文封装在协议中传输出去； UDP 协议的长度主要由应用层传输数据的长度决定，应用层传输数据越长 UDP 报文就越长； UDP 报文分为 UDP 首部、UDP 报文数据； UDP 首部非常简单： 16 位源端口号：源机器使用网络的进程； 16 位目的端口号：目的机器使用网络的进程； 16 位 UDP 长度： UDP 数据报的长度，最小值为 8 （仅包括首部） 16 位 UDP 校验和：监测 UDP 数据报在传输中是否出错； 1.1、UDP 的特点 UDP 协议是无连接的协议：在发送数据报时不需要事先建立连接，也没有断开连接的过程； UDP 是面向报文传输的：既不合并、也不拆分，不对应用层传输的数据做任何处理； UDP 不能保证可靠的交付数据：无连接，无法感知数据在网络中是否丢失； UDP 没有拥塞控制：不能感知网络是否拥塞，尽最大努力交付数据： UDP 首部开销很小：只有源端口号、目的端口号、UDP 长度、UDP 校验和总计 8 个字节； 1.2、UDP 的功能 多端口复用、分用、差错检测（UDP 校验和） 多端口复用： 建立传输的过程，需要有 IP 地址与端口号； 在同一台计算机可能有不同的进程，同一个进程使用不同的应用层协议、所对应的端口号不同； 不论从哪个端口传输数据出去，都可以复用传输层的数据报，再经由网络层传输出去； 分用： 在网络层接收一个 IP 报文，拆分为 UDP/TCP 数据报传递到传输层； 在每一个报文中都有源端口号与目的端口号；根据目的端口进行数据纷发，发送到不同的端口； 2、TCP 协议 TCP 协议全称 传输控制协议 (Transmission Control Protocol)， 是计算机网络中非常复杂的一个面向连接的协议。 2.1、TCP报文首部信息 16 位源端口号：源机器使用网络的进程； 16 位目的端口号：目的机器使用网络的进程； 序号：32 个比特位，每个字节都有一个序号，用来标记传输的字节；TCP 报文传输的数据首个字节序号； 确认号：每个字节都有一个序号，表达期望收到下一个数据报中的数据首字节序号；与序号配合使用；如果确认号为 N，则表示 N-1 序号的数据都已收到； 数据偏移：4 个比特位（0~15）,单位是 4 字节，表示传输数据偏移 TCP 首部的距离；如果 TCP 报文中包含可选数据，由于不知道 TCP 选项内容的大小，需要该字段记录 真实的TCP数据偏离首部的距离 ； 保留字段：暂未使用； TCP 标记：6 个比特位各有不同含义 URG、ACK、PSH、RST、SYN、FIN； 窗口：16 个比特位，指明允许对方发送的数据量，用于控制 TCP 连接中数据传输的速率； 如 1000 表示对方可以发送 1000 个字节； 如确认号 501、窗口 1000，表示从 501 ～ 1500 这些数据都是可以接收的； 校验和：监测 TCP 数据报在传输中是否出错； 紧急指针：只有 URG=1 才使用，表示紧急数据位于报文的数据； TCP 选项：最多有 40 个字节，支持未来的拓展； 填充：填充为 32 比特位的整数倍； /// 根据数据偏移计算出 TCP 首部的长度 TCP 首部固定 20 个字节 最大的数据偏移是 15 * 4 = 60 个字节 TCP 首部的长度是 20 ～ 60 字节 TCP标记 含义 URG Urgent 紧急位；URG=1 表示紧急报文 ACK Acknowledgement 确认位；ACK=1 确认号 才生效 PSH Push 推送位，PSH=1 表示尽快地把数据交付给应用层 RST Reset 重置位，RST=1 表示当前连接发生严重错误、希望重新建立连接 SYN Synchronization 同步位，SYN=1 表示连接请求报文 FIN Finish 终止位，FIN=1 表示释放连接报文 2.2、特点 TCP 协议是面向连接的协议：通信前需要先建立连接通道（三次握手），通信结束断开通道（四次挥手）； TCP 协议提供可靠的传输服务：无差错、不丢失、无重复、按序到达； TCP 协议是面向 字节流 的协议： TCP 协议是可以流量控制； TCP 协议是可以拥塞控制； TCP 协议的一个连接有两端（点到点通信）; TCP 协议提供全双工的通信；建立连接的两个计算机都可以同时发送或者接收数据； 2.2.1、面向 字节流 流 是流入进程或者流出进程的字节序列； 传输层的数据由应用层一块一块的传递过来； TCP 不会将这些数据块看作完整的数据，而是看作一系列、一整串的字节流； TCP 逐个字节的处理这些数据流； TCP 协议可能取出数据的某一段进行传输，剩下的数据在后续 TCP 报文传输； 因此 TCP 报文可能对用户的数据进行 合并、或者 分拆； 如图所示，有发送方与接收方；当发送方发送数据的时候，在传输层的 TCP 层面有一个缓冲；对应的，接收方也有一个接收的缓存； 发送的每一个数据，通过 TCP 连接传送给接收方； 发送方可能发生一个序列如 13、14，其缓冲区接收数据后，每次发送多少字节由 TCP 控制； TCP 可能把发送方多次发送的数据拼接成一个 TCP 报文发送给接收方； 不管发送方一次性提交给 TCP 缓冲多大的数据，对于 TCP 协议而言会根据实际情况决定传递多少字节； 2.3、可靠传输 如何保证 TCP 报文的可靠传输呢？需要做到四点：无差错、不丢失、无重复、按序到达。 可靠传输依赖于超时重传，即接收方需要发送确认消息给发送方，如果一定时间内发送方没有收到确认消息，则认为消息没有到达接收方，重新发送数据。 2.3.1、停止等待协议 可靠传输在 TCP 层面通过停止等待协议来实现：停止等待协议是最简单的可靠传输协议，但是对信道的利用率并不高。 停止等待协议可以考虑四种情况： 无差错情况 超时重传 确认丢失 确认重传 无差错情况的停止等待协议 为简化讨论，将计算机分为客户端与服务端： 首先客户端建立 TCP 数据并发送出去，经过一段时间后到达服务端； 服务端收到消息后，需要回馈给发送方一条确认消息（确认我已收到你的消息）； 确认消息经过一段时间后到达客户端，客户端确认对方收到消息后接着建立数据 2 并发送出去； 经过一段时间后到达服务端，服务端收到消息后回馈给客户端一条确认消息； ... 如此按序发送消息； 客户端的停止等待：客户端发送一条消息后，停止生产新的消息，等待服务端的确认消息；只有收到服务端的确认消息，客户端才会生成新的消息。 服务端的停止等待：服务端没有消息来临的时候处于等待过程，有消息来的时候生成一个确认消息并且发送出去；然后又继续等待。 超时重传 假如客户端发送一条报文，被滞留、拦截、篡改等；服务端判断该条报文属于差错报文，会丢弃掉； 或者由于超时或者网络环境差而丢失，服务端根本没有收到报文； 在期许的时间内客户端不能收到确认报文，就会产生超时； 超时之后，客户端会重新发送该条报文； 解决方案：在客户端设置一个超时定时器，在规定时间内没有收到确认报文，开启重传机制进行超时重传！ 通过重传策略，保证了报文 不丢失； 服务端的差错检测，保证了报文 无差错； 确认丢失 客户端向服务端发送报文，服务端在向客户端确认时该报文丢失； 在期许的时间内客户端不能收到确认报文，就会产生超时； 通过超时重传策略，客户端会重新发送该报文至服务端； 但是服务端之前已经接收了该报文，此时服务端需要丢失该报文并重传一条确认报文到客户端； 确认迟到 客户端向服务端发送报文，服务端在向客户端发送的确认报文可能迟到了； 在期许的时间内客户端不能收到确认报文，就会产生超时； 通过超时重传策略，客户端会重新发送该报文至服务端； 服务端之前已经接收了该报文，此时服务端需要丢失该报文并重传一条确认报文到客户端； 在未来的某个时间，超时的报文可能会到达客户端，此时客户端简单的收下迟到报文但什么也不做； 超时重传 ：不管是上述哪个原因，发送方等待一段时间后没有收到接收方的确认消息，此时发送方会重新发送该条消息！ 停止等待协议通过 超时重传，保证了可靠传输！ 超时定时器：每发送一个消息，都需要设置一个定时器；以计算消息的过期时间。 2.3.2、连续 ARQ 协议 ARQ (Automatic Repeat reQuest) 自动重传请求。 既然单个发送和确认效率低下，可不可以批量发送和确认呢？ 假如有序号为 1～12 的字节需要发送： 此时不是发送一个等待一条确认消息了，可能会连续的发送 6 个字节； 假设收到报 1、2 的确认消息，就会将窗口向前移动两个位置，再发送字节 7、8； 等待新的确认消息之后，再将窗口向前移动； 滑动窗口：发送字节消息时会批量的发送，批量发送的大小称之为窗口大小；只要窗口前端的确认消息被收到，窗口就会向前推动，再将窗口内部没有发送的数据发送出去。 TCP 的滑动窗口以字节为单位； 对于滑动窗口的每个字节，如果都需要确认接收的话，开销也是很大的； 滑动窗口并不需要对每个字节确认，而是采用 累计确认 的方法； 累计确认 ： 假如收到某条消息，就代表这条消息之前的所有消息都已收到 假如连续的发送 6 个字节，在某个时刻收到了字节 5 的确认消息； 如果采用了累计确认，确认消息 5 就代表着 1～5 的消息都已收到； 此时会将窗口向前推动 5 个位置，窗口可以发送字节 7～11； 大大的减少了确认报文的数量，以此提升网络效率； 可用窗口：窗口内部有一部分字节已发送但未收到确认，剩余的部分是允许使用的窗口； 假如窗口内部的字节都已发送出去，但一个也没收到确认，此时可用窗口为 0；滑动窗口不能向前推进； 确认号并没有按顺序收到： 23、24 没有收到确认消息，而25、27 收到了确认消息；窗口并不能向前推进； 假如超时时间到了，即使25、27 已经收到，还是需要从 23 开始重传消息； 可靠传输的效率还是不够高，此时需要 选择重传； 2.3.3、选择重传 每一个字节都有唯一的 32 位序号； 选择重传需要指定重传的字节序号； TCP 首部并没有存储选择重传指定内容的位置，因此选择重传的信息存放在 TCP 选项部分； TCP 选项最多有 40 个字节，每个字节的序号占 4 个字节，因此 TCP 选项最多存储 10 个序号； TCP 选项存储的 10 个字节序号，并非存储 10 个字节； TCP 报文一次可以传输很多字节，如果出错，只能是 TCP 整个报文丢失，一次丢掉一段字节； TCP 重传，更多的是对一段字节的重传； 因此 TCP 选项中的序号并不是指定某个字节，表示的是需要重传的字节序号边界； 假如需要重传字节段 1000 ～ 3500； 以 500 字节为一个 TCP 报文； 分别指定两个边界 1000、 1500 存储到 TCP 选项，表示需要重传的字节段； 2.4、TCP协议的流量控制 流量控制通过调整滑动窗口的大小，来控制发送方发送的字节量。 一般而言，发送方发送的数据越快越好；但现实中还需要考虑接收方的接收能力，如果接收方处理数据的速度太慢，而发送方发送太快，就会造成信息堆积在接收方；此时接收方会希望发送方发送信息的速度慢一点！ 流量控制指让发送方发送速率不要太快； TCP 首部的窗口占 16 个比特位，允许对方可以发送的数据量有多少；如 1000 表示对方可以发送 1000 个字节；如确认号 501、窗口 1000，表示从 501 ～ 1500 这些数据都是可以接收的； TCP 的流量控制和 TCP 头部的窗口字段有关系，流量控制根据 TCP 报文中窗口的大小来进行数据的传输； 当窗口较大时，增加数据发送速度，当窗口较小时，降低数据发送速度。 滑动窗口如何进行流量控制呢？ 假设有发送方与接收方两个计算机； 发送方发送序列号为 1 ，数据量为 100 字节的数据；接着发送方发送序列号为 101 ，数据量为 100 字节的数据； 此时接收方已接收 200 个字节的数据、发出一个确认消息，确认号为 201 表明期待收到的下一个字节的序号，并且添加一个数据 rwnd=300 表明当前可用窗口为 300； 发送方收到确认消息并且知道可用窗口为 300 ，就可以发送 300 个字节的数据； 发送方发送序列号为 201 ，数据量为 100 字节的数据；接着发送方发送序列号为 301 ，数据量为 200 字节的数据； 此时接收方总计接收 500 个字节的数据、发出一个确认消息，确认号为 501 表明期待收到的下一个字节的序号，并且添加一个数据 rwnd=0 表明当前可用窗口为 0； 接收方通过可用窗口的大小控制发送方的流量。 假如接收方处理完 500 字节的数据，此时又可以再次接收新的消息； 此时接收方向发送方发送一条消息 rwnd=1000，告诉接收方我还可以接收 100 个字节的数据； 接收方通过调整可用窗口的大小控制发送方的流量 ； 此时发送方会进行数据的封装，并将数据发送给接收方； 特殊情况：假如接收方向发送方发送的 rwnd=1000 的消息在网络中丢失; TCP 的可靠传输是基于字节的序列号，对特殊消息如 可用窗口调整 是没有超时重传的机制； 发送方由于上一个消息“接收方的可用窗口为 0”会一直等待接收方的调整可用窗口的消息； 接收方由于已经告诉发送方 “调整可用窗口的消息”，因此会一直等到发送方的数据； 由于一条报文的丢失，导致接收方与发送方的循环等待、形成死锁； 那么这个死锁如何解开呢？ 坚持定时器，解决死锁局面： 当接收到可用窗口为 0 的消息，则启动 坚持定时器； 坚持定时器 每隔一段时间发送一个 窗口探测报文，询问接收方可用窗口是否调整； 即使接收方向发送方发送的 可用窗口调整 的消息在网络中丢失，也不会导致死锁； 2.5、TCP协议的拥塞控制 当网络中的数据报文过多的时候，会出现拥塞！TCP 协议是如何拥塞控制呢？ 在互联网上，数据从一个地方到达另一个地方，需要经过很多设备； 网络中的各种路由器性能不一样、或传输导体的传输速率不同；导致数据链路中的各个部分都有可能成为网络传输的瓶颈； 根本来说，网络对硬件设备要求大于可用资源就会导致拥塞； 判断网络拥塞：如果发送的报文超时，则认为网络发生了拥塞： 在传输过程中，由于某些路由器处理不过来，而导致超时； 如果在传输过程中，网络中断也会导致报文超时；此时就是因为网络故障导致的超时，而非拥塞； 2.5.1、慢启动、拥塞避免 由小到大逐渐增加发送数据量； 每收到一个报文确认，就加一；如第一次发送 1 个报文、第二次发送 2 个报文、第三次发送 4 个报文...； 发送报文的数量指数增长，到达慢启动阈值就停止增长； 拥塞避免： 维护一个拥塞窗口的门限值，这个变量大于慢启动阈值； 只要网络不拥塞（报文不超时），就试探着将拥塞窗口调大；如每次发送一个报文，呈线性增长； 发生网络拥塞时采用乘法减小的策略，恢复到只发送一个报文，再将拥塞窗口的门限值将为原来的一半； 减少向网络中发送报文数量，尽量减小网络层的压力； 然后再重新开始； 2.5.2、快恢复、快重传 快恢复、快重传基于慢启动与拥塞避免； 如达到窗口上限时，回到新的门限值开始； 2.5.3、流量控制与拥塞控制 流量控制是点对点的通信量控制，强调 TCP 连接双方的发送 - 接收速率； 拥塞控制从全局考虑，感知整个网络是否发生拥塞、发生拥塞该怎么办； 拥塞控制需要考虑整个网络，很难有最优解； 2.6、TCP三次握手 TCP标记 含义 URG 紧急位；URG=1 表示紧急数据 ACK 确认位；ACK=1 确认号 才生效 PSH 推送位，PSH=1 表示尽快地把数据交付给应用层 RST 重置位，RST=1 表示当前连接发生严重错误、希望重新建立连接 SYN 同步位，SYN=1 表示连接请求报文 FIN 终止位，FIN=1 表示释放连接 发送方需要主动和接收方建立连接通道： 第一次握手：发送方发出 SYN=1,seq=x 的报文表示这是一个连接请求报文，并且同步自己的序列号 x； 第二次握手：接收方接到 连接请求报文 会被动的打开 TCP 连接，发出 SYN=1,ACK=1,seq=y,ack=x+1， SYN=1 是连接请求；ACK=1,ack=x+1 是对发送方序列号 seq=x 的确认；seq=y 是接收方的序列号； 第三次握手：发送方发出 ACK=1,seq=x+1,ack=y+1 的报文； ACK=1,ack=y+1 是对接收方方序列号 seq=y 的确认；自己发送数据的序列号 seq=x+1； 三次握手，不仅仅建立了 TCP 连接通道；还通过两次 ACK，同步了发送方与接收方的序列号 seq。 在时间轴的不同时间，也会有不同的状态： 接收方没有接收到数据之前，一直处于 监听 状态； 发送方发出第一次握手请求、还没有收到对方应答的时间段，处于 同步已发送 状态； 接收方发出第二次握手请求、还没有收到发送方第三次握手，处于 同步已接收 状态； 表示收到了发送方的 SYN=1 信息； 发送方发出第三次握手请求之后，就处于 建立连接 状态； 对于发送方而言，只要第二次握手成功，就建立起连接； 但是对于接收方而言，只有接收到第三次握手信息，才是 建立连接 的状态； 对于发送方与接收方，建立连接状态的时间是不一致的；只有双方都是建立连接 状态，才可以进行数据传输； 为什么发送方要发出第三个确认报文呢？ 三次握手主要是避免 已经失效的连接请求报文 传送到对方，引起错误 。 假设发送方发出的第一条建立请求的报文，在网络上传输了很久才到达接收方；所以发送方很久都不会收到确认报文； 发送方会认为第一条报文已经超时，会发送第二次建立请求的报文，该报文很快就到达接收方； 接收方接到 建立请求的报文 后会做出回应； 此时对于发送方发送的第一条报文 已经算作失效报文，因为它的功能被发送方发出的第二次报文 所完成； 假如两次握手就建立连接：对于失效的报文，只要接收方回应了，就代表连接建立了；这就导致同样的报文建立了两个 TCP 通道；这明显是错误的！ 三次握手确认的重要作用：对于失效的报文接收方会做出回应，回应报文到达发送方；由于发送方已经发出了第三次握手消息，会丢弃该报文不做任何处理！这就避免了重复建立 TCP 通道的错误！ 2.7、TCP四次挥手 当数据传输完成，发送方或者接收方需要主动的断开连接，假设发送方 在数据传输完成之后 主动进行连接释放： 第一次挥手：发送方发出 FIN=1,seq=u 的报文表示这是一个 断开连接请求 报文，并且同步自己的序列号 u； 此时发送方处于 连接结束等待状态； 第二次挥手：接收方接到 断开连接请求报文 之后会去确认，发出 ACK=1,seq=v,ack=u+1 的报文； ACK=1,ack=u+1 是对发送方序列号 seq=u 的确认，seq=v 是接收方的序列号； 此时接收方处于 关闭等待状态；发送方收到第二次挥手消息后，处于 断开连接等待状态； 此时接收方还可以进行数据的发送，因为接收方的数据可能还没传送完毕；等到接收方的数据发送完之后，会发出第三次挥手消息； 第三次挥手：接收方发出 FIN=1,ACK=1,seq=w,ack=u+1 的报文表示这是一个 断开连接请求 报文，并且携带 ACK=1 重复的对第一次挥手报文确认； 第四次挥手：发送方发出 ACK=1,seq=u+1,ack=w+1 的确认报文，确认断开连接； 发送方在第四次挥手之后不会立即关闭通道，而是处于一种特殊的状态 时间等待状态 ；发送方等待一段时间，确保这段时间没有出现任何问题，然后才进入关闭状态。 接收方在收到第四次挥手之后立即关闭通道。 TCP 协议的四次挥手涉及到报文首部的 序号、确认号、TCP 标记 ACK、SYN、FIN等！ 2.7.1、等待计时器 MSL (Max Segment Lifetime)：最长报文段寿命，一般而言 MSL 设置为 2 分钟； 等待计时器会等待 2 MSL 的时间，保证 ACK 报文可以正确到达对方； 对于每个 TCP 连接都会占用一个端口，在连接状态时使用另外进程来复用该端口是不行的、会提示“该端口已经被占用”； 在计时器等待的这个时间，并不会释放这个端口；只有计时器结束计时，才会释放端口； 2.7.2、为何需要等待计时器？ 等待计时器功能1：确保第四次挥手报文可以正确到达接收方！ 发送方在发出第四条挥手报文后处于等待状态，而这条报文并没有被确认； 处于等待，主要是确保发送方的 ACK 可以到达接收方； 假如在 2 MSL 的时间之内接收方没有收到 第四条挥手报文，接收方会认为自己发出的第三条报文没有到达发送方，接收方会重新发送第三次挥手报文； 发送方重复收到第三次挥手报文，就该明白自己发出的 第四条挥手报文 并没有到达 接收方；发送方会再次发送 第四条挥手报文； 等待计时器功能2：确保当前连接的所有报文都已过期！ 最后一条报文都等待了 2 MSL 的时间，那么其它报文肯定超过了 2 MSL 时间而过期！ 2.8、TCP中的四个定时器 TCP的四个定时器对TCP协议非常重要，理解TCP的四个定时器对理解TCP协议的原理有非常重要的帮助！ 2.8.1、超时定时器 超时定时器也称为超时重传定时器，在可靠传输中使用的定时器： 超时定时器主要应用在TCP的可靠传输协议里面，是为了控制可能发生丢失的报文而设计的定时器； 当TCP协议发送端发送一个报文时，就会为该报文设置一个超时定时器； 如果在超时定时器结束之前收到了来自接收端对该报文段的确认，则撤销这个定时器； 如果在超时定时器结束时仍然没有收到来自接收端对该报文段的确认（超时），则认为这个报文可能已经丢弃，发送端重新发送该报文，并重新设置一个超时定时器； 需要注意的是，发送端在超时定时器撤销之前，必须继续缓存已发送未确认的报文，直到发送端收到了来自接收端的确认。 2.8.2、坚持定时器 坚持定时器是使用滑动窗口进行流量控制的时候而设置的： 要理解坚持定时器，需要理解“零窗口通知”的情况。我们知道接收端通过调整接收窗口的大小可以控制发送端的发送速度，当接收端把接收窗口调小时，那么发送端就会调小发送的流量。 这就可能产生一种情况，就是接收端的缓存区已经满了，这个时候接收端会给发送端发送一个“零窗口”的消息，表示说“当前我已经没有余力处理更多的数据了”，这就是“零窗口通知”的情况。 当出现这种情况的时候，双方都会陷入等待的状态，发送端等待接收端的窗口调大，接收端等待发送端发送的数据。当接收端窗口可以调大的时候，接收端会发送窗口调大的信息给发送端，但是这个消息是不可靠的，也即是这个消息可能会在传输中丢失，并且不会被感知到丢失和重传。 如果这个消息在发送过程中丢失的话，那么发送端和接收端就会进入死锁状态，因为接收端认为“我已经把窗口调大的消息发送出去了，发送端理应发送新的消息给我才对”，所以接收端会一直等待发送端的消息；而发送端因为没有收到窗口调大的消息，则认为“接收端还没有调大窗口，因此我不能发送”，发送端也会一直等待。 因此为了解决这个问题，当发送端收到窗口为零的消息之后，会启动一个坚持定时器来周期性主动的向接收方查询，以便发现窗口是否增大，这个就是坚持定时器的作用。 2.8.3、时间等待计时器 时间等待定时器是在 TCP连接的四次挥手 中使用的计时器！ 时间等待计时器(Time-Wait)是由主动关闭TCP连接的一方设置的，当主动关闭TCP连接的一方收到来自对方的FIN报文的时候（第三次挥手），则认为对方也可以关闭TCP连接，这个时候主动关闭TCP连接的一方发送一个消息确认的报文（第四次挥手），并启动这个时间等待计时器，这个计时器会等待2倍MSL的时间； 这个定时器主要是为了正确关闭一个TCP连接而考虑的，这主要是为了保证 主动关闭方 在对最后一个FIN报文（第三次挥手）发送确认的报文可以到达 被动关闭方。 当 主动关闭方 发出这个报文之后，就会启动2MSL计时器，注意，这个报文是有可能在网络传输过程中丢失的，如果 被动关闭方 收不到这个确认，那么 被动关闭方 会重新发送一次FIN报文，主动关闭方 会重新收到这个报文并重传一次最后的确认，并重新启动2MSL计时器，直到双方正常结束TCP连接。 2MSL时间可以保证当 被动关闭方 没有收到确认时，可以再次发出FIN报文，并且 主动关闭方 可以再次收到并重新发送确认，所以2MSL的时间可以保证连接正常结束。 2.8.4、保活计时器 保活计时器是为了保活TCP连接而设计的，保活定时器可以防止TCP连接的两端出现长时期的空闲，当一方出现状态变化或故障时，另一方没有察觉的情况。 设想连接双方在建立连接后，只传输了一些数据，然后就都保持静默了，双方也都没有关闭连接（这种情况经常存在），如果这个时候其中一方已经故障，那么这个连接将会永远被打开，如果被连接的一方是服务端的话，那将浪费很多服务端的资源。 因此为了解决这个问题，服务端一般都会设置一个保活定时器，每次收到对方的数据则重置这个定时器，如果定时器超时，服务端则发送探测报文段，探测客户端是否还在线，如果没有收到响应的话，那么则认为客户端已经断开连接了，因此服务端也会终止这个连接。 保活定时器其实有很广泛的应用，在今天，很多的分布式系统，都会使用保活定时器来检测其他节点是否在线还是已经故障，或者其他节点也会每隔一段时间向主节点上报心跳信息以证明在线，这些都是保活定时器在更多领域的广泛应用。 3、套接字与套接字编程 使用端口来标记不同的网络进程； 端口使用 16 比特位来表示 0～65535； 使用 IP:Port 可以指定网络中某台主机的具体进程是什么 使用套接字来表示 IP:Port 组合； 套接字 Socket 是抽象概念，表示 TCP 连接的一端； 通过套接字可以进行数据发送或接收； 通过两个套接字唯一指定一个 TCP 连接； 一个 IP 可能有多个套接字，因为有多个端口，不同的端口与 IP 组合就是不同的套接字； TCP = {套接字1:套接字2} = {IP:Port}:{IP:Port}; 网络套接字与域套接： 网络套接字：不管是跨计算机、还是在同一台计算机，只要使用网络套接字，都会经过计算机的协议栈； 如数据经过 应用层 -> 传输层 -> 网络层 -> 网络接口层； 域套接字：主要通过域套接字文件进行传输，不需要经过协议栈； 所以单机通信，最好使用 域套接字 来通信；处理流程简单，系统消耗小。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/计算机应用层.html":{"url":"计算机基础/计算机网络/计算机应用层.html","title":"计算机应用层","keywords":"","body":"计算机应用层 传输层、网络层、网络接口层已经提供了完整了通信服务，应用层无需管理通信服务，只需对接用户提供丰富的功能即可！ 应用层主要 定义应用间通信的规则 ： 应用进程的报文类型：如请求报文、响应报文； 报文的语法、格式； 应用进程发送数据的时机、规则； 1、域名系统 DNS 域名系统 DNS (Domain Name System )：域对应网络段、或者 AS 系统，名指的是某个 IP 对应的名字是什么！ DNS存在的意义： 将枯燥的点分十进制 IP 地址与端口号转为 域名，帮助记忆某些网站； 域名由 DNS 服务提供，通过 DNS 服务可以将域名映射为 IP 地址； 域名由点、字母和数字组成；点分割不同的域 www.baidu.com，可以分为顶级域 com、二级域 baidu、三级域 www；也可以向前继续分四级域、五级域等； 顶级域与二级域一般都国际通用的： 根域名服务器：最高层次的域名服务器，由国家自行维护，分布在不同的国家； 顶级域名服务器：由不同的国家/地区维护； 地区域名服务器：由一些结构或者公司维护； 1.1、DNS 解析 域名到 IP 地址的映射，DNS 解析请求采用 UDP 报文，且明文传输。 客户端向服务端发送请求的时候，首先需要经历 DNS 解析的过程，如访问 www.baidu.com ： 检查浏览器缓存中是否缓存过该域名对应的 IP 地址； 如果在浏览器缓存中查询到 www.baidu.com 对应的 IP，直接访问其 IP 地址； 如果在浏览器缓存中没有找到 IP，那么将继续查找本机系统是否缓存过 IP； 如果本机系统没有缓存，则向 DNS 域服务器发起域名解析的请求； DNS 域服务器将解析结果的 IP 地址返回给客户端； 客户端再向对应的 IP 服务器发送数据通信。 DNS 解析查询有两种方式：递归查询、迭代查询。 1.1.1、递归查询 递归查询可以归纳为 “我去给你问一下” 来概括整个查询过程！ 客户端在向 DNS 域名服务器发送请求的时候 客户端首先询问本地 DNS 服务器，如果本地 DNS 服务器能够直接解析结果，就会返回给客户端对应的 IP 地址； 如果本地 DNS 服务器不知道域名对应的 IP 地址，本地 DNS 服务器就会去询问根域 DNS 服务器； 如果根域 DNS 服务器能够直接解析结果，就会返回给本地 DNS 服务器域名对应的 IP 地址； 如果根域 DNS 服务器不知道域名对应的 IP 地址，根域 DNS 服务器会去询问顶级 DNS 服务器； 如果顶级 DNS 服务器能够直接解析结果，就会返回给根域 DNS 服务器域名对应的 IP 地址； 如果顶级 DNS 服务器不知道的话，就会去询问权限 DNS 服务器对应域名的 IP； 权限 DNS 服务器会将对应域名的 IP 返回给顶级 DNS，再由顶级 DNS 服务器返回给根域 DNS 服务器； 最终返回给本地 DNS 服务器，再返回给客户端； 在上述过程中，任何一个环节的 DNS 服务器不知道对应域名的 IP 时，该环节会作为主问方去询问别人，再由别人去问其他人，最后再层层返回结果！ 1.1.2、迭代查询 迭代查询可以归纳为 “我告诉你谁可能知道” 来概括整个查询过程！ 客户端在向 DNS 域名服务器发送请求的时候 客户端首先询问本地 DNS 服务器，如果本地 DNS 服务器能够直接解析结果，就会返回给客户端对应的 IP 地址； 如果本地 DNS 服务器不知道域名对应的 IP 地址，本地 DNS 服务器就会去询问顶级 DNS 服务器； 顶级 DNS 服务器会告诉本地 DNS 服务器“你要的答案我不知道”，根域 DNS 服务器可能知道，你去问它吧； 然后本地 DNS 服务器就去询问根域 DNS 服务器； 根域 DNS 服务器会告诉本地 DNS 服务器“你要的答案我不知道”，权限 DNS 服务器可能知道，你去问它吧； 然后本地 DNS 服务器就去询问权限 DNS 服务器； 权限 DNS 服务器会将对应域名的 IP 返回给本地 DNS 服务器； 再由本地 DNS 服务器交给客户端域名对应的 IP ； 1.1.3、DNS 解析中存在的问题 在上述DNS 解析过程中，存在哪些问题呢？ DNS 劫持问题； DNS 解析转发问题； 1.2、DNS 劫持 客户端向 DNS 域名服务器发送请解析请求 DNS 解析请求采用 UDP 报文，且是明文传输；可能涉及到窃听、拦截的问题； 假如有一个钓鱼 DNS 服务器劫持了“DNS 解析请求报文”，钓鱼服务器可能返回一个错误的 IP 地址； 此时客户端拿到错误的 IP 地址去进行访问，就会访问到一个错误的网站； 注意：DNS 解析发生在传输层 TCP 通道建立之前，而且 DNS 解析采用 UDP 报文、端口号是 53；因此 DNS 解析与应用层的 HTTP 请求没有任何关系！ 如何解决 DNS 劫持呢？可以采用 httpDNS、长连接两种解决方案。 1.2.1、 httpDNS 防止 DNS 劫持 DNS 解析采用 DNS 协议，向 DNS 服务器的 53 端口发送 UDP 报文； 采用 httpDNS，使用 HTTP 协议向 DNS 服务器的 80 端口发送请求报文；此时规避了 DNS 解析查询，也就避免了 DNS 劫持的情况！ 客户端通过 DNS 服务器寻求域名解析的时候，发送一个 HTTP 报文的 Get/Post 请求； 通过 IP 直连的方案去请求 DNS 服务器； 如中介服务器“腾讯DNSPod” 119.29.29.29； 通过 HTTP 请求， DNS 服务器以响应的方式返回给客户端一个具体的 IP 地址； 客户端拿到这个 IP 地址进行后续的数据传输； 1.2.2、长连接 防止 DNS 劫持 在客户端与要请求的 API 服务端之间，增加一个长连接服务器（代理服务器）； 客户端与长连接服务器建立一个 TCP 长连通道；长连接服务器与 API 服务端之间通过内网专线连接； 如客户端发送一个 HTTP 请求，通过长连通道，传到长连服务器； HTTP 请求的域名由长连服务器经过内网专线到内网服务器的 DNS 解析； 规避了公网 DNS 解析涉及到的劫持问题； 1.3、DNS 解析转发 客户端询问本地 DNS 服务器某一网站的 IP 地址 如果是手机用的移动网，可能就会去询问当地的移动 DNS 服务器； 某些小的运营商为了节省资源，不会遵循 DNS 协议规范；而是转发给当地的电信 DNS 服务器，让电信 DNS 服务器帮助自己来解析； 电信 DNS 服务器会向权威 DNS 服务器请求解析域名对应的 IP 地址； 权威 DNS 服务器可能根据不同的运营商请求情况，针对不同网络的流量调度分发； 由于是电信请求解析，可能返回一个电信的 IP 3.3.3.3 ；此时将域名对应的 IP 一步步返回给客户端； 此时客户端用着移动的网络， 由于解析转发 ，访问的服务器可能是 网站设立的电信服务分支节点； 这样可能造成跨网访问的过程，造成网速过慢 等问题； 2、DHCP 协议 DHCP (Dynamic Host Configuration Protocol)：动态主机设置协议 DHCP 协议是一个局域网协议； DHCP 协议通过 UDP 协议进行数据通信；（DNS 协议也是通过 UDP 协议进行数据通信） 不同的设备如手机、电脑等，进行数据通信时都需要配置 IP 地址； 同一部手机在不同的地方，如家里、户外、公司等连接的 IP 地址不同； DHCP 协议提供了一种 即插即用联网 的机制，只要通信终端使用了 DHCP 协议就无需自行配置 IP 地址； DHCP 协议可以在不同的网络环境，为通信终端配置一个临时 IP 地址； 临时 IP 地址有时效性“租期”，在租期之内可以使用这个 IP；租期到了之后就会回收这个 IP； 如果一些主机或者设备需要继续使用这个 IP ，可以续租； DHCP 协议过程： 对于一个刚加入局域网的设备，刚开始不知道自己的 IP 地址； DHCP 服务器监听默认端口号 67； 刚加入的设备使用 UDP 协议广播 DHCP 发现报文，查找 DHCP 服务器在哪里； DHCP 服务器收到报文后，知道本地局域网中有新的设备需要动态配置 IP；因此发出 DHCP 提供报文，告诉新设备，我可以提供 DHCP 服务； 当新设备收到服务报文后，就知道是谁提供 DHCP 服务； 新设备向 DHCP 服务器发出 DHCP 请求报文；DHCP 服务器做出回应，为新设备提供 IP 地址； 3、其它内容 3.1、Web缓存 Web缓存将某些数据缓存起来，以提高访问效率！ Web 服务就是对内容的提供；内容有热门数据、冷门数据； 对热门数据，访问的人居多；对冷门数据，访问的人少； 二八原则：一个网站内容可以分为 20% 的热门内容、80% 的冷门内容；保障热门内容的访问速度与稳定性，有助于提高网站浏览量；因此需要优先缓存热门数据，保存到访问速度更快的地方； 3.2、Web代理 Web代理工作在客户端与服务端之间！ 代理的工作过程： 客户端访问服务端，首先经过一个代理 Proxy ，再访问到后面的服务器； 服务器通过代理 Proxy 将数据返回给客户端； 需要代理的场景： 需要屏蔽服务器的部署结构，通过设置代理，客户端只能看到代理而无法看到后面服务端的部署； 服务器部署在敏感的地方需要保证安全，在代理中设置一些安全规则（防火墙），以免服务器暴露在危险的环境； 相对于客户端而言代理分为正向代理与反向代理： 正向代理是代表客户端去访问服务端； 反向代理是代表服务端将数据传给客户端； 3.3、CDN CDN (Content Delivery Network)：内容分发网络； 内容包括文本、图片、文件、动图、音频、视频等； 使用 CDN 可以进行多媒体内容的加速； 网络应用层CDN作用: 假设有一个大型的网站部署在首都，该网站可以浏览丰富的图片、视频等资源； 相对于雾都，魔都距离首都的距离更近；由于物理距离的客观因素，导致网络请求的时间不平等； 魔都访问该网站的速度更快，因为物理距离更近； 对于一些大的热门的内容，留一个备份(CDN)在某个中心热门区域，以此来缩短访问距离； 如在雾都留一个备份，辐射整个西南地区，对于该地区的用户会有更好地体验； 3.4、爬虫 通常将互联网比作一张蜘蛛网，爬虫就是蜘蛛，在互联网上走来走去； 爬虫的本质就是一段程序，在互联网中走来走去，采集一些信息； 搜索引擎（百度、谷歌）的本质就是爬虫，通过爬取整个网络的数据并且做一定的索引；在搜索的时候，将匹配的内容提供给大家； 不好的爬虫，也会 造成网络的拥塞 、损耗服务器资源 ； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/HTTP协议.html":{"url":"计算机基础/计算机网络/HTTP协议.html","title":"HTTP协议","keywords":"","body":"HTTP 协议 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。 HTTP 协议全称 HyperText Transfer Protocol：超文本传输协议； 超文本：一个带有超链接的文本；通过超文本可以从网站的一个地方到达另外一个地方； 它允许将超文本标记语言 HTML 从 Web 服务器传送到客户端的浏览器； 它可以使浏览器更加高效，使网络传输减少； 它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 /// 地址格式 http(s)://:/ /// 主机：IP或者域名 /// 端口：http 是 80 端口，https 是 443 端口 /// 路径：资源所在路径 HTTP 协议属于应用层协议，基于传输层的 TCP 协议，因此是可靠的数据传输协议； 数据可以是文本、图片、文件、动图、音频、视频等，这些丰富的数据构成了 Web 网站的内容； HTTP 协议运行在典型的 客户端-服务端 模式上，用于客户端与服务器之间的通信； 1、HTTP 协议的发展史 发展历史 产生时间 内容 HTTP/0.9 1991年 不涉及数据包传输，规定C/S通信格式，仅支持GET请求 HTTP/1.0 1996年 传输内容格式不限制，不仅支持传输文字，还支持传输图像、视频、二进制文件等；增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 请求 HTTP/1.1 1999年 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 HTTP/2 2015年 多路复用、服务器推送、头信息压缩、二进制协议等 HTTP/0.9 和 HTTP/1.0 使用非持久连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开 TCP 连接。 HTTP/1.1 使用持久连接：不必为每条请求建立一个 TCP 通道；一个 TCP 通道可以支持多个请求，大大提升了传输效率。 多路复用：通过一个HTTP/2 连接请求可以同时发起多个请求/响应 消息，多个请求流共享一个 TCP 连接，实现多留并行而非建立多个 TCP 连接。 2、HTTP 协议的特点 HTTP 协议是一个应用层协议，主要特点可概括如下： 基于 “客户端-服务端” 通信模式：客户端发送请求，服务器做出响应；服务器不会主动将消息推送给客户端； 灵活：HTTP 允许传输任意类型的数据；传输的数据类型由 Content-Type 加以标记； 无状态协议：协议对客户端没有状态存储；比如访问一个网站需要反复进行登录操作，这样可能导致每次连接传送的数据量增大。 不安全：通信使用明文，请求报文和响应报文不会对通信方进行确认，无法保护数据的完整性。 无状态协议 协议的状态是指下一次传输可以“记住”这次传输信息的能力。 HTTP 协议为了保证服务器内存、提高服务器对并发访问的处理能力；在服务器发送响应报文时，是不会为了下一次连接而维护这次连接所传输的信息。 这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过响应报文而不接受第二次请求。 是否进行持久连接？ HTTP 对 TCP 连接的使用，分为两种方式：短连接 和 长连接 在 HTTP 1.0 版本，使用的是短连接； 从HTTP/1.1 起，支持 长连接 并默认都开启了 Keep-Alive ，保持连接特性； 简单地说，HTTP/1.1之后，当一条数据传输完成后，客户端和服务器之间的TCP通道不会关闭；如果客户端再次与该服务器通信，会继续使用这一条通道。 利用持久连接的优点，当加载多个图片时，显著地减少下载所需要的时间。 当然，Connection: Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器设定这个时间。 在请求头部设置Connection: close 代表一个请求完成后，客户端和服务器之间的TCP通道断开，当客户端再次发送请求，需要重新建立TCP连接。 3、HTTP 协议通信流程 一次 HTTP 通信可分为四步： step1：客户端与服务器建立端口为 80 的 TCP 通道（ TCP 的三次握手）； step2：客户端通过 TCP 通道发送 请求报文 给服务器；请求报文有四大部分：请求行、请求头、空行、请求数据 ； step3：服务器接到请求后，发送 响应报文；响应报文有三大部分：状态行、消息报头、响应正文 ; step4：客户端接收服务器返回的数据后，根据 Connection 字段信息决定是否关闭 TCP 通道。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端。 3.1、Web 服务器运行过程 Web 服务器如何进行客户端连接、如何处理客户端请求； 1、接受来自客户端的连接（IP 通过域名系统解析，端口默认为 80）； 2、接收来自客户端的请求报文（HTTP请求方法有 Get、Post、Delete、Update、Put、Options、Patch、Head、Trace等） HTTP请求通过不同的方法，请求到 Web 服务器的不同内容； 3、处理请求，验证请求是否合法，了解客户端需要哪些资源； 4、访问 Web 资源（Web服务就是内容的提供） 5、构造应答（获取相应资源构造应答报文） 6、发送应答； 3.2、如何指定资源呢？ 在地址中指定； 如http://www.baidu.com/images/123.png； 如http://www.baidu.com/?page=1&pageSize=20； 在请求数据中指定 HTTP有两类报文： 请求报文：由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。 响应报文：由状态行、消息报头、响应正文三个部分组成。 4、请求报文 请求报文 请求行：由请求方法、URL 和 HTTP协议版本 3 个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。 请求头：通知服务器有关于客户端请求的信息；由键/值对组成。 空 行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。 4.1、请求方法 HTTP 请求通过不同的方法，请求到 Web 服务器的不同内容： GET ：获取指定的服务端资源； POST：提交数据到服务端（如本地对某个数据做了修改，希望服务器可以对这个修改保存下来）；数据被包含在请求体中； POST 请求可能会导致新的资源的建立和/或已有资源的修改。 DELETE：删除指定的服务端资源； UPDATE：更新指定的服务端资源； OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向服务器发送 * 的请求来测试服务器的功能性。 HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 PUT：向指定资源位置上传其最新内容。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 PATCH：用来将局部修改应用于某一资源，添加于规范 RFC5789。 4.2、GET 与 POST的区别 区别 GET POST 提交数据 放在URL之后，以?分割 URL 和传输数据，参数之间以& 相连，如 EditPosts.aspx?name=test1&id=123456 把提交的数据放在 HTTP 包的 Body 中 大小限制 最多只能有1024字节的数据 没有限制 获取变量 使用Request.QueryString来取得变量的值 通过Request.Form来获取变量的值 安全性 比如一个登录页面，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码 在请求体中，相对安全 常见的请求头： 4.3、缓存相关 If-Modified-Since：把客户端缓存数据页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回 304 ，客户端就直接使用本地缓存文件。如果时间不一致，就会返回 200 和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来。 If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT If-None-Match：和ETag一起工作，工作原理是在 HTTP Response 中添加 ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能。 If-None-Match: \"03f2b33c0bfcc1:0\"。 Pragma：指定 no-cache 值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control。 Cache-Control：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求报文或响应报文中设置Cache-Control 并不会修改另一个消息处理过程中的缓存处理过程）。请求报文的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应报文中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。 Cache-Control:no-cache： 所有内容都不会被缓存 Cache-Control:no-store： 用于防止重要的信息被无意的发布。在请求报文中发送将使得请求和响应文中都不使用缓存。 Cache-Control:Public 可以被任何缓存所缓存 Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:max-age 指示客户端可以接收生存期不大于指定时间（以秒为单位）的响应。 Cache-Control:min-fresh 指示客户端可以接收响应时间小于当前时间加上指定时间的响应。 Cache-Control:max-stale 指示客户端可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户端可以接收超出超时期指定值之内的响应消息。 4.4、接收的数据限制 Accept：客户端可以接受的MIME类型；例如：Accept: text/html 代表客户端可以接受服务器回发的类型为 text/html 也就是html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 代表任意类型，例如 `Accept: /*` 代表客户端可以处理所有类型。 Accept-Encoding：客户端申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet 能够向支持gzip 的客户端返回经gzip编码的 HTML 页面。许多情形下这可以减少5到10倍的下载时间。例如： Accept-Encoding: gzip。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。 Accept-Language：客户端申明自己接收的语言；例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。 Accept-Charset：客户端可接受的字符集，中文有多种字符集，比如big5、gb2312、gbk等等。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。 Content-Type：具体请求中的数据类型；例如：Content-Type: application/x-www-form-urlencoded。 Content-Length：表示请求消息正文的长度。例如：Content-Length: 38。 4.5、HTTP 1.1之后是否进行持久连接？ Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。HTTP 1.1默认进行持久连接。利用持久连接的优点，当加载多个图片时，显著地减少下载所需要的时间。 Connection: close 代表一个Request 完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。 4.6、分段下载与断点续传 Range:bytes=start-end：可以请求实体的一个或者多个子范围，用于大文件的分段下载： Range:bytes=0-499：表示前500个字节； Range:bytes=500-999：表示第二个500字节； Range:bytes=-500：表示最后500个字节； Range:bytes=500-：表示500字节以后的范围； Range:bytes=0-0,-1：第一个和最后一个字节； 同时指定几个范围：Range:bytes=500-600,601-999。 服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。 4.7、其它字段 User-Agent：告诉服务器，客户端使用的操作系统和App的名称和版本。 例如：User-Agent:objective-c-language/1.0 (iPhone; iOS 10.3.3; Scale/2.00) Cookie：最重要的请求头之一, 将客户端的cookie值发送给HTTP服务器。 Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中，用base64将用户名和密码编码，用于证明客户端是否有权查看某个资源。当客户端发起一个请求时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 例如：Authorization:MTM4MDAwMDAwMDA6YTEyMzQ1Njc Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 例如:Referer:http://translate.google.cn/?hl=zh-cn&tab=wT 5、响应报文 响应报文 状态行：通过提供一个状态码来说明所请求的资源情况。HTTP-Version Status-Code Reason-Phrase CRLF 消息报头：通知客户端有关于服务器请求的信息；由键/值对组成。 响应正文： 5.1、状态码 状态码 含义 200~299 成功状态码 300~399 重定向状态码 400~499 客户端错误状态码 500~599 服务端错误状态码 常见的响应头 5.2、缓存相关 Expires：缓存文档的有效期；过期文档需要更新。过期之前使用本地缓存；HTTP1.1 的客户端和缓存会将非法的日期格式（包括0）看作已经过期。 ETag：和If-None-Match 配合使用。 Last-Modified：用于指示资源的最后修改日期和时间。 5.3、响应数据 Content-Type：服务器告诉浏览器自己响应的对象的类型和字符集。 ///Content-Type:大类/小类 //通常显式指定为 text/html Content-Type:text/html;charset=utf-8 Content-Type:text/html;charset=GB2312 Content-Type:image/png Content-Type:message/http Content-Type:audio/mpeg Content-Type:video/quicktime Content-Type:multipart/form-data Content-Type:image/png Content-Type:application/vnd.ms-excel Content-Length：指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。只有当客户端使用持久连接时才需要这个数据。 例如: Content-Length: 19847 Content-Encoding：服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解压之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 Content-Language：服务器告诉客户端自己响应的对象所用的语言。例如：Content-Language:da。没有设置该字段则认为实体内容将提供给所有的语言阅读。 5.4、分段下载与断点续传 Content-Range：响应的资源范围。 在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。 5.5、其它字段 Set-Cookie： 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie。 例如:Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com P3P：用于跨域设置 Cookie, 这样可以解决 iframe跨域访问 cookie 的问题； Allow：服务器支持哪些请求方法（如GET、POST等）； Date：表示消息发送的世界标准时间，如 Date:Mon,31Dec200104:25:57GMT； Location：用于重定向一个新的位置，包含新的URL地址；表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是用在更换域名的时候。 WWW-Authenticate：该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。 //可以看出服务器对请求资源采用的是基本验证机制。 WWW-Authenticate:Basic MTM4MDAwMDAwMDA6YTEyMzQ1Njc Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机网络/HTTPS协议.html":{"url":"计算机基础/计算机网络/HTTPS协议.html","title":"HTTPS协议","keywords":"","body":"HTTPS 协议 HTTPS 协议 = HTTP 协议 + SSL/TLS 协议 HTTPS 协议全称 超文本传输安全协议； 基于 HTTP 协议，在不安全的 TCP 通道中，利用 SSL/TLS 协议加密 HTTP 报文，从而进行安全的通信； 通过 数字证书 校验客户端与服务器的真实身份，对窃听和中间人攻击提供一定程度的合理防护，保护数据的隐私与完整性； 相比于 HTTP 协议使用的 80 端口号，HTTPS 协议使用 443 端口！ HTTPS 协议的特点 兼容性：基于 HTTP 协议，通过 SSL\\TLS 提供加密处理数据、验证对方身份以及数据完整性保护； 保密性：采用混合加密技术，中间者无法直接查看明文内容； 完整性：确保传输的数据不被中间人冒充或者篡改； 真实性：通过证书认证客户端与服务器的身份，辨别中间人，防止“域名劫持”； 1、安全套接层 SSL/TLS 安全套接层 SSL 是 Secure Sockets Layer 的缩写，在上世纪90 年代中期由网景公司Netscape设计； 发明 SSL 协议是为了解决 HTTP 协议明文传输存在的一些问题，如传输内容会被偷窥（嗅探）和篡改； 到了1999年，由于 SSL 被广泛应用，已经成为互联网上的事实标准；IETF 就将把 SSL 标准化。 标准化之后的名称改为 TLS ： Transport Layer Security 传输层安全协议； 介于传输层和应用层之间，是一个子层； 提供数据安全和数据完整的服务； 保证数据不泄露、传输过程中不被篡改； 对传输层的数据进行加密后，再传输； 1.1、加密方式 SSL/TLS 加密过程中涉及到的一些密码学名词： 明文：未被加密过的原始数据。 密文：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全； 密文也可以被解密，得到原始的明文； 密钥：是一种在 明文转换为密文 或将 密文转换为明文 的算法中输入的参数； 密钥分为 对称密钥 与 非对称密钥 ，分别应用在 对称加密 和 非对称加密 上。 1.1.1、 对称加密 对称加密又叫做私钥加密： 即信息的发送方和接收方使用同一个密钥去加密和解密数据； 私钥表示个人私有的密钥，即该密钥不能被泄露； 加密过程如下：明文 + 加密算法 + 私钥 -> 密文； 解密过程如下：密文 + 解密算法 + 私钥 -> 明文； 对称加密的特点： 算法公开、加密和解密速度快，适合于对大数据量进行加密； 但私钥泄露，密文很容易就被破解，所以对称加密的缺点是密钥安全管理困难。 常见的对称加密算法有 DES、AES、3DES、TDEA、Blowfish、RC5 和 IDEA 等。 1.1.2、 非对称加密 非对称加密也叫做公钥加密： 使用公钥和私钥，且二者成对出现； 公匙与私钥具有一定的数学关系，而非任意两个密匙； 私钥由自己保存，不能对外泄露； 公钥指的是公共密钥，任何人都可以获得公钥； 用公钥或私钥中的任何一个进行加密，用另一个进行解密； 被公钥加密的密文只能被私钥解密： 明文 + 加密算法 + 公钥 -> 密文 密文 + 解密算法 + 私钥 -> 明文 被私钥加密的密文只能被公钥解密： 明文 + 加密算法 + 私钥 -> 密文 密文 + 解密算法 + 公钥 -> 明文 由于加密和解密使用了两个不同的密钥，相对于对称加密，非对称加密安全性更好。 但非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 在非对称加密中使用的主要算法有RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。 1.2、哈希算法 使用 Hash算法将任意长度的二进制明文串映射为较短的二进制串（ Hash 值），并且不同的明文很难映射为相同的 Hash 值（发生碰撞）。 这意味着对于某个文件，无需查看其内容，只要对其 Hash 计算后，结果相同，则说明文件内容没有被篡改。 Hash 算法与加密是不同的： Hash是将目标文本转换成具有相同长度、不可逆的 消息摘要； 加密是将目标文本转换成具有不同长度的、可逆的密文； 常用的Hash 算法有：MD5、SHA1、SHA256 等。 1.3、数字摘要 数字摘要是对内容进行 Hash 运算，获取唯一的哈希值来映射原始完整内容。 根据 Hash函数的抗碰撞性特性，数字摘要可以判断内容是否被篡改。 2、如何保证 HTTPS 协议是安全的？ 我们知道 HTTPS 协议是安全的，那么在通信过程中是如何保证其安全性的呢？ HTTPS 传输的简单过程： 1、首先建立 443 端口的 TCP 通道 (HTTP 协议建立端口为 80 的 TCP 通道)； 2、进行 SSL 安全参数的握手；握手之后就可以进行数据的加密与解密； 3、客户端通过 TCP 通道向服务端发送数据；发送之前将数据加密，服务端收到数据后对数据解密； 4、服务端通过 TCP 通道向客户端发送数据；发送之前将数据加密，客户端收到数据后对数据解密； 关键是在第 2 步中， SSL 安全参数的握手！ 2.1、SSL/TLS 安全参数的握手 安全套接层 SSL/TLS 介于传输层和应用层之间，通过握手传递安全参数，来解决传输中数据安全的问题： 由于非对称加密算法的加密/解密效率不高，对称加密算法的密匙不能在互联网传输； 因此 SSL/TLS 的握手使用非对称加密算法与对称加密两种算法； 握手阶段：采用 非对称加密 算法，客户端与服务端需要商定加密算法、交换制作密匙的参数，最终各自生成 对称加密 算法使用的密匙； 数据通信阶段：使用 对称加密的私钥 加密与解密数据。 握手阶段可以分为下述步骤： step1 客户端提供自己支持的 SSL/TLS 协议版本号、加密方法列表、压缩方法列表以及生成一个随机数； step2 服务器确认双方使用的SSL/TLS协议版本号、加密方法、压缩方法，并给出非对称加密的公匙、以及生成一个随机数； step3 客户端生成一个新的随机数，并使用服务器的公钥加密这个随机数，发给服务器； step4 服务器使用自己的私钥，解密客户端发来的随机数； step5 客户端和服务器根据约定的加密方法，使用上述的三个随机数，生成 会话密钥 session key ，用来加密接下来的通信过程。 上述流程需要注意： 生成 会话密钥 session key 需要三个随机数； 服务器非对称加密的公钥和私钥只用于加密和解密 对话密钥，只用到一次，无其他作用； 2.2、被拦截的公钥 假如有一个中间人，拦截服务器的公匙，并向客户端发送自己伪造的公匙，那么依旧可以获取并篡改通信内容！ 在上述过程中，客户端与服务端，均不知道他们的通信被中间人拦截了。 怎么才能避免中间人拦截呢？？可以对客户端对服务端的身份做合法性的校验，保证客户端收到的公钥是服务端的公钥，而不是中间人伪造的公钥！ 2.3、数字证书 合法性的校验，需要找一个客户端和服务器都信任的组织： 可信任组织：只有客户端和服务端都认为是公平的、安全的组织； 该组织证明 “客户端就是客户端”、“服务端就是服务端”，剔除中间人； 服务器将公匙交给该组织，该组织在验证服务器身份后颁布一个证书，证书包含公钥以及服务器的身份信息等； 客户端通过验证证书的合法性来确保公匙来自于服务端； 可信任的组织，一般都是数字证书颁发机构，如CA机构！ 证书是用来认证公钥持有者身份的电子文档，防止第三方进行冒充。一个证书中包含了公钥、持有者信息、证明证书内容有效的签名以及证书有效期，还有一些其他额外信息。 数字证书，也可以称为 CA证书、HTTPS 证书、SSL/TLS 证书等，是由数字证书颁发机构 CA 签发的数字证书。 数字签名，证书指纹：CA签发的证书内容，一段加密的密文； CA机构得到服务端的一些必要信息，如身份信息，公钥、服务器域名等； 使用 Hash 算法生成证书内容的摘要； 再用自己的私钥给这份摘要加密，生成 数字签名； 综合已有的信息，生成分别包含公钥和私钥的两个证书。 2.3.1、证书信任链 数字证书的生成是分层级的，下一级的证书需要其上一级证书的私钥签名；也就是证书由颁发者的私钥签名。 根CA认证中心的证书称为根证书，根证书自己认证自己的有效性，根证书是整个证书体系安全的根本，如果根证书出了问题，它下面所有子证书都不可被信任。 因为子证书都是依赖根证书证明自己的有效性的，从而形成证书信任链。 2.3.2、数字证书的合法性 如何确保证书颁发机构颁布的证书不被拦截篡改呢？我们需要了解证书的签名与认证方式！ 数字签名过程： 1、证书颁发者用数字摘要算法（ Hash），将服务器的公钥和身份信息等生成一个 摘要； 2、证书颁发者根据非对称加密使用自己的私钥将摘要进行加密，生成 数字签名； 3、证书颁发机构将 服务器的公钥和身份信息等 与 数字签名 合并，形成 数字证书 ； 数字证书验证合法性： 服务器将数字证书发送给客户端，客户端需要对数字证书的合法性进行校验！！ 1、根据证书信任链，找到该证书的上一层CA认证中心的数字证书（内置证书）； 2、从上一层数字证书中获取公钥，使用该公钥对收到证书的数字签名进行解密生成摘要信息； 3、使用数字摘要算法将收到的证书中的公钥和身份信息等生成摘要信息； 4、步骤2、3 的摘要信息（ Hash值）比对，如果能匹配，就说明数字证书没有被篡改； 2.3.3、证书颁发机构的信任问题 根证书是整个证书体系安全的根本。 采用数字证书方式是为了解决公钥传输的中间人攻击问题，假如证书颁发机构的公钥传输也出现中间人攻击问题，那么问题死循环了？ 可以把证书颁发者的公钥预先加载在操作系统中！如果操作系统和客户端的公钥也被篡改，那就没招了；所以不要轻易信任/安装未知证书。 苹果、微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认安装在操作系统中，并且设置为操作系统信任的数字证书。 2.4、证书认证的 SSL/TLS 安全参数握手 HTTPS 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。 HTTPS 的单向验证和双向验证 HTTPS 的证书认证，大多数也都是采用 单向认证 ，也就是客户端向服务端请求证书、验证服务端身份。 而像银行等机构，对安全性的要求更高，服务端也要求验证客户端的身份，即 双向认证 的方式。 Question1、HTTPS 是否需要防域名劫持？ 没必要防域名劫持！客户端除了校验证书的有效性，还会比较证书上的域名是否与自己要访问的域名一致。因此，只要服务器的证书是可信的且客户端不跳过 证书验证 这个步骤，HTTPS 能够防止域名劫持。 Question2、客户端的证书要提前安装吗？ 如果是权威CA机构签发的证书，在系统默认信任证书列表中，则会直接通过验证，一般不需要提前安装； 如果是私人签发的证书，未在系统信任列表中的证书，需要提前安装。 Question3、HTTPS使用了几套非对称加密？ SSL 握手阶段，协商对称加密密钥时使用的非对称加密，服务器生成，私钥在服务端； 数字证书签名加密，CA机构使用的非对称加密，私钥在CA机构那边。 2.5、session 的恢复 如果出于某种原因，对话中断，就需要重新进行 SSL/TLS 安全参数握手，这时有两种方法可以恢复原来的 session： 一种叫做 session ID ：每一次对话都有一个编号，如果对话中断，下次重连的时候，只要客户端给出 session ID ，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信； 另一种叫做 session ticket：客户端发送服务器在上一次对话中发送过来的 session ticket。这个 session ticket 是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。 参考文章： HTTPS 与 SSL 证书概要 HTTPS协议 Https原理及流程 HTTPS安全通信过程 客户端认证https服务端证书过程:证书链 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机图形学/矩阵的变换.html":{"url":"计算机基础/计算机图形学/矩阵的变换.html","title":"矩阵的变换","keywords":"","body":"空间的平移、缩放、旋转 1、二维空间的变换 1.1、平移 平移可以使用平移向量 (Tx,Ty) 来表示: 每个点都是按照相同的方向移动相同的距离。 使用 2x2 矩阵来表示平移 /// 没有任何改变 {{1,0},{0,1}} * {x,y} = {x,y}; /// 拉伸矩阵 {{2,0},{0,3}} * {x,y} = {2x,3y}; /// 复合变换 {{1,3},{2,1}} * {x,y} = {x+3y,2x+y}; 二维矩阵不能能完成平移变换！ 增加一个纬度，使用三维矩阵来平移： {{1,0,0},{0,1,0},{0,0,1}} * {x,y,1} = {x,y,1}; /// 3D矩阵的平移 {{1,0,2},{0,1,3},{0,0,1}} * {x,y,1} = {x+2,y+3,1}; 也就是说：二维矩阵的平移需要使用三维矩阵来完成！平移操作可以看作一个矩阵，产生这个矩阵的函数，功能上类似一个高阶函数，可以记做 (Tx,Ty)，其中 T 是 Translation ！ /// Tx, Ty 就是待平移的向量 { {1, 0, Tx}, {0, 1, Ty}, {0, 0, 1} } 这种增加一个纬度的做法，称之为 齐次坐标 (Homogeneous) ! 使用 齐次坐标 对齐维度，可以使用统一的方法进行计算！ 1.2、缩放 1.2.1、剪裁空间 对于图形引擎，没有太多的屏幕分辨率，仅仅定义了 [-1, 1] 的区间范围，跨度为 2，这个空间叫做剪裁空间！ 图形引擎仅仅处理剪裁空间的数据，所以需要将 世界坐标 转为 剪裁空间坐标！ /// 矩形在剪裁空间的宽高 100 * (2 / 1920) 150 * (2 / 1080) /// 由于剪裁空间的坐标是 [-1, 1]`，因此坐标还需要 -1 可以使用矩阵变换，将 世界坐标 转为 剪裁空间坐标 ！ /// 缩放 平移 {{2/w,0,0},{0,2/h,0},{0,0,1}} * {{1,0,-2/w},{0,1,-2/h},{0,0,1}} = {{2/w,0,-1},{0,2/h,-1},{0,0,1}}; /// 缩放 * 平移 = 复合变换 1.2.2、缩放 拉伸缩放的功能可以看作一个生成矩阵的函数，记做 S(Sx, Sy)，其中 S 是 Scale! /// 拉伸缩放矩阵 { {Sx, 0 , 0}, {0 , Sy, 0}, {0 , 0 , 1} } 1.3、旋转 如下图，顶点 (x, y) 相对于原点做逆时针旋转！ 相对于原点旋转的功能可以看作一个生成矩阵的函数 R(t)，其中 R 是 Rotation! /// 旋转矩阵 { {cos(t), -sin(t), 0}, {sin(t), cos(t), 0}, {0 , 0 , 1} } 矩阵不满足交换律，所以在做复合变换时，矩阵的顺序对结果产生直接影响！ 思考：如何相对于任意点旋转？ 正方形如何相对于自己的中心点旋转？ 三角形如何相对于一个顶点旋转？ 先将旋转中点移动到原点，然后做旋转，最后再移动回原位置： 将旋转中心平移到原点的矩阵 T(-x,-y)； 旋转矩阵 R(t)； 将旋转中心平移回原位置 T(x, y)； 组合起来就是 T(-x,-y) * R(t) * T(x, y) ； 2、三维空间的变换 2.1、平移 类似于二维变换，看做一个产生矩阵的函数T(Tx,Ty,Tz) { {1, 0, 0, Tx}, {0, 1, 0, Ty}, {0, 0, 1, Tz}, {0, 0, 0, 1}, } {{1, 0, 0, Tx},{0, 1, 0, Ty},{0, 0, 1, Tz},{0, 0, 0, 1}} * {x, y, z, 1} = {x + Tx, y + Ty, z + Tz, 1} 2.2、缩放 类似于二维变换，看做一个产生矩阵的函数S(Sx,Sy,Sz) { {Sx, 0, 0, 0}, {0, Sy, 0, 0}, {0, 0, Sz, 0}, {0, 0, 0, 1}, } {{Sx, 0, 0, 0},{0, Sy, 0, 0},{0, 0, Sz, 0},{0, 0, 0, 1}} * {x, y, z, 1} = {x * Sx, y * Sy, z * Sz, 1} 2.3、旋转 3D 旋转（逆时针旋转 angle 度） 以 X 轴旋转，是 YZ 组成的 2D 坐标系在旋转，x 值不变； 以 Y 轴旋转，是 XZ 组成的 2D 坐标系在旋转，y 值不变； 以 Z 轴旋转，是 XY 组成的 2D 坐标系在旋转，z 值不变； 2.3.1、X轴为旋转轴 /// t 指的是逆时针旋转的角度 { {1, 0, 0, 0}, {0, cos(t), -sin(t), 0}, {0, sin(t), cos(t), 0}, {0, 0, 0, 1} } {{1, 0, 0, 0},{0, cos(t), -sin(t), 0},{0, sin(t), cos(t), 0},{0, 0, 0, 1}} * {x, y, z, 1} = {x, y * cos(t) - z * sin(t), y * sin(t) + z * cos(t), 1} 2.3.2、Y轴为旋转轴 /// t 指的是逆时针旋转的角度 { { cos(t), 0, sin(t), 0}, { 0, 1, 0, 0}, {-sin(t), 0, cos(t), 0}, { 0, 0, 0, 1} } {{cos(t), 0, sin(t), 0},{0, 1, 0, 0},{-sin(t), 0, cos(t), 0},{0, 0, 0, 1}} * {x, y, z, 1} = {x * cos(t) + z * sin(t), y, z * cos(t) - x * sin(t), 1} 2.3.3、Z轴为旋转轴 /// t 指的是逆时针旋转的角度 { { cos(t), -sin(t), 0, 0}, { sin(t), cos(t), 0, 0}, { 0, 0, 1, 0}, { 0, 0, 0, 1} } {{ cos(t), -sin(t), 0, 0},{ sin(t), cos(t), 0, 0},{ 0, 0, 1, 0},{0, 0, 0, 1}} * {x, y, z, 1} = {x * cos(t) - y * sin(t), x * sin(t) + y * cos(t), z, 1} Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"计算机基础/计算机图形学/三维空间的观察.html":{"url":"计算机基础/计算机图形学/三维空间的观察.html","title":"三维空间的观察","keywords":"","body":"三维空间的投影 投影就是从投影中心发出射线，经过三维物体上的每一个点之后，与投影面相交所形成的交点集合。 投影变换：从数学角度观察，投影就是将三维坐标转变为二维坐标的过程；也就是说：投影的本质就是降维！ 1、投影分类 当投影中心到投影面的距离为无穷大时，可以使用平行投影； 当投影中心到投影面的距离为有限值时，适用于透视投影； 1.1、平行投影 平行投影：每个点的投影方向一致！ 根据投影方向与投影面的关系，可以分为： 斜投影： 正交投影：投影方向和投影平面垂直！ 1.2、透视投影 透视投影：使用中心投影法将物体投射到投影面上，从而获得的一种较为接近视觉效果的单面投影图！ 根据屏幕切割世界坐标系的坐标轴数量，可以分为： 一点透视； 二点透视； 三点透视； 1.2.1、灭点 模拟人的眼睛于一个点，透过一个平面观察立方体！ 按照透视投影的规则：观察的四边形，随着视线的延伸，会越来越小，直到变成一个点（灭点），然后消失；这是一种 ‘近大远小’ 的观察效果！ 以中轴线为分界线，眼睛与灭点之间可以看作对称的效果；同样高度的线段，随着距离眼睛越近，看起来就越高；随着距离灭点越近，看起来就越小！ 灭点 ：在透视投影中，一束平行于投影面的平行线投影可以保持平行，而不平行于投影面的平行线的投影会聚集到一个点，这个点成为灭点（Vanishing Point）。 灭点可以看作是无限远处的一点在投影面上的投影。 如果是平行透视，只有一个灭点，在对象中间的后方。方法是延长物体左右纵深的两条有会聚趋势的线，向后方会聚于一点，平行透视能产生纵深感。 如果是成角透视，有两个灭点，在对象的两侧的后方； 方法是分别延长物体左右两方的有会聚趋势的四条线，两两交于对象左右两边的后方，形成两个灭点； 成角透视是最符合视觉习惯的透视，很富有立体感； 凡是平行于画面的直线都没有灭点，凡是与画面有一定角度的一组平行线，都有灭点。 如果这个角度是90度，就是平行透视；否则是成角透视。 影灭点——正面自然光照射，阴影向后的消失点。标识为VS（Vanishingofshadow），光灭点——影灭点向下垂直于触影面的点。标识为VL（Vanishingoflight） 2、三维变换流水线 在整个渲染管线中，一个顶点可能会经历一下六种坐标空间之间的转换： 1、模型坐标：模型坐标表示的是模型中所有点相对于模型本身原点的一个坐标系；属于右手坐标系； 2、世界坐标：世界坐标是指模型中每个点，相对于世界坐标系原点的一个坐标位置；属于右手坐标系； 3、观察坐标（相机坐标或者人眼坐标）：在世界坐标中的模型，相对于观察坐标的映射；右手或者左手坐标系； 4、投影坐标：投影的最终目的是将一个三维物体展示在 二维平面的剪裁空间 里；属于左手坐标系； 如果是正交投影，可以将剪裁空间想象为一个立方体空间； 如果是透视投影，则剪裁空间是一个锥体，物体呈现方式就是近大远小的效果； 5、NDC坐标：将剪裁空间坐标系的结果进行归一化；属于左手坐标系； 在 Metal 中(x,y) 取值范围 [-1,1], z 取值范围 [0,1]； 在 OpenGL 中，Z 轴的取值范围为 [-1,1] 且使用右手坐标系 6、屏幕坐标：所有顶点最终会转换成在屏幕坐标系上的一个坐标 /// 保存常量数据 typedef struct { matrix_float4x4 worldMatrix; /// 模型从模型坐标转换到世界坐标：平移、旋转、缩放等最终形成的复合变换 matrix_float4x4 viewMatrix; /// 世界坐标到相机坐标上的转换：两个坐标系的切换 matrix_float4x4 projectionMatrix; /// 透视投影：使得在平面上产生物体近大远小的效果 } Uniforms; 2.1、世界坐标系与观察坐标系 从模型坐标，到世界坐标的转换，可以通过矩阵的平移、旋转来轻松实现！ 从世界坐标系到观察坐标系的转换，稍显复杂些！因为观察点（眼睛或相机）是随时移动的，我们需要一个算法，通过给定眼睛的位置、视线的方向，来求出此刻的复合变换矩阵！ 在观察坐标系中: 观察点在坐标原点； 视线方向为 Z 轴的正方向： 可以是右手坐标系、也可以是左手坐标系；如果是右手坐标系，需要在剪裁空间之前转为左手坐标系； XY 平面和 Z 垂直； 2.1.1、世界坐标系到观察坐标系的公式推导 物体的运动是相对的！ 当物体与观察点的距离越来越大时，可能是： 物体在远离观察点，所以看起来“物体越来越远、越来越小”； 观察点在远离物体，所以看起来“物体越来越远、越来越小”； 物体和观察坐标的相对位置不会发生变换，仅仅求出观察坐标系到世界坐标系的转换矩阵，再将此矩阵用于物体，就能得出观察坐标系下的物体坐标！ 世界上的物体运动是相对的 :随着观察点在世界的移动，观察到的物体也会变得有所不同； 如：观察点向 X 轴的正方向移动，则物体相对而言应该向 X 轴的负方向移动； 如：沿着 X 轴逆时针旋转，观察点向上移动，物体相对向下移动； 三维空间中世界坐标系的点如何转换到观察坐标系？ 1、将观察点在世界坐标系的位置 (x, y, z) 平移 (-x, -y, -z) 到世界坐标系的原点；使观察坐标系的原点与世界坐标系的原点重合； 2、观察点 x, y, z 三个方向分别相对于世界坐标系 逆时针 旋转了 (ax, ay, az) 2.1、旋转 Vx 轴 -ax，将 Vz 轴旋转到 XZ 平面上； 2.2、旋转 Vy 轴 -ay，将 Vz 轴于 Z 轴重叠； 2.3、旋转 Vz 轴 -az，将 Vx 与 X 轴、Vy 与 Y 轴重叠； /// 矩阵变换：平移、旋转 matrix_float4x4 lookAt(float eyeX, float eyeY, float eyeZ, float angleX, float angleY, float angleZ) { matrix_float4x4 matrix = matrix_multiply(matrix4x4_identity(), matrix4x4_translation(-eyeX, -eyeY, -eyeZ)); matrix = matrix_multiply(matrix, matrix4x4_rotationX(-angleX)); matrix = matrix_multiply(matrix, matrix4x4_rotationY(-angleY)); matrix = matrix_multiply(matrix, matrix4x4_rotationZ(-angleZ)); return matrix; } 2.2、观察坐标系下的视景体 距离观察点较近的平面为 近剪裁平面，垂直于观察方向向量，距离为 zNear ； 距离观察点较远的平面为 远剪裁平面，垂直于观察方向向量，距离为 zFar ； 透视投影的投影线互不平行，相交于视点；因此同样尺寸的物体，近处的投影效果大，远处的投影效果小；从而产生现实世界中 近大远小 的效果； 影响透视投影最终效果的参数： 视野的大小：如果视野很窄，则仅能看到物体的某一部分； 观察点与近剪裁平面的距离zNear ：如果距离太近，超出视野范围，则没必要去处理这部分数据； 观察点与远剪裁平面的距离zFar：如果距离太远，超过了 `zFar ，也没必要处理这部分数据； 最终处理透视投影：使用近剪裁平面与远剪裁平面，做成一个锥形空间（剪裁空间），在锥形剪裁空间之外的物体不显示，仅显示锥形剪裁空间之内的物体！ 2.2.1、透视投影公式推导 在视景体中的点，是如何映射到 Z[0, 1] 的剪裁空间的 (体积为 2 * 2 * 1)？ 左手坐标系，随着视线看的越来越远，Z 值越来越大； 眼睛看到的范围称为 视场 fov； 当 zNear 超过 zFar 时，将什么也观察不到； 从数学角度而言，透视投影就是对世界坐标系中的每一个点，找出它在屏幕上对应的坐标；该点和视点的连线与屏幕的交点，正是其屏幕坐标！ 数学问题：已知视景体的 YZ 平面某一点 (y, z), 求取对应在剪裁空间的 YZ 平面的点 (y‘, z’) ！ 那么推导过程如下所示： 1、根据物体与视野的范围比值，可得关系式 y / y0 = y' / 1； 2、根据正切函数得到公式 tan(fov / 2.0) = y0 / z； 3、由此可以推导出 y' = y / (z * tan(fov / 2.0)); 4、不妨令 f = 1.0 / tan(fov / 2.0) ; 5、那么有 y' = f / z * y; 同样的，在 XZ 平面可以推导出 x' = x / (z * tan(fovx / 2.0)); 我们的视口 viewport 的宽高比为 aspect = weight / height; 也就是说 x0 / y0 = aspect; 近一步推出 tan(fovx / 2.0) / tan(fovy / 2.0) = aspect; 此时：tan(fovx / 2.0) = aspect * tan(fovy / 2.0) = aspect / f; 所以有：x' = f / (z * aspect) * x; 眼睛看到的是近大远小的视觉效果： 眼睛看到的 Z 值并非成比例的减小； 人的视觉：越近越重要，越远越容易忽略； 考虑使用曲线来表达 z' 与 'z' 的对应关系 z' = m / z + c； 当 zFar 无穷趋近于 1，zNear 无穷趋近于 0 时有 m / zFar + c = 1; m / zNear + c = 0; 从而推导出 m = zFar * zNear / (zNear - zFar); c = zFar / (zFar - zNear); 此时 z' = (zFar * zNear / (zNear - zFar)) / z + zFar / (zFar - zNear)； 最终推导出从观察坐标系到剪裁空间的坐标变换： x' = f / (z * aspect) * x; y' = f / z * y; z' = (zFar * zNear / (zNear - zFar)) / z + zFar / (zFar - zNear); /// 其中 f = 1.0 / tan(fov / 2.0) 那么如何将上述关系组织为矩阵变换呢？x', y'都包含了 1/z, 不妨令： x'' = x' * z; y'' = y' * z; z'' = z' * z; 此时有： x'' = f / aspect * y; y'' = f * y; z'' = (zFar * zNear / (zNear - zFar)) + zFar / (zFar - zNear) * z; /// 其中 f = 1.0 / tan(fov / 2.0) 相应的透视投影矩阵 matrix_perspective 为： float f = tan(M_PI_2 - 0.5 * fovy); float zs = farZ / (farZ - nearZ); { {f / aspect, 0, 0, 0}, { 0, f, 0, 0}, { 0, 0, zs, -nearZ * zs}, { 0, 0, 1, 0} } 注意：矩阵的 [3][2] = 1 是基于图形学引擎的特性而设置的： {x, y, z, 1} * matrix_perspective = { f / aspect * x, f * y, (zFar * zNear / (zNear - zFar)) + zFar / (zFar - zNear) * z, z } 图形学引擎最终会 xyz / w，所以最终结果仍为我们推算出的： { f / (z * aspect) * x, f / z * y, (zFar * zNear / (zNear - zFar)) / z + zFar / (zFar - zNear), 1 } Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:19 "},"iOS开发/Runtime/Objective_C简介.html":{"url":"iOS开发/Runtime/Objective_C简介.html","title":"Runtime","keywords":"","body":"Objective-C 简介 1、Objective-C 语言 Objective-C 是 C 语言的超集，兼容标准 C 语言的大部分语法；在 C 的基础上增加了面向对象的特性，是一门面向对象的语言。 1.1、 面向对象的编程功能 Objective-C 在 C 的基础上增加了面向对象的特性：如封装、继承、多态、消息传递等！ 1.1.1、 封装 封装是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。 优点1：隐藏内部实现细节,设置访问权限,提高了数据的安全性。 优点2：任何出入的数据都要流经接口,通过重写-set方法可以起到过滤数据的作用。 1.1.2、 继承 指一个对象直接使用另一对象的属性和方法。Objective-C 的继承具有单继承的特点（不可以多重继承），每个子类都只能有一个直接父类。 当子类继承父类时，子类可以得到父类全部的成员变量与方法。 优点：抽取重复代码、建立联系； 缺点：耦合性强； 1.1.3、 多态 不同的接收器调用同一方法可以获得不同的结果。实现多态的条件： 必须存在继承关系； 子类重写父类的方法； 父类声明的变量指向子类对象； Objective-C 指针类型的变量有两个：编译时类型和运行时类型。编译时类型由声明变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现多态。 @interface FatherModel : NSObject - (void)eat; @end @interface BigChildModel : FatherModel @end @interface SmallChildModel : FatherModel @end { //此时编译时类型和运行时类型不一致，发生多态 FatherModel *bigModel = [[BigChildModel alloc]init]; FatherModel *smalModel = [[SmallChildModel alloc]init]; [bigModel eat]; [smalModel eat]; //父类 FatherModel 的 -eat方法表现的形式为多种形态，这就叫多态 } 1.1.4、 消息传递 在OOP中，消息传递是指一种在对象之间发送和接收消息的通信模式；对象通过彼此传递消息协同工作。 1.2、 Objective-C 的运行时 Objective-C 既具有与许多面向对象的语言类似的静态语言的特性，又有动态语言的特性。它将许多处理类型、消息和方法决议的工作转移到运行程序的时候进行，而不是在编译或者链接时处理。 Objective-C 主要的动态特性有： 动态类型：在运行时决定对象的类型。如声明变量为 id 类型，编译器无法知道其类型，系统运行时决定对象的类型； 动态绑定：在程序运行时（而不是编译时）将消息与方法对应起来的处理过程。基于动态类型，在实例对象的类型被确定后，响应的消息也被完全确定。 动态绑定实现了 OOP 的多态性，能够在不影响已有代码的情况下将新对象和代码添加到程序中，从而降低程序之间的耦合； 动态加载：根据需求加载 Objective-C 代码，而无需在启动程序时加载它的所有组件。苹果公司提供了 bundle 机制，使用NSBundle 类管理资源包bundle。 对象消息传递：接收器和接收器中被调用的方法在运行时决定！ 动态方法决议：以动态方式实现方法。如 @dynamic 指令告知编译器与该属性关联的方法以动态方式实现；NSObject的类方法 +resolveClassMethod:与+resolveInstanceMethod:以动态方式实现由选择器指定的实例和类方法。 对象消息转发机制：当对象收到与其方法不匹配的消息时，通过消息转发机制可以使对象执行用户预先定义的处理过程；将消息发送给能够做出回应的其它接收器；将所有无法识别的消息都发送给同一接收器；既不执行处理过程也不使程序崩溃，默默的吞下消息。 1.3、 Objective-C、C 与 Runtime 的关系 Runtime 是一套由C、C++、汇编实现的 API； 调用 OC 的方法，都是在调用 Runtime API 接口，由 API 接口执行 C 代码； Runtime 可以理解为 Objective-C 与 C 桥接： Objective-C = C + Preprocessor + Runtime； 编译器 Clang 把 OC 代码编译成 C++ 代码； 运行时系统 Runtime 执行编译后的代码； 运行时特性：向编译后的类添加方法、转发消息、交换方法等； Runtime 主要做了两个核心功能： 封装：将 C 语言的结构体封装为 Objective-C 的类； 消息机制：执行 Objective-C 的方法，实际是通过 Runtime 的消息机制去执行 C 语言函数； 2、Objective-C 的类与对象 在Objective-C中，对象是广义的概念，类也是对象，所以严谨的说法应该是类对象和实例对象。既然实例所属的类称为类对象，那类对象有所属的类吗？有，称之为元类(Metaclass)。 2.1、类 在Objective-C中我们接触最多的也是最基本的就是类与实例，类使用关键字 Class表示！当我们在创建类或者实例时，是否考虑过类和实例到底是什么？ Objective-C 类本质是一个结构：在 objc-runtime-new.mm 文件中找到Class 是一个objc_class类型的结构指针， ///Class是一个 objc_class 类型的结构指针： typedef struct objc_class *Class; /// objc_object 主要持有一个 isa 指针 struct objc_object { private: isa_t isa; ///指向所属的类 public: Class ISA();// ISA() 假设不是tagged pointer对象 Class getIsa();// getIsa() 允许这是tagged pointer对象 Class changeIsa(Class newCls);//更改现有对象的 isa，如果这是一个新对象，则使用initIsa()来提高性能。 } // objc_class 的结构成员 struct objc_class : objc_object { Class super_class; // 指向当前类的父类 cache_t *cache; // 用于缓存指针和 vtable，加速方法的调用 class_data_bits_t bits; class_rw_t *data() {//存储类的方法、属性、遵循的协议等信息 return bits.data(); } }; struct class_data_bits_t { uintptr_t bits;//值是上面的 FAST_ 标志。 public: class_rw_t* data() { return (class_rw_t *)(bits & FAST_DATA_MASK); } } // ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中 struct class_rw_t { // Symbolication 知道此结构的布局。 uint32_t flags; //运行时使用的一些位标识，比如: `CLS_CLASS(0x1L)`表示该类为普通类，`CLS_META (0x2L)`表示该类为元类； uint32_t version; // 类的版本信息(默认为0) const class_ro_t *ro; method_array_t methods; // 方法 property_array_t properties; //属性 protocol_array_t protocols; // 协议 Class firstSubclass; Class nextSiblingClass; char *demangledName; }; //class_ro_t 存储了该类在编译时就已经确定的属性、方法以及遵循的协议 struct class_ro_t { uint32_t flags;//标志 uint32_t instanceStart; uint32_t instanceSize; // 该类的实例变量大小 const uint8_t * ivarLayout; const char * name;//类的名称 method_list_t * baseMethodList;//基础方法列表 protocol_list_t * baseProtocols;//基础协议列表 const ivar_list_t * ivars;//变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties;//基础属性列表 //获取基础方法列表 method_list_t *baseMethods() const { return baseMethodList; } }; 分析主要的结构成员： isa 指针指向所属的类，是和 Class 同类型的 objc_class 结构指针； 实例对象的isa指向所属的类，实例方法存储在所属的类中； 类的isa指向所属的元类，元类中存储着类方法，当访问类方法时通过该类的isa指针从元类中寻找方法对应的函数指针； super_class 指针指向该类的父类，如果是根类（如NSObject或NSProxy）, 则 super_class为NULL； cache 缓存最近调用的方法：对象调用方法的过程是个查找 methodLists 的过程，如果每次调用都去查找一遍，效率会非常低。 ivars 成员变量链表，存储每一个实例变量的地址；是结构体 class_ro_t 的成员，在编译时已经确定下来， 运行时不能再改变该内存布局；由于 class_rw_t没有变量表，所以不能在分类增加实例变量； methodLists 存放方法的链表，当该类为普通类时，存储实例方法；如果是元类则存储的类方法； Runtime对于调用过的方法，会以映射的方式保存在 cache中，系统调用方法时首先在cache中查找，没有找到时才会去methodLists中遍历获取指定的方法；这对于多次调用的方法，大大的提升了效率！ protocols 存放协议的链表； 2.1.1、结构成员isa指针的使用 a：利用 isa 指针获取其所属的类 根类 NSObject 的API提供了用来获取指定对象所属的类的一些方法： /* @return 返回自身 */ + (Class)class { return self; } /* @return 返回该实例所属的类 */ - (Class)class { return object_getClass(self); } /* 获取 obj 的 isa 指针 * @param obj 指定对象 * 如果是实例对象，那么该实例对象的 isa 指向其所属的类； * 如果是一个类，那么该类的 isa 指向其所属的元类； * @note 如果 obj 为 nil ，则返回 nil */ Class object_getClass(id obj){ if (obj) return obj->getIsa(); else return Nil; } 示例1、测试 NSObject 的class方法 @interface SuperModel : NSObject @end @interface Model : SuperModel @end { Model *objct = [[Model alloc] init]; id object_class = objct.class; id model_class = Model.class; NSLog(@\"objct.class == %@ : %p\",object_class,object_class); NSLog(@\"Model.class == %@ : %p\",model_class,model_class); } /* 打印数据 objct.class == Model : 0x10071f7d8 Model.class == Model : 0x10071f7d8 */ 分析打印数据：实例方法-calss 返回该实例所属的类；类方法 +calss 返回该类自身。 再次获取对象 objct 与类 Model 的 isa 指针： { id object_isa = object_getClass(objct); id model_class_isa = object_getClass(Model); NSLog(@\"objct -> isa == %@ : %p\",object_isa,object_isa); NSLog(@\"Model -> isa == %@ : %p\",model_class_isa,model_class_isa); NSLog(@\"Model_ISA_isMeta === %d\",class_isMetaClass(model_class_isa));//判断一个类是否是元类 } /* 打印数据 objct -> isa == Model : 0x10071f7d8 Model -> isa == Model : 0x10071f7b0 Model_ISA_isMeta === 1 */ 分析打印数据：实例对象 objct 的 isa 指针指向类Model；类Model 的 isa 指针指向了元类。 那么元类的 isa 指针指向何处？元类到底是什么？我们留作疑问，稍后在讲解！ b：利用isa 指针判断是否是某个类 根类NSObject的API提供用来判断指定对象是否是某个类的方法： /* 判断该类的元类是否是 cls * @note object_getClass((id)self) 获取该类的元类 */ + (BOOL)isMemberOfClass:(Class)cls { return object_getClass((id)self) == cls; } /* 判断该实例对象所属的类是否是 cls * @note [self class] 获取该实例所属的类 */ - (BOOL)isMemberOfClass:(Class)cls { return [self class] == cls; } /* 判断该类的元类或者父元类 是否是 cls * @note for 循环遍历 superclass ，直到根元类时tcls = nil，for 循环停止 */ + (BOOL)isKindOfClass:(Class)cls { for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) { if (tcls == cls) return YES; } return NO; } /* 判断该实例对象所属的类 或者 父类 是否是 cls * @note for 循环遍历 superclass ，直到根类时tcls = NULL，for 循环停止 */ - (BOOL)isKindOfClass:(Class)cls { for (Class tcls = [self class]; tcls; tcls = tcls->superclass) { if (tcls == cls) return YES; } return NO; } 示例2、 { //注意：根元类的superclass指向根类 [NSObject isKindOfClass:NSObject.class];// YES [NSObject isMemberOfClass:NSObject.class];//NO [SuperModel isKindOfClass:SuperModel.class];//NO [SuperModel isMemberOfClass:SuperModel.class];//NO [SuperModel.new isKindOfClass:SuperModel.class];//YES [SuperModel.new isMemberOfClass:SuperModel.class];//YES } 2.1.2、父类super_class 根类NSObjectAPI提供了获取指定类的父类的方法： @property (readonly) Class superclass; + (Class)superclass; 那么这两个方法有何区别呢？我们去研究下它们的底层实现： /* 首先获取该实例所属的类，接着获取类的父类 */ - (Class)superclass { return [self class]->superclass; } /* 获取该类的父类 */ + (Class)superclass { return self->superclass; } 示例3、测试NSObject的superclass方法 元类的父类指向何处？父类的元类指向何处？ { id model_isa_superclass = class_getSuperclass(object_getClass(Model));//获取 Model 元类的父类 id model_superclass_isa = object_getClass(Model.superclass);//获取 Model 父类的元类 NSLog(@\"model_isa_superclass == %@ : %p\",model_isa_superclass,model_isa_superclass); NSLog(@\"model_superclass_isa == %@ : %p\",model_superclass_isa,model_superclass_isa); NSLog(@\"Model_superISA_isMeta == %d\",class_isMetaClass(model_superclass_isa)); } /* 打印数据 model_isa_superclass == SuperModel : 0x10071f710 model_superclass_isa == SuperModel : 0x10071f710 Model_superISA_isMeta == 1 */ 分析打印数据：元类的父类与父类的元类指向相同的类，都指向元类； 2.1.3、获取结构objc_class 的其它成员信息 Runtime 函数库提供了获取结构objc_class成员信息的函数： /* 获取指定类的类名 * @param cls 类. * @return 如果 class 为 nil，则返回空字符串 */ const char *class_getName(Class cls); /* 获取类定义的版本号。 */ int class_getVersion(Class cls); /* 设置类定义的版本号。 * @param version 新的版本号， int 型数据类型 * @note 可以使用类定义的版本号来提供类表示给其他类的接口的版本控制。 * 这对于对象序列化特别有用，在这种情况下，识别不同类定义版本中实例变量布局的更改非常重要。 */ void class_setVersion(Class cls, int version); /* 获取指定类的实例大小（字节数） * @return 如果 cls 为nil，则返回 0 字节。 */ size_t class_getInstanceSize(Class cls); 2.1.4、类的实例变量链表：ivars //变量 Ivar 是个结构指针，指向结构体实例 objc_ivar typedef struct ivar_t *Ivar; //变量的结构 struct ivar_t { int32_t *offset;//变量偏移量 const char *name;//变量名称 const char *type;//变量数据类型 uint32_t size; uint32_t alignment_raw; // 对齐有时是 -1;使用 alignment() uint32_t alignment() const { if (alignment_raw == ~(uint32_t)0) return 1U 2.1.5、获取类的方法链表methodLists /* 选择器类型 SEL 是一个结构指针，指向结构 objc_selector ； * SEL 用于在编译源代码时替换选择器值的唯一标识符； * 所有具有相同选择器值的方法都拥有相同的 SEL 标识符； */ typedef struct objc_selector *SEL; /* 函数指针 IMP 的声明，该函数的前两个参数是默认参数：id 和 SEL * @param id：对于实例方法来说，self 指向实例对象的地址；对于类方法来说，self 指向类的地址； * @param SEL 要执行的 method_t 的结构成员 */ typedef id (*IMP)(id, SEL, ...); //方法 Method 是一个结构指针，指向结构 method_t typedef struct method_t *Method; //变量的结构 struct method_t { SEL name; //选择器类型：描述了方法的名称 const char *types; //描述了方法参数的数据类型 MethodListIMP imp; //函数指针：提供方法实现的地址 struct SortBySELAddress : public std::binary_function{ bool operator() (const method_t& lhs, const method_t& rhs){ return lhs.name 2.1.6、获取类的协议protocols 通知是使用观察者模式实现，用于跨层传递消息的机制； 代理Delegate是一种软件设计模式 代理的传递是一对一的；而通知是一对多的； //协议的本质也是一个 Objective-C 对象 typedef struct objc_object Protocol; struct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // 以下字段并不总是出现在磁盘上。 const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; }; //协议链表 struct protocol_list_t { uintptr_t count; protocol_ref_t list[0]; // variable-size }; 2.1.7、动态创建一个类 Runtime 函数库提供了相关函数动态创建一个类： /* 创建一个新类和元类。 * * @param superclass 创建新类的父类，如果为 nil 则用于创建根类。 * @param name 创建新类的类名称。 * @param extraBytes 在类和元类对象的末尾为索引ivars分配的字节数；通常是 0。 * * @return 新类，如果无法创建类，则为 nil (如，该名称已经在使用中)。 * * @note 通过调用 object_getClass(newClass) 来获得指向新元类的指针。 * @note 要创建一个新类，首先调用 objc_allocateClassPair() 函数。 * 然后使用 class_addMethod() 和class_addIvar() 等函数设置类的属性。 * 构建完类后，调用 objc_registerClassPair( )。 * 新类现在可以使用了。 * @note 实例方法和实例变量应该添加到类本身。类方法应该添加到元类中。 */ Class _Nullable objc_allocateClassPair(Class _Nullable superclass, const char * _Nonnull name, size_t extraBytes); /* 注册使用 objc_allocateClassPair() 分配的类。 */ void objc_registerClassPair(Class _Nonnull cls); /* 用于 Foundation 的键值观察 * 不要自己调用这个函数。 */ Class _Nonnull objc_duplicateClass(Class _Nonnull original, const char * _Nonnull name,size_t extraBytes); /* 销毁一个类及其关联的元类。 * @param cls 要销毁的类。它必须是用 objc_allocateClassPair( ) 分配的 * @warning 如果存在此类或子类的实例，则不要调用。 */ void objc_disposeClassPair(Class _Nonnull cls); 通过上文的学习，我们已经对一个类的结构有了详细的了解！接着我们使用 Runtime 函数库提供的函数动态创建一个类： void dynamicClass_func(void){ NSLog(@\"%s\",__func__); } { //以动态方式创建一个类 Class dynamicClass = objc_allocateClassPair(NSObject.class, \"DynamicClass\", 0); //以动态方式添加一个方法 Method description = class_getInstanceMethod(NSObject.class, @selector(description)); const char *types = method_getTypeEncoding(description); class_addMethod(dynamicClass, @selector(dynamicClass_func), (IMP)dynamicClass_func, types); //注册该类 objc_registerClassPair(dynamicClass); //使用该类 id dynamicOjct = [[dynamicClass alloc] init]; objc_msgSend(dynamicOjct,NSSelectorFromString(@\"dynamicClass_func\")); } 2.2、实例对象 实例对象是我们对类 alloc、new 操作时所创建的，在这个过程中会拷贝实例所属的类的成员变量，但并不拷贝类定义的方法。 调用实例方法时，系统会根据实例的 isa 指针去类的方法列表及父类的方法列表中寻找与SEL对应的函数指针IMP。 我们来看下实例对象的定义: #define ISA_MASK 0x0000000ffffffff8ULL #define ISA_MAGIC_MASK 0x000003f000000001ULL #define ISA_MAGIC_VALUE 0x000001a000000001ULL /** 64 位 isa 指针的一些信息 * @note 非指针型ISA：SUPPORT_NONPOINTER_ISA 64位中存储的内容有：引用计数、析构状态，是否有弱引用指针等等 * @note 一个实例少量的引用计数不会直接存放在 SideTables 中，引用计数存放在extra_rc 中，当其被存满时才会存入相应的SideTables 散列表中 */ struct ISA_BITFIELD { uintptr_t nonpointer : 1; // 是否使用 Tagged Pointer uintptr_t has_assoc : 1; // 是否有关联对象 uintptr_t has_cxx_dtor : 1; // 是否有析构器（在ARC环境下标记对象是否通过ARC来管理的） uintptr_t shiftcls : 33; // 当前对象所属类的指针地址 uintptr_t magic : 6; // 是否完成初始化 uintptr_t weakly_referenced : 1; // 是否被弱引用 uintptr_t deallocating : 1; // 对象是否正在释放内存（进行 dealloc 操作） uintptr_t has_sidetable_rc : 1; // 引用计数是否过大 uintptr_t extra_rc : 19 // 对象的引用计数，当引用计数过大时，使用 sitetable 结构存储引用计数 } #define RC_ONE (1ULL实例对象是 objc_object 结构，该结构体的 isa 变量，指向实例对象所属的类。 2.2.1、self 指针与 super 指针的区别 日常开发中常用的self 与super 指针，我们对它了解多少呢？ 示例：测试self 指针与super 指针 @implementation SuperModel - (instancetype)init{ self = [super init]; if (self) { id self_object = self.class; id super_object = super.class; NSLog(@\"1 ---- %@ : %p\",self_object,self_object); NSLog(@\"2 ---- %@ : %p\",super_object,super_object); } return self; } @end @implementation Model - (instancetype)init{ self = [super init]; if (self) { id self_object = self.class; id super_object = super.class; NSLog(@\"3 ==== %@ : %p\",self_object,self_object); NSLog(@\"4 ==== %@ : %p\",super_object,super_object); } return self; } @end { Model *objct = [[Model alloc] init];//创建实例，调用 -init 方法 } /* 打印数据 1 ---- Model : 0x105f77730 2 ---- Model : 0x105f77730 3 ==== Model : 0x105f77730 4 ==== Model : 0x105f77730 */ 直觉告诉我们：super.class获取的是该类的父类，但是打印数据却是该类，这是为什么呢？ 使用 clang 将 [super class]转为 C++ 源码： /* super 是一个结构指针，指向结构 objc_super * @param receiver 指向当前实例 * @param 发送消息时搜索的第一个类 */ struct objc_super2 { id receiver; Class current_class; }; /* 向实例所属类的父类发送消息 * @param super 结构指针：包含接收消息的实例和开始搜索方法实现的父类。 * @param op 选择器类型 SEL */ id objc_msgSendSuper(struct objc_super *super, SEL op, ...); /* [super class] 伪代码 * 接收器仍然是 self * 但是方法的查找，是从父类开始； */ objc_msgSendSuper((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(\"SuperModel\"))}, sel_registerName(\"class\")); self 与super的异同： 相同之处：self 与super消息主体都是 self，指向同一个实例对象。 不同之处：查找方法的开始位置，self从实例所属类的方法列表开始查询；super从实例所属类的父类的方法列表开始查询。 self.class 与 super.class，最终都是在根类 NSObject 找到实现的方法 ；因此super.class获取的是该类。 2.3、id类型 id指针指向结构objc_object；该类型的实例可以转换为任何一种对象，类似于 C 语言中不确定类型 void *指针。 typedef struct objc_object *id; id类型灵活的体现了 Objective-C 动态类型 的特性：声明变量时指定为id 类型，编译器无法知道其类型；运行时系统通过结构体实例objc_object的isa指针找到其所属的类。 2.4、元类 在 Objective-C 中，Runtime 在调用 objc_allocateClassPair() 函数创建类的时候，创建的是一对类：该类以及该类的元类。因此类也被设计为一个对象。 Objective-C 类方法存储在元类上，这是使用元类的根本原因。 在给实例对象或类对象发送消息时，寻找方法的规则为: 当调用实例方法时，在实例所属类的方法列表查询该方法； 当调用类方法时，在该类元类的方法列表查询该方法； 元类与之前的类一样，也是一个对象！那么元类的 isa 指向哪里呢？为了不让这种结构无限延伸下去， Objective-C 设计所有元类的 isa 指向根元类 NSObject；而根元类的 isa 指向自己；这样就形成了一个完美的闭环。 类关系总结如下： isa 指针 superclass指针 实例对象的 isa 指向所属的类 实例对象的 superclass 指向所属类的父类 类的 isa指向元类 类的 superclass指向父类 元类的 isa 指向根元类 NSObject 元类的 superclass 指向父类的元类 根元类 NSObject的 isa指向根元类自身 根元类的 superclass 指向根类 根类 NSObject 的 isa指向根元类 NSObject 根类 NSObject 的 superclass指向 nil 2.5、分类 分类 Category 的定义如下： //Category 本质是一个结构指针，指向结构体实例 category_t typedef struct category_t *Category; // 结构 category_t struct category_t { const char *name;//分类所属的类的名称 classref_t cls;//分类所属的类 struct method_list_t *instanceMethods;//分类里添加的实例方法列表 struct method_list_t *classMethods;//分类添加的类方法列表 struct protocol_list_t *protocols;//分类实现的协议列表 struct property_list_t *instanceProperties;//分类添加的实例属性列表 struct property_list_t *_classProperties; //分类添加的类属性列表 //获取方法列表 method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } //获取属性列表 property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi); }; 分类是如何实现的？ 2.6、类扩展 Extension 类扩展 Extension 是一个匿名类，与分类 Category 不同： 区别 匿名类 分类Category 加载时机 是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @implement 一起形成完整的类，它伴随类的产生而产生，亦随之一起消亡。 在运行期决定 能否添加变量 可以添加实例变量 无法添加实例变量；因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局 是否依赖于该类源码 必须有一个类的源码才能为一个类添加扩展，无法为系统的类比如 NSString 添加扩展 不需要知道类的源码即可使用 用处 一般用来隐藏类的私有信息 用来分散类的实现；为原有类增加功能等 3、Objective-C 的方法Method 在 Objective-C 中，方法使用关键字 Method 表示。那么方法是什么？如何调用方法呢？方法与函数有何区别呢？ 3.1、Method 的本质 在 objc-private.h 文件中找到Method的声明：一个指向method_t结构的指针 //方法 Method 是一个结构指针，指向结构 method_t typedef struct method_t *Method; //变量的结构 struct method_t { SEL name; //选择器类型：描述了方法的名称 const char *types; //描述了方法参数的数据类型 MethodListIMP imp; //函数指针：提供方法实现的地址 struct SortBySELAddress : public std::binary_function{ bool operator() (const method_t& lhs, const method_t& rhs){ return lhs.name Method建立了SEL和IMP的关联：当向一个对象发送消息时，通过指定的SEL查询函数指针 IMP，然后执行函数。 3.2、Objective-C 的方法调用 Objective-C 的方法调用实际就是一个消息传递的过程。 调用类方法 [NSString class];，转为 C++ 代码： ((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSString\"), sel_registerName(\"class\")); 也就是说：Objective-C 的方法调用，本质是向对象发送消息。主要使用 objc_msgSend() 函数： /* 该函数由汇编语言写，大致逻辑如下： * 1、根据 self->isa 获取所属的类； * 2、获取该类的缓存 cache * 3、通过选择器类型 SEL 查找与之对应的 Method 的结构成员 IMP； * 如果找到函数指针 IMP，则执行函数； * 如果没有找到与 SEL 对应的 Method ；接着执行步骤 4 * 4、遍历该类的方法列表 methodLists ，通过 SEL ，查找与之对应的 IMP； * 如果找到 IMP 指针，则执行函数； * 如果没有找到与 SEL 对应的 Method ,则去查询父类的 methodLists；一直查询到根类 * 5、如果到根类也没有找到，那么就抛出 unrecognized selecto */ id objc_msgSend(id self, SEL op, ...); 3.2.1、方法查找过程 /** 查找某个类指定选择器的方法实现 IMP （ 标准IMP查找 ） * @param cls 指定的类 * @param sel 指定的选择器 * @param inst 类cls的实例或者子类；如果cls未初始化需要初始化，那么 inst 非空时效率更高 * @param initialize 是否初始化：当没有初始化时 (NO)，避免调用 +initialize * @param cache 是否先去缓存中查找 * @param resolver 是否需要执行动态方法决议； * @return 返回 IMP * * @note 如果不想执行消息转发机制，可以调用 lookUpImpOrNil() 函数，而不是调用该函数 */ IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = nil; bool triedResolver = NO;//是否实行动态决议的标记，指标记防止循环调用 动态方法决议 runtimeLock.assertUnlocked(); /******************** 1、先去缓存查找 ******************/ if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } runtimeLock.lock(); checkIsKnownClass(cls);//检查该类，如果未知就终止程序 if (!cls->isRealized()) { realizeClass(cls);//如果未实现，则去实现 } if (initialize && !cls->isInitialized()) {//初始化但还没完成时 runtimeLock.unlock(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.lock(); // 如果 sel == initialize， _class_initialize将发送+initialize，然后在此过程完成后，messenger将再次发送 +initialize。当然，如果这不是由 messenger 调用，那么它就不会发生。2778172 } retry: runtimeLock.assertLocked(); /******************** 从该类的缓存中查找 ******************/ imp = cache_getImp(cls, sel); if (imp) goto done; /******************* 从该类的方法列表中查找 *****************/ { Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, cls); // 找到并缓存至该类 imp = meth->imp; goto done; } } /******************* 从该类的父类缓存和方法列表中查找 *****************/ { unsigned attempts = unreasonableClassCount(); for (Class curClass = cls->superclass; curClass != nil; curClass = curClass->superclass){ if (--attempts == 0) {// 如果超类链中存在循环，则停止。 _objc_fatal(\"Memory corruption in class list.\"); } imp = cache_getImp(curClass, sel);// 父类缓存中查找 if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { log_and_fill_cache(cls, imp, sel, inst, curClass); //在超类中找到该方法，在 cls 中缓存它。 goto done; }else { break; } } Method meth = getMethodNoSuper_nolock(curClass, sel);// 父类方法列表中查找 if (meth) { log_and_fill_cache(cls, meth->imp, sel, inst, curClass);// 在超类中找到该方法。在这个类中缓存它。 imp = meth->imp; goto done; } } } /********************** unrecognized selector 的补救时机 ************************/ // 如果指定选择器 SEL 对应的方法没有实现，而且没有执行方法决议；第一次解决：尝试动态决议 if (resolver && !triedResolver) { runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); runtimeLock.lock(); triedResolver = YES;//标记为已经执行动态决议 goto retry; } // 没有找到 IMP ，动态决议也没有结果：第二次补救机会：消息转发机制 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp; } /** 根据指定SEL查找某个类的方法实现 IMP * 相比于lookUpImpOrForward() 函数，该函数不会执行消息转发机制 */ IMP lookUpImpOrNil(Class cls, SEL sel, id inst,bool initialize, bool cache, bool resolver){ IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp; } 从 lookUpImpOrForward() 函数可以看出标准 IMP 查找过程: 1、先去该类的缓存中查找，如果找到则返回；否则接着查找 2、从这个类的方法列表中查找，如果找到，加入缓存列表，并返回 IMP；否则接着查找 3、从这个类的父类缓存和方法列表中查找；如果找到；缓存到该类（而非父类），并返回 IMP；否则接着查找； 4、如果从父类一直找到根类也没有找到，一般会抛出 unrecognized selector 错误；但该函数还没执行完； 5、如果允许方法决议: resolver=YES，则执行补救措施： 5.1、 第一次补救：动态方法决议；如果动态方法决议成功，则返回步骤 1 执行；否则往下执行； 5.2、第二次补救：消息转发机制，将 IMP 赋值为 _objc_msgForward_impcache ，缓存到该类的方法列表，然后返回 IMP； 3.2.2、对象消息传递 在 OOP 中，消息传递是指一种在对象之间发送和接收消息的通信模式。 Objective-C 传递的消息到底是什么？消息与方法有何区别？ 苹果对 Objective-C 的消息做了封装，以类 NSInvocation 呈现；NSInvocation 类包含消息的所有元素：目标target、选择器SEL、参数和返回值。 Objective-C 的对象消息传递是以动态方式实现的，用于调用类方法与实例方法： 类或者实例称为接收器，是消息的目的地； 消息本身由选择器和相应的参数构成。 接收器的类型和相应的方法在运行时决定！ Objective-C 的对象消息传递，向接收器发送消息，然后接收器会使用该消息调用相应的方法，并在有需要时返回结果。如果接收器没有相应的方法，也可以使用其它方式处理该消息，如将其发送给另一个对象、检查该消息并自定义其逻辑等！ 3.2.3、方法签名 方法签名定义了方法输入参数的数据类型和方法的返回值。 苹果对 Objective-C 的消息做了封装，以类 NSMethodSignature 呈现； 3.3、消息传递过程 向一个 Objective-C 对象发送消息 NSInvocation 时，Runtime 执行了一系列查询逻辑： 1、根据NSInvocation 的target找到目标对象object_A； 2、根据目标对象object_A的isa找到其所属的类Class_A； 3、在Class_A的结构体实例中首先查询 cache ；如果缓存中找到该方法，则执行； 4、如果缓存中没有找到该方法，则查询 methodLists；如果找到该方法，则执行； 5、如果没有找到，则根据 super_class 查找Class_A的父类Class_A_Super；然后接着执行步骤 3、4； 6、如果找到NSObject 也一直没有找到该方法；一般而言，程序会抛出异常unrecognized selector sent to instance ***。 Objective-C 不会阻止程序向没有响应方法的对象发送消息。如果出现这种情况，程序默认抛出运行时异常 unrecognized selector。 然而Objective-C 的运行时为 unrecognized selector提供了三次补救机会： 1、动态方法决议：以动态方式实现方法。NSObject的 +resolveClassMethod:类方法与+resolveInstanceMethod:类方法以动态方式实现由选择器指定的实例和类方法。如果动态方法决议成功，则执行IMP指向的函数；如果失败，还有第二次补救措施； 2、消息转发机制：当对象收到无法处理的消息时，将消息转发给能够做出回应的其它接收器；将所有无法识别的消息都发送给同一接收器；既不执行处理过程也不使程序崩溃，默默的吞下消息。Objective-C 提供了两种消息转发机制： 2.1、快速转发：重写 - forwardingTargetForSelector:方法，将无法识别的方法转发给其它对象； 2.2、完整转发：重写 - forwardInvocation:方法。 3.3.1、动态绑定 动态绑定是在程序运行时（而不是编译时）将消息与方法对应起来的处理过程。 消息传递过程，就是一个动态绑定的过程！在程序运行前和消息发送前，消息与接收消息的对象不会对应。 在发送消息时，通过消息 NSInvocation 的 -invokeWithTarget:方法设置接收器；此时NSInvocation 的 target 与SEL 绑定；Runtime 通过搜索指向target的缓存列表或者方法列表，找到与选择器类型SEL匹配的Method，跳转到Method的结构成员IMP指向的函数执行代码。 使用动态绑定可以在不影响既有代码的情况下，将新对象和代码连接或添加到系统中，从而降低对象之间的耦合度。 3.3.2、多态性 Objective-C 的对象消息传递功能支持 OOP 多态性：不同的接收器调用同一方法可以获得不同的结果。 对于方法名相同的 在不同类中 的方法，虽然选择器类型SEL相同，但是执行的 IMP地址并不一定相同。我们已经知道，在对象消息传递过程中，接收器的类型在运行时确定，之后寻找到target中的Method，跳转到Method的结构成员IMP指向的函数执行代码。 如果 target 不同，那么结构体实例Method也不会相同，它的结构成员IMP也可能不相同，这时执行的代码就不相同。 因此，不同的接收器对同一条消息可以做出不同的响应。 3.3.3、方法交换 通过前面的学习，我们已经对 Objective-C 的对象调方法过程有了大致的了解。我们来实现一个 Runtime 的黑魔法 - 方法交换：为系统类的原有方法增加新的功能。 由于Objective-C的方法执行主要是寻找 IMP 指向的函数执行，假如我们在不改变选择器类型 SEL的前提下改变method_t的成员IMP的值，那么 Runtime 就会顺着SEL找到method_t实例，然后执行 被指向它处 IMP的函数。说的通俗些：方法交换的本质是交换两个方法持有的函数指针，而不是两个方法换了。这就是方法交换的核心原理。 3.4、方法与函数的区别 Objective-C 方法： 1、Objective-C 的方法分为实例方法与类方法：实例方法以 - 开头，存储在实例所属的类的methodLists中 ；类方法以 + 开头，存储在元类的methodLists中 ； 2、Objective-C 的方法依赖于对象：实例方法只能由类对象调用、类方法只能由类来调用； 3、Objective-C 方法的实现必须在@implementation与 @end 之间； 4、Objective-C 方法 Method 本质为一个结构指针，指向 结构体实例method_t； 5、Objective-C 方法的执行，是根据选择器类型SEL找到匹配的函数指针IMP，执行IMP处的函数； C 语言的函数： 1、函数能写在文件的任何位置； 2、函数归文件所有； 3、函数的调用不依赖对象； 4、函数的内部不能用类的成员变量名直接去访问类的成员变量； 参考文章： 格物致知iOS类与对象 新手也看得懂的 iOS Runtime 教程 iOS 消息发送与转发详解 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/Runtime/OC之Blocks.html":{"url":"iOS开发/Runtime/OC之Blocks.html","title":"OC之Blocks","keywords":"","body":"Objective-C的Block Blocks 是将函数及其执行上下文封装起来的对象！ 特别说明：本文代码如无说明，均在 ARC 下编译；在 MRC 下编译会做注释。 1、Blocks 语法 1.1、Blocks 变量声明 Blocks 类型由返回值类型和参数类型列表构成。使用脱字符 ^ 声明 Blocks 类型的变量。 返回值类型：当 Blocks 被调用时返回值的类型；如 int 型。无返回值时设置为void。 Blocks 变量名：带有脱字符 ^ 前缀并且封装在括号中 参数类型列表：被封装在括号中并且位于块名称的后面，其中的参数类型以逗号分隔。如果没有参数，将参数列表设置为 void。 声明的一些简单Blocks 变量： //变量 sumBlock 拥有两个 int 类型参数，返回值也是 int 类型 int (^sumBlock)(int,int); //变量 logBlock 拥有一个 NSString 类型参数，无返回值 void void (^logBlock)(NSString *); //变量 simpleBlock 没有参数 void，无返回值void void (^simpleBlock)(void); 既然可以将变量设为Blocks 类型，那么也可以将函数与方法的参数、类属性设为 Blocks (能够定义变量的地方就能够定义Blocks )： @interface ModelClass : NSObject //requestBlcok 用作对象的属性，使用 copy 修饰，具有文件作用域，被分配在堆区 @property (nonatomic ,copy) void (^requestBlcok)(BOOL isSuccess); //requestBlcok 用于方法的参数，具有块作用域，被分配在栈区 - (void)requestCompletion:(void(^)(BOOL isSuccess))requestBlcok; @end 使用 typedef 为 Blocks提供别名，可以简化 Blocks 类型变量名称： //为 block 类型提供别名 RequestBlcok typedef void(^RequestBlcok)(BOOL isSuccess); @interface ModelClass : NSObject //别名 RequestBlcok 用作对象的属性类型，使用 copy 修饰，具有文件作用域，被分配在堆区 @property (nonatomic ,copy) RequestBlcok requestBlcok; //别名 RequestBlcok 用于方法的参数类型，具有块作用域，被分配在栈区 - (void)requestCompletion:(RequestBlcok)completion; @end 疑问 1：为何使用 copy 修饰属性变量 Blocks，？能用strong 嘛？ 答：当Blocks不持有自动变量时，使用 retain 、 copy、strong 都会持有该变量；但当Blocks持有作用域之外的自动变量时，使用 retain 修饰，被持有的自动变量引用计数没有变化，可能随时释放，存在内存问题！ 而使用 copy 、strong 修饰的 Blocks，会调用 _Block_object_assign() 函数将持有的自动变量引用计数加 1，保证当使用时不会被释放！ 1.2、Blocks 常量表达式 定义Blocks常量表达式：以脱字符^开头，后跟返回值类型、参数列表、Blocks 主体： 脱字符 ^ 表明该表达式是一个常量表达式； 脱字符 ^ 后的返回值类型 (可选项) 设置了该Blocks 表达式返回值的类型； Blocks 参数被封装在括号中传递给Blocks 主体，每个Blocks 参数都由一个参数类型和一个参数名表示，Blocks 参数之间以逗号分隔。 Blocks 常量表达式的简单定义： //有返回类型的 Blocks 常量表达式 ^int(int a ,int b){ return a + b; }; /** 没有设置返回类型的 Blocks 常量表达式 * @note 返回值类型 int 可以不做定义，因为编译器会从 return 语句推断出返回值类型。 * @note Blocks常量表达式被编译器存储在栈区 */ ^(int a,int b){ return a + b; }; Blocks 被用作方法参数，类属性时，定义Blocks常量表达式： ModelClass *test = [[ModelClass alloc] init]; test.requestBlcok = ^(BOOL isSuccess) { printf(\"Block 主体，执行某些操作\\n\"); }; [test requestCompletion:^(BOOL isSuccess) { printf(\"Block 主体，执行某些操作\\n\"); }]; Blocks 的声明与定义组合为一条语句： /* @note Blocks常量表达式被编译器存储在栈区 * @note 通过赋值操作将其赋给Blocks变量，此时被复制到堆上或者全局静态区。 */ void (^logBlock)(NSString *) = ^(NSString *log){ NSLog(@\"log:%@\",log); }; //在Blocks定义中，没有参数可不使用void void (^simpleBlock)(void) = ^{ }; 如果在函数体外面声明并定义 Blocks 变量，那么它具有文件作用域，由编译器静态分配，存储在全局静态区的数据区： static BOOL(^isEvenNumberBlock1)(int number) = ^BOOL(int number){return (number % 2) == 0 ? YES : NO;}; Blocks 变量声明 和 Blocks 常量表达式的语法区别 语法元素 Blocks变量声明 Blocks常量表达式 脱字符 ^ 标识Blocks变量声明的开始，脱字符位于Blocks变量名称之前，两者都被封装在圆括号中 标识Blocks常量表达式的开始 名称 Blocks变量的名称是必选项 Blocks 常量表达式没有名称 返回值类型 必选项，没有返回值时声明为void 可选项，因为编译器能够从Blocks 表达式推断出返回值类型。 参数 必选项，没有参数时声明为void 参数列表是可选项 2、Blocks 是一个闭包 Blocks 是一个实现的闭包，一个允许访问其常规作用域之外变量的函数。 在 C 函数中声明的变量具有块作用域、无链接；这意味着这些自动变量仅在该函数访问。 与 C 函数相比，Blocks 扩大了变量的作用域，可以访问 Blocks 主体之外的自动变量。 2.1、持有被访问的自动变量 Blocks 访问其作用域之外的变量 void func(void){ NSString *log = @\"打印日志\"; int a = 5; NSLog(@\"log1:%@ : %p : %p\",log,log,&log); NSLog(@\"a 1:%d : %p\",a,&a); void (^simpleBlock)(void) = ^{//block 声明并赋值 NSLog(@\"log2:%@ : %p : %p\",log,log,&log); NSLog(@\"a 2:%d : %p\",a,&a); }; log = @\"hello word!\"; a = 6; NSLog(@\"log3:%@ : %p : %p\",log,log,&log); NSLog(@\"a 3:%d : %p\",a,&a); simpleBlock();//调用 block 变量 } /* 打印数据 log1:打印日志 : 0x1000021c0 : 0x7ffeefbff5c8 a 1:5 : 0x7ffeefbff5c4 log3:hello word! : 0x100002260 : 0x7ffeefbff5c8 a 3:6 : 0x7ffeefbff5c4 log2:打印日志 : 0x1000021c0 : 0x100705250 a 2:5 : 0x100705258 */ 分析打印数据：Blocks 表达式中的变量与作用域之外的自动变量，内存地址相同，但不是同一个指针指向该内存；类似于 Blocks 表达式对作用域之外的变量进行浅拷贝。 Blocks 表达式对通过浅拷贝 持有 作用域之外的自动变量。 疑问 2：Blocks变量为何要持有作用域之外的自动变量？如何持有？ 2.2、存储类别说明符 __block 默认情况下，Blocks 常量表达式对作用域之外的局部变量无权修改，否则编译器报错 Variable is not assignable (missing __block type specifier)。 存储类别说明符 __block 用于指定将变量值设置到哪个存储区域，可以将这些变量切换为读写模式。 __block NSString *log = @\"打印日志\"; void (^simpleBlock)(void) = ^{ log = @\"hello word!\"; }; __block 说明符不能与存储类别说明符 auto、register、static组合使用。 2.3、Blocks访问全局变量 在Blocks常量表达式中可以直接修改全局变量，无需使用 __block 说明符。 int a = 3;//声明并赋值一个全局变量 a int main(int argc, const char * argv[]) { void (^simpleBlock)(void) = ^{ printf(\"a 1==== %d \\n\",a); a = 4; printf(\"a 2==== %d \\n\",a); }; a = 5; simpleBlock(); return 0; } /* 打印数据 a 1==== 5 a 2==== 4 */ 在 C 语言中，下述类型变量允许在 Blocks 常量表达式中直接修改： 静态变量：使用 static 修饰的变量； 全局变量：具有内部链接的全局变量、具有外部链接的全局变量。 同样的，在 OC 中对象的属性属于全局变量，也可以在 Blocks 常量表达式中直接修改。 疑问 3：Blocks表达式中的全局变量为什么可以修改？Blocks持有该全局变量了嘛？ 3、Blocks 底层实现 Blocks 是持有自动变量的匿名函数，允许访问其作用域之外的变量。那么，Blocks 到底是什么呢？利用 clang 将 Objective-C 代码转为 C ++ 源码： clang -rewrite-objc main.m //支持 ARC 并指定 Runtime 版本 clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 ModelClass.m //支持 ARC 并指定 Runtime 版本 xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m //指定 sdk 和模拟器 并 指定 sdk 和真机 xcrun -sdk iphoneos clang -rewrite-objc main.m //指定 sdk 和模拟器 xcrun -sdk iphonesimulator clang -rewrite-objc main.m //指定具体某版本的模拟器 xcrun -sdk iphonesimulator9.3 clang -rewrite-objc main.m //如果使用了第三SDK xcrun -sdk iphonesimulator9.3 clang -rewrite-objc –F /Users/goanywhere/Downloads/nbs-newlens-ios-2.3.6 main.m 3.1、分析Blocks 的本质 变量有地址，同样的，函数也有地址，指向函数的指针中存储着函数代码的起始处地址。 Objective-C 代码： int main(int argc, const char * argv[]) { int (^addBlock)(int,int) = ^(int a ,int b){ return a + b; }; printf(\"1 + 2 = %d \\n\",addBlock(1,2)); return 0; } 转换后相关的 C++ 源码： /** Block 结构模版 * @param isa 指向所属类的指针， * @param FuncPtr 函数指针，指向Block的功能实现函数 */ struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; /** Block的描述信息 * @note Block_size 赋值 sizeof(struct __main_block_impl_0) * 意味着Block可能就是结构 __main_block_impl_0 */ static struct __main_block_desc_0 { size_t reserved; size_t Block_size;//表明 Block 所占内存空间的大小 } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; /// 嵌套 __block_impl 与 __main_block_desc_0 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; /** 结构体的构造函数 * @param fp 函数指针，被赋值 __main_block_func_0() * @param desc 结构指针，指向结构 __main_block_desc_0 */ __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = &_NSConcreteStackBlock;//isa 指针，栈内存 impl.Flags = flags;//标志位，0 impl.FuncPtr = fp;//函数指针，指向 Block 的功能实现函数 Desc = desc;//描述信息：block 内存 } }; /** 实现 OC 代码中Block的主要功能。 * @param __cself 结构指针，类似于 OC 中的 self 指针；指向模板 (__block_impl *)addBlock； * 意味着 Block 主体是一个__main_block_impl_0的结构； * @param int a、int b ： Block 表达式的参数列表 * @return 返回 int 类型 */ static int __main_block_func_0(struct __main_block_impl_0 *__cself, int a, int b) { return a + b; } /** main() 函数的实现，分为 3 大部分：声明、实现、调用 * 1、Block 声明：本质为函数指针 int(*addBlock)(int,int)，指向构造函数 __main_block_impl_0() 的起始位置 * 2、Block 常量表达式：获取函数地址 &__main_block_impl_0() * 2.1、强制类型转换 ((int (*)(int, int)) * 2.2、构造函数 __main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA)) * 2.3、函数指针指向构造函数 * 3、Block 的调用转为 ((int (*)(__block_impl *, int, int))((__block_impl *)addBlock)->FuncPtr)((__block_impl *)addBlock, 1, 2) * 3.1、函数 ((int (*)(__block_impl *, int, int))((__block_impl *)addBlock)->FuncPtr) 就是 __main_block_func_0() * 3.2、参数列表 ((__block_impl *)addBlock, 1, 2) * 3.3、__cself 指针指向模板类 (__block_impl *)addBlock * 3.4、调用 addBlock(1,2) 也就是调用函数指针 __block_impl.FuncPtr 指向的函数__main_block_func_0() */ int main(int argc, char * argv[]) { int (*addBlock)(int,int) = ((int (*)(int, int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA)); printf(\"1 + 2 = %d \\n\",((int (*)(__block_impl *, int, int))((__block_impl *)addBlock)->FuncPtr)((__block_impl *)addBlock, 1, 2)); return 0; } 疑问 4：在构造函数__main_block_impl_0()中，isa指针所指向的 _NSConcreteStackBlock 是什么？isa指针为何指向_NSConcreteStackBlock？ 小结： Blocks 本质是结构__block_impl，其成员isa指针表明在内存中的位置。 Blocks 声明本质声明了一个特定类型的函数指针。 Blocks 常量表达式本质上是一个指向 __main_block_impl_0 的结构指针。 Blocks 调用本质是通过函数指针__main_block_impl_0.FuncPtr 调用特定函数。 3.2、Blocks如何持有其作用域之外的自动变量？ Blocks 与函数、方法类似，但除了是可执行代码外，Blocks 还持有与堆内存或栈内存绑定的变量！ 对于基本数据类型的局部变量，截获其值； 对于对象类型的基本变量，连同所有权修饰符一起截获； 以指针形式截获其局部静态变量； 不截获全局变量、静态全局变量； int main(int argc, const char * argv[]) { int a = 3;///基本数据类型的自动变量 NSString *string = @\"Hello word!!\";///OC 类：自动变量 __weak NSString *weakString = @\"弱引用\"; void (^simpleBlock)(void) = ^{ NSLog(@\"string1 ==== %@ : %p\",string,string); NSLog(@\"weakString = %@ : %p\",weakString,weakString); printf(\"a1 ========= %d : %p \\n\",a,&a); }; a = 4; string = @\"打印日志\"; simpleBlock(); return 0; } 转为 C++ 代码： /* 将一个对象的值复制给另一个对象 * @param dst 目的对象：接收值 * @param src 源对象： * @note BLOCK_FIELD_IS_OBJECT 代表Objective-C对象，此处相当于调用 -retain 方法 */ static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&dst->string, (void*)src->string, BLOCK_FIELD_IS_OBJECT); _Block_object_assign((void*)&dst->weakString, (void*)src->weakString, BLOCK_FIELD_IS_OBJECT); } /* 销毁一个对象 */ static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src->string, BLOCK_FIELD_IS_OBJECT);//相当于调用 -release 方法 _Block_object_dispose((void*)src->weakString, BLOCK_FIELD_IS_OBJECT); } /* Block的描述信息 * @note 持有 复制函数 与 释放函数 的函数指针 */ static struct __main_block_desc_0 { size_t reserved; size_t Block_size;//表明 Block 所占内存空间的大小 void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);//复制函数 void (*dispose)(struct __main_block_impl_0*);//销毁函数 } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *__strong string; // Blocks 持有作用域之外的自动变量 NSString *__weak weakString; int a; /* 结构体的构造函数 * @param fp 函数指针，被赋值 __main_block_func_0() * @param desc 结构指针，指向结构 __main_block_desc_0 * @param 作用域之外的 _string、_weakString、_a 被赋值给该结构体成员 */ __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *__strong _string, NSString *__weak _weakString, int _a, int flags=0) : string(_string), weakString(_weakString), a(_a) { impl.isa = &_NSConcreteStackBlock;//isa 指针，栈内存 impl.Flags = flags;//标志位，0 impl.FuncPtr = fp;//函数指针，指向 Block 的功能实现函数 Desc = desc;//描述信息：block 内存 } }; /* 实现 OC 代码中Block的主要功能 * @note __cself->string 调用的是Block对象的成员 string ，并不是作用域之外的 string 变量 */ static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString *__strong string = __cself->string; // 复制的副本 NSString *__weak weakString = __cself->weakString; // 复制的副本 int a = __cself->a; // 复制的副本 NSLog((NSString *)&__NSConstantStringImpl__var_folders_d8_yqx6_fxx1gzbwsghfv7n6r8w0000gn_T_main_490ccf_mi_2,string,string); NSLog((NSString *)&__NSConstantStringImpl__var_folders_d8_yqx6_fxx1gzbwsghfv7n6r8w0000gn_T_main_490ccf_mi_3,weakString,weakString); printf(\"a1 ========= %d : %p \\n\",a,&a); } int main(int argc, const char * argv[]) { int a = 3; NSString *string = (NSString *)&__NSConstantStringImpl__var_folders_d8_yqx6_fxx1gzbwsghfv7n6r8w0000gn_T_main_490ccf_mi_0; __attribute__((objc_ownership(weak))) NSString *weakString = (NSString *)&__NSConstantStringImpl__var_folders_d8_yqx6_fxx1gzbwsghfv7n6r8w0000gn_T_main_490ccf_mi_1; void (*simpleBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, string, weakString, a, 570425344)); a = 4; string = (NSString *)&__NSConstantStringImpl__var_folders_d8_yqx6_fxx1gzbwsghfv7n6r8w0000gn_T_main_490ccf_mi_4; ((void (*)(__block_impl *))((__block_impl *)simpleBlock)->FuncPtr)((__block_impl *)simpleBlock); return 0; } Blocks 持有其作用域之外的自动变量的大致过程： 1、Blocks 访问其作用域之外的自动变量时，将这些变量添加为实例__main_block_impl_0的结构成员并赋值； 2、当Blocks表达式从栈内存复制到堆内存或者全局静态区时，调用 _Block_object_assign() 函数将持有的自动变量也复制到堆内存或者全局静态区； Objective-C类对象浅拷贝其内存地址，基础数据类型拷贝其数据值； 3、功能实现函数__main_block_func_0()使用的变量string是实例__main_block_impl_0的结构成员string，而不是Blocks作用域之外的自动变量string; 3.2.1、 函数__main_block_copy_0()与__main_block_dispose_0()的调用时机 函数__main_block_copy_0()的调用时机： 当Blocks变量调用_Block_copy() 函数 或 -copy方法时； 赋值操作，将 Blocks 表达式从栈内存复制到堆内存、或者全局静态区时； 堆上的 Block 被废弃时，会调用__main_block_dispose_0()函数！ 当Block从栈复制到堆上时，Block实例通过_Block_object_assign()函数，将持有的自动变量的引用计数加 1！ 当Block从堆释放时，Block实例通过_Block_object_dispose()函数，释放持有自动变量的所有权！ 3.3、__Block 发挥什么作用？ 既然 Blocks 持有作用域之外的自动变量，为何使用__Block修饰之后，修改Blocks 持有的自动变量，会对作用域之外的变量产生影响呢？ int main(int argc, const char * argv[]) { __block int a = 3; void (^simpleBlock)(void) = ^{ printf(\"a 1==== %d \\n\",a); a = 4; printf(\"a 2==== %d \\n\",a); }; a = 5; simpleBlock(); return 0; } 转为C++代码： /** 将一个对象的值复制给另一个对象 * @param dst 目的对象：接收值 * @param src 源对象： */ static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&dst->a, (void*)src->a, BLOCK_FIELD_IS_BYREF); } /** 销毁一个对象 */ static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src->a, BLOCK_FIELD_IS_BYREF); } /** Block的描述信息 */ static struct __main_block_desc_0 { size_t reserved; size_t Block_size;///表明 Block 所占内存空间的大小 void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);///复制函数 void (*dispose)(struct __main_block_impl_0*);///销毁函数 } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; /** __Block 变量转为结构体 * @note __forwarding 指针，指向外部变量指针的内存地址 */ struct __Block_byref_a_0 { void *__isa;//指向所属的类的 isa 指针 __Block_byref_a_0 *__forwarding; int __flags; int __size;//该结构的内存大小 int a;//该结构持有相当于原自动变量 }; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref /** 结构体的构造函数 * @param fp 函数指针，被赋值 __main_block_func_0() * @param desc 结构指针，指向结构 __main_block_desc_0 * @param 作用域之外的 _a 被拷贝给该结构体成员 */ __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a->__forwarding) { impl.isa = &_NSConcreteStackBlock;//isa 栈内存 impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; /* 实现 OC 代码中Block的主要功能 * @note __cself->a 调用的是Block对象的成员 a ，并不是作用域之外的变量 a * a->__forwarding 是作用域之外的变量 a 的指针地址 * a->__forwarding->a 作用域之外的变量 a 的成员 * (a->__forwarding->a) = 4 本质上修改的还是作用域之外的变量值 */ static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_a_0 *a = __cself->a; // bound by ref printf(\"a 1==== %d \\n\",(a->__forwarding->a)); (a->__forwarding->a) = 4;//修改的是作用域之外的变量值 printf(\"a 2==== %d \\n\",(a->__forwarding->a)); } /* mian() 函数 * __block a 转为结构体 __Block_byref_a_0 * a=3 被赋值给结构成员 __Block_byref_a_0.a * __forwarding 指针指向变量a的内存地址 */ int main(int argc, const char * argv[]) { __attribute__((__blocks__(byref))) __Block_byref_a_0 a = { (void*)0,// __isa 指针:指向空指针NULL (__Block_byref_a_0 *)&a,// __forwarding 指针 0, sizeof(__Block_byref_a_0),//__size 内存大小 3 }; void (*simpleBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_a_0 *)&a, 570425344)); (a.__forwarding->a) = 5; ((void (*)(__block_impl *))((__block_impl *)simpleBlock)->FuncPtr)((__block_impl *)simpleBlock); return 0; } __block 发挥的作用： 1、__block 类似于强制转换，将修饰的变量转换为结构 __Block_byref_a_0； 结构成员__forwarding指向__block变量的指针地址。 2、在功能函数 __main_block_func_0() 修改变量值: (a->__forwarding->a)=4，本质上修改的还是作用域之外的__block变量； 3.4、Blocks 表达式访问的全局变量 Blocks对象可以持有作用域之外的自动变量；但并不会持有全局变量！ int a = 3;//全局变量 int main(int argc, const char * argv[]) { void (^simpleBlock)(void) = ^{ static int b = 13;//静态变量 void (^simpleBlock)(void) = ^{ a = 4; b = 14; }; a = 5; b = 15; simpleBlock(); return 0; } 转为 C++ 代码： int a = 3; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int *b; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_b, int flags=0) : b(_b) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int *b = __cself->b; // bound by copy a = 4; (*b) = 14; } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; int main(int argc, const char * argv[]) { static int b = 13; void (*simpleBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &b)); a = 5; b = 15; ((void (*)(__block_impl *))((__block_impl *)simpleBlock)->FuncPtr)((__block_impl *)simpleBlock); return 0; } 执行函数__main_block_func_0() 在全局变量a 的作用域之内，可以直接使用全局变量a，不需要复制。 但是具有块作用域的静态变量b，在函数__main_block_func_0()的作用域之外，不能直接访问；将静态变量的地址保存在结构__main_block_impl_0，通过地址访问作用域之外的静态变量！ 4、Blocks 内存管理 Blocks 常量表达式的 isa 指针指向 _NSConcreteStackBlock，表明Blocks常量被编译器存储到栈区！与之类似的类有：_NSConcreteGlobalBlock、_NSConcreteMallocBlock。 Blocks所属的类 设置对象的存储域 _NSConcreteStackBlock 由编译器自动分配在栈区，并在合适时机释放 _NSConcreteMallocBlock 由 _malloc()函数分配在堆区 _NSConcreteGlobalBlock 全局静态区，存放全局变量 4.1、类实例 _NSConcreteGlobalBlock Blocks 作为全局变量或者类的属性时，创建的Blocks对象属于_NSConcreteGlobalBlock。 //具有文件作用域，由程序静态分配，存储在全局静态区的数据区 static BOOL(^isEvenNumberBlock2)(int number) = ^BOOL(int number){return (number % 2) == 0 ? YES : NO;}; int main(int argc, const char * argv[]) { return 0; } 声明并定义全局变量isEvenNumberBlock2，转为 C++ 代码： static struct __isEvenNumberBlock2_block_impl_0 { struct __block_impl impl; struct __isEvenNumberBlock2_block_desc_0* Desc; __isEvenNumberBlock2_block_impl_0(void *fp, struct __isEvenNumberBlock2_block_desc_0 *desc, int flags=0) { impl.isa = &_NSConcreteGlobalBlock;//isa 初始化为 _NSConcreteGlobalBlock impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 全局变量isEvenNumberBlock2实例属于_NSConcreteGlobalBlock类。 即使在块作用域内创建Blocks变量，只要Blocks不持有作用于之外的自动变量，编译器就会将Blocks变量存储在全局静态区。 4.2、Blocks变量从栈复制到堆上 由于Blocks可以看做 Objective-C 对象，而在 ARC 模式下编译器默认使用__strong 修饰变量；因此simpleBlock变量持有Blocks实例的所有权，类似于MRC下的-retain ！因此simpleBlock变量存储在堆区。 假如使用 __weak修饰Block变量，则该变量存储在栈区！ 4.2.1、什么情况下栈上的Block复制到堆上？ 调用函数_Block_copy()将Block变量从栈复制到堆！ 都在什么情况下，编译器会将栈上的Block变量复制到堆上呢？ 调用Block的实例方法-copy时：如果Block配置在栈上，那么该Block从栈复制到堆上； ARC下Block 作为函数返回值时； ARC下将Block表达式赋值给有__strong修饰的 id 类型或 Block类型成员变量时: 编译器自动的将对象的Block 作为参数并调用_Block_copy() 函数；与-copy效果相同！ 在方法名中含有usingBlock 的Cocoa方法； GCD的API传送的Block时； 4.2.2、为什么把栈上的Block复制到堆上？ 栈上的Block变量，如果其作用域结束，该Block就会被释放；由于__Block变量也配置在栈上，其变量作用域结束，则该__Block变量也被释放。 例子：MRC 下Block变量作为函数返回值时 /* @note MRC 编译：Block常量表达式分配在栈内存，不被任何指针持有，当函数返回时，Block变量被释放； * 因此编译错误： Returning block that lives on the local stack * 调用 -copy 将Block变量从栈复制到堆上，解决该编译错误； * 需要在适当时机调用 -release 释放所有权，否则引起内存泄露； * @note ARC 编译，Block常量表达式作为函数返回值时会被编译成 autoreleased NSConcreteMallocBlock 类型，存储在堆内存 * 编译器会自动释放，无需我们操心 */ typedef void (^SimpleBlock)(void); SimpleBlock getBlockFunc(){ int b = 20; return ^{ NSLog(@\"b ====== %d\",b); }; } 注意：将 Block 从栈复制到堆上需要消耗CPU资源。如果Block在栈上也能使用，则无需复制到堆上！ 疑问6：思考一下，在此处可以使用 -autorelease 或者 -retain方法嘛？ 4.2.3、持有自动变量 当Block从栈上复制到堆上时，作用域之外的自动变量仍然存储在栈上，仅仅对应的Block结构成员被复制在堆上。 a、Block变量调用-copy //MRC 下编译代码 int main(int argc, const char * argv[]) { //自动变量存储在栈区，地址都是高位地址 NSString *log = @\"hello word\";//栈上，高地址 int a = 5;//栈上，高地址 NSLog(@\"log1:%@ : %p : %p\",log,log,&log); NSLog(@\"a 1:%d : %p\",a,&a); SimpleBlock simpleBlock = [^{ NSLog(@\"log2:%@ : %p : %p\",log,log,&log);//堆上 NSLog(@\"a 2:%d : %p\",a,&a);//堆上 } copy]; log = @\"打印日志\";//栈上，高地址 a = 6;//栈上，高地址 NSLog(@\"log3:%@ : %p : %p\",log,log,&log); NSLog(@\"a 3:%d : %p\",a,&a); simpleBlock(); NSLog(@\"log4:%@ : %p : %p\",log,log,&log);//栈上，高地址 NSLog(@\"a 4:%d : %p\",a,&a);//栈上，高地址 return 0; } /*打印数据 log1:hello word : 0x1000021e0 : 0x7ffeefbff578 a 1:5 : 0x7ffeefbff574 log3:打印日志 : 0x100002280 : 0x7ffeefbff578 a 3:6 : 0x7ffeefbff574 log2:hello word : 0x1000021e0 : 0x100502d10 a 2:5 : 0x100502d18 log4:打印日志 : 0x100002280 : 0x7ffeefbff578 a 4:6 : 0x7ffeefbff574 */ 持有的自动变量 Block 从栈copy到堆时的影响 Block从堆区release后 基本数据类型如int 从栈复制到堆 从堆区释放掉 Objective-C 对象 该对象引用计数加1，堆上的Block持有该对象 该对象引用计数减1，堆上的Block释放该对象所有权 b、对Block使用-retain、-autorelease操作 Block 能否调用使用-autorelease或者 -retain方法？ Block调用-copy从栈复制到堆时， 底层调用_Block_object_assign()函数持有被捕获的对象（自动变量）；从堆区释放时调用_Block_object_dispose()释放被捕获对象的所有权！ 使用-retain或者-autorelease 获取Block所有权，引用计数retainCount加1；但是并没有调用_Block_object_assign()函数与_Block_object_dispose()，被持有自动变量仍然在栈内存中： 对于基本数据类型如int等，只要持有Block所有权，就可以正常使用这些被持有的基本数据类型； 对于Objective-C类对象，捕获操作将变量指针赋值到Block结构体实例的结构成员上！对于变量指针的赋值操作，对变量的所有权没有任何影响，对变量的retainCount也没有任何影响！ 因此，捕获操作并没有捕获 Objective-C 类对象的所有权。 我们通过 retain 或者 autorelease 操作获取的Block 结构体实例的所有权，所以调用Block可以确保该对象存在！但是对被捕获的 Objective-C 类对象，Block结构体实例没有该变量的所有权，程序运行到此处，变量指针（Block 结构体实例的结构成员）指向的变量可能已被释放，此时程序可能闪退！！ 被捕获的自动变量 Block 在栈上retain或者autorelease 基本数据类型如int 没影响 Objective-C 对象 没影响 如果Block没有捕获自动变量，那么它被配置在全局静态区，此时又没有必要再次获取所有权了！ 获取Block 所有权的操作最好使用 copy 操作。 被捕获的自动变量释放问题 在MRC下，被捕获的自动变量随着 Block 使用 copy 操作，引用计数加 1 。当我们使用 release 释放 Block 时，Block 会将持有的自动变量引用计数减 1！！ 在 ARC 下，Block 会随着作用域的结束而被释放，此时被 Block 捕获的自动变量也随之释放！！ 4.2.3、__block 变量 通过 copy 操作，因为捕获的自动变量是指针，复制操作会使引用计数加 1！！那么 copy 将 Block 从栈复制到堆的时候，__block 变量会产生什么影响呢？？ __block 变量的配置存储域 Block 从栈复制到堆时的影响 栈 从栈复制到堆并被Block 持有 堆 Block 持有 a、在一个 Block中使用多个__block 变量 若在一个 Block 中使用 __block 变量，则 Block 持有该变量，该 __block 也必定配置在栈上。将 Block 从栈复制到堆上，所捕获的 __block 也被从栈上配置到堆上。 注意：__block 变量若不在 Block 中使用，则不会被复制到堆区！Block 的复制操作，对不被捕获的__block 变量没有任何影响！！ b、在多个 Block 中使用某个__block 变量 1、在多个Block中使用某个__block变量时，最初这些Block和 __block 变量都配置在栈上。 2、将任何一个 Block 从栈复制到堆上，这个 __block 变量也被从栈上复制到堆上被 Block 持有。 3、当剩下的 Block 从栈复制到堆上时，被复制的 Block 持有 __block 变量，并增加 __block 变量的引用计数。 c、Block被废弃 就像Objective-C的引用计数管理一样：使用__block变量的Block持有__block。如果Block被废弃，它所持有的__block变量就被释放。 d、__block变量的__forwarding指针 通过Block 的复制，__block变量也从栈上复制到堆上，此时可同时访问栈上和堆上的__block变量！那么栈上的__block变量的__forwarding指针指向何处？？堆上的__block变量的__forwarding指针又指向何处？？ 将栈上的__block变量复制到堆上，栈上的__block变量__forwarding指针将指向被复制到堆上的__block变量； 堆上__block变量的__forwarding指针指向其自身！！ 通过__block 变量的 __forwarding 指针，无论在 Block 表达式之中、在 Block 表达式之外，无论在栈上、还是复制到堆上。都能保证程序始终访问同一个 __block 变量！ e 、_Block_object_assign()函数与_Block_object_dispose()函数 在__block变量有__strong修饰时：当__block变量从栈复制到堆时，使用_Block_object_assign()函数持有赋值给__block变量的对象！当堆上的__block变量被废弃时，使用_Block_object_dispose()函数释放赋值给__block变量的对象。 被捕获的对象 BLOCK_FIELD_IS_OBJECT __block变量 BLOCK_FIELD_IS_BYREF 5、 Blocks 的循环引用问题 5.1、 Blocks 典型的循环引用 如下代码，造成循环引用： { ModelClass *model = [[ModelClass alloc] init]; model.requestBlcok = ^(BOOL isSuccess) { NSLog(@\"model ==== %@\",model); }; model.requestBlcok(YES); } 转为 C++ 源码，只看关键部分： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; ModelClass *__strong model; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, ModelClass *__strong _model, int flags=0) : model(_model) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 结构体 __main_block_impl_0 （即变量 Block ）持有 model；而 model 又持有该 Block ；因为双方互相持有，造成循环引用，导致内存无法释放！ 5.2、 使用 __weak 解决循环引用？ 如下代码，在 Block 表达式中使用 __weak 避免循环引用 { ModelClass *model = [[ModelClass alloc] init]; __weak typeof(model) weakModel = model; model.requestBlcok = ^(BOOL isSuccess) { NSLog(@\"weakModel ==== %@\",weakModel); }; model.requestBlcok(YES);} 转为 C++ 源码，只看关键部分： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; ModelClass *__weak weakModel; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, ModelClass *__weak _weakModel, int flags=0) : weakModel(_weakModel) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 结构体 __main_block_impl_0 通过 __weak 弱引用 model；虽然 model 持有该结构体，但不会造成循环引用！ 注意：由于是 __weak 修饰的弱引用， __main_block_impl_0 无法保证 弱引用对象的释放时机，所以有可能 在使用弱引用对象时该变量已经被释放，__weak 指针指向 nil ！ 5.3、 __weak 与 __strong 成对使用， 解决循环引用！ Block 表达式外面声明弱引用 __weak ，表达式中使用__strong再对弱引用 强引用： { ModelClass *model = [[ModelClass alloc] init]; __weak typeof(model) weakModel = model; model.requestBlcok = ^(BOOL isSuccess) { __strong typeof(weakModel) strongModel = weakModel; NSLog(@\"strongModel ==== %@\",strongModel); }; model.requestBlcok(YES); } 疑问：使用了 __strong 对 model 强引用，这不是和当初一样，再次造成了循环引用？ 转为 C++ 源码，分析关键部分： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; ModelClass *__weak weakModel; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, ModelClass *__weak _weakModel, int flags=0) : weakModel(_weakModel) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL isSuccess) { ModelClass *__weak weakModel = __cself->weakModel; // bound by copy __attribute__((objc_ownership(strong))) typeof(weakModel) strongModel = weakModel; NSLog((NSString *)&__NSConstantStringImpl__var_folders_s5_127zrd4j7kl4llwhcl4cz3_40000gn_T_main_ecfcbd_mi_0,strongModel); } strongModel 在 block 内部 （函数 __main_block_func_0() 中） 仅仅作为自动变量使用，而不是结构体 __main_block_impl_0 的结构成员，因此不存在 block 变量持有 model，所以也就不会导致循环引用！ 同时又通过强引用，保证了对 model 的所有权，不会导致使用时 model 被释放的情况发生！ 5.4、 为何 Masonry 不会导致循环引用？ 在 Masonry 的 Block 表达式中，使用它的持有者，为何不会导致循环引用呢？ { [self.aView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.left.equalTo(self.view); }]; } 不妨去探寻下 Masonry 的关键代码： @implementation UIView (MASAdditions) /// block 作为方法的实参，属于自动变量，不被任何对象持有 /// 因此即使在该 block 中使用 self.view ，也不会导致循环引用！ - (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block { self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; block(constraintMaker); return [constraintMaker install]; } @end @interface MASConstraintMaker : NSObject /// 对 view 弱引用，也不会导致循环引用 @property (nonatomic, weak) UIView *view; @property (nonatomic, strong) NSMutableArray *constraints; @end @implementation MASConstraintMaker - (id)initWithView:(UIView *)view { self = [super init]; if (!self) return nil; self.view = view; self.constraints = NSMutableArray.new; return self; } @end 1、 Masonry 的 Block 变量，仅仅作为方法参数，是一个自动变量、存储在栈区，不被任何对象持有！ 因此即使在该 block 中使用 self.view ，也不会导致循环引用！ 2、MASConstraintMaker 实例虽然引用了 self.view ，却是弱引用，也不会导致循环引用！ 6、 Blocks 面试题 Blocks 被捕获的自动变量 Blocks 的本质、 __block 变量的本质 Blocks 内存问题：什么时候配置在堆区？什么时候配置在栈区？什么时候配置在全局区！ Blocks 为何要使用 -copy 操作？可不可以使用 -retain 操作、 -autorelease 操作 Blocks使用 -copy 操作之后要不要 -release ？被捕获的自动变量引用计数有何变化？被捕获的自动变量需不需要释放？ Blocks使用 -copy 操作 对 __block 变量 的影响？ __block 变量赋值后， __forwarding 指针的指向问题？ 参考文章/图书 Demo C/C++语言的闭包 精通Objective-C Objective-C高级编程 iOS与OS X多线程和内存管理 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/OC内存管理.html":{"url":"iOS开发/Runtime/OC内存管理.html","title":"OC内存管理","keywords":"","body":"OC内存管理 Objective-C 的内存管理是通过引用计数实现的，引用计数是一种通过对象的唯一引用，确定对象是否正在被使用的技术！如果引用计数降到 0，对象就被视为不再有用，运行时系统会释放它的内存！ 引用计数通过可以递增递减的计数器来管理内存。对象创建好之后，保留引用计数至少为 1，若引用计数为正，则对象继续存活；若引用计数降为 0，则系统释放该对象。 内存管理不当导致的问题： 内存泄漏：应当废弃的对象在超出其生存周期后仍然存在！ 程序没有释放不再使用的对象会导致内存泄露；浪费内存资源，最终程序耗尽系统内存！ 悬挂指针：程序释放了还在使用的对象； Objective-C 提供了两种内存管理机制：手动管理 MRC 和 自动引用计数 ARC。 1、MRC 手动管理是一种建立在 对象所有权 概念上的内存管理机制，只要对象的所有者还存在，对象就不会被 Objective-C 运行时环境释放。 我们需要搞清楚 访问和使用对象的方式 以及 访问对象与对象所有权 之间的差别。 1.1、 对象引用与对象所有权 Objective-C 对象是通过指向该对象内存地址的指针，以间接方式访问的。 //定义一个 object1 的指针变量，指向一个 NSObject 对象 NSObject *object1 = [[NSObject alloc] init]; 指针实现了 Objective-C 对象的间接访问功能，但是它们本身不具备所有权： /* 声明指针 object2，指向一个名为 object1 的 NSObject 对象 * object2 并没有获取对象的所有权。 * 如果对象 object1 被释放，指针 object2 就是一个悬挂指针，不再指向一个合法对象 */ NSObject *object2 = object1; 1.2、内存管理原则 要正确使用 MRC ，编写代码时就必须在获取对象所有权与释放对象所有权之间进行平衡；需要遵循以下内存管理原则： 自己生成的对象，自己持有 : 通过+alloc、-new、-copy、-mutableCopy 等方法创建对象并持有对象的所有权； 非自己生成的对象，自己也能持有：通过-retain 方法可以获取一个对象的所有权； 不再需要自己持有的对象时释放所有权：自己持有的对象，一旦不再需要，持有者需要释放所有权，使用 -release 或者 -autorelease 方法释放该对象所有权；如果对象的引用计数为 0，编译器使用-dealloc 方法将该对象从堆内存清除； 无法释放非自己持有的对象：倘若在程序中释放了非自己持有的对象就会造成崩溃 /* 非自己生成的对象 * 取得的对象存在，但并不被 array 持有 */ NSMutableArray *array = [NSMutableArray array] [array retain];//通过 -retain 持有该对象 [array release];//不再使用时，释放所有权 在 Objective-C 中释放对象有两种方式： 调用-release 方法，使对象的引用计数立即递减； 调用-autorelease 方法将该对象加入自动释放池，虽然不再持有该对象所有权，但该对象可能仍然存在，并不会立即释放。清空自动释放池时，系统会向其中的对象发送 release 消息。 2、ARC 自动引用计数 ARC 是一种强大的内存管理工具，在编译程序时，编译器会分析源代码，确定以动态方式创建的对象的回收需求，然后在已编译代码的必要位置自动插入 retain 和 release 消息。 使用 ARC ，可以提升应用的性能、避免内存管理错误；与 MRC 相比，大幅度简化内存管理工作。但 ARC 仍需遵守一些规则： 不能使用 -retain、-release 、-autorelease、-retainCount 等方法； 不能直接进行 id 和 (void *) 类型的互换。ARC 只管理 Objective-C 对象，对于通用指针 (void *)，需要限制！如 Foundation 与 Core Foundation 框架对象的互换； 2.1、ARC的所有权修饰符 ARC 下的所有权修饰符： __strong：默认修饰符，强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象随之释放。 __weak：弱引用，对象随时可以被释放，释放后指针指向 nil；解决循环引用问题 __unsafe_unretained：不安全，编译器不负责内存管理；对象释放后指针不会指向 nil，变为悬挂指针； __autoreleasing : 等价于-autoreleasing ，将被修饰的变量注册到 NSAutoreleasePool Ⅰ、__strong 修饰符_ 在 ARC 下，由于 __strong 修饰符 是默认修饰符，因此非自己生成的对象，自己也能持有： /* 非自己生成的对象，自己也能持有 * NSMutableArray *array 等价于 __strong NSMutableArray *array * 超出其作用域，强引用失效，释放其所有权 */ NSMutableArray *array = [NSMutableArray array] __strong 修饰符在赋值上也能够正确管理其对象的所有权： // object1 自己生成并持有的对象 NSObject *object1 = [[NSObject alloc] init]; /* 声明指针 object2，指向一个名为 object1 的 NSObject 对象 * object2 获取对象的所有权：因为 object2 被 __strong 修饰 * 即使 object1 释放其所有权，指针 object2 仍然具有所有权 */ NSObject *object2 = object1; __strong 修饰符相当于 -retain 方法，要废弃 __strong 变量，只需将指针它处！ NSMutableArray *array = [NSMutableArray array];//对象A array = [NSMutableArray array];//对象B；此时对象A 被释放 array = nil;//对象B被释放 Ⅱ 、__weak 修饰符 当几个对象互相引用，会导致循环引用问题： @interface PeopleModel : NSObject @property (nonatomic ,strong) CarModel *car; @end @interface CarModel : NSObject @property (nonatomic ,strong) PeopleModel * owner; @end { PeopleModel *liSi = [[PeopleModel alloc]init]; CarModel *car = [[CarModel alloc]init]; liSi.car = car; car.car = liSi; } liSi 持有某辆车，该车又指向它的主人！两者互相引用：只有 car 被释放，变量liSi 才能释放掉；而变量 liSi 又等待 car 释放，它才会释放！这是最简单的的循环引用的例子。 ARC 下的循环引用，导致内存泄漏！为避免出现内存泄漏，需要使用弱引用。 弱引用是一种非所有权引用，被弱引用的对象不属于引用它的对象，从而消除循环引用！当弱引用修饰的变量被释放时，其指针指向 nil，不会造成悬挂指针！ Ⅲ 、__unsafe_unretained 修饰符 __unsafe_unretained 修饰符，是不安全的所有权修饰符！尽管 ARC 下内存管理由编译器负责，但 __unsafe_unretained 修饰修饰的变量不属于编译器管理的范畴！ __unsafe_unretained 变量同 __weak 变量一样，生成的对象并不被自己所持有！ __unsafe_unretained NSMutableArray *array_0; { NSMutableArray *array_1 = [NSMutableArray array]; array_0 = array_1;//变量 0 并不具备所有权 } /* 块作用域结束，数组 array_1 被释放 * 此时指针 array_0 指向的内存被废弃，array_0 是一个悬挂指针 */ NSLog(@\"array_0 === %@\",array_0); Ⅳ 、__autoreleasing 修饰符 内存峰值 是指应用程序在某个特定时间段内的最大内存用量。合理运用自动释放池，可降低应用程序的内存峰值。 自动释放池机制就像栈一样：系统创建好自动释放池之后，就将其推入栈中；而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里！ Cocoa 框架中的 Foundation 框架库中的 NSObject 类担负着内存管理的职责！ Objective-C 内存管理的 autorelease 就是自动释放，类似于 C 语言中的自动变量，而 NSAutoreleasePool 对象的生存周期相当于 C 语言变量的作用域。 对于所有调用过 -autorelease 方法的对象，在释放 NSAutoreleasePool 对象时，都将调用 -release 方法。 在 Cocoa 框架中，相当于程序主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象生成，持有和释放。NSRunLoop 每次循环过程中 NSAutoreleasePool 对象被生成和释放！ ARC 下，使用 @autoreleasepool块替代 NSAutoreleasePool 类对象。使用 __autoreleasing 修饰变量来替代 变量调用 -autorelease 方法！ 显式的附加 __autoreleasing 修饰符在编程中非常罕见，作为方法返回值的对象，编译器会自动将其注册到 autoreleasepool。 int main(int argc, const char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } return 0; } 从技术角度来说， main() 函数的自动释放池不是必需的，因为块的末尾恰好就是应用程序的终止处，而此时操作系统会把程序所占的全部内存都释放掉。虽然如此，但没有这个自动释放池，那么由 UIApplicationMain() 函数所自动释放的那些对象，就没有自动释放池可以容纳，于是系统会发出警告来表明这一信息！所以该自动释放池可以理解为最外围捕捉全部自动释放对象所用的池！ - [NSObject autorelease] └── id objc_object::rootAutorelease() └─ id objc_object::rootAutorelease2() └─ static id AutoreleasePoolPage::autorelease(id obj) └─ static id AutoreleasePoolPage::autoreleaseFast(id obj) ├─ id *add(id obj) ├─ static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├─ AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └─ id *add(id obj) └─ static id *autoreleaseNoPage(id obj) ├─ AutoreleasePoolPage(AutoreleasePoolPage *newParent) └─ id *add(id obj) ARC 有效，指定编译器属性为 -fobjc-arc 3、用僵尸对象调试内存管理 向已释放掉的对象发送消息是不安全的，这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有为其它内容所覆写。而这块内存有没有移作他用，又无法确定，因此应用程序只是偶尔崩溃，在没有崩溃的情况下，那块内存只是复用了其中一部分，所以对象中的某些二进制数据依然有效。还有另一种可能，该块内存恰好为另一个有效且存活的对象所占据，在这种情况下，运行时系统可能会把消息发到新对象那里，此新对象也许应答、也许不能！如果能，那么程序就不会崩溃，但处理的消息不是你预想的结果！ Cocoa 提供了 “僵尸对象”可以调试上述问题：将环境变量 NSZombieEnabled 设置为 YES，开启此功能。运行时系统会把所有已经回收的实例转化成特殊的 “僵尸对象”，而不会真正回收它们；这种对象所在的核心内存无法重用，不可能被覆写。僵尸对象收到消息后，会抛出异常：包含发送过来的消息、描述回收之前的对象！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/OC内存管理之引用计数.html":{"url":"iOS开发/Runtime/OC内存管理之引用计数.html","title":"OC内存管理之引用计数","keywords":"","body":"OC内存管理之引用计数 Objective-C 的内存管理是通过引用计数实现的！若引用计数为正，则对象存活；若引用计数降为 0，运行时系统会释放它的内存！ 在 objc 源码中使用散列表 SideTable 辅助管理对象的强引用计数和弱引用依赖： //散列表 SideTable ：主要用于辅助管理对象的 强引用计数 和 弱引用依赖 struct SideTable { spinlock_t slock;// 保证操作线程安全的自旋锁; RefcountMap refcnts;//引用计数的Map表 key-value：当isa中extra_rc不足以保存时,使用散列表保存refcnts.find(obj) weak_table_t weak_table; //弱引用表 } 自旋锁spinlock_t :如果把所有的类都存储在同一个表中，改动任何一个类都需要对整个表上锁，这导致操作效率和查询效率都很低。因此使用 Hash 数组 SideTables 管理多个SideTable，每个SideTable存储一部分对象，操作单个SideTable并不会影响到其它的表！ 1、弱引用表 weak_table_t 在ARC模式中使用关键字weak来处理对象之间的互相强引用导致的内存泄漏问题，主要是因为使用weak修饰变量不会导致引用计数的增加、不会影响对象的生命周期、而且在对象释放之后会将自动指针置空避免也指针访问问题！那么系统是如何管理weak变量呢？ 散列表SideTable中的 weak_table_t被设计用来管理指向对象的弱引用指针： /** 全局的弱引用表是一个由自旋锁控制的哈希表 : 程序中所有的弱引用都在该表中进行存储； * 该表以键值对的形式存储，对象作为 key，value 是结构 weak_entry_t */ struct weak_table_t { weak_entry_t *weak_entries;//存储所有指向某个对象的weak指针 size_t num_entries;//哈希表的容量大小 uintptr_t mask;//参与判断引用计数辅助量 uintptr_t max_hash_displacement;//hash key 最大偏移值 : hash冲撞时最大尝试次数，用于优化搜索算法 }; 哈希表weak_table_t并不直接管理弱引用指针，而是通过 weak_entry_t 来管理！在weak_table_t表中，每个对象对应一个 weak_entry_t，而每个 weak_entry_t 中存储着指向该对象的所有弱引用指针。 /** 用来存储某一对象的所有弱引用指针 * @param referent 被弱引用指针指向的对象， * @note 该结构使用两种存储方案存储弱引用指针： * case_1：弱引用指针数量 4 : 使用二维数组 referrers 保存, out_of_line_ness = 2; **/ struct weak_entry_t { DisguisedPtr referent; union { struct {//当弱引用指针个数大于 WEAK_INLINE_COUNT 时,使用二维指针数组进行存储 weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; }; struct {//当弱引用指针个数小于 WEAK_INLINE_COUNT 时,使用一维数组进行存储 weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; }; bool out_of_line() {//判断当前是否是离线存储 return (out_of_line_ness == REFERRERS_OUT_OF_LINE); } weak_entry_t& operator=(const weak_entry_t& other) {//重载运算符= memcpy(this, &other, sizeof(other)); return *this; } //第一个弱引用指针使用该方法存储 weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent){ inline_referrers[0] = newReferrer; for (int i = 1; i 1.1、弱引用表weak_table_t的管理 1.1.1、弱引用表的插入、删除、查询 通过插入、删除、查询操作，可以管理弱引用表weak_table_t的某个对象 weak_entry_t /** 将 new_entry 添加到弱引用表中 * @note 不会检查引用是否已经在表中 */ static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry); /** 从弱引用表移除弱引用 weak_entry_t */ static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry); /** 在弱引用表查询指定对象的 weak_entry_t * @param referent 指定对象，不能为 nil * @return 如果弱引用表没有该对象的 weak_entry_t ，则返回 NULL */ static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent); 1.1.2、弱引用表容量的扩增与缩减 当 weak_table_t 容量过满或者过空时，需要及时调整其大小，以优化内存的使用率，提高运行效率！ /* 调整弱引用表中的大小 * @param new_size 新的大小 */ static void weak_resize(weak_table_t *weak_table, size_t new_size){ size_t old_size = TABLE_SIZE(weak_table); weak_entry_t *old_entries = weak_table->weak_entries; weak_entry_t *new_entries = (weak_entry_t *)calloc(new_size, sizeof(weak_entry_t));//申请相应大小的内存 weak_table->mask = new_size - 1;//记录weak_table实际占用的内存边界 weak_table->weak_entries = new_entries; /* 哈希表可能会有 hash 碰撞，而 weak_table_t 使用了开放寻址法来处理碰撞。 * 如果发生碰撞的话，将寻找相邻(如果已经到最尾端的话，则从头开始)的下一个空位。 * max_hash_displacement 记录当前 weak_table 最大的偏移值，即hash函数计算的位置和实际存储位置的最大偏差。 */ weak_table->max_hash_displacement = 0; weak_table->num_entries = 0;// restored by weak_entry_insert below if (old_entries) { weak_entry_t *entry; weak_entry_t *end = old_entries + old_size; for (entry = old_entries; entry referent) { weak_entry_insert(weak_table, entry); } } free(old_entries); } } /** 扩充 weak_table_t 的空间，扩充条件是表的 3/4及以上的空间已经被使用。 * @note 该表初始化大小是 64 个 weak_entry_t 的空间，每次扩充后的空间都是当前空间的两倍，即2的N次方(N>=6) */ static void weak_grow_maybe(weak_table_t *weak_table){ size_t old_size = TABLE_SIZE(weak_table); if (weak_table->num_entries >= old_size * 3 / 4) { weak_resize(weak_table, old_size ? old_size*2 : 64); } } /** 缩小 weak_table_t 的空间，缩小的条件是表的容量不小于1024个weak_entry_t的空间，并且低于1/16的空间被占用 * 缩小后的空间是当前空间的1/8。 */ static void weak_compact_maybe(weak_table_t *weak_table){ size_t old_size = TABLE_SIZE(weak_table); if (old_size >= 1024 && old_size / 16 >= weak_table->num_entries) { weak_resize(weak_table, old_size / 8); } } 1.2、weak_entry_t的插入与删除 weak_entry_t使用数组存储指向某个对象的所有弱引用指针！Runtime 提供了一些函数可以将弱引用指针插入这个数组、从数组移除指定的弱引用指针、扩充数组容量等操作 /** 将弱引用指针存储至weak_entry_t的数组中 * 该函数主要做了以下几件事： * 1、当前没有使用离线存储，将 new_referrer 保存至数组 inline_referrers的空余位置； * 如果没有空余位置，将数组 new_referrer 的元素拷至数组 referrers 并设置为离线存储； * 2、如果数组 new_referrer 当前已经使用了总量的3/4 ，则需要扩充容量，并将指针 new_referrer 存储至 weak_entry_t * 3、如果数组 new_referrer 当前还未超出总量的3/4 ，则直接将指针 new_referrer 存储至 weak_entry_t */ static void append_referrer(weak_entry_t *entry, objc_object **new_referrer) /** 从指定 weak_entry_t 实例中的数组移出某个弱引用指针 * 该函数主要做了以下几件事： * 1、如果使用非离线存储,则遍历静态数组 inline_referrers,找到 old_referrer 则移出数组，否则继续执行; * 2、如果使用离线存储：使用 w_hash_pointer(old_referrer) & (entry->mask)获取起始索引, * 遍历entry->referrers，找到之后置空，并entry->num_refs自减. */ static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer) /** 扩容并增加新的弱引用指针,最终的存储还是依靠append_referrer() 函数完成 */ static void grow_refs_and_insert(weak_entry_t *entry,objc_object **new_referrer) 1.3、weak变量的管理机制 疑问：弱引用指针是如何一步步的存储到weak_entry_t的数组中，被weak_table_t管理的呢？ 弱引用指针的使用有多种情况： 1、初始化一个弱引用指针并赋值: __weak MyModel *weakModel = model; 2、将一个已声明的弱引用指针重新赋值:*weakModel = model; 3、被弱引用的对象释放 dealloc； 我们分别看下它们的底层调用有何不同！ 1.3.1、注册一个有效的弱引用指针 注册一个有效的弱引用指针，底层函数调用流程： - __weak MyModel *weakModel = model; └── id objc_initWeak(id *location, id newObj) └─ id storeWeak(id *location, objc_object *newObj) └─ id weak_register_no_lock() └─ void append_referrer() ├─ void weak_grow_maybe() ├─ void weak_entry_insert() I、 初始化一个新的弱引用指针 /** 初始化一个新的弱引用指针指向对象的地址 * @param location 弱引用指针的内存地址 * @param newObj 弱指针指向的新对象 * @note 该函数不是线程安全的 * @note 函数有一个前提条件：就是object必须是一个没有被注册为__weak对象的有效指针 */ id objc_initWeak(id *location, id newObj){ if (!newObj) {//判断原始引用对象是否为空 *location = nil; return nil; } //调用 objc_storeWeak() 函数，更新指针指向，创建对应的弱引用表 return storeWeak(location, (objc_object*)newObj); } II、新指针指向，创建对应的弱引用表 /** 更新指针指向，创建对应的弱引用表 * 该函数主要做了以下几件事： * 1、分别获取新、旧值相关联的 SideTable * 2、如果有旧值就调用 weak_unregister_no_lock() 函数，从旧值的 weak_entry_t 数组中移出旧指针 * 3、如果有新值就调用 weak_register_no_lock() 函数分配新值，并标记新值存在弱引用 */ template static id storeWeak(id *location, objc_object *newObj){ assert(haveOld || haveNew);//断言新值和旧值至少有一个是存在 if (!haveNew) assert(newObj == nil); //在类没有完成 +initialized 方法之前调用 weakStore 时,作为初始化的标识 Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; retry: /******************* 分别获取新旧值相关联的引用表 *****************/ if (haveOld) { oldObj = *location;//获取弱引用指针的旧指向 oldTable = &SideTables()[oldObj];//获取oldObj对应的弱引用表 } else { oldTable = nil; } if (haveNew) { newTable = &SideTables()[newObj];//获取newObj对应的弱引用表 } else { newTable = nil; } SideTable::lockTwo(oldTable, newTable);//上锁 if (haveOld && *location != oldObj) {//如果旧值改变就重新获取旧值相关联的表 SideTable::unlockTwo(oldTable, newTable); goto retry; } // 如果有新值，判断新值所属的类是否已经初始化，如果没有初始化，则先执行初始化，防止+initialize内部调用 storeWeak() 产生死锁 if (haveNew && newObj) { Class cls = newObj->getIsa(); if (cls != previouslyInitializedClass && !((objc_class *)cls)->isInitialized()){ SideTable::unlockTwo(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // 如果这个类在它自身的一个实例上调用storeWeak()进行 +initialize，那么我们可以继续，但是它将显示为正在初始化，并且还没有初始化到上面的检查中。 previouslyInitializedClass = cls; goto retry; } } /*********** 如果旧值存在，则从旧值的 weak_entry_t 数组中移出旧指针 **********/ if (haveOld) { weak_unregister_no_lock(&oldTable->weak_table, oldObj, location); } /*********** 如果有新值，绑定新值与弱引用指针 **********/ if (haveNew) { newObj = (objc_object *)weak_register_no_lock(&newTable->weak_table, (id)newObj, location,crashIfDeallocating); if (newObj && !newObj->isTaggedPointer()) { newObj->setWeaklyReferenced_nolock();//标记新值存在弱引用 } *location = (id)newObj;//不要在其他地方设置 *location。那会引起数据竞争。 }else { // 没有新值，存储没有更改。 } SideTable::unlockTwo(oldTable, newTable); return (id)newObj; } 注意： 使用模板参数进行常量参数传递是为了优化性能,预判了大概率会发生的事情优先处理； param HaveOld 是否有旧的引用，如果有旧的引用则需要释放； param HaveNew 是否有新的引用，如果有则需要存储新的引用； param crashifdeallocate 为true，则当newObj正在释放或newObj的类不支持弱引用时，进程将停止；为false则存储nil。 case1 初始化一个弱引用指针并赋值，该指针没有旧值：HaveOld=false,haveNew=true； case2 将弱引用指针指向nil，该指针没有新值：HaveOld=true,haveNew=false； case3 将一个指向其它对象的弱引用指针重新赋值：HaveOld=true,haveNew=true； III、向弱引用表里添加新的弱应用指针 /** 向弱引用表里添加新的弱应用指针 * 该函数主要做了以下几个事情： * 1、如果被引用对象正在释放，则不能再添加弱应用指针 * 2、在弱引用表查询指定对象的 weak_entry_t * 2.1、如果查到 weak_entry_t ，则将弱引用指针存储至 weak_entry_t * 2.2、如果没有查到 weak_entry_t，新建一个 weak_entry_t 并存储弱指针，将 weak_entry_t 存储在弱引用表 * @param referent 被引用对象，不能为空、不能是TaggedPointer * @note 在 -dealloc 方法中,不能增加新的弱引用指针,否则会报错. */ id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating){ objc_object *referent = (objc_object *)referent_id;//获取被引用对象 objc_object **referrer = (objc_object **)referrer_id;//强转referrer_id为二级指针 if (!referent||referent->isTaggedPointer()) return referent_id; /*********************** 如果被引用对象正在释放，则不能再添加弱应用指针 ***********************/ bool deallocating;//确保被引用对象是可行的 if (!referent->ISA()->hasCustomRR()) { deallocating = referent->rootIsDeallocating(); }else { BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) { return nil; } deallocating = !(*allowsWeakReference)(referent, SEL_allowsWeakReference); } if (deallocating) {//如果对象正在释放,不能增加新的弱引用指针 if (crashIfDeallocating) { _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); } else { return nil; } } /*********************** 在弱引用表查询指定对象的 weak_entry_t ***********************/ weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) { /********* 将弱引用指针referrer存储到对象referent关联的weak_entry_t中 *************/ append_referrer(entry, referrer); } else {//在weak_table中未找到referent对应的weak_entry_t /********* 新建一个 weak_entry_t 并存储弱指针，将 weak_entry_t 存储在弱引用表 *************/ weak_entry_t new_entry(referent, referrer);//给对象referent创建一个新的引用列表 weak_grow_maybe(weak_table);// weak_table 增加内存 weak_entry_insert(weak_table, &new_entry);//把referent的引用列表加入到weak_table中 } // Do not set *referrer. // objc_storeWeak() requires that the value not change. return referent_id; } IV、将弱引用指针存储至weak_entry_t的数组中 /** 将弱引用指针存储至weak_entry_t的数组中 * 该函数主要做了以下几件事： * 1、当前没有使用离线存储，将 new_referrer 保存至数组 inline_referrers的空余位置； * 如果没有空余位置，将数组 new_referrer 的元素拷至数组 referrers 并设置为离线存储； * 2、如果数组 new_referrer 当前已经使用了总量的3/4 ，则需要扩充容量，并将指针 new_referrer 存储至 weak_entry_t * 3、如果数组 new_referrer 当前还未超出总量的3/4 ，则直接将指针 new_referrer 存储至 weak_entry_t */ static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ //在增加新的弱引用指针之前使用非离线存储弱引用指针：使用静态数组inline_referrers来进行存储 if (!entry->out_of_line()) { for (size_t i = 0; i inline_referrers[i] == nil) {//将新的弱引用指针存储在该数组空位置上,并返回 entry->inline_referrers[i] = new_referrer; return; } } // 在静态数组中没有可用的存储位置，需要开辟离线空间 weak_referrer_t *new_referrers = (weak_referrer_t *)calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); //将之前inline_referrers数组的元素复制到数组 new_referrers 中 for (size_t i = 0; i inline_referrers[i]; } entry->referrers = new_referrers; entry->num_refs = WEAK_INLINE_COUNT; entry->out_of_line_ness = REFERRERS_OUT_OF_LINE; entry->mask = WEAK_INLINE_COUNT-1; entry->max_hash_displacement = 0; } assert(entry->out_of_line());//断言：代码执行到这个位置时 entry 应该是离线存储 if (entry->num_refs >= TABLE_SIZE(entry) * 3/4) {//如果当前已经使用了总量的3/4,则扩容并添加新的引用,并返回 return grow_refs_and_insert(entry, new_referrer); } //如果当前已经使用量小于总量的3/4,则直接添加 size_t begin = w_hash_pointer(new_referrer) & (entry->mask); size_t index = begin; size_t hash_displacement = 0; while (entry->referrers[index] != nil) {//发生hash碰撞 hash_displacement++; index = (index+1) & entry->mask; if (index == begin) bad_weak_table(entry); } //更新存储时最大的hash碰撞次数,由于优化取值时算法减少搜索次数 if (hash_displacement > entry->max_hash_displacement) { entry->max_hash_displacement = hash_displacement; } weak_referrer_t &ref = entry->referrers[index]; ref = new_referrer; entry->num_refs++; } 至此，Runtime 已经初始化一个新的弱引用指针，并将它存储在散列表 SideTable! 1.3.2、将被注册的弱引用指针重新赋值 - weakModel = model; └── id objc_storeWeak(id *location, id newObj) └─ id storeWeak(id *location, objc_object *newObj) └─ void weak_unregister_no_lock() └─ void remove_referrer() └─void void weak_entry_remove() └─ id weak_register_no_lock() └─ void append_referrer() ├─ void weak_grow_maybe() ├─ void weak_entry_insert() 将已经被注册的弱引用指针再次指向别的变量，会通过objc_storeWeak()函数调用storeWeak()函数！在storeWeak()函数中，首先需要将被注册的弱引用指针从被引用变量weak_entry_t的数组中移除；然后才可以将该弱引用指针与新变量重新关联！ /** 移除指定的弱引用指针： * 该函数主要做了以下几件事： * 1、在 weak_table 中查找对应的 weak_entry_t； * 2、从 weak_entry_t 的数组中移除referrer指针； * 3、判断 weak_entry_t 的数组是否为空，若不再存储弱引用指针,则从弱引用表中移除 weak_entry_t； */ void weak_unregister_no_lock(weak_table_t *weak_table, id referent_id,id *referrer_id){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; /**************** 在弱引用表查询指定对象的 weak_entry_t *************/ if ((entry = weak_entry_for_referent(weak_table, referent))) { /********** 从指定 weak_entry_t 实例中的数组移出某个弱引用指针 **********/ remove_referrer(entry, referrer); /********** 若 weak_entry_t 的数组为空,则从弱引用表中移除 weak_entry_t **********/ bool empty = true;//判断移除指针之后entry数组是否为空 if (entry->out_of_line() && entry->num_refs != 0) { empty = false; }else { for (size_t i = 0; i inline_referrers[i]) { empty = false; break; } } } if (empty) {//如果移出指针之后entry数组为空，则从弱引用表中移除entry weak_entry_remove(weak_table, entry); } } } 1.3.3、弱引用变量 dealloc 当对象调用 -dealloc 方法时，Runtime 会从弱引用表清空指向该对象的所有弱引用指针： - [weakModel dealloc]; └── [NSObject dealloc]; └─ void _objc_rootDealloc(id obj) └─ void objc_object::rootDealloc() └─ id object_dispose(id obj) └─ void *objc_destructInstance(id obj) └─ void objc_object::clearDeallocating() └─ void objc_object::clearDeallocating_slow() └─ void weak_clear_no_lock() 关键的函数是 weak_clear_no_lock() /** 当对象调用 -dealloc 方法时，从弱引用表清空某个对象的所有弱引用指针 */ void weak_clear_no_lock(weak_table_t *weak_table, id referent_id){ objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) {//若entry为空则证明当前对象不存在弱引用指针. return; } weak_referrer_t *referrers;//声明一个数组用来存储所有指向该对象的弱引用指针 size_t count;//数组容量 if (entry->out_of_line()) {//使用离线存储弱引用指针 referrers = entry->referrers; count = TABLE_SIZE(entry); } else { //使用内部静态数组存储弱引用指针 referrers = entry->inline_referrers; count = WEAK_INLINE_COUNT; } //遍历数组，将所有指向该对象的弱引用指针全部指向 nil for (size_t i = 0; i 2、强引用表 RefcountMap 2.1、+alloc 方法 - [MyModel alloc]; └── id objc_alloc(Class cls) └─ id callAlloc() └─ [NSObject alloc]; └─ id _objc_rootAlloc(Class cls) └─ id callAlloc() └─ id class_createInstance() └─ id _class_createInstanceFromZone() 2.2、-retain 方法 /** 对象的引用计数 +1 * 该函数主要做了以下几件事： * 1、通过对象内存地址，在SideTables找到对应的SideTable * 2、通过对象内存地址，在refcnts中取出引用计数 * 3、判断引用计数是否增加到最大值，如果没有，则 +4 */ id objc_object::sidetable_retain(){ #if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer); #endif /****************** 在SideTables找到对应的SideTable ******************/ SideTable& table = SideTables()[this]; table.lock(); /****************** 在 RefcountMap 中取出引用计数 ******************/ size_t& refcntStorage = table.refcnts[this]; if (!(refcntStorage & SIDE_TABLE_RC_PINNED)) { /****************** 没有到最大值，1 则+4 ******************/ refcntStorage += SIDE_TABLE_RC_ONE; } table.unlock(); return (id)this; } 2.3、-release 方法 /** 对象的引用计数 -1 * 该函数主要做了以下几件事： * 1、通过对象内存地址，在 SideTables 找到对应的SideTable * 2、通过对象内存地址，在refcnts中取出引用计数 * 3、根据当前引用计数分别做出对应处理: * 3.1、没有引用计数，标记为正在释放状态 * 3.2、强引用计数为 0 ，不做操作 * 3.3、没有达到最高位，则引用计数 -1 * 4、如果需要释放，则调用 -dealloc 方法 */ uintptr_t objc_object::sidetable_release(bool performDealloc){ #if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer); #endif /****************** 在 SideTables 找到对应的SideTable ******************/ SideTable& table = SideTables()[this]; bool do_dealloc = false; table.lock(); /****************** 在 RefcountMap 中取出引用计数 ******************/ RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) { /* table.refcnts.end()表示使用一个iterator迭代器到达了end()状态 * end() 状态表示从头开始查找，一直找到最后都没有找到 * 该条 if 语句表示查找到最后都没找到引用计数表 RefcountMap */ do_dealloc = true; table.refcnts[this] = SIDE_TABLE_DEALLOCATING;//标记对象为正在释放 } else if (it->second second |= SIDE_TABLE_DEALLOCATING; //不会影响 弱引用标记位 } else if (!(it->second & SIDE_TABLE_RC_PINNED)) { it->second -= SIDE_TABLE_RC_ONE; //引用计数 -1 } table.unlock(); if (do_dealloc && performDealloc) {//如果需要释放对象，则调用dealloc ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); } return do_dealloc; } Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/+load方法的调用历程.html":{"url":"iOS开发/Runtime/+load方法的调用历程.html","title":"+load方法","keywords":"","body":"Objective-C中+load方法的调用历程 根类 NSObject 中有两个类方法用于加载和初始化类： + (void)load; + (void)initialize; 区别 +load +initialize 调用时机 在类被加载之后，调用 +initialize 之前调用 用于加载该类之后初次使用该类之前调用 实现环境 可以由类实现，也可以在分类实现 不能在分类重写 实现处代码 当类被加载时，该处实现代码被调用一次 当类收到第一条消息时，+initialize 会被调用一次；没有收到消息就不会被调用 1、分析 objc-loadmethod.m 文件 关于 +load 方法的大部分操作，Runtime 封装在文件 objc-loadmethod.m 中。想要了解 +load 方法的调用流程，首先需要了解一下关于 +load 方法的功能函数！！ 1.1、该文件中的变量 1.1.1、存储实现 +load 方法类的数组 struct loadable_class { Class cls; IMP method; }; static struct loadable_class *loadable_classes = nil; static int loadable_classes_used = 0; static int loadable_classes_allocated = 0; 结构体loadable_class用于存储实现了 +load 方法的Class和 +load 方法的实现IMP； 结构数组loadable_classes ：存储结构loadable_class； 静态变量 loadable_classes_used 用于记录 add_class_to_loadable_list() 函数的调用次数，同时也是 loadable_classes 数组的元素个数； 1.1.2、存储实现+load方法分类的数组 //存储了 +load 方法所属的 Category 和 +load 方法的IMP struct loadable_category { Category cat; //+load 方法所属的 Category；可能为 nil IMP method; }; static struct loadable_category *loadable_categories = nil; static int loadable_categories_used = 0; static int loadable_categories_allocated = 0; 结构体loadable_category用于存储实现了 +load 方法的category和 +load 方法的实现IMP； 结构数组loadable_categories ：存储元素为 loadable_category； 静态变量loadable_categories_used 用于记录 add_category_to_loadable_list()函数的调用次数，也是 loadable_categories 数组的元素个数； 1.2、结构数组 loadable_classes 的增删操作 1.2.1、向数组 loadable_classes 添加一个类 void add_class_to_loadable_list(Class cls){ IMP method; loadMethodLock.assertLocked(); method = cls->getLoadMethod();//获取类 cls 的 +load 方法的 IMP if (!method) return; if (PrintLoading) { _objc_inform(\"LOAD: class '%s' scheduled for +load\", cls->nameForLogging()); } if (loadable_classes_used == loadable_classes_allocated) { //如果数组 loadable_classes 分配的内存已用完，对数组进行动态扩容 loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *)realloc(loadable_classes, loadable_classes_allocated *sizeof(struct loadable_class)); } loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++; } 该函数的主要的功能就是将一个实现了 +load 的指定类添加到数组 loadable_classes中： 如果该类没有实现+load 方法，自然是什么操作也不做； 如果如果数组 loadable_classes 分配的内存已用完，对数组进行动态扩容； 将指定的类与IMP存储在数组 loadable_classes中； loadable_classes_used数组加 1，用于记录该函数的调用次数；相当于数组loadable_classes 的元素个数； 1.2.2、移除数组 loadable_classes中某个类 void remove_class_from_loadable_list(Class cls){ loadMethodLock.assertLocked(); if (loadable_classes) { int i; //遍历结构数组 loadable_classes，根据入参 cls 找到数组中指定的元素 for (i = 0; i nameForLogging()); } return; } } } } 该函数的主要功能就是遍历数组 loadable_classes ，找到指定的类，并将该类从数组loadable_classes 中移除。 1.3、结构数组 loadable_categories 的增删操作 1.3.1、向数组 loadable_categories 添加一个分类 void add_category_to_loadable_list(Category cat){ IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); if (!method) return; if (PrintLoading) { _objc_inform(\"LOAD: category '%s(%s)' scheduled for +load\", _category_getClassName(cat), _category_getName(cat)); } if (loadable_categories_used == loadable_categories_allocated) { //如果数组 loadable_categories 分配的内存已用完，对数组进行动态扩容 loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); } loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++; } 该函数的主要的功能就是将一个实现了 +load 的指定分类添加到数组 loadable_categories中： 如果该分类没有实现+load 方法，自然是什么操作也不做； 如果数组 loadable_categories 分配的内存已用完，对数组进行动态扩容； 将指定的分类与IMP存储在数组 loadable_categories中； loadable_categories_used数组加 1，用于记录该函数的调用次数；相当于数组loadable_categories 的元素个数； 1.3.2、移除数组 loadable_categories中某个分类 void remove_category_from_loadable_list(Category cat){ loadMethodLock.assertLocked(); if (loadable_categories) { int i; //遍历结构数组 loadable_categories，根据入参 cat 找到数组中指定的元素 for (i = 0; i 该函数的主要功能就是遍历数组 loadable_categories ，找到指定的分类，并将该分类从数组 loadable_categories中移除。 1.4、使用数组 loadable_categories与 loadable_classes 在objc-loadmethod.m文件的 call_load_methods()函数，是调用程序中实现的 +load 方法的入口： void call_load_methods(void){ static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do { // 1. 重复调用 loadable_classes 数组上的 +load，直到不再有其他类为止 while (loadable_classes_used > 0) { //遍历数组 loadable_classes ，调用数组中所有挂起的类的 +load 方法; 调用之后，将 loadable_classes_used 置为 0； call_class_loads(); } // 2. 调用 loadable_categories 数组中的 +load 一次：调用该函数期间，是否有新的分类添加到数组 more_categories = call_category_loads(); } while (loadable_classes_used > 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO; } 该函数的主要功能就是： 调用 call_class_loads() 函数，执行数组loadable_classes中的 +load方法； 调用 call_category_loads() 函数，执行数组loadable_categories中的 +load方法； 1.4.1、调用数组loadable_classes中的 +load方法 static void call_class_loads(void){ int i; struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; for (i = 0; i nameForLogging()); } (*load_method)(cls, SEL_load);//通过函数指针执行指定类 cls 的 +load 方法 } if (classes) free(classes);//释放列表 } 该函数的主要功能就是： 遍历数组loadable_classes_used，取出每个元素的类与 +load的实现，然后执行该实现 (*load_method)(cls, SEL_load) ； 遍历数组loadable_classes_used完毕，释放该数组，重置计数loadable_classes_used； 1.4.2、调用数组loadable_categories中的 +load方法 static bool call_category_loads(void){ int i, shift; bool new_categories_added = NO;//该函数返回值 struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; for (i = 0; i isLoadable()) {//要求该类可加载 if (PrintLoading) { _objc_inform(\"LOAD: +[%s(%s) load]\\n\", cls->nameForLogging(), _category_getName(cat)); } (*load_method)(cls, SEL_load);//通过函数指针执行指定分类的 +load 方法 cats[i].cat = nil; } } //将所有调用 +load 方法的分类移除数组 shift = 0; for (i = 0; i 0);//是否有新的分类添加到数组 loadable_categories for (i = 0; i 该函数的主要功能就是： 遍历数组loadable_categories，取出每个元素的分类与 +load的实现，然后执行该实现 (*load_method)(cls, SEL_load) ； 将所有调用 +load 方法的分类移除数loadable_classes_used； 接着判断是否有新的分类被添加到数组loadable_categories；如果有，则返回 YES 1.5、文件objc-loadmethod.m功能总结 1.5.1、全局变量 结构数组loadable_classes 中的每个元素都存储了类以及它的 +load 方法的 IMP； 结构数组 loadable_categories中的每个元素都存储了分类以及它的 +load 方法的 IMP； 1.5.2、功能函数 add_class_to_loadable_list() 函数将一个实现了 +load 方法的类添加到数组 loadable_classes； add_category_to_loadable_list()函数将一个实现了 +load 方法的分类添加到数组 loadable_categories； remove_class_from_loadable_list() 函数从数组 loadable_classes 中移除指定类； remove_category_from_loadable_list() 函数从数组 loadable_categories 中移除指定分类； call_class_loads() 函数遍历数组 loadable_classes 调用数组中所有挂起的类的 +load 方法；调用之后数组 loadable_classes 置为 nil； call_category_loads() 函数遍历数组 loadable_categories调用分类挂起的 +load 方法； call_load_methods() 函数调用所有挂起(未注册)的类和分类的 +load 方法。 2、+load方法的调用历程 从 objc-loadmethod.m 文件中的变量与函数来看：程序中类或者分类实现的+load方法，Runtime 都记录在了数组loadable_classes 与数组 loadable_categories，那么何时调用指定类或者分类的+load方法呢？ 也就是说何时使用这两个数组的元素呢？ 首先打印PeopleModel类的+load方法的调用栈信息： (lldb) thread backtrace * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1 * frame #0: 0x0000000100000bd7 objc-test`+[PeopleModel load](self=PeopleModel, _cmd=\"load\") at PeopleModel.m:12 frame #1: 0x000000010037218c libobjc.A.dylib`call_class_loads() at objc-loadmethod.mm:200 frame #2: 0x0000000100359b0d libobjc.A.dylib`::call_load_methods() at objc-loadmethod.mm:326 frame #3: 0x000000010035996a libobjc.A.dylib`::load_images(path=\"/Users/longlong/Library/Developer/Xcode/DerivedData/SourceCode-gbviaxaumpwhkieshjwwgrxrxpva/Build/Products/Debug/objc-test\", mh=0x0000000100000000) at objc-runtime-new.mm:2035 frame #4: 0x000000010000a454 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 420 frame #5: 0x000000010001c0c5 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 337 frame #6: 0x000000010001b254 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 134 frame #7: 0x000000010001b2e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 74 frame #8: 0x000000010000a774 dyld`dyld::initializeMainExecutable() + 199 frame #9: 0x000000010000f78f dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 6237 frame #10: 0x00000001000094f6 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1154 frame #11: 0x0000000100009036 dyld`_dyld_start + 54 为了优化程序启动速度和利用动态库缓存，iOS 系统采用了共享缓存技术；dyld 缓存在 iOS系统中。 dyld 从 dyldStartup.s 文件开始执行： 其中用汇编实现的 __dyld_start 函数里面调用了 dyldbootstrap::start() 函数; 然后调用了 dyld::_main() 函数，创建镜像加载类 ImageLoader，分析 Mach-O 文件； 接着根据指定的 Mach-O 文件的头信息mach_header 调用load_images()函数加载镜像信息 针对 dyld 的调用流程，这里不做过多分析！笔者从 Runtime 库中objc-runtime-new.mm文件的load_images()函数说起： void load_images(const char *path __unused, const struct mach_header *mh){ if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); { mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); } call_load_methods(); } 通过该函数的入参可知，该函数可能会被多次调用，每次调用，处理一个指定 mach_header 中的 +load 信息。该函数的全部代码如上所示，执行的功能很简单： 1、判断该 Mach-O 文件是否有实现的 +load 方法，如果没有就直接返回；否则向下执行； 2、调用 prepare_load_methods() 函数将该 Mach-O 文件中所有实现的 +load 方法分别存储到数组loadable_classes 与数组 loadable_categories； 3、调用 call_load_methods() 函数执行数组loadable_classes 与数组 loadable_categories的 +load 方法； 关于call_load_methods() 函数的功能，笔者在章节 1已经详细讲过，这里不再重复！我们来看看 prepare_load_methods() 函数： 2.1、prepare_load_methods()函数 void prepare_load_methods(const headerType *mhdr){ size_t count, i; runtimeLock.assertLocked(); //获取实现了+load方法的类的列表 classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &count); for (i = 0; i cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls->ISA()->isRealized()); add_category_to_loadable_list(cat); } } 分析该函数，主要功能为： 1、获取程序中所有实现了 +load 方法的类列表 classlist 与分类列表 categorylist ； 2、遍历类列表 classlist ，通过调用schedule_class_load()函数，将类与它的+load 方法存储到数组loadable_classes 中； 3、遍历分类列表 categorylist ，通过调用add_category_to_loadable_list()函数，将分类与它的+load 方法存储到数组loadable_categories 中； 2.1.1、schedule_class_load()函数 static void schedule_class_load(Class cls){ if (!cls) return; assert(cls->isRealized()); // _read_images should realize // 已经添加 Class 的 +load 方法到调用列表中 if (cls->data()->flags & RW_LOADED) return; // 确保 super 已经被添加到 +load 列表中，默认是整个继承者链的顺序 schedule_class_load(cls->superclass); // 将IMP和Class添加到调用列表 add_class_to_loadable_list(cls); // 设置Class的flags，表示已经添加Class到调用列表中 cls->setInfo(RW_LOADED); } 在该函数中，看到了 add_class_to_loadable_list() 函数将类与它的+load 方法存储到数组loadable_classes 中。 在存入数组loadable_classes之前，必须确保它的父类如果实现+load 方法则在它之前加入数组loadable_classes。 2.2、调用时机 众所周知，程序通过入口函数 main() 开始执行，而 +load 的执行，却是在 Runtime 中实现的，此时程序并没有走到入口函数 main() ！ +load 方法可能被加载多次嘛？ 如何确保+load 方法只被加载一次？ 总结： +load 方法是 Runtime 调用的，无需开发者去调用； +load 的调用顺序遵循：父类调用+load之后，子类才能调用； +load 方法是在所有类被 Runtime 写入内存后才调用的； +load方法是按照 Compile Sources 的排列顺序加载的，但要遵循调用子类加载之前，必须先调用其父类的+load方法。 在所有类的+load 方法调用完以后再调用分类的 +load 方法，分类的+load 方法调用顺序完全按照 Compile Sources 排列顺序。 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的+load方法的实现是被区别对待的。 Runtime 自动调用+load 方法时，分类中的+load 方法并不会对主类中的+load 方法造成覆盖。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/TaggedPointer.html":{"url":"iOS开发/Runtime/TaggedPointer.html","title":"TaggedPointer","keywords":"","body":"标记指针 Tagged Pointer 1、Tagged Pointer 介绍 1.1、什么是 Tagged Pointer ？ Tagged Pointer 是一个特别的指针，它分为两部分： 一部分直接保存数据 ； 另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址； 因此，我们说Tagged Pointer 是一个伪指针！ 1.2、 Tagged Pointer 出现的背景 对于一个 NSNumber 对象，如果存储NSInteger的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位CPU下占4个字节。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在32位CPU下为4个字节。 在2013年9月，苹果推出了iPhone 5s，该款机型首次采用64位架构的A7双核处理器。此时，对于一个NSNumber对象，如果存储NSInteger的普通变量，那么它将占 8 个字节；一个指针也将占用 8 个字节。 对于一个普通的程序而言，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但对于 NSNumber、NSDate、NSString等类型的实例所占用的内存会翻倍、浪费了稀有的内存资源！！同时维护程序中的对象需要也分配内存，维护引用计数，管理生命周期，使用对象给程序的运行增加了负担！！ 为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。苹果将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。 1.3、苹果对 Tagged Pointer 的介绍 苹果对于 Tagged Pointer 特点的做出了介绍: Tagged Pointer 被设计的目的是用来存储较小的对象，例如NSNumber、NSDate、NSString 等； Tagged Pointer 的值不再表示地址，而是相关数据； 相关逻辑能减少一半的内存占用； 3 倍的访问速度提升：原本需要以指针的方式访问地址，再从地址拿到数据；现在直接从地址获取数据； 不需要在堆、栈创建与销毁；创建时比以前快106倍 ； 1.4、Tagged Pointer 的使用 在一个程序中运行下述代码，获取输出日志： NSNumber *number = @(0); NSNumber *number1 = @(1); NSNumber *number2 = @(2); NSNumber *number3 = @(9999999999999999999); NSString *string = [[@\"a\" mutableCopy] copy]; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0]; NSLog(@\"number ---- %@, %p\", [number class], number); NSLog(@\"number1 --- %@, %p\", [number1 class], number1); NSLog(@\"number2 --- %@, %p\", [number2 class], number2); NSLog(@\"number3 --- %@, %p\", [number3 class], number3); NSLog(@\"NSString -- %@, %p\", [string class], string); NSLog(@\"indexPath - %@, %p\", indexPath.class,indexPath); /********************* 输出日志 ********************* number ---- __NSCFNumber, 0xb000000000000002 number1 --- __NSCFNumber, 0xb000000000000012 number2 --- __NSCFNumber, 0xb000000000000022 number3 --- __NSCFNumber, 0x600003b791c0 NSString -- NSTaggedPointerString, 0xa000000000000611 indexPath - NSIndexPath, 0xc000000000000016 */ 分析日志： 1、NSNumber存储的数据不大时，NSNumber *指针是伪指针Tagged Pointer ； 2、NSNumber存储的数据很大时，NSNumber *指针一般指针，指向NSNumber实例的地址，如 number3； 3、NSTaggedPointerString 经常遇见，它就是Tagged Pointer 对象； Tagged Pointer 由 Runtime 实现，无需开发者操心！但是作为开发者，也要知道NSTaggedPointerString 的实现机制！ 1.5、Tagged Pointer 的思考 通过上文的概念 + 应用，相信大家对 Tagged Pointer 有了一定的了解；那么大家有没有一些疑问呢？ 系统是如何将 NSNumber、NSDate、NSString等类型的数据存储在 Tagged Pointer 上？ 既然Tagged Pointer 是一个伪指针，不再指向实例对象，那么isa指针就不能再调用！不通过isa指针获取它所属的类，系统是如何知道它存储的数据结构的？ 数据展示在Tagged Pointer ，可以被人通过Tagged Pointer 获取，明显不再安全，那么苹果是如何加密Tagged Pointer 上的数据的？ 2、Tagged Pointer 的底层探究 苹果设计的 Tagged Pointer 技术，是在 Runtime 库 中实现的。 关于 Tagged Pointer 技术的一些宏定义： #if !__LP64__ /// 32 位机器，不支持 Tagged Pointer # define SUPPORT_TAGGED_POINTERS 0 #else # define SUPPORT_TAGGED_POINTERS 1 #endif #if __arm64__ // ARM64 指令集使用了一种新的 TaggedPointers 方案：普通标记位于低位，扩展标记位于高位，并且一半的扩展标记空间预留给未混淆的有效负载 # define OBJC_SPLIT_TAGGED_POINTERS 1 #else # define OBJC_SPLIT_TAGGED_POINTERS 0 #endif #if (TARGET_OS_OSX || TARGET_OS_MACCATALYST) && __x86_64__ // 64 位的 Mac - tag bit is LSB # define OBJC_MSB_TAGGED_POINTERS 0 #else // 其余系统 - tag bit is MSB # define OBJC_MSB_TAGGED_POINTERS 1 #endif 2.1、Tagged Pointer 技术的启用与禁用 苹果预留了环境变量 OBJC_DISABLE_TAGGED_POINTERS，通过设置该变量的布尔值，可以将Tagged Pointer 技术的启用与关闭的决定权交给开发者！ 如果禁用Tagged Pointer ，只需设置环境变量 OBJC_DISABLE_TAGGED_POINTERS为YES 即可！ 2.1.1、Tagged Pointer 的禁用函数 Runtime 库 的 objc-runtime-new.mm文件中有一个禁用Tagged Pointer 的函数： static void disableTaggedPointers(){ objc_debug_taggedpointer_mask = 0; objc_debug_taggedpointer_slot_shift = 0; objc_debug_taggedpointer_slot_mask = 0; objc_debug_taggedpointer_payload_lshift = 0; objc_debug_taggedpointer_payload_rshift = 0; objc_debug_taggedpointer_ext_mask = 0; objc_debug_taggedpointer_ext_slot_shift = 0; objc_debug_taggedpointer_ext_slot_mask = 0; objc_debug_taggedpointer_ext_payload_lshift = 0; objc_debug_taggedpointer_ext_payload_rshift = 0; } 在该函数内部，将一些列变量全部设置为 0 ！至于这些变量都有什么用处，我们后文用到了再解释！ 2.1.2、何时调用 disableTaggedPointers() 函数? 何时调用 disableTaggedPointers() 函数禁用 Tagged Pointer 呢？ 还是在 objc-runtime-new.mm 文件中，在大名鼎鼎的 _read_images() 函数中有一处关键代码： /// 注意：由于_read_images() 函数中完成了大量的初始化操作，我们在此处省略大量无关代码， void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){ //禁用NSNumber等的 Tagged Pointer 指针优化 if (DisableTaggedPointers) { disableTaggedPointers(); } //初始化 TaggedPointer 混淆器：用于保护 Tagged Pointer 上的数据 initializeTaggedPointerObfuscator(); } 可以看到，首先判断Tagged Pointer 是否被禁用，如果被禁用，才调用disableTaggedPointers()函数将Tagged Pointer 相关变量全部设置为 0。 OPTION( DisableTaggedPointers, OBJC_DISABLE_TAGGED_POINTERS, \"disable tagged pointer optimization of NSNumber et al.\") 判断 Tagged Pointer 时，使用的是预定义的宏 OPTION！本质是获取环境变量 OBJC_DISABLE_TAGGED_POINTERS的值，设置该变量为 YES，则Tagged Pointer 被禁用。 2.1.3、判断是否禁用的函数 static inline bool _objc_taggedPointersEnabled(void){ extern uintptr_t objc_debug_taggedpointer_mask; return (objc_debug_taggedpointer_mask != 0); } DisableTaggedPointers 通过环境变量 OBJC_DISABLE_TAGGED_POINTERS 来判断是否使用 Tagged Pointer ； 函数 _objc_taggedPointersEnabled() 通过全局变量objc_debug_taggedpointer_mask判断是否使用Tagged Pointer 。 2.1.4、能否禁用？ 可能有的读者去测试 OBJC_DISABLE_TAGGED_POINTERS 为 YES 时，发现程序报错： objc[3658]: tagged pointers are disabled Message from debugger: Terminated due to signal 9 既然苹果给了OBJC_DISABLE_TAGGED_POINTERS这个环境变量让我们设置，为何程序还无法启动呢？分析下图错误堆栈： 在调用栈中发现了Runtime 库 杀手 _objc_fatal()函数，该函数一言不合就杀死进程！可以看到，是_objc_registerTaggedPointerClass() 函数请求_objc_fatal()杀死程序的！ 那么_objc_registerTaggedPointerClass() 函数是什么呢？它凭什么一言不合就杀死程序？我们下节分析！ 2.2、注册成为Tagged Pointer 为什么NSNumber、NSDate、NSString等类型可以自动转为Tagged Pointer ？而UIViewController就不能自动转化呢？这就要说到上节遗留的_objc_registerTaggedPointerClass() 函数了！！ 加载程序时，从 dyld2 库 的_dyld_start()函数开始，经历了多般步骤，开始调用_objc_registerTaggedPointerClass() 函数！ 在讲解_objc_registerTaggedPointerClass() 函数之前先说说题外话：classSlotForBasicTagIndex() 函数与 classSlotForTagIndex() 函数！ 2.2.1、classSlotForBasicTagIndex() 函数 static Class *classSlotForBasicTagIndex(objc_tag_index_t tag){ uintptr_t tagObfuscator = ((objc_debug_taggedpointer_obfuscator >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK); uintptr_t obfuscatedTag = tag ^ tagObfuscator; // objc_tag_classes 数组的索引包含标记的位本身 #if SUPPORT_MSB_TAGGED_POINTERS//高位优先 return &objc_tag_classes[0x8 | obfuscatedTag]; #else return &objc_tag_classes[(obfuscatedTag classSlotForBasicTagIndex() 函数的主要功能就是根据指定索引 tag 从数组 objc_tag_classes中获取类指针；该函数要求索引tag是个有效的索引！ 注：可能大家会对 objc_debug_taggedpointer_obfuscator 产生疑惑，这个东西是什么?是用来干嘛的？别急，在此处不影响该函数的功能，后文用到了我们再讲！ a、这里有两个重要的全局变量数组： #if SUPPORT_TAGGED_POINTERS //支持 Tagged Pointer extern \"C\" { extern Class objc_debug_taggedpointer_classes[_OBJC_TAG_SLOT_COUNT*2]; extern Class objc_debug_taggedpointer_ext_classes[_OBJC_TAG_EXT_SLOT_COUNT]; } #define objc_tag_classes objc_debug_taggedpointer_classes #define objc_tag_ext_classes objc_debug_taggedpointer_ext_classes #endif 数组 objc_tag_classes：存储苹果定义的几个基础类； 数组 objc_tag_ext_classes ：存储苹果预留的扩展类； b、数组 objc_debug_taggedpointer_classes 与 objc_debug_taggedpointer_ext_classes 的初始化 笔者在 Runtime 库 的objc-msg-armXX.s文件发现了相关代码： #if SUPPORT_TAGGED_POINTERS .data .align 3 .globl _objc_debug_taggedpointer_classes _objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes _objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 #endif 注：在别的地方没有关于这两个数组的代码，笔者怀疑这俩个数组在此处被初始化的！如果有大神认为笔者错了，这俩个数组的初始化另有地方，还望告知！ 2.2.2、classSlotForTagIndex() 函数 static Class *classSlotForTagIndex(objc_tag_index_t tag){ if (tag >= OBJC_TAG_First60BitPayload && tag = OBJC_TAG_First52BitPayload && tag > _OBJC_TAG_EXT_INDEX_SHIFT)& _OBJC_TAG_EXT_INDEX_MASK); return &objc_tag_ext_classes[index ^ tagObfuscator]; } return nil; } 该函数的主要功能就是根据指定索引 tag 获取类指针： 当索引tag为基础类的索引时，去数组objc_tag_classes中取数据； 当索引tag为扩展类的索引时，去数组objc_tag_ext_classes中取数据； 当索引tag无效时，返回一个 nil； 2.2.3、索引objc_tag_index_t classSlotForBasicTagIndex() 函数与classSlotForTagIndex() 函数的本质就是获取数组objc_tag_classes与数组objc_tag_ext_classes中的数据！ 那么它的索引 objc_tag_index_t 是何方神圣呢？ 在 Runtime 库 的 objc-internal.h文件中找到了 objc_tag_index_t的定义： //有关于标志位的枚举如下： #if __has_feature(objc_fixed_enum) || __cplusplus >= 201103L enum objc_tag_index_t : uint16_t #else typedef uint16_t objc_tag_index_t;//无符号短整型 enum #endif { // 60位净负荷 OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, //表示这是一个NSString对象 OBJC_TAG_NSNumber = 3, //表示这是一个NSNumber对象 OBJC_TAG_NSIndexPath = 4, //表示这是一个NSIndexPath对象 OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6,//表示这是一个NSDate对象 OBJC_TAG_RESERVED_7 = 7, //60位净负荷： 索引 7 被保留 // 52 位净负荷 OBJC_TAG_Photos_1 = 8, OBJC_TAG_Photos_2 = 9, OBJC_TAG_Photos_3 = 10, OBJC_TAG_Photos_4 = 11, OBJC_TAG_XPC_1 = 12, OBJC_TAG_XPC_2 = 13, OBJC_TAG_XPC_3 = 14, OBJC_TAG_XPC_4 = 15, OBJC_TAG_First60BitPayload = 0, OBJC_TAG_Last60BitPayload = 6, OBJC_TAG_First52BitPayload = 8, // 52 位净负荷的开始处 OBJC_TAG_Last52BitPayload = 263, // 52 位净负荷的结束处 OBJC_TAG_RESERVED_264 = 264 // 52 位净负荷： 索引 264 被保留 }; #if __has_feature(objc_fixed_enum) && !defined(__cplusplus) typedef enum objc_tag_index_t objc_tag_index_t; #endif objc_tag_index_t 就是个枚举变量，存储在 Tagged Pointer 的特殊标记的部位！ Runtime 就是根据 objc_tag_index_t的枚举值判断Tagged Pointer 存储的是 NSString对象或者 NSNumber对象... 2.2.4、_objc_registerTaggedPointerClass() 函数 现在知道了classSlotForBasicTagIndex() 函数与classSlotForTagIndex() 函数的本质就是获取数组objc_tag_classes与数组objc_tag_ext_classes中的数据！而索引 objc_tag_index_t 又用来在Tagged Pointer 对象标记存储的类！ 准备工作已经做足，现在去分析_objc_registerTaggedPointerClass()函数！ 在 Runtime 库 的 objc-runtime-new.mm文件中找到该函数的实现： void _objc_registerTaggedPointerClass(objc_tag_index_t tag, Class cls){ if (objc_debug_taggedpointer_mask == 0) { _objc_fatal(\"tagged pointers are disabled\"); } Class *slot = classSlotForTagIndex(tag);//根据索引获取指定的类指针 if (!slot) { _objc_fatal(\"tag index %u is invalid\", (unsigned int)tag); } Class oldCls = *slot;//取出指针指向的类 if (cls && oldCls && cls != oldCls) { //指定的索引被用于两个不同的类，终止程序 _objc_fatal(\"tag index %u used for two different classes (was %p %s, now %p %s)\", tag,oldCls, oldCls->nameForLogging(),cls, cls->nameForLogging()); } *slot = cls;//将入参 cls 赋值给该类指针指向的地址 if (tag OBJC_TAG_Last60BitPayload) { Class *extSlot = classSlotForBasicTagIndex(OBJC_TAG_RESERVED_7); if (*extSlot == nil) { extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer; *extSlot = (Class)&OBJC_CLASS_$___NSUnrecognizedTaggedPointer;//表示 TaggedPointer 类 } } } 分析该函数的实现： 1、首先判断 objc_debug_taggedpointer_mask是否为 0 ，也就是判断开发者是否把 OBJC_DISABLE_TAGGED_POINTERS 设置为 YES；如果禁用了 Tagged Pointer ，那么不好意思，直接调用 _objc_fatal()函数终止该程序，不让该程序启动！ 只有启用 Tagged Pointer ，程序才有执行下去的意义！ 2、根据索引 tag去取出数组objc_tag_classes或数组objc_tag_ext_classes中指定的类指针classSlotForTagIndex(tag)： 如果传递无效的索引 tag，获取一个 nil，还是要调用_objc_fatal()终止该程序； 3、尝试着去获取该指针指向的类Class oldCls = *slot：如果要注册的类和该处的类不是同一个？不好意思，_objc_fatal()终止程序！ 只有类指针 slot指向的位置为 NULL，或者类指针 slot指向的位置就是存储着我们要注册的类，系统才能安稳的运行下去； 4、将入参cls赋值给类指针 slot指向的位置*slot = cls；到此，该函数的功能经过重重考验就已经实现了！ 5、假如注册的不是基础类，而是第一次注册扩展类，该函数还有个额外功能：在OBJC_TAG_RESERVED_7出存储占位类 OBJC_CLASS_$___NSUnrecognizedTaggedPointer 2.2.5、打印系统注册的Tagged Pointer 不妨在_objc_registerTaggedPointerClass()函数中插入一条 print()语句，打印出系统注册的Tagged Pointer ，如下图所示： 观察打印日志，可以得知NSNumber、NSString等确实在启动程序时，被系统注册！ 2.2.6、获取_objc_registerTaggedPointerClass()函数调用栈 在_objc_registerTaggedPointerClass()函数打一个断点，打印该线程栈信息： (lldb) thread backtrace * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1 * frame #0: 0x0000000100382213 libobjc.A.dylib`::_objc_registerTaggedPointerClass(tag=OBJC_TAG_NSNumber, cls=__NSCFNumber) at objc-runtime-new.mm:6668 frame #1: 0x00007fff433a0b5b CoreFoundation`__CFNumberGetTypeID_block_invoke + 65 frame #2: 0x0000000100d087c3 libdispatch.dylib`_dispatch_client_callout + 8 frame #3: 0x0000000100d0a48b libdispatch.dylib`_dispatch_once_callout + 87 frame #4: 0x00007fff433a0b17 CoreFoundation`CFNumberGetTypeID + 39 frame #5: 0x00007fff433a0103 CoreFoundation`__CFInitialize + 715 frame #6: 0x0000000100020a68 dyld`ImageLoaderMachO::doImageInit(ImageLoader::LinkContext const&) + 316 frame #7: 0x0000000100020ebb dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 29 frame #8: 0x000000010001c0da dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 358 frame #9: 0x000000010001c06d dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 249 frame #10: 0x000000010001c06d dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 249 frame #11: 0x000000010001c06d dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 249 frame #12: 0x000000010001b254 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 134 frame #13: 0x000000010001b2e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 74 frame #14: 0x000000010000a756 dyld`dyld::initializeMainExecutable() + 169 frame #15: 0x000000010000f78f dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 6237 frame #16: 0x00000001000094f6 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1154 frame #17: 0x0000000100009036 dyld`_dyld_start + 54 具体的调用信息如上所示，这里不再过多啰嗦！ 至此，笔者已经讲完了注册为Tagged Pointer 的流程！ 2.3、判断一个指针是否是 Tagged Pointer Tagged Pointer 之所以特殊，是因为它有个标记位表明它是特殊指针，那么该如何判断这个特殊的标记呢？ 在 Runtime 库 的 objc-internal.h文件中找到了 _objc_isTaggedPointer()的实现： static inline bool _objc_isTaggedPointer(const void * _Nullable ptr){ //将一个指针地址和 _OBJC_TAG_MASK 常量做 & 运算：判断该指针的最高位或者最低位为 1，那么这个指针就是 Tagged Pointer。 return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK; } 该函数将 指针ptr 与 _OBJC_TAG_MASK 做了按位与 运算，这个运算有什么意义呢？我们先看下_OBJC_TAG_MASK 的定义： #if OBJC_MSB_TAGGED_POINTERS //MSB 高位优先 # define _OBJC_TAG_MASK (1UL对于 iOS 系统而言，遵循 MSB 规则（高位优先）！因此_OBJC_TAG_MASK的值为 0x8000000000000000：一个64 位的二进制，最左边一位是 1，其余位全是 0！ 在 64 位系统中，使用指针很难将有限的 CPU 资源耗尽；因此 64 位还有很大的剩余！ 苹果将64中的最左边一位（MSB 时）标记是 1 ，或者最右边一位（LSB 时）标记是 1 ，以此来表示这个指针是 Tagged Pointer 。 因此 ptr & _OBJC_TAG_MASK) 按位与 运算后可以判断它的标志位是否是 1，即是否是 Tagged Pointer ！ 2.4、在伪指针 Tagged Pointer 存储数据 讲了半天：又是禁用 Tagged Pointer 、又是注册 Tagged Pointer 、又是判断 Tagged Pointer 的 ！ 那么到底怎么存储NSNumber、NSDate、NSString等类型的数据呢？ 在 Runtime 库 的 objc-internal.h文件中找到了 _objc_makeTaggedPointer() 函数的实现： static inline void * _Nonnull _objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value){ if (tag > _OBJC_TAG_PAYLOAD_LSHIFT)); return _objc_encodeTaggedPointer(result); } else {//如果是扩展的索引 uintptr_t result = (_OBJC_TAG_EXT_MASK | ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) > _OBJC_TAG_EXT_PAYLOAD_LSHIFT)); return _objc_encodeTaggedPointer(result); } } 该函数将 value 位运算，然后再编码 _objc_encodeTaggedPointer()，就是指针的值！ a、尝试计算 #if OBJC_MSB_TAGGED_POINTERS //MSB 高位优先 # define _OBJC_TAG_MASK (1UL我们以 1.4 节 中的NSNumber为例尝试计算一下：当存储整数0 时Tagged Pointer 的值为0xb000000000000002！（以MSB 规则计算） 由于NSNumber为基础类，它的索引为 OBJC_TAG_NSNumber=3，所以 tag ： 1、_OBJC_TAG_MASK 取值 0x8000000000000000 ； 2、tag 转为0x3 ，位运算结果是 0x3000000000000000；该运算的目的是将类的标识符存储在标志位里； 3、_OBJC_TAG_MASK | ((uintptr_t)tag 转为 0x8000000000000000 | 0x3000000000000000 ，位运算结果是0xb000000000000000；该结果就是Tagged Pointer 的标记； 4、(value > _OBJC_TAG_PAYLOAD_LSHIFT)： 5、先来说说(value ，将value左移 4 位，为何是 4 位？因为有 4 位标识符，最右边一位的1是Tagged Pointer 的标志，剩余三位是存储类的识别！ 6、再来说说>> _OBJC_TAG_PAYLOAD_LSHIFT)，将第 5 步的位运算结果右移 _OBJC_TAG_PAYLOAD_LSHIFT 遵循 MSB 时右移 4 位，因为4 位标识符在最左边，即最左边 4 位不能用来表示值！ 遵循 LSB 时右移 0 位，因为4 位标识符在最右边，即最右边 4 位不能用来表示值！ 7、第4步公式转为(0>0计算结果是：0 8、最终 result结果是 0xb000000000000000！！ 疑问：程序运行的是 0xb000000000000002，但为何计算的是0xb000000000000000？该处问题笔者暂时没有找到答案，如果有大神知道为何不同，怎么计算，还望告知！！ b、编码与解码 Tagged Pointer 指针的函数 /* 编码 TaggedPointer 指针 */ static inline void * _Nonnull _objc_encodeTaggedPointer(uintptr_t ptr){ return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr); } /* 解码 TaggedPointer 指针 * @param ptr 编码后的 TaggedPointer 指针 */ static inline uintptr_t _objc_decodeTaggedPointer(const void * _Nullable ptr){ return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator; } 注：此处又出现了变量objc_debug_taggedpointer_obfuscator，在该处的取值为 0 ，至于作用，后文再讲！ 通过一步步计算可知，Tagged Pointer 指针上存储的数据我们完全能够计算出来，此时数据暴露在外，及其危险！苹果为了数据安全问题，设计了数据混淆！ 2.5、Tagged Pointer 的数据混淆 在 2.1.2 节的_read_images()函数中还遗留了 initializeTaggedPointerObfuscator()没有讲解，现在来说说它的作用。 在 Runtime 库 的 objc-runtime-new.mm文件中找到该函数的实现： static void initializeTaggedPointerObfuscator(void){ if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) || DisableTaggedPointerObfuscation) { // 对于链接到旧sdk的应用程序，如果它们依赖于tagged pointer表示，将混淆器设置为0， objc_debug_taggedpointer_obfuscator = 0; } else { // 将随机数据放入变量中，然后移走所有非净负荷位。 arc4random_buf(&objc_debug_taggedpointer_obfuscator, sizeof(objc_debug_taggedpointer_obfuscator)); objc_debug_taggedpointer_obfuscator &= ~_OBJC_TAG_MASK; } } 该函数的主要功能： 如果SDK版本过低，或者禁用混淆，则设置 objc_debug_taggedpointer_obfuscator 为 0； 否则为objc_debug_taggedpointer_obfuscator 设置一个随机数； 前文遗留的objc_debug_taggedpointer_obfuscator是什么，到此终于有了明确的定义：该变量就是一个随机生成的数字，通过编码函数、或者解码函数，用来与 value做位运算，这样控制台就看不出是否是Tagged Pointer 指针，该指针存储的数据也是安全的！ 2.5.1、Tagged Pointer 数据混淆功能的开启与关闭 OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION, \"disable obfuscation of tagged pointers\") 通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为 YES，可以关闭Tagged Pointer 的数据混淆，方便我们调试程序！ 2.5.2、objc_debug_taggedpointer_obfuscator的使用 除了上文的编码解码函数使用了objc_debug_taggedpointer_obfuscator来混淆指针，还有最前文提到的通过指定索引tag获取类指针时使用objc_debug_taggedpointer_obfuscator。 2.6、获取Tagged Pointer 的数据 前文讲解了如何存储Tagged Pointer 的数据，如何加密Tagged Pointer 的数据！现在我们来看下如何获取Tagged Pointer 的数据！ 在 Runtime 库 的 objc-internal.h文件中找到相关函数的实现： /* 获取 Tagged Pointer 指针上存储的数据 * @note 存储的数据是 zero-extended * @note 前提条件：假设启用了 tagged pointer 功能 */ static inline uintptr_t _objc_getTaggedPointerValue(const void * _Nullable ptr){ // assert(_objc_isTaggedPointer(ptr)); uintptr_t value = _objc_decodeTaggedPointer(ptr);// 解码 TaggedPointer 指针 uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK; if (basicTag == _OBJC_TAG_INDEX_MASK) { return (value > _OBJC_TAG_EXT_PAYLOAD_RSHIFT; } else { return (value > _OBJC_TAG_PAYLOAD_RSHIFT; } } /* 获取 Tagged Pointer 指针上存储的数据 * @note 存储的数据是 sign-extended * @note 前提条件：假设启用了 tagged pointer 功能 */ static inline intptr_t _objc_getTaggedPointerSignedValue(const void * _Nullable ptr){ // assert(_objc_isTaggedPointer(ptr)); uintptr_t value = _objc_decodeTaggedPointer(ptr); uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK; if (basicTag == _OBJC_TAG_INDEX_MASK) { return ((intptr_t)value > _OBJC_TAG_EXT_PAYLOAD_RSHIFT; } else { return ((intptr_t)value > _OBJC_TAG_PAYLOAD_RSHIFT; } } 2.7、Tagged Pointer 其他函数 /* 获取一个 Tagged Pointer 指针的索引 * @param ptr 指定的指针 */ static inline objc_tag_index_t _objc_getTaggedPointerTag(const void * _Nullable ptr){ // assert(_objc_isTaggedPointer(ptr)); uintptr_t value = _objc_decodeTaggedPointer(ptr); uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK; uintptr_t extTag = (value >> _OBJC_TAG_EXT_INDEX_SHIFT) & _OBJC_TAG_EXT_INDEX_MASK; if (basicTag == _OBJC_TAG_INDEX_MASK) { return (objc_tag_index_t)(extTag + OBJC_TAG_First52BitPayload); } else { return (objc_tag_index_t)basicTag; } } /* 根据指定的索引获取 Tagged Pointer 表示的类 * @param tag 指定的索引 * @return 如果该索引还没有使用 或 该索引超出范围，则返回nil。 */ Class _objc_getClassForTag(objc_tag_index_t tag){ Class *slot = classSlotForTagIndex(tag); if (slot) return *slot; else return nil; } 至此，关于 伪指针Tagged Pointer，笔者已经讲完！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/Runtime/方法签名.html":{"url":"iOS开发/Runtime/方法签名.html","title":"消息与方法签名","keywords":"","body":"Objective-C的消息与方法签名 Objective-C 方法调用就是一个对象消息传递的过程。在对象消息传递的过程中，涉及到了几个概念： 选择器：是一种文本字符串，用于指明调用的方法； 消息：NSInvocation 封装了消息，包含消息的所有元素:目标target、选择器SEL、参数和返回值； 方法签名NSMethodSignature：定义了方法参数类型和返回值类型。 1、选择器 在对象消息传递过程中，选择器是一种文本字符串，用于指明调用实例或类中的哪些方法。 选择器示例 logModel sumA: b: sumA: : //空选择器分段 在Objective-C中，消息的选择器直接与一个或者多个类方法/实例方法声明对应。 - (void)logModel; - (int)sumA:(NSNumber *)a b:(int)b; - (int)sumA:(int)a :(int)b; 编译代码时，编译器会创建数据结构和函数调用语句，使用它们以动态绑定将接收器和消息选择器的实现代码对应起来。在执行程序时，Runtime利用这些信息找到并调用适当的方法。 1.1、选择器类型 SEL //SEL 的声明：是 objc_selector 类型的结构指针 typedef struct objc_selector *SEL： SEL是一种特殊的Objective-C数据类型，用于在编译源代码时替换选择器值的唯一标识符。相同选择器值的方法具有相同的SEL。 创建SEL变量： @selector指令：在编译时创建一个SEL变量； NSSelectorFromString(NSString *) 函数：在程序运行时创建一个选择器变量。 2、对 Objective-C 消息的封装NSInvocation NSInvocation 是以对象方法呈现封装的 Objective-C 消息。用于在对象之间、应用程序之间存储和转发消息，主要由NSTimer对象和分布式对象系统来实现。 NSInvocation对象包含Objective-C消息的必要元素:目标target、选择器SEL、参数和返回值。可以直接设置这些元素，并且在发送消息时自动设置返回值。 NSInvocation 对象可以重复地分派到不同的目标：它的参数可以根据不同的结果在调度之间进行修改；甚至它的选择器也可以更改为具有相同方法签名(参数和返回类型)的另一个选择器。这种灵活性使NSInvocation可用于许多具有重复参数和变量的消息;而不是为每条消息重新输入略有不同的表达式，每次根据需要修改NSInvocation对象，然后再将其分派给新目标。 NSInvocation 不支持使用可变数量的参数或联合参数调用方法。应该使用类方法+invocationWithMethodSignature:创建NSInvocation实例。 默认情况下，该类不会保留调用的参数。这些参数可能会释放，应该显式地保留这些参数，或者调用-retainArguments方法来让调用对象保留它们本身。 注意：NSInvocation 符合NSCoding协议，但仅支持NSPortCoder编码。 NSInvocation不支持存档。 2.1、封装一个消息 /* 使用指定的方法签名 sig 构造消息 */ + (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)sig; //接收者的方法签名。 @property(readonly, retain) NSMethodSignature *methodSignature; 2.2、配置NSInvocation 2.2.1、配置接收器、选择器 //接收器的选择器，默认为 nil。 @property SEL selector; //目标是发送消息的接收者。默认为 nil。 @property(assign) id target; 2.2.2、配置接收器的参数 /* 将 argumentLocation 的数据复制为index的参数 * @param 分配给接收器的参数的无类型缓冲区 * @param idx 索引；0 和 1 表示隐藏的参数 self 和 _cmd。通常使用 2 或者更大值 * @note 复制的字节数由参数大小决定 */ - (void)setArgument:(void *)argumentLocation atIndex:(NSInteger)idx; /* 将存储在索引 idx 的参数复制到缓冲区指向的存储中 argumentLocation。 * @note 缓冲区的大小必须足够大以容纳参数值。 */ - (void)getArgument:(void *)argumentLocation atIndex:(NSInteger)idx; 当参数值是对象时，将指针传递给应从中复制对象的变量（或内存）： NSArray *anArray; [invocation setArgument:&anArray atIndex:3]; [invocation getArgument:&anArray atIndex:3]; 如果index的值大于选择器的实际参数的数量，则此方法引发NSInvalidArgumentException。 2.2.3、是否保留参数 为了提高效率，新创建的NSInvocation实例不持有参数，也不持有其目标。 如果需要缓存，则应指示NSInvocation对象保留其参数，否则在调用之前可能会释放参数。 NSTimer 对象总是指示其调用保留其参数，例如，因为在计时器触发之前通常会有一个延迟。 //如果接收者持有其参数，则为YES，否则为 NO。 @property(readonly) BOOL argumentsRetained; /* 在调用此方法之前，argumentsRetained=NO * 在调用此方法之后，argumentsRetained=YES * * 如果接收方尚未这样做，则保留接收方的目标和所有对象参数，并复制其所有C字符串参数和块 * 如果已设置returnvalue，则也会保留或复制该值。 */ - (void)retainArguments; 2.2.4、接收者的返回值 /* 设置接收者的返回值。 * 通常在发送 -invoke 或 -invokeWithTarget：消息前需要设置此值。 * * @param retLoc 一个无类型缓冲区，其内容被复制为接收方的返回值。 */ - (void)setReturnValue:(void *)retLoc; /* 接收器复制其返回值的无类型缓冲区。 * @param retLoc 应该足够大以容纳其值。 */ - (void)getReturnValue:(void *)retLoc; 使用方法签名NSMethodSignature的方法-methodReturnLength确定缓冲区所需的大小： NSUInteger length = [[myInvocation methodSignature] methodReturnLength]; buffer = (void *)malloc(length); [invocation getReturnValue:buffer]; 当返回值是对象时，将指针传递给应放置对象的变量（或内存）： id anObject; NSArray *anArray; [invocation1 getReturnValue:&anObject]; [invocation2 getReturnValue:&anArray]; 如果从未调用过NSInvocation 对象，则此方法的结果是未定义的。 2.3、发送消息 /* 调用：将接收者的消息（带参数）发送到其目标并设置返回值。 * 注意：在调用此方法之前，必须设置接收器的目标，选择器和参数值。 */ - (void)invoke; /* 指定目标的调用：设置接收者的目标，将接收者的消息（带参数）发送到该目标，并设置返回值。 * 注意：在调用此方法之前，必须设置接收器的选择器和参数值。 */ - (void)invokeWithTarget:(id)target; 3、方法签名NSMethodSignature 什么是方法签名？方法签名由方法返回类型的一个或多个字符组成，后面是隐式参数self和_cmd的字符串编码，接着可能是更多显式参数。 NSMethodSignature 以对象方式对方法签名的封装。使用methodReturnType和methodReturnLength属性确定字符串编码和返回类型的长度。使用-getArgumentTypeAtIndex: 方法和numberOfArguments属性单独访问参数。在方法签名不匹配时，使用NSMethodSignature转发消息。 /* 必须重写该方法，创建 NSMethodSignature 实例 * 消息转发通过该方法创建的 NSMethodSignature 创建 NSInvocation 对象 */ - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ NSMethodSignature *sign = [super methodSignatureForSelector:aSelector]; if (sign == nil && aSelector == NSSelectorFromString(@\"unrecognized selector\")){ if ([ModelHelper instancesRespondToSelector:aSelector]){ sign = [ModelHelper instanceMethodSignatureForSelector:aSelector]; } } return sign; } /* 将消息转发给其它对象处理 */ - (void)forwardInvocation:(NSInvocation *)anInvocation{ if ([ModelHelper instancesRespondToSelector:anInvocation.selector]){ [anInvocation invokeWithTarget:self.helper]; } } 类型编码 NSMethodSignature对象是用代表返回字符串编码和方法参数类型的字符数组初始化的。使用@encode()编译器指令获得特定类型的字符串编码。因为字符串编码是特定于实现的，所以不应该硬编码这些值。 例如，NSString实例方法-containsString:具有带以下参数的方法签名： @encode(BOOL) (c)：返回值类型 @encode(id) (@) ：接收者self @encode(SEL) (:) ：选择器 _cmd @encode(NSString *) (@) ：第一个参数 3.1、创建方法签名 /* 返回指定Objective-C方法类型字符串的NSMethodSignature对象。 * @param types 包含方法参数的类型编码 */ + (NSMethodSignature *)signatureWithObjCTypes:(const char *)types; /* 获取指定位置参数的类型编码 * @param idx 参数索引；0 代表 self ，1 代表 _cmd；显式参数从索引2开始 * @return 该索引处参数的类型编码 * @note 如果索引超过参数数量，则引发异常NSInvalidArgumentException */ - (const char *)getArgumentTypeAtIndex:(NSUInteger)idx; /* 接收器中的参数数量 * @note 至少有两个参数 self 和 _cmd */ @property(readonly) NSUInteger numberOfArguments; /* 所有参数总共占用内存的字节数 * @note 内存因应用程序运行的硬件体系结构而异 */ @property(readonly) NSUInteger frameLength; /* 方法的返回类型 */ @property(readonly) const char *methodReturnType; /* 方法的返回值大小 */ @property(readonly) NSUInteger methodReturnLength; /* 确定同步状态 * @return 接收器异步调用，则为YES，否则为NO * @note 如果方法是单向的，则远程消息的发送方不会阻止等待回复。 */ - (BOOL)isOneway; Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/Runtime/OC_方法交换.html":{"url":"iOS开发/Runtime/OC_方法交换.html","title":"方法交换","keywords":"","body":"Objective-C的方法交换 Objective-C 方法调用实际就是一个消息传递的过程。在消息传递过程中，根据消息的选择器SEL找到IMP执行具体代码。 在项目开发中利用Runtime的 方法交换，可以为 系统类的原有方法增加新的功能：如防止数组越界、防止按钮连击、埋点需求等 ！ 由于Objective-C的方法执行主要是寻找 IMP 的过程，假如我们在不改变选择器类型 SEL 的前提下改变 objc_method的成员IMP，那么 Runtime 就会顺着SEL找到objc_method实例，然后执行 被指向它处 IMP的函数。说的通俗些：方法交换的本质是交换两个方法持有的函数指针，而不是两个方法换了。 利用 Runtime 提供的某些 API 接口来实现 交换两个方法持有的函数指针 的目的： /* Runtime 库提供的 C 语言函数：根据指定的 SEL，获取指定类的实例方法 * @param name 指定的选择器 * @note 如果该类的 methodLists 中没有该方法，则去父类的方法链表查询；直到根类也找不到，就返回 NULL */ Method class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name); /* 为某个类添加方法 * @param imp 函数指针，该函数必须具有至少两个参数 self 和 _cmd 。 * @param types 描述方法参数类型的字符数组 * * @note 如果该类没有实现SEL方法，则将方法添加到 method_list_t ，返回 YES ，表示添加成功 * 如果该类已经实现SEL方法，则不再添加，返回 NO ， */ BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) ; /* 替换某个类的方法的具体实现。 * @param cls 指定的类 * @param name 新的方法的选择器 * @param imp 新的函数指针 * @param types 描述方法参数类型的字符数组 * * @note 如果该类没有实现SEL方法，则将方法添加到 method_list_t ，返回 nil * 如果该类已经实现SEL方法，替换 IMP，返回旧有的 IMP */ IMP class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) ; /* Runtime 库提供的 C 语言函数：交换两个方法的函数指针IMP。 */ void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2); 示例：为UIButton增加防止连击功能 UIButton防止连击，就是在原有方法的基础上增加一个判断逻辑： - (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event; 使用 Runtime 为该方法增加新的功能： @interface UIButton (DoubleHit) /* 设置点击时间间隔 * 默认为 0 ，没有防暴击效果 */ @property (nonatomic, assign) NSTimeInterval hitTimeInterval; /* 记录是否刚点击的状态 */ @property (nonatomic, assign) BOOL isIgnoreEvent; @end @implementation UIButton (DoubleHit) + (void)load{ static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ // oldMethod 可能来自于父类的实现，也可能为 NULL Method oldMethod = class_getInstanceMethod(self.class,@selector(sendAction:to:forEvent:)); Method newMethod = class_getInstanceMethod(self.class, @selector(l_sendAction:to:forEvent:)); // 如果该类已实现 oldMethod ，则添加失败返回 NO BOOL addResult = class_addMethod(self.class, @selector(sendAction:to:forEvent:), method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); if (addResult) { /* @selector(sendAction:to:forEvent:) 指向了新方法的 IMP * 还需要将 @selector(l_sendAction:to:forEvent:) 指向旧方法的 IMP */ class_replaceMethod(self.class, @selector(l_sendAction:to:forEvent:), method_getImplementation(oldMethod), method_getTypeEncoding(oldMethod)); }else{ //如果该类已实现 oldMethod ，此时：只需交换 oldMethod 与 newMethod 的 IMP 即可 method_exchangeImplementations(oldMethod, newMethod); } }); } - (void)l_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event{ if ([NSStringFromClass(self.class) isEqualToString:@\"UIButton\"] && self.hitTimeInterval > 0){ //为 UIButton 添加新的功能：防暴击 //如果在防暴击中，则不执行；否则执行如下代码 if (self.isIgnoreEvent == NO){ self.isIgnoreEvent = YES;//设置状态：在防暴击中 [self performSelector:@selector(resertState) withObject:nil afterDelay:self.hitTimeInterval];//指定时间后重置点击状态 //该行代码很重要：接着执行原始方法的内部逻辑 [self l_sendAction:action to:target forEvent:event]; } }else{ [self l_sendAction:action to:target forEvent:event]; } } - (void)resertState{ [self setIsIgnoreEvent:NO]; } //记录是否是刚点击的状态 - (BOOL)isIgnoreEvent{ return [objc_getAssociatedObject(self, _cmd) boolValue]; } - (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent{ objc_setAssociatedObject(self, @selector(isIgnoreEvent), @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (void)setHitTimeInterval:(NSTimeInterval)hitTimeInterval{ objc_setAssociatedObject(self, @selector(hitTimeInterval), @(hitTimeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (NSTimeInterval)hitTimeInterval{ return [objc_getAssociatedObject(self, _cmd) doubleValue]; } @end a、为何首先调用 class_addMethod() 函数？ 假如通过函数 class_getInstanceMethod() 获取的实例方法来自父类：这时调用 method_exchangeImplementations()函数交换两个方法的函数指针IMP ，改变的是父类方法的实现，而非该类指定方法的实现。如果我们交换方法的意图是交换这个类系的方法，那么没问题！但是如果我们的意图仅仅是交换该类的该方法，而不要父类的方法被交换，那么这个做法就与我们的意图背道而驰！！ 首先调用class_addMethod()函数添加一个方法：选择器依旧是指定的选择器，但是IMP指向新的函数地址。 如果该类已实现该方法，那么添加失败；这时可以交换两个方法的IMP！ 如果该类没有实现该方法，就添加该方法；此时添加的方法IMP指向新的实现，还需要调用class_replaceMethod()函数将新方法的IMP 指向原方法的函数地址！ b、 注意 -l_sendAction:to:forEvent:方法中的self 通过交换两个方法的IMP，已经达到交换方法的目的！但是在增加功能后，还需要实现旧有的功能！ 这时，在新方法中调用-l_sendAction:to:forEvent:，该方法的的IMP指向了旧方法的实现，也就是执行了原有的功能！ 注意：新方法中不可调用[self sendAction:action to:target forEvent:event];语句，否则会造成无限递归，直至程序性能耗尽而闪退！！ c、为什么方法交换要在+ load中执行？ 加载并初始化一个类时，Objective-C的 Runtime 会自动调用两个类方法+load与+initialize +load方法是在类被加载的时候调用的，也就是一定会被调用； +initialize方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说+initialize方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的+initialize方法是永远不会被调用的。 此外+load方法还有一个非常重要的特性，那就是子类、父类和分类中的+load方法的实现是被区别对待的。换句话说在 Objective-C的 Runtime自动调+load方法时，分类中的+load方法并不会对主类中的+load方法造成覆盖。 综上所述，+load方法是实现方法交换的最佳场所！！ d、为什么方法交换要在dispatch_once()中执行？ 如果上述示例代码调用两次，那么两个IMP又会指向各自原有的实现，方法又被交换回来；所以方法交换需要保证线程安全。 +load方法本身无法保证其代码只被执行一次，因此仍需添加dispatch_once()。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/Runtime/三次补救措施.html":{"url":"iOS开发/Runtime/三次补救措施.html","title":"方法不被识别的补救","keywords":"","body":"Objective-C方法不被识别时的三次补救机会 Objective-C 的对象消息传递允许程序向没有相应方法的对象发送消息。默认情况下，如果出现这种情况，程序就会抛出运行时异常 unrecognized selector。 然而Objective-C 的运行时为 unrecognized selector提供了三次补救机会： 1、动态方法决议：以动态方式实现方法。NSObject的 +resolveClassMethod:类方法与+resolveInstanceMethod:类方法以动态方式实现由选择器指定的实例和类方法。如果动态方法决议成功，则执行IMP指向的函数；如果失败，还有第二次补救措施； 2、消息转发机制：当对象收到与其方法不匹配的消息时，通过消息转发机制可以使对象执行用户预先定义的处理过程；将消息发送给能够做出回应的其它接收器；将所有无法识别的消息都发送给同一接收器；既不执行处理过程也不使程序崩溃，默默的吞下消息。Objective-C 提供了两种消息转发机制： 2.1、快速转发：通过重写 NSObject的 - forwardingTargetForSelector:方法，将无法识别的方法转发给其它对象，从而实现快速转发 2.2、完整转发：通过重写 NSObject的 - forwardInvocation:方法，实现完整转发。 补救措施 1、动态方法决议 以动态方式实现方法。NSObject提供了由选择器指定实现代码的操作。 //为指定的类方法选择器提供实现代码 + (BOOL)resolveClassMethod:(SEL)sel; //为指定的实例方法选择器提供实现代码 + (BOOL)resolveInstanceMethod:(SEL)sel; 当找不到实现方法时，第一步先执行动态决议方法： @implementation Model - (void)logModel{ NSLog(@\"%s\",__func__); } #pragma mark - 第一步：动态方法决议 void drinkingMethodIMP(id self ,SEL _cmd){ NSLog(@\"为指定的选择器 SEL : %@ 提供函数指针 IMP , 根据 IMP 执行具体的实现\",NSStringFromSelector(_cmd)); } + (BOOL)resolveInstanceMethod:(SEL)sel{ if (sel == NSSelectorFromString(@\"drinking\")){ //为指定的选择器 SEL 提供函数指针 IMP：IMP 指向实现代码 return class_addMethod(self.class, sel, (IMP)drinkingMethodIMP, \"v@:@\"); } //去父类判断：是否父类提供了 IMP BOOL superResult = [super resolveInstanceMethod:sel]; NSLog(@\"step_1 : %s | selector : %@ | superResult : %d\",__func__,NSStringFromSelector(sel),superResult); return superResult; } @end 测试动态方法决议 int main(int argc, char * argv[]) { @autoreleasepool { id model = [[Model alloc] init]; [model performSelector:@selector(logModel)]; [model performSelector:@selector(drinking)]; } return 0; } 执行上述代码，程序正常运行，没有 unrecognized selector sent to instance的异常，获取打印日志： -[Model logModel] 为指定的选择器 SEL : drinking 提供函数指针 IMP , 根据 IMP 执行具体的实现 实例方法-logModel正常执行，但是 -drinking被指向了 drinkingMethodIMP()函数。 我们再来回忆下 Objective-C 的方法 Method的本质，它的实现代码从本质来说是结构体objc_method的成员IMP指向的函数； 在动态决议中，我们通过class_addMethod()函数为指定的选择器sel提供IMP，因此程序不会异常闪退； /* Runtime 库提供的 C 语言函数：为一个指定类添加方法 * @param cls 指定的类 * @param name 选择器 * @param imp 函数指针 * @param types 描述方法参数类型的字符数组 * * 说明：参数 name 、imp、types 是方法Method的结构体objc_method 的三个成员 * 该函数将添加超类实现的重写，但不会替换该类中的现有实现。 * 也就是说：如果该类没有实现选择器指定的方法，则添加成功，返回YES; * 如果该类已经实现选择器指定的方法，则添加失败，返回 NO; * 需要更改现有的实现，使用 method_setImplementation()函数。 */ BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 补救措施 2、快速转发（重定向接收者） 通过重写 NSObject的 - forwardingTargetForSelector:方法，将无法识别的方法转发给其它对象，从而实现快速转发。 //消息转发辅助类 @interface ModelHelper : NSObject - (void)eatFood; @end @implementation ModelHelper - (void)eatFood{ NSLog(@\"%s\",__func__); } @end @interface Model : NSObject @property (nonatomic ,strong) ModelHelper *helper; @end @implementation Model #pragma mark - 第二步：重定向接收者 /* 重定向接收者：当一个对象无法找到消息时，为该消息提供一个能够处理它的对象 * * 如果动态方法决议没有提供实现的函数或者提供失败，就会执行该方法重定向接收者； * 注意：不能提供 self，否则进入死循环 */ - (id)forwardingTargetForSelector:(SEL)aSelector{ //检查消息 aSelector 能否由 ModelHelper 实例处理：如果能处理，那么返回 ModelHelper 实例 if ([self.helper respondsToSelector:aSelector]) { return self.helper; } //如果不能处理，那么去父类判断：是否父类重定向接收者 id superResult = [super forwardingTargetForSelector:aSelector]; NSLog(@\"step_2 : %s | selector : %@ | superResult : %@\",__func__,NSStringFromSelector(aSelector),superResult); return superResult; } //懒加载一个消息转发辅助类 - (ModelHelper *)helper{ if (_helper == nil) { _helper = [[ModelHelper alloc] init]; } return _helper; } @end 测试快速转发功能： int main(int argc, char * argv[]) { @autoreleasepool { id model = [[Model alloc] init]; [model performSelector:@selector(eatFood)]; } return 0; } 执行上述代码，程序正常运行，没有 unrecognized selector sent to instance的异常，获取打印日志： step_1 : +[Model resolveInstanceMethod:] | selector : eatFood | superResult : 0 -[ModelHelper eatFood] 没有实现的实例方法 -eatFood首先执行动态方法决议，动态方法决议返回 NO，也就是补救失败了；接着重定向接收者，实例方法 -eatFood被转发给ModelHelper实例执行。 我们知道 Objective-C 消息封装为NSInvocation类，该类包含Objective-C消息的所有元素：目标target、选择器SEL、参数和返回值。 也就是说；重定向接收者本质来讲就是调用了NSInvocation的- invokeWithTarget:实例方法，指定目标并再次发送消息。重新执行消息传递过程的几个步骤。 补救措施 3、完整转发 完整转发是相对于快速转发来说的：快速转发的本质是重定向接收者，调用NSInvocation的- invokeWithTarget:方法向指定目标发送消息。 #pragma mark - 第三步：完整消息转发 //获取方法签名 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ if ([ModelHelper instancesRespondToSelector:aSelector]){ //从消息转发辅助类 获取 方法签名 NSMethodSignature *helperSign = [ModelHelper instanceMethodSignatureForSelector:aSelector]; NSLog(@\"step_3_1 : %s | selector : %@ | helperSign : %@\",__func__,NSStringFromSelector(aSelector),helperSign); return helperSign; } //尝试从父类获取方法签名：如果父类没有实现该方法，则返回 null NSMethodSignature *superSign = [super methodSignatureForSelector:aSelector]; NSLog(@\"step_3_2 : %s | selector : %@ | superResult : %@\",__func__,NSStringFromSelector(aSelector),superSign); return superSign; } /* 未知消息分发中心，将未知消息转发给其它对象 * 只有在消息接收对象无法正常响应消息时才被调用 */ - (void)forwardInvocation:(NSInvocation *)anInvocation { NSLog(@\"step_3_3 : %s | target : %@ | selector : %@\",__func__,anInvocation.target,NSStringFromSelector(anInvocation.selector)); NSLog(@\"step_3_3 : NSMethodSignature : %@\",anInvocation.methodSignature); if ([ModelHelper instancesRespondToSelector:anInvocation.selector]){ [anInvocation invokeWithTarget:self.helper]; } } 测试完整转发功能： int main(int argc, char * argv[]) { @autoreleasepool { id model = [[Model alloc] init]; [model performSelector:@selector(playGames)]; } return 0; } 执行上述代码，程序正常运行，没有 unrecognized selector sent to instance的异常，获取打印日志： step_1 : +[Model resolveInstanceMethod:] | selector : playGames | superResult : 0 step_2 : -[Model forwardingTargetForSelector:] | selector : playGames | superResult : (null) step_3_1 : -[Model methodSignatureForSelector:] | selector : playGames | helperSign : step_1 : +[Model resolveInstanceMethod:] | selector : _forwardStackInvocation: | superResult : 0 step_1 : +[Model resolveInstanceMethod:] | selector : encodeWithOSLogCoder:options:maxLength: | superResult : 0 step_3_3 : -[Model forwardInvocation:] | target : | selector : playGames step_3_3 : NSMethodSignature : -[ModelHelper playGames] Runtime 没有找到 Model实例的-playGames方法 首先执行动态方法决议，动态方法决议失败； 接着重定向接收者，没有找到能够处理该消息的对象； 然后通过选择器类型SEL获取消息转发辅助类ModelHelper的指定方法签名 NSMethodSignature，将这个方法签名赋值给该消息NSInvocation； 最后在消息转发中心判断上步骤中出现的消息转发辅助类能否响应该方法；如果可以，调用NSInvocation的- invokeWithTarget:方法向消息转发辅助类实例发送消息。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/Runtime/编译objc4.html":{"url":"iOS开发/Runtime/编译objc4.html","title":"编译objc4备忘录","keywords":"","body":"编译 objc4 备忘录 笔者从苹果官网下载的 objc4-818.2 源码 由于 缺失某些.h文件 、代码不适配当前系统 、Build Settings 某些配置问题 等诸多原因，不能编译运行成功！因此特别写下此文，记录笔者解决这些问题的艰辛历程！ 1、macosx.internal 引发的错误 1.1、 unable to find sdk macosx.internal error: unable to find sdk 'macosx.internal' (in target 'objc' from project 'objc') error: unable to find sdk 'macosx.internal' (in target 'objc-trampolines' from project 'objc') 解决：配置 TARGETS -> objc/objc-trampolines -> Build Settings -> Architectures -> Base SDK 为系统自适配 macOS！ 1.2、macosx.internal cannot be located xcodebuild: error: SDK \"macosx.internal\" cannot be located. xcrun: error: sh -c '/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -sdk macosx.internal -find clang++ 2> /dev/null' failed with exit code 16384: (null) (errno=No such file or directory) xcrun: error: unable to find utility \"clang++\", not a developer tool or in PATH 这是由于 TARGETS -> objc -> Build Phases -> Run Script(markgc) 脚本引起的！ 2、.h文件缺失 objc 相关联的库如下所示： 注意： objc4-818.2 缺失的头文件，笔者统一放在一个 ThirdLib 的文件夹下！ 注意： 需要为文件夹 ThirdLib 配置文件路径 TARGETS -> objc -> Build Setting -> Heard Search Path！ 注意： 编译报错缺失头文件，凡是多层文件夹（带有 / ），都在 ThirdLib 的文件夹下根据缺失头文件的路径，创建一个文件夹。 2.1、 sys/reason.h file not found /objc4-818.2/runtime/objc-os.h:136:13: fatal error: 'sys/reason.h' file not found # include ^~~~~~~~~~~~~~ 1 error generated. 解决：下载xnu-7195源码，在指定目录 bsd -> sys 找到文件 reason.h ，添加到 objc 项目的自定义目录 ThirdLib/sys！ 2.2、mach-o/dyld_priv.h file not found /objc4-818.2/runtime/objc-os.h:144:13: fatal error: 'mach-o/dyld_priv.h' file not found # include ^~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载dyld-832 源码，在指定目录 include -> mach-o 找到文件 dyld_priv.h ，添加到 objc 项目的自定义目录ThirdLib/mach-o！ 2.2.1、 bridgeos(3.0) 引发的错误 添加的 dyld_priv.h 文件的某些代码，不被笔者的系统所兼容： /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:130:130: error: expected ',' extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:156:148: error: expected ',' extern dyld_platform_t dyld_get_base_platform(dyld_platform_t platform) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:159:141: error: expected ',' extern bool dyld_is_simulator_platform(dyld_platform_t platform) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:163:166: error: expected ',' extern bool dyld_sdk_at_least(const struct mach_header* mh, dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:167:168: error: expected ',' extern bool dyld_minos_at_least(const struct mach_header* mh, dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:170:144: error: expected ',' extern bool dyld_program_sdk_at_least(dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:171:146: error: expected ',' extern bool dyld_program_minos_at_least(dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /objc4-818.2/ThirdLib/mach-o/dyld_priv.h:176:230: error: expected ',' extern void dyld_get_image_versions(const struct mach_header* mh, void (^callback)(dyld_platform_t platform, uint32_t sdk_version, uint32_t min_version)) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); 分析上述的报错日志，几个error 都引用了宏 __API_AVAILABLE() ；笔者在系统库 usr/include/Availability.h 发现了宏定义 /** 用于指定特定API可用的发布版本 * Platform names: macos, ios, tvos, watchos * * Examples: * __API_AVAILABLE(macos(10.10)) * __API_AVAILABLE(macos(10.9), ios(10.0)) * __API_AVAILABLE(macos(10.4), ios(8.0), watchos(2.0), tvos(10.0)) * __API_AVAILABLE(driverkit(19.0)) */ #define __API_AVAILABLE(...) __API_AVAILABLE_GET_MACRO(__VA_ARGS__,__API_AVAILABLE7, __API_AVAILABLE6, __API_AVAILABLE5, __API_AVAILABLE4, __API_AVAILABLE3, __API_AVAILABLE2, __API_AVAILABLE1, 0)(__VA_ARGS__) 可以看到，笔者的开发系统并不支持 Bridge OS 系统（Apple独立的T2安全芯片使用的嵌入式操作系统）！所以删掉 bridgeos(3.0) 即可！修改后的一句代码如下（往后碰到的 bridgeos error 皆如此处理 ）： /// 修改前的代码 extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); /// 修改后的代码 extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0)); 2.3、os/lock_private.h file not found /objc4-818.2/runtime/objc-os.h:146:13: fatal error: 'os/lock_private.h' file not found # include ^~~~~~~~~~~~~~~~~~~ 1 errors generated. 解决：下载libplatform-254源码，在指定目录 private -> os 找到文件 lock_private.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 2.3.1、 bridgeos(4.0) 引发的错误 添加的 lock_private.h 文件的某些代码，不被笔者的系统所兼容： /objc4-818.2/ThirdLib/os/lock_private.h:288:37: error: expected ',' tvos(13.0), watchos(6.0), bridgeos(4.0)) = 0x00040000, 同上文的 Bridge OS 处理类似，删除 bridgeos(4.0)： OS_OPTIONS(os_unfair_lock_options, uint32_t, OS_UNFAIR_LOCK_NONE OS_SWIFT_NAME(None) OS_UNFAIR_LOCK_AVAILABILITY = 0x00000000, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION OS_SWIFT_NAME(DataSynchronization) OS_UNFAIR_LOCK_AVAILABILITY = 0x00010000, OS_UNFAIR_LOCK_ADAPTIVE_SPIN OS_SWIFT_NAME(AdaptiveSpin) __API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0), watchos(6.0)) = 0x00040000, ); 2.4、os/base_private.h file not found /objc4-818.2/ThirdLib/os/lock_private.h:31:10: fatal error: 'os/base_private.h' file not found #include ^~~~~~~~~~~~~~~~~~~ 1 errors generated. 解决：下载xnu-7195源码，在指定目录 libkern -> os 找到文件 base_private.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 2.5、pthread/tsd_private.h file not found /objc4-818.2/ThirdLib/os/lock_private.h:579:10: fatal error: 'pthread/tsd_private.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载libpthread-416.100.3 源码，在指定目录 private 找到文件 tsd_private.h ，添加到 objc 项目的自定义目录ThirdLib/pthread！ 2.6、System/machine/cpu_capabilities.h file not found /objc4-818.2/ThirdLib/pthread/tsd_private.h:52:10: fatal error: 'System/machine/cpu_capabilities.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 1 errors generated. 解决：下载xnu-7195源码，在指定目录 osfmk -> machine 找到文件 cpu_capabilities.h ，添加到 objc 项目的自定义目录ThirdLib/System/machine！ 2.7、os/tsd.h file not found /objc4-818.2/ThirdLib/pthread/tsd_private.h:56:10: fatal error: 'os/tsd.h' file not found #include ^~~~~~~~~~ 1 errors generated. 解决：下载xnu-7195源码，在指定目录 libsyscall -> os 找到文件 tsd.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 2.8、pthread/spinlock_private.h file not found /objc4-818.2/ThirdLib/pthread/tsd_private.h:57:10: fatal error: 'pthread/spinlock_private.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载libpthread-416.100.3 源码，在指定目录 private 找到文件 spinlock_private.h ，添加到 objc 项目的自定义目录ThirdLib/pthread！ 2.9、System/pthread_machdep.h file not found /objc4-818.2/runtime/objc-os.h:149:13: fatal error: 'System/pthread_machdep.h' file not found # include ^~~~~~~~~~~~~~~~~~~~~~~~~~ 1 errors generated. 解决：下载Libc-825.40 源码，在指定目录 pthreads 找到文件 pthread_machdep.h ，添加到 objc 项目的自定义目录ThirdLib/System！ # Showing All Errors Only /objc4-818.2/ThirdLib/System/pthread_machdep.h:214:13: error: typedef redefinition with different types ('int' vs 'volatile OSSpinLock' (aka 'volatile int')) typedef int pthread_lock_t; /objc4-818.2/ThirdLib/System/pthread_machdep.h:217:1: error: static declaration of '_pthread_has_direct_tsd' follows non-static declaration _pthread_has_direct_tsd(void) /objc4-818.2/ThirdLib/System/pthread_machdep.h:244:1: error: static declaration of '_pthread_getspecific_direct' follows non-static declaration _pthread_getspecific_direct(unsigned long slot) /objc4-818.2/ThirdLib/System/pthread_machdep.h:268:1: error: static declaration of '_pthread_setspecific_direct' follows non-static declaration _pthread_setspecific_direct(unsigned long slot, void * val) 4 errors generated. 解决：将 pthread_machdep.h 文件中相关函数注释即可！ 2.10、CrashReporterClient.h file not found /objc4-818.2/runtime/objc-os.h:250:13: fatal error: 'CrashReporterClient.h' file not found # include ^~~~~~~~~~~~~~~~~~~~~~~ 1 errors generated. 解决：下载Libc-825.40 源码，在指定目录 include 找到文件 CrashReporterClient.h ，添加到 objc 项目的自定义目录ThirdLib！ 2.10.1、未经声明的 CRGetCrashLogMessage() 即使添加了 CrashReporterClient.h 文件，后期可能还会报错： /objc4-818.2/runtime/objc-errors.mm:105:28: error: use of undeclared identifier 'CRGetCrashLogMessage' char *oldmsg = (char *)CRGetCrashLogMessage(); /objc4-818.2/runtime/objc-errors.mm:127:9: error: use of undeclared identifier 'CRSetCrashLogMessage' CRSetCrashLogMessage(newmsg); 2 errors generated. 解决：在添加 CrashReporterClient.h 文件之后，需要在 TARGETS -> objc -> Build Settings -> Preprocessor Macros 中添加 LIBC_NO_LIBCRASHREPORTERCLIENT 宏定义。 2.11、os/feature_private.h file not found /objc4-818.2/runtime/objc-runtime.mm:36:10: fatal error: 'os/feature_private.h' file not found #include // os_feature_enabled_simple() ^~~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：由于笔者无法找到该文件，只能在 objc 项目的 objc-runtime.mm 与 NSObject.mm 文件中注释该引用！ //#include 2.11.1、未声明的函数 os_feature_enabled_simple() 注释了 feature_private.h 文件之后，某些地方使用的该文件的函数，也将报错 /objc4-818.2/runtime/objc-runtime.mm:451:10: error: use of undeclared identifier 'os_feature_enabled_simple' if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) { 1 error generated. 对于未经声明的 os_feature_enabled_simple() 函数，只能注释！ /// objc-runtime.mm 文件的 void environ_init(void) 函数中 // if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) { // DisablePreoptCaches = true; // } 2.12、objc-bp-assist.h file not found /objc4-818.2/runtime/objc-os.mm:31:10: fatal error: 'objc-bp-assist.h' file not found #include \"objc-bp-assist.h\" ^~~~~~~~~~~~~~~~~~ 1 error generated. 解决：文件 objc-bp-assist.h 本应在 objc4-818.2 源码 中，但官方没有提供，所以只能在 objc-os.mm 文件中注释该引用！ //#include \"objc-bp-assist.h\" 2.12.1、注释objc-bp-assist.h 导致某些宏定义找不到 /objc4-818.2/runtime/objc-runtime.mm:379:36: error: use of undeclared identifier 'dyld_fall_2020_os_versions' if (!dyld_program_sdk_at_least(dyld_fall_2020_os_versions)) /objc4-818.2/runtime/objc-runtime.mm:444:36: error: use of undeclared identifier 'objc4' if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) { /objc4-818.2/runtime/objc-runtime.mm:444:43: error: use of undeclared identifier 'preoptimizedCaches' if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) { 3 errors generated. 在上个步骤，注释掉 objc-bp-assist.h 的引用后，在 objc-runtime.mm 文件的 void environ_init(void) 函数中找不到 dyld_fall_2020_os_versions 、objc4 、preoptimizedCaches 三个宏定义！ 我们不妨现在 objc-runtime.mm 文件函数void environ_init(void)的上面声明这几个宏！ #define dyld_fall_2020_os_versions #define objc4 preoptimizedCaches #define preoptimizedCaches 2.13、objc-shared-cache.h file not found /objc4-818.2/runtime/objc-opt.mm:113:10: fatal error: 'objc-shared-cache.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载dyld-832 源码，在指定目录 include 找到文件 objc-shared-cache.h ，添加到 objc 项目的自定义目录ThirdLib！ 2.14、os/linker_set.h file not found /objc4-818.2/runtime/objc-class.mm:163:10: fatal error: 'os/linker_set.h' file not found #include ^~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载Libc-1439源码，在指定目录 os 找到文件 linker_set.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 2.14.1、不被识别的宏定义 dyld_platform_version_ /objc4-818.2/runtime/objc-os.mm:567:40: error: use of undeclared identifier 'dyld_platform_version_macOS_10_13' if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_13)) { 1 error generated. 分析错误日志：发现是找不到定义的 dyld_platform_version_macOS_10_13！笔者发现， objc 项目中很多地方都要相关的宏定义 dyld_platform_version_ ，都会报错 use of undeclared identifier！ 由于一些文件找不到的缘故，笔者在此处不得不使用旧版本的代码来处理，在 dyld_priv.h 文件定义几个相关宏： /// dyld_priv.h /// 文件起始处 #define DYLD_MACOSX_VERSION_10_11 0x000A0B00 #define DYLD_MACOSX_VERSION_10_12 0x000A0C00 #define DYLD_MACOSX_VERSION_10_13 0x000A0D00 #define DYLD_MACOSX_VERSION_10_14 0x000A0E00 将报错处的 dyld_platform_version_macOS_10_13 替换为 DYLD_MACOSX_VERSION_10_13！ ///if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_13)) { if (!dyld_program_sdk_at_least(DYLD_MACOSX_VERSION_10_13)) { 2.14.2、不匹配的函数 dyld_program_sdk_at_least() /objc4-818.2/runtime/objc-runtime.mm:383:10: error: no matching function for call to 'dyld_program_sdk_at_least' if (!dyld_program_sdk_at_least(DYLD_MACOSX_VERSION_10_13)) 1 error generated. 既然 dyld_program_sdk_at_least() 函数不适配，笔者继续使用老版本的判断方法： /// if (!dyld_program_sdk_at_least(DYLD_MACOSX_VERSION_10_13)) { if (!(dyld_get_program_sdk_version() >= DYLD_MACOSX_VERSION_10_13)) { /// if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) { if (!(dyld_get_program_sdk_version() >= DYLD_MACOSX_VERSION_10_11)) { /// if (!DisableTaggedPointerObfuscation && dyld_program_sdk_at_least(dyld_fall_2018_os_versions)) { if (!DisableTaggedPointerObfuscation && (dyld_get_program_sdk_version() >= dyld_fall_2018_os_versions)) { 2.14.3、水土不服的宏定义 sdkIsAtLeast() error: use of undeclared identifier 'dyld_platform_version_macOS_10_12' error: use of undeclared identifier 'dyld_platform_version_iOS_10_0' error: use of undeclared identifier 'dyld_platform_version_tvOS_10_0' error: use of undeclared identifier 'dyld_platform_version_watchOS_3_0' error: use of undeclared identifier 'dyld_platform_version_bridgeOS_2_0' 上述几个错误，仅仅是由于 sdkIsAtLeast(10_12, 10_0, 10_0, 3_0, 2_0) 引起的！笔者在 objc-os.h 文件中找到了它的声明： #define sdkIsAtLeast(x, i, t, w, b) \\ (dyld_program_sdk_at_least(dyld_platform_version_macOS_ ## x) || \\ dyld_program_sdk_at_least(dyld_platform_version_iOS_ ## i) || \\ dyld_program_sdk_at_least(dyld_platform_version_tvOS_ ## t) || \\ dyld_program_sdk_at_least(dyld_platform_version_watchOS_ ## w) || \\ dyld_program_sdk_at_least(dyld_platform_version_bridgeOS_ ## b)) 可以看到，由于不被识别的宏定义 dyld_platform_version_ 与不匹配的函数 dyld_program_sdk_at_least() ，这个宏 sdkIsAtLeast() 严重的水土不服！ 笔者在此处，将 sdkIsAtLeast() 还原为旧版本的定义： #if TARGET_OS_OSX # define DYLD_OS_VERSION(x, i, t, w, b) DYLD_MACOSX_VERSION_##x # define sdkVersion() dyld_get_program_sdk_version() #elif TARGET_OS_IOS # define DYLD_OS_VERSION(x, i, t, w, b) DYLD_IOS_VERSION_##i # define sdkVersion() dyld_get_program_sdk_version() #elif TARGET_OS_TV # define DYLD_OS_VERSION(x, i, t, w, b) DYLD_IOS_VERSION_##t # define sdkVersion() dyld_get_program_sdk_version() #elif TARGET_OS_BRIDGE # if TARGET_OS_WATCH # error bridgeOS 1.0 not supported # endif # define DYLD_OS_VERSION(x, i, t, w, b) DYLD_IOS_VERSION_##t # define sdkVersion() dyld_get_program_sdk_bridge_os_version() #elif TARGET_OS_WATCH # define DYLD_OS_VERSION(x, i, t, w, b) DYLD_WATCHOS_VERSION_##w # define sdkVersion() dyld_get_program_sdk_watch_os_version() #else # error unknown OS #endif #define sdkIsAtLeast(x, i, t, w, b) \\ (sdkVersion() >= DYLD_OS_VERSION(x, i, t, w, b)) 2.15、_simple.h file not found /objc4-818.2/runtime/objc-errors.mm:77:10: fatal error: '_simple.h' file not found #include ^~~~~~~~~~~ 1 error generated. 解决：下载libplatform-254源码，在指定目录 private 找到文件 _simple.h ，添加到 objc 项目的自定义目录ThirdLib！ 2.16、Cambria/Traps.h.h file not found 和 Cambria/Cambria.h.h file not found /objc4-818.2/runtime/objc-cache.mm:87:10: fatal error: 'Cambria/Traps.h' file not found #include ^~~~~~~~~~~~~~~~~ /objc4-818.2/runtime/objc-cache.mm:88:10: fatal error: 'Cambria/Cambria.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~~ 2 error generated. 解决：在 objc-cache.mm 文件中注释相关引用！ #if TARGET_OS_OSX //#include //#include #endif 2.17、Block_private.h file not found /objc4-818.2/runtime/objc-block-trampolines.mm:36:10: fatal error: 'Block_private.h' file not found #include ^~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载 libclosure-78源码，找到文件 Block_private.h ，添加到 objc 项目的自定义目录ThirdLib！ 2.18、kern/restartable.h file not found /objc4-818.2/runtime/objc-cache.mm:1038:10: fatal error: 'kern/restartable.h' file not found #include ^~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载xnu-7195源码，在指定目录 osfmk -> kern 找到文件 restartable.h ，添加到 objc 项目的自定义目录ThirdLib/kern！ 2.18.1、未经声明的 oah_is_current_process_translated() /objc4-818.2/runtime/objc-cache.mm:1121:13: error: use of undeclared identifier 'oah_is_current_process_translated' if (oah_is_current_process_translated()) { /objc4-818.2/runtime/objc-cache.mm:1122:33: error: use of undeclared identifier 'objc_thread_get_rip' kern_return_t ret = objc_thread_get_rip(threads[count], (uint64_t*)&pc); 2 errors generated. 解决：在 objc-cache.mm 文件中注释相关代码！ if (oah_is_current_process_translated()) { kern_return_t ret = objc_thread_get_rip(threads[count], (uint64_t*)&pc); if (ret != KERN_SUCCESS) { pc = PC_SENTINEL; } } else { pc = _get_pc_for_thread (threads[count]); } 2.18.2、 /objc4-818.2/runtime/objc-runtime-new.mm:176:1: error: '_static_assert' declared as an array with a negative size STATIC_ASSERT((~ISA_MASK & MACH_VM_MAX_ADDRESS) == 0 || 解决：在 objc-runtime-new.mm 文件中注释相关代码！ //STATIC_ASSERT((~ISA_MASK & MACH_VM_MAX_ADDRESS) == 0 || // ISA_MASK + sizeof(void*) == MACH_VM_MAX_ADDRESS); 2.19、os/reason_private.h file not found /objc4-818.2/runtime/NSObject.mm:45:10: fatal error: 'os/reason_private.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载xnu-7195源码，在指定目录 libkern -> os 找到文件 reason_private.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 2.20、os/variant_private.h file not found /objc4-818.2/runtime/NSObject.mm:46:10: fatal error: 'os/variant_private.h' file not found #include ^~~~~~~~~~~~~~~~~~~~~~ 1 error generated. 解决：下载Libc-1439源码，在指定目录os 找到文件 variant_private.h ，添加到 objc 项目的自定义目录ThirdLib/os！ 3、链接配置有误 3.1、二进制重排文件 .order 的路径错误 ld: can't open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk/AppleInternal/OrderFiles/libobjc.order clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决：在 TARGETS -> objc -> Build Settings -> Linking -> Order File 为 .order 文件配置路径！ 3.2、删除 -lCrashReporterClient ld: library not found for -lCrashReporterClient clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决：找到 TARGETS -> objc -> Build Settings -> Other Link Flags 删除 -lCrashReporterClient。 3.3、删除 -loah ld: library not found for -loah clang: error: linker command failed with exit code 1 (use -v to see invocation) 解决：找到 TARGETS -> objc -> Build Settings -> Other Link Flags 删除 -loah。 4、调试 objc 花了这么多时间，终于将 objc 编译成功；接下来，就可以调试程序了！ 笔者在这里新建了一个 target：macOS -> Command Line Tool 然后添加依赖 objc： 此时，已经可以使用新建的 target 调试 objc 了！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/Runtime_Protocol.html":{"url":"iOS开发/Runtime/Runtime_Protocol.html","title":"Runtime函数库中关于协议Protocol的函数使用","keywords":"","body":"Runtime函数库中关于协议Protocol的函数使用 Runtime 函数库提供了很多函数用于一些操作，本篇主要总结关于协议 Protocol 的操作函数： /* 获取指定名称的协议。 * @return 如果找不到指定名称的协议，则为NULL。 * @note 这个函数获取运行时锁。 */ Protocol * _Nullable objc_getProtocol(const char * _Nonnull name); /* 返回运行时所有已知协议的数组。 * @param outCount 数组中的协议数量 * @return 必须使用free()释放数组。 * @note T这个函数获取运行时锁。 */ Protocol * __unsafe_unretained _Nonnull * _Nullable objc_copyProtocolList(unsigned int * _Nullable outCount); /* 判断一个协议 proto 是否遵守了另一个协议 other * @return 如果 proto 遵守 other，则为YES，否则为NO。 * @note 一种协议可以使用与类采用协议相同的语法来合并其他协议: * 如： @protocol ProtocolName * 尖括号中列出的所有协议都被认为是协议名称协议的一部分。 */ BOOL protocol_conformsToProtocol(Protocol * _Nullable proto, Protocol * _Nullable other); /* 判断两个协议是否相等。 * @return 如果 proto 与 other 相等，则为YES，否则为NO。 */ BOOL protocol_isEqual(Protocol * _Nullable proto, Protocol * _Nullable other); /* 获取协议的名称。 */ const char * _Nonnull protocol_getName(Protocol * _Nonnull proto); /* 获取指定协议的指定方法的方法描述结构。 * @param isRequiredMethod 指示 aSel 是否是必需实现的方法 * @param isInstanceMethod 指示 aSel 是否是实例方法 * @return 如果协议不包含指定的方法，则返回一个值为{NULL, NULL}的objc_method_description结构。 * @note 这个函数递归地搜索这个协议所遵循的任何协议。 */ struct objc_method_description protocol_getMethodDescription(Protocol * _Nonnull proto, SEL _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod); /* 获取满足指定协议的指定规范的方法的方法描述数组。 * @param isRequiredMethod 指示返回的方法是否应该是必需的方法(传递YES以指定必需的方法)。 * @param isInstanceMethod 指示返回的方法是否应该是实例方法(传递YES以指定实例方法)。 * @param outCount 数组中元素的数量。 * @return 必须使用free()释放数组。如果协议声明没有满足规范的方法，则返回 NULL 并且 *outCount 指为 0。 * @note 不包括本协议所采用的其他协议中的方法。 */ struct objc_method_description * _Nullable protocol_copyMethodDescriptionList(Protocol * _Nonnull proto,BOOL isRequiredMethod, BOOL isInstanceMethod,unsigned int * _Nullable outCount); /* 获取指定协议的指定属性。 * @param proto 指定协议 * @param name 指定属性名称. * @param isRequiredProperty YES 搜索必须属性，NO 搜索可选属性。 * @param isInstanceProperty YES 搜索实例属性，NO 搜索类属性。 * @return 如果 proto 的所有属性都不满足规范，则为NULL。 */ objc_property_t _Nullable protocol_getProperty(Protocol * _Nonnull proto,const char * _Nonnull name, BOOL isRequiredProperty, BOOL isInstanceProperty); /* 获取协议声明的必需实例属性的数组。 * @note 作用类似于 protocol_copyPropertyList2(proto, outCount, YES, YES); */ objc_property_t _Nonnull * _Nullable protocol_copyPropertyList(Protocol * _Nonnull proto,unsigned int * _Nullable outCount); /* 获取协议声明的属性数组。 * @param isRequiredProperty YES 返回必须属性，NO 返回可选属性。 * @param isInstanceProperty YES 返回实例属性，NO 返回类属性。 * @return 不包括本协议采用的其他协议声明的任何属性； * 必须使用free()释放数组；如果协议声明没有匹配的属性，则返回 NULL 并且 *outCount 指为 0。 */ objc_property_t _Nonnull * _Nullable protocol_copyPropertyList2(Protocol * _Nonnull proto,unsigned int * _Nullable outCount, BOOL isRequiredProperty, BOOL isInstanceProperty); /* 获取协议所遵守的其它协议的数组。 * @return 必须使用free()释放数组；如果协议声明没有遵守其它协议，则返回 NULL 并且 *outCount 指为 0。 */ Protocol * __unsafe_unretained _Nonnull * _Nullable protocol_copyProtocolList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount); /* 创建一个新的协议实例，该实例在注册 objc_registerProtocol() 之前不能使用 * @param name 要创建的协议的名称。 * @return 创建成功返回协议实例，如果已存在同名协议则返回 nil。 * @note 没有销毁的函数 */ Protocol * _Nullable objc_allocateProtocol(const char * _Nonnull name); /* 向 Runtime 注册新构造的协议：协议将准备好使用，并且在此之后是不可变的。 */ void objc_registerProtocol(Protocol * _Nonnull proto); /* 向协议中添加方法；此时该协议还没有注册 * @param name 要添加方法的选择器类型 SEL * @param types 方法签名：方法的入参类型与返回值类型 * @param isRequiredMethod 必需实现的方法为 YES ，可选方法为 NO。 * @param isInstanceMethod 实例方法为 YES ，类方法为 NO。 */ void protocol_addMethodDescription(Protocol * _Nonnull proto, SEL _Nonnull name, const char * _Nullable types, BOOL isRequiredMethod, BOOL isInstanceMethod); /* 将合并的协议添加到另一个协议：正在添加的协议还没有注册，而附加协议已经注册。 * @param proto 正在添加的协议还没有注册 * @param addition 附加协议已经注册 */ void protocol_addProtocol(Protocol * _Nonnull proto, Protocol * _Nonnull addition); /* 向协议添加属性：该协议还没有注册。 * @param name 添加属性的名称 * @param attributes 属性的特征数组 * @param attributeCount 属性的特征数量 * @param isRequiredProperty 如果属性(访问器方法)是必需实现的，则为 YES。 * @param isInstanceProperty 如果属性(访问器方法)是实例方法，则为 YES。 * 这是属性唯一允许的情况，因此，将其设置为NO将不会将属性添加到协议中。 */ void protocol_addProperty(Protocol * _Nonnull proto, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/Runtime_Property.html":{"url":"iOS开发/Runtime/Runtime_Property.html","title":"Runtime函数库中关于属性与变量的函数使用","keywords":"","body":"Runtime函数库中关于属性与变量的函数使用 Runtime 函数库提供了很多函数用于一些操作，本篇主要总结关于属性 Property 与变量的操作函数： 1、使用属性 /* 获取属性的名称 */ const char * _Nonnull property_getName(objc_property_t _Nonnull property); /* 获取属性的特征 */ const char * _Nullable property_getAttributes(objc_property_t _Nonnull property); /* 获取属性的特征数组。 * @param outCount 特征数组的元素数量 * @return 必须使用 free() 函数释放 */ objc_property_attribute_t * _Nullable property_copyAttributeList(objc_property_t _Nonnull property,unsigned int * _Nullable outCount); /* 获取指定特征的值。 * @param attributeName 指定特征名称 * @return 如果它不存在于属性中则为nil。 */ char * _Nullable property_copyAttributeValue(objc_property_t _Nonnull property,const char * _Nonnull attributeName); 2、关联属性 /* 关联引用时的一些选项 */ typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, //指定对关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //指定对关联对象的强引用；这种关联不是原子性的。 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, //指定复制关联的对象；这种关联不是原子性的。 OBJC_ASSOCIATION_RETAIN = 01401, //指定对关联对象的强引用；这种关联是原子性的。 OBJC_ASSOCIATION_COPY = 01403 //指定复制关联的对象；这种关联是原子性的。 }; /* 使用指定键和关联选项为指定对象设置关联值。 * @param object 关联的实例对象。 * @param key 关联的键 * @param value 关联的键对应的值；传递 nil 以清除现有关联。 * @param policy 关联的选项 */ void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy); /* 获取与指定对象关联的指定键的值。 * @param object 关联的实例对象。 * @param key 关联的键 * @return 与对象的键键关联的值。 */ id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); /* 移除指定对象的所有关联。 * @note 该函数的主要目的是使指定对象很容易返回到“原始状态”。 * 不应该将此函数用于从对象中删除关联，因为它还会删除添加到对象中的关联。 * 通常使用 objc_setAssociatedObject() 和 nil 值来清除关联。 */ void objc_removeAssociatedObjects(id _Nonnull object); 3、关于变量 Ivar 的操作函数 /* 获取指定类的 指定实例变量 Ivar。 * @param cls 指定实例对象所属的类 * @param name 要获取的实例变量的定义名称 * @return 一个指向 Ivar 数据结构的指针，该结构包含关于由名称指定的实例变量的信息。 */ Ivar class_getInstanceVariable(Class cls, const char *name); /* 获取指定类的 指定类变量 Ivar。 * @param cls 指定类 * @param name 要获取的类变量的定义名称 */ Ivar class_getClassVariable(Class cls, const char *name); /* 获取类的所有实例变量 * @param cls 要检查的类。 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 类型为Ivar的指针数组，描述类声明的实例变量。 * 不包括由父类声明的任何实例变量。 * 必须使用 free() 函数释放数组。 * * 如果类声明没有实例变量，或者 cls 为Nil，则返回 NULL 并 *outCount 值为 0。 */ Ivar *class_copyIvarList(Class cls, unsigned int *outCount); /* 获取实例变量的名称 */ const char * _Nullable ivar_getName(Ivar _Nonnull v); /* 获取实例变量的数据类型 */ const char * _Nullable ivar_getTypeEncoding(Ivar _Nonnull v); /* 获取实例变量的偏移量。 * @note 对于id类型或其他对象类型的实例变量，调用 object_getIvar() 和 object_setIvar() ，而不是使用此偏移量直接访问实例变量数据。 */ ptrdiff_t ivar_getOffset(Ivar _Nonnull v); /* 获取一个指针，指向与实例给定对象一起分配的任何额外字节。 * @param obj 一个 Objective-C 对象 * @return 一个指针，指向用obj分配的任何额外字节。如果没有为obj分配任何额外字节，那么对返回指针的解引用就是未定义的。 * @note 这个函数返回一个指针，指向与实例一起分配的任何额外字节(由class_createInstance指定，extraBytes>0)。 * 该内存遵循对象的普通ivar，但可能与上一个ivar不相邻。 * @note 返回的指针保证是指针大小对齐的，即使对象最后一个ivar后面的区域的对齐程度低于该值。 * 永远不能保证对齐大于指针大小，即使对象最后一个ivar后面的区域比指针大小更对齐。 * @note 在 garbage-collected 环境中，对内存进行保守扫描。 */ void * _Nullable object_getIndexedIvars(id _Nullable obj); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/Runtime_Instance.html":{"url":"iOS开发/Runtime/Runtime_Instance.html","title":"Runtime函数库中关于实例对象的函数使用","keywords":"","body":"Runtime函数库中关于实例对象的函数使用 Runtime 函数库提供了很多函数用于一些操作，本篇主要总结关于实例对象的操作函数： 1、类的实例化 /* 创建类的实例，为默认 malloc() 内存区域中的类分配内存。 * @param cls 要创建的实例的类。 * @param extraBytes 要分配的额外字节数；额外的字节用来存储类中定义的实例变量之外的其他实例变量。 * @return 指定类的一个实例 */ id class_createInstance(Class cls, size_t extraBytes); /* 在提供的特定位置创建类的实例。 * @param cls 要创建的实例的类。 * @param bytes 创建 cls 实例的位置。必须指向至少 class_getInstanceSize(cls) 字节的对齐良好的零填充内存。 */ id _Nullable objc_constructInstance(Class _Nullable cls, void * _Nullable bytes); /* 在不释放内存的情况下销毁类的实例，并删除该实例可能具有的任何关联引用。 */ void * _Nullable objc_destructInstance(id _Nullable obj); 2、使用实例 /* 拷贝指定对象 * @param obj 一个 Objective-C 实例对象. * @param size 对象obj的大小 */ id _Nullable object_copy(id _Nullable obj, size_t size); /* 释放指定对象占用的内存。 * @return 返回 nil */ id _Nullable object_dispose(id _Nullable obj); /* 获取对象的类。如果 obj 为Nil，则返回 nil */ Class _Nullable object_getClass(id _Nullable obj); /* 设置对象的类。 * @return 返回该对象之前所属的类；如果 obj 为Nil，则返回 nil */ Class _Nullable object_setClass(id _Nullable obj, Class _Nonnull cls); /* 判断一个对象是否是类对象。 * @return 如果对象是类或元类，则为true，否则为false。 */ BOOL object_isClass(id _Nullable obj); /* 获取对象中实例变量的值。 * @return 如果 obj 为nil，则为nil。 * @note 如果实例变量的 Ivar 已知，则 object_getIvar() 函数比 object_getinstancevable() 函数快。 */ id _Nullable object_getIvar(id _Nullable obj, Ivar _Nonnull ivar); /* 设置对象中实例变量的值。 * @note 具有已知内存管理的实例变量(如ARC的strong 与 weak)使用该内存管理。 * 具有未知内存管理的实例变量被分配为unsafe_unretain。 * @note 如果实例变量的Ivar已知，则 object_setIvar() 函数比 object_setinstancevable() 函数快。 */ void object_setIvar(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value); /* 设置对象中实例变量的值。 * @note 具有已知内存管理的实例变量(如ARC的strong 与 weak)使用该内存管理。 * 具有未知内存管理的实例变量时，将它们视为 strong 。 * @note 如果实例变量的Ivar已知，则 object_setIvar() 函数比 object_setinstancevable() 函数快。 */ void object_setIvarWithStrongDefault(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value); /* 设置实例对象的指定变量的值。 * @param name 一个C字符串，是实例变量的名称。 * @param value 实例变量的新值。 * @return 一个指向Ivar数据结构的指针，该结构定义了由name指定的实例变量的类型和名称。 * @note 具有已知内存管理的实例变量(如ARC strong和 weak)使用该内存管理。 * 具有未知内存管理的实例变量被分配为 unsafe_unretain。 */ Ivar _Nullable object_setInstanceVariable(id _Nullable obj, const char * _Nonnull name,void * _Nullable value); /* 设置实例对象的指定变量的值。 * @param name 一个C字符串，是实例变量的名称。 * @param value 实例变量的新值。 * @return 一个指向Ivar数据结构的指针，该结构定义了由name指定的实例变量的类型和名称。 * @note 具有已知内存管理的实例变量(如ARC strong和 weak)使用该内存管理。 * 分配具有未知内存管理的实例变量时，将它们视为 strong 变量。 */ Ivar _Nullable object_setInstanceVariableWithStrongDefault(id _Nullable obj, const char * _Nonnull name,void * _Nullable value); /* 获取实例对象的指定变量的值。 * @param name 一个C字符串，是实例变量的名称。 * @param outValue 返回时，包含指向实例变量值的指针。 * @return 一个指向Ivar数据结构的指针，该结构定义了由name指定的实例变量的类型和名称。 */ Ivar _Nullable object_getInstanceVariable(id _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/Runtime_Class.html":{"url":"iOS开发/Runtime/Runtime_Class.html","title":"Runtime函数库中关于Class的函数使用","keywords":"","body":"Runtime函数库中关于 Class 的函数使用 Runtime 函数库提供了很多函数用于一些操作，本篇主要总结关于类 Class 的操作函数： 1、根据类名获取类 /* 获取指定名称的类： * @param name 要查找的类的名称。 * @return 返回指定名称的类； * @note 如果类没有在Objective-C运行时注册，则返回 nil。 * @note 如果该类不存在,调用 _objc_classLoader() 函数，然后调用objc_classHandler() 函数，两者都可以创建一个新类。 * @note objc_getClass() 与objc_lookUpClass() 的不同之处在于，如果类没有注册，objc_getClass() 将调用类处理程序回调，然后再次检查类是否注册。objc_lookUpClass() 不调用类处理程序回调。 * @Warning: 如果aClassName是为类的 isa 设置的名称，则无法执行! */ Class _Nullable objc_getClass(const char * _Nonnull name); /* 获取指定名称的类： * @note 该函数功能基于 objc_getClass() 函数，内部首先调用 objc_getClass() 函数获取返回值； * 然后判断返回值是否为空，如果返回值为空，则终止进程； * @note 此函数由 ZeroLink 使用，如果没有 ZeroLink，则无法找到类将是编译时链接错误。 */ Class _Nonnull objc_getRequiredClass(const char * _Nonnull name); /* 获取指定名称的类 * @note 如果类没有在Objective-C运行时注册，则返回 nil。 * 如果该类不存在, 调用_objc_classLoader() 函数，它可以创建一个新类。 * @note objc_getClass() 与这个函数的不同之处在于，如果类没有注册，objc_getClass() 将调用类处理程序回调函数，然后第二次检查类是否注册。这个函数不调用类处理程序回调。 */ Class _Nullable objc_lookUpClass(const char * _Nonnull name); /* 获取指定名称的类的元类 * @note 如果指定名称的类不存在，则返回 nil 并且打印日志 objc[3966]: class `aClassName' not linked into application * @note 如果命名类的定义未注册，则此函数调用类处理程序回调，然后再次检查类是否注册。但是，每个类定义都必须有一个有效的元类定义，因此无论元类定义是否有效，它总是返回。 */ Class _Nullable objc_getMetaClass(const char * _Nonnull name); /* 获取指定数量的已注册类，获取的类列表为任意子集。 * @param buffer 用于写入已注册类集的缓存；最多有 bufferCount 或注册类的总数量(以较少者为准)。 * 可以传递NULL来获取注册类定义的总数： * @param bufferCount 指定获取类的数量； * @return 返回已注册类的总数量。 * @note 该次函数执行 objc_getClassList(NULL, 0) 获取所有已注册类的总数量； * @note Objective-C 运行库自动注册在源代码中定义的所有类； * 可以在运行时创建类定义，并将它们注册到objc_addClass() 函数中。 * @warning 该函数中获得的类的父类可能是任意类；因此如果不首先检测方法的实现，就不能安全地调用这些类上的任何方法。 */ int objc_getClassList(Class _Nonnull * _Nullable buffer, int bufferCount); /* 获取所有已注册类的指针列表。 * @param outCount 所有已注册类数量 * @note 该函数与 objc_getClassList() 函数区别在于： * 该函数只能获取所有已注册的类；但是用法简单 * objc_getClassList() 函数可以获取指定数量的任意集合类；用法稍微复杂些； */ Class _Nonnull * _Nullable objc_copyClassList(unsigned int * _Nullable outCount); 2、使用类 2.1、获取类的一些简单信息 /* 获取指定类的类名 * @param cls 类. * @return 如果 class 为 nil，则返回空字符串 */ const char *class_getName(Class cls); /* 判断指定类是否是元类 */ BOOL class_isMetaClass(Class cls) ; /* 获取指定类的父类 * @note 如果该类是 NSObject，则返回 nil；如果 cls为 nil， 则返回 nil； */ Class class_getSuperclass(Class cls); /* 设置指定类的父类 * * @param cls 要设置的指定类 * @param newSuper 指定类的新父类 * @return 指定类的原有父类 */ Class class_setSuperclass(Class cls, Class newSuper); /* 获取类定义的版本号。 */ int class_getVersion(Class cls); /* 设置类定义的版本号。 * @param version 新的版本号，int 型数据类型 * @note 可以使用类定义的版本号来提供类表示给其他类的接口的版本控制。 * 这对于对象序列化特别有用，在这种情况下，识别不同类定义版本中实例变量布局的更改非常重要。 */ void class_setVersion(Class cls, int version); /* 获取指定类的实例大小（字节数） * @return 如果 cls 为nil，则返回 0 字节。 */ size_t class_getInstanceSize(Class cls); 2.2、获取类的变量 /* 获取指定类的 指定实例变量 Ivar。 * @param cls 指定实例对象所属的类 * @param name 要获取的实例变量的定义名称 * @return 一个指向 Ivar 数据结构的指针，该结构包含关于由名称指定的实例变量的信息。 */ Ivar class_getInstanceVariable(Class cls, const char *name); /* 获取指定类的 指定类变量 Ivar。 * @param cls 指定类 * @param name 要获取的类变量的定义名称 */ Ivar class_getClassVariable(Class cls, const char *name); /* 获取由指定类声明的所有实例变量 * @param cls 指定的类。 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 类型为Ivar的指针数组，描述类声明的实例变量。 * 不包括由超类声明的任何实例变量。 * 必须使用 free() 函数释放数组。 * * 如果类声明没有实例变量，或者 cls 为Nil，则返回 NULL 并 *outCount 值为 0。 */ Ivar *class_copyIvarList(Class cls, unsigned int *outCount); /* 获取指定类的变量 Ivar 布局的描述。 */ const uint8_t *class_getIvarLayout(Class cls); /* 设置指定类的 Ivar 布局。 */ void class_setIvarLayout(Class cls, const uint8_t *layout); /* 获取指定类的弱引用变量 Ivars 布局的描述。 */ const uint8_t *class_getWeakIvarLayout(Class cls); /* 设置指定类的弱引用变量 Ivars 布局。 */ void class_setWeakIvarLayout(Class cls, const uint8_t *layout); /* 向指定类添加新实例变量。 * @return 如果实例变量添加成功返回 YES；则为 NO 如该类已经包含一个同名的实例变量 * @note 此函数只能在 objc_allocateClassPair() 函数之后和 objc_registerClassPair() 函数之前调用； * 不支持向现有类中添加实例变量。 * @note 指定类不能是元类；不支持向元类中添加实例变量。 * @note 实例变量的最小字节对齐是 12.3、获取类的属性 /* 获取指定类的指定名称的属性。 * @param name 指定属性的名称。 * @return 如果类没有使用该名称声明属性，则返回 NULL；如果cls为 Nil，则返回NULL。 */ objc_property_t class_getProperty(Class cls, const char *name); /* 获取指定类声明的所有属性。 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 返回类型为 objc_property_t 的指针数组，用于描述该类声明的属性。 * 不包括父类声明的任何属性。 * 必须使用free()释放数组。 * 如果cls 声明没有属性，或者 cls 为 Nil，则返回 NULL 且 *outCount 值为 0。 */ objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount); /* 向指定类中添加属性。 * @param name 属性名称. * @param attributes 属性特征数组. * @param attributeCount 属性特征数组元素数量. * @return 如果属性添加成功返回 YES；则为 NO 如该类已经存在该属性 */ BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount); /* 替换指定类的某个属性。 * @param name 要替换的属性名称. * @param attributes 属性特征数组. * @param attributeCount 属性特征数组元素数量. */ void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount); 2.4、获取类的方法 /* 获取指定类的指定实例方法。 * @param name 要获取方法的选择器类型。 * @return 如果指定的类或其父类不包含具有指定选择器的实例方法，则返回 NULL。 * @note 该函数会去父类中搜索，而 class_copyMethodList() 函数不会去父类中搜索。 */ Method class_getInstanceMethod(Class cls, SEL name); /* 获取指定类的指定类方法。 * @return 如果指定的类或其父类不包含具有指定选择器的类方法，则返回 NULL。 * @note 该函数会去父类中搜索，而 class_copyMethodList() 函数不会去父类中搜索。 */ Method class_getClassMethod(Class cls, SEL name); /* 获取指定类实现的所有实例方法。 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 获取类实现的实例方法的类型指针数组； * 不包括由父类实现的任何实例方法；必须使用 free() 函数释放数组。 * @note 如果 cls 没有实现实例方法，或者 cls 为 Nil，则返回 NULL 且 *outCount 值为 0。 * @note 要获取类的类方法，使用 class_copyMethodList(object_getClass(cls), &count). * @note 要获得父类可能实现的方法的实现，可以使用 class_getInstanceMethod() 函数 或者 class_getClassMethod() 函数. */ Method *class_copyMethodList(Class cls, unsigned int *outCount); /* 获取在将指定消息发送到类的实例时将调用的函数指针。 * @return 如果cls为 nil，则返回空指针 NULL * * @note 该函数在运行效率上可能比 method_getImplementation(class_getInstanceMethod(cls, name)) 更快 * @note 返回的函数指针可能是运行时的内部函数，而不是实际的方法实现。 * 例如，如果类的实例不响应 SEL，返回的函数指针将成为运行时消息转发机制的一部分。 */ IMP class_getMethodImplementation(Class cls, SEL name); /* 获取在将指定消息发送到类的实例时将调用的函数指针。 * @return 如果cls为 nil，则返回空指针 NULL */ IMP class_getMethodImplementation_stret(Class cls, SEL name); /* 判断指定类的实例能否响应指定选择器。 * @prama cls 指定类的实例 * @param sel 指定选择器 * @return 如果类的实例响应选择器，则为YES，否则为NO。 * @note 一般使用 NSObject 的 -respondsToSelector: 方法或者 +instancesRespondToSelector: 方法来替代这个函数 */ BOOL class_respondsToSelector(Class cls, SEL sel); /* 向指定类添加新方法 * @param cls 要添加方法的类。 * @param name 指定要添加方法的选择器 SEL。 * @param imp 函数指针，该函数必须具有至少两个参数 self 和 _cmd 。 * @param types 描述方法参数类型的字符数组。 * @return 如果方法添加成功，则为YES；否则为 NO，如添加该类已实现的方法则失败 * @note 该函数将重写父类的方法，但不会替换该类中的现有方法。要更改现有的实现，使用 method_setImplementation() 函数。 */ BOOL class_addMethod(Class cls, SEL name, IMP imp,const char *types); /* 替换指定类的方法的实现。 * @param name 要替换其实现方法的选择器 SEL * @param imp 新的函数地址 * @param types 描述方法参数类型的字符数组。 * @return 指定类的方法的原有实现； * @note 这个函数有两种不同的行为方式: * - 如果该方法还不存在，那么就像调用 class_addMethod() 函数一样添加它；types 将按给定的方式使用。 * - 如果该方法已经实现，则替换其IMP，就像调用 method_setImplementation() 函数一样；忽略 types。 */ IMP class_replaceMethod(Class cls, SEL name, IMP imp,const char *types); 2.5、获取类的协议 /* 判断指定类是否实现了指定的协议。 * @param cls 指定类 * @param protocol 指定的协议. * @return 如果cls 实现协议，则为YES，否则为NO。 * @note 一般使用 NSObject 的 -conformsToProtocol: 方法来替代这个函数 */ BOOL class_conformsToProtocol(Class cls, Protocol *protocol); /* 获取指定类所声明的所有协议 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 返回类型为 Protocol* 的指针数组，描述类所声明的协议。 * 不包括父类或其他协议所声明的任何协议； * 必须使用 free() 函数释放数组； * 如果 cls 不采用协议，或者 cls 为 Nil，则返回 NULL 且 *outCount 值为 0。 */ Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount); /* 向指定类中添加协议。 * @return 如果协议添加成功返回 YES；则为 NO 如该类已经声明该协议 */ BOOL class_addProtocol(Class cls, Protocol *protocol); /* 用于CoreFoundation的桥接。 * @warning 不要自己调用这个函数。 */ Class _Nonnull objc_getFutureClass(const char * _Nonnull name); 3、动态添加类 /* 创建一个新类和元类。 * @param superclass 要用作新类的父类；如果为 nil 则创建根类。 * @param name 用作新类名称的字符串；字符串将被复制。 * @param extraBytes 在类和元类对象的末尾为索引ivars分配的字节数。这通常是0。 * @return 返回新类；如果无法创建类则为Nil(例如，所需的名称已经在使用中)。 * @note 通过调用 object_getClass(newClass) 来获得指向新元类的指针。 * @note 要创建一个新类，首先调用 objc_allocateClassPair() 。 * 然后使用class_addMethod() 和class_addIvar() 等函数设置类的属性。 * 构建完类后，调用 objc_registerClassPair() 注册类。 * 新类现在可以使用了。 * @note 实例方法和实例变量应该添加到类本身；类方法应该添加到元类中。 */ Class _Nullable objc_allocateClassPair(Class _Nullable superclass, const char * _Nonnull name,size_t extraBytes); /* 注册使用 objc_allocateClassPair() 创建的类。 */ void objc_registerClassPair(Class _Nonnull cls); /* 用于Foundation的键值观察。 * @warning 不要自己调用这个函数。 */ Class _Nonnull objc_duplicateClass(Class _Nonnull original, const char * _Nonnull name,size_t extraBytes); /* 销毁一个类及其关联的元类； * @param cls 要销毁的类必须是用objc_allocateClassPair() 创建的； * @warning 如果存在此类或子类的实例，则不要调用。 */ void objc_disposeClassPair(Class _Nonnull cls); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/Runtime/Runtime_Method.html":{"url":"iOS开发/Runtime/Runtime_Method.html","title":"Runtime函数库中关于 Class 的函数使用","keywords":"","body":"Runtime函数库中关于 Method 的函数使用 Runtime 函数库提供了很多函数用于一些操作，本篇主要总结关于方法 Method 的操作函数： /* 返回指定类的指定实例方法。 * @param name 要获取的方法的选择器类型。 * @return 如果指定的类或其父类不包含具有指定选择器的实例方法，则返回 NULL。 * @note 该函数会去父类中搜索，而 class_copyMethodList() 函数不会去父类中搜索。 */ Method class_getInstanceMethod(Class cls, SEL name); /* 返回指定类的指定类方法。 * @return 如果指定的类或其父类不包含具有指定选择器的类方法，则返回 NULL。 * @note 该函数会去父类中搜索，而 class_copyMethodList() 函数不会去父类中搜索。 */ Method class_getClassMethod(Class cls, SEL name); /* 获取由类实现的所有实例方法。 * @param outCount 返回数组的长度；如果为 NULL，则不返回长度。 * @return 获取类实现的实例方法的类型指针数组； * 不包括由父类实现的任何实例方法；必须使用 free() 函数释放数组。 * * 如果 cls不实现实例方法，或者 cls 为Nil，则返回 NULL 且*outCount 值为 0。 * * @note 要获取类的类方法，使用 class_copyMethodList(object_getClass(cls), &count). * @note 要获得父类可能实现的方法的实现，可以使用 class_getInstanceMethod() 函数 或者 class_getClassMethod() 函数. */ Method *class_copyMethodList(Class cls, unsigned int *outCount); 1、使用方法 /* 获取方法的选择器 */ SEL _Nonnull method_getName(Method _Nonnull m); /* 获取方法的函数地址。 */ IMP _Nonnull method_getImplementation(Method _Nonnull m); /* 获取方法的参数类型和返回值类型；可能为 NULL */ const char * _Nullable method_getTypeEncoding(Method _Nonnull m); /* 获取方法的参数数量。 */ unsigned int method_getNumberOfArguments(Method _Nonnull m); /* 获取方法的返回值类型 * @return 描述返回类型的C字符串。必须使用 free() 函数释放字符串。 */ char * _Nonnull method_copyReturnType(Method _Nonnull m); /* 获取方法的中指定索引位置的参数类型 * @param index 参数的索引。 * @return 一个C字符串，描述在索引索引处的参数类型；如果方法没有参数索引，则为NULL；必须使用free()释放字符串。 */ char * _Nullable method_copyArgumentType(Method _Nonnull m, unsigned int index); /* 获取返回值类型。 * @param dst 存储描述的引用字符串 * @param dst_len 可以存储在dst中的最大字符数。 * @note 方法的返回类型字符串复制到dst；就像调用 strncpy(dst, parameter_type, dst_len) 一样填充dst。 */ void method_getReturnType(Method _Nonnull m, char * _Nonnull dst, size_t dst_len); /* 获取方法的中指定索引位置的参数类型 * @param index 参数的索引。 * @param dst 存储描述的引用字符串。 * @param dst_len 可以存储在dst中的最大字符数。 * @note 参数类型字符串复制到 dst ；就像调用 strncpy(dst, parameter_type, dst_len) 一样填充d st。 * 如果该方法不包含具有该索引的参数，则将 dst 填充为调用 strncpy(dst, \"\", dst_len)。 */ void method_getArgumentType(Method _Nonnull m, unsigned int index,char * _Nullable dst, size_t dst_len); /* 获取方法的描述结构体 */ struct objc_method_description * _Nonnull method_getDescription(Method _Nonnull m); /* 设置方法的实现。 * @return 返回该方法的原有 IMP */ IMP _Nonnull method_setImplementation(Method _Nonnull m, IMP _Nonnull imp); /* 交换两个方法的实现。 * @note 以下代码是细微实现: * IMP imp1 = method_getImplementation(m1); * IMP imp2 = method_getImplementation(m2); * method_setImplementation(m1, imp2); * method_setImplementation(m2, imp1); */ void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2); 2、使用选择器 /* 获取指定选择器的对应方法的名称。 * @param sel 选择器类型 SEL * @return 选择器名称 */ const char * _Nonnull sel_getName(SEL _Nonnull sel); /* 向 Objective-C 运行时系统注册一个方法，将方法名映射到选择器，并返回选择器值。 * @param str 要注册的方法的名称 * @return 指定方法的选择器。 * @note 在将方法添加到类定义之前，必须向 Objective-C 运行时系统注册方法名，以获得方法的选择器。 * 如果方法名已经注册，则该函数只返回选择器。 */ SEL _Nonnull sel_registerName(const char * _Nonnull str); /* 判断两个选择器是否相等。 * @return 如果相等则为YES，否则为NO。 * @note 该函数等价于 == */ BOOL sel_isEqual(SEL _Nonnull lhs, SEL _Nonnull rhs); /* 判断选择器为有效或无效。 * @param sel 要标识的选择器。 * @return 如果选择器有效且具有函数实现，则为YES，否则为NO。 * @warning 在某些平台上，无效引用(对无效内存地址的访问)可能导致崩溃。 */ BOOL sel_isMapped(SEL _Nonnull sel); /* 向Objective-C运行时系统注册一个方法名。 * @param str 注册的方法的名称 * @return 指定方法的选择器。 * @note 该方法的实现与 sel_registerName() 函数的实现相同。 * @note 在 OS X version 10.0之前，该函数尝试查找映射到给定名称的选择器，如果没有找到选择器，则返回NULL。 * 为了安全起见，更改了这个值，因为观察到这个函数的许多调用者没有检查返回值是否为NULL。 */ SEL _Nonnull sel_getUid(const char * _Nonnull str); 3、其它函数 3.1、使用库 /* 获取加载的所有 Objective-C frameworks 和动态库的名称。 */ const char * _Nonnull * _Nonnull objc_copyImageNames(unsigned int * _Nullable outCount); /* 获取指定类所在的动态库名称。 * @param cls 要查询的类。 * @return 包含此类的库的名称。 */ const char * _Nullable class_getImageName(Class _Nullable cls); /* 获取指定库中所有类的名称。 * @param image 查询的 framework 或 library 。 */ const char * _Nonnull * _Nullable objc_copyClassNamesForImage(const char * _Nonnull image, unsigned int * _Nullable outCount); 3.2、使用Objective-C语言特性 /* 当遍历过程中检测到改变时，编译器会插入此函数。发生改变时会调用它，如果设置了enumerationMutationHandler，则对其进行设置。如果未设置处理程序，则抛出异常。 * @param obj 被改变的对象。 */ void objc_enumerationMutation(id _Nonnull obj); /* 设置当前的变更处理程序。 * @param handler 函数指针指向新的改变处理程序。 */ void objc_setEnumerationMutationHandler(void (*_Nullable handler)(id _Nonnull )); /* 设置objc_msgForward() 调用的函数。 * @param fwd 由 objc_msgForward() 跳转到的函数。 * @param fwd_stret 由 objc_msgForward_stret() 跳转到的函数。 */ void objc_setForwardHandler(void * _Nonnull fwd, void * _Nonnull fwd_stret); /* 创建一个指向函数的指针，该函数将在调用方法时调用块。 * @param block 实现此方法的块。其签名应该是:method_return_type ^(id self, method_args...)。 * 选择器不是此块的参数；使用Block_copy()复制块。 * @return 调用这个块的IMP；必须用imp_removeBlock() 释放。 */ IMP _Nonnull imp_implementationWithBlock(id _Nonnull block); /* 获取与使用 imp_implementationWithBlock() 创建的IMP关联的块。 * @param anImp 调用这个块的IMP。 * @return 由 anImp 调用的块。 */ id _Nullable imp_getBlock(IMP _Nonnull anImp); /* 将一个块与使用 imp_implementationWithBlock() 创建的IMP分离，并释放创建的块的副本。 * @param anImp 使用imp_implementationWithBlock() 创建的IMP。 * @return 如果块被成功释放，则为YES；否则为NO 如，块以前可能没有用于创建IMP。 */ BOOL imp_removeBlock(IMP _Nonnull anImp); /* 加载由弱指针引用的对象，并在保留和自动释放该对象以确保它保持足够长时间的活动以供调用方使用之后返回该对象。 * 在表达式中使用 __weak 变量的任何地方都可以使用这个函数。 * @param location 弱指针地址 * @return 如果 *location 为nil，则返回 nil。 */ id _Nullable objc_loadWeak(id _Nullable * _Nonnull location); /* 这个函数将一个新值存储到 __weak 变量中。 * 它将在 __weak 变量是赋值目标的任何地方使用。 * @param location 弱指针本身的地址 * @param obj 弱指针现在应该指向的新对象 */ id _Nullable objc_storeWeak(id _Nullable * _Nonnull location, id _Nullable obj); 3.3、Hooks for Swift /** * Function type for a hook that intercepts class_getImageName(). * * @param cls The class whose image name is being looked up. * @param outImageName On return, the result of the image name lookup. * @return YES if an image name for this class was found, NO otherwise. * * @see class_getImageName * @see objc_setHook_getImageName */ typedef BOOL (*objc_hook_getImageName)(Class _Nonnull cls, const char * _Nullable * _Nonnull outImageName); /** * Install a hook for class_getImageName(). * * @param newValue The hook function to install. * @param outOldValue The address of a function pointer variable. On return, * the old hook function is stored in the variable. * * @note The store to *outOldValue is thread-safe: the variable will be * updated before class_getImageName() calls your new hook to read it, * even if your new hook is called from another thread before this * setter completes. * @note The first hook in the chain is the native implementation of * class_getImageName(). Your hook should call the previous hook for * classes that you do not recognize. * * @see class_getImageName * @see objc_hook_getImageName */ void objc_setHook_getImageName(objc_hook_getImageName _Nonnull newValue, objc_hook_getImageName _Nullable * _Nonnull outOldValue); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreText/CoteText概述.html":{"url":"iOS开发/CoreText/CoteText概述.html","title":"CoreText","keywords":"","body":"CoreText 简单了解 1、 排版的一些基础知识 1.1、字符（Character）和字形（Glyphs） 1.1.1、概念 文本显示的主要过程就是字符到字形的转换： 字符：信息本身的元素；在计算机中是一个编码，如 Unicode 字符集囊括了大部分字符 字形：字符的图标特征，一般存储在字体文件中； 一个字符可以对应多个字形（不同的字体，同种字体的不同样式：粗体、斜体） 一个字形，也可以容纳多个字符连字符，如下：（右边的字形是连写ff，包括两个字符f）： 连字符是一种上下文相关的字形，一个字符的字形由受到下一个字符的影响。 1.1.2、字形度量 在 iOS 中渲染到屏幕的字形有多个度量(Glyph Metrics)： 边界框 bounding box ：一个假想的框子，在边界框内尽可能紧密的装入字形； 基线 baseline ：一条假想的线，同一行的字形以该条线作参考；该条线最左侧的一个点是基线的原点； 上行高度 ascent ： 基线距字体中最高的字形顶部的距离，是一个正值 下行高度 descent： 基线距字体中最低的字形底部的距离，是一个负值 行距 linegap 行高 lineHeight = ascent + |descent| + linegap 文字的排版顺序 text direction ：像English是从左上角开始，从左到右；也有文字的排版是从右到左或者是从上到下的排版等； 断行 line breaking：在字符串中找到一个点，截取出一段文本用于显示一行； 左间隙 left-side bearing：是字符之间默认的间隙；（同理还有right-side bearing） 2、CoreText Core Graphics 是一个2D图形渲染引擎，能够处理iOS中图形显示问题：能够直接处理字体（Fonts）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。 CoreText 是在 Core Graphics 基础上对处理文字和字体的功能的封装，将显示的文字内容、位置、字体、字形直接传递给 Core Graphics。与其他 UI 组件相比，CoreText 具有更高效的排版功能！ CoreText 处在非常底层的位置，我们常用的 UILable、UITextField、UITextView、UIWebView 都是基于 CoreText 来实现的。 使用 CoreText 的优点： CoreText 占用内存更少，渲染速度更快； CoreText 的 CTFrame 可以在后台线程渲染； CoreText 在渲染界面前就可以精确地获得显示内容的高度； CoreText 可以做更好的原生交互效果，更细腻的视觉特效！ 2.1、CoreText 坐标系问题 CoreText 以 Core Graphics 基础，使用 Core Graphics 的坐标系，以左下角为坐标原点；而我们常使用的UIKit是以左上角为坐标原点！ 因此使用 CoreText 绘制文字需要对其坐标系进行转换，否则直接绘制出现位置反转的镜像情况。 通常情况下是直接获取当前上下文 CGContext，将 CGContext 的坐标系转换为CoreText坐标系，再将布局好的CoreText绘制到当前上下文中： - (void)drawRect:(CGRect)rect{ //1.获取当前绘图上下文 CGContextRef context = UIGraphicsGetCurrentContext(); //2.旋转坐坐标系(默认和UIKit坐标是相反的) CGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置当前文本矩阵 CGContextTranslateCTM(context, 0, CGRectGetHeight(rect));//文本沿y轴移动 CGContextScaleCTM(context, 1.0, -1.0);//文本翻转成为CoreText坐标系 //3.开始绘制 CTFrameDraw(_frameRef, context); } 3、 CoreText 的常用布局元素 渲染文字到屏幕时常用的几个元素如下： CTFrameRef：由多个 CTLineRef 组成，有几行文字就有几行 CTLineRef； CTLineRef：可以看做 CoreText 绘制中的一行的对象； 通过它可以获得当前行的上行高度 ascent , 下行高度 descent ,行距 leading, 还可以获得Line下的所有 Glyph Runs CTRunRef：基本绘制单元，由属性 attributes 都相同的部分字形组成； 除了上述几个元素，还有一些类默默的处理排版： CTRunDelegate：是 CTRunRef 的代理回调，通过 Delegate 可以手动设置 CTRunRef 的Ascent、Descent、Width等属性，这是图文混排的基础；插入一个空白的字符，将其字符的大小设置为(width, height)，留出对应的大小空白区域，然后在排版结束完通过 CGContextDrawImage() 在对应的位置插入Image 就实现了图文混排的效果； CTFontRef： 是 CoreText 的字体，可以读取字体的版权信息（copyright）、fontFamily、style等信息； CTTypesetterRef：是 CoreText 的排版类，通过 AttributeString创建，也可以根据需要附加 options；常用于创建多行文本的换行和其他上下文相关的字符处理； CTFramesetterRef：排版生成类，内部持有一个 CTTypesetterRef来负责换行、字符处理等； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreText/CoteText排版与布局.html":{"url":"iOS开发/CoreText/CoteText排版与布局.html","title":"CoteText排版与布局","keywords":"","body":"CoreText 排版与布局 CoreText 通过 CTTypesetterRef、 CTFramesetterRef 、 CTFrameRef 完成文字的排版与布局！ 1、排版类 CTTypesetterRef typedef const struct CF_BRIDGED_TYPE(id) __CTTypesetter * CTTypesetterRef; CTTypesetter 是基础的排版类，可以通过富文本创建，并根据需要附加 options； 该类常用于文本的创建行、执行断行和其它上下文相关的字符处理；（CTLineRef也可以排版，但是只有自己当前行的信息） 1.1、 创建一个排版类 可以根据富文本创建一个排版类 CTTypesetterRef CTTypesetterCreateWithAttributedString(CFAttributedStringRef string); 还可以根据富文本和一些额外配置创建一个排版类 #prama mark - 配置选项 /** 常量：允许无边界的（不限制大小）布局 * @discussion 值为CFBooleanRef 类型，默认值为false； * 某些文本的 Proper Unicode 布局需要大量工作； 除非将此选项设置为 kCFBooleanTrue，否则此类输入将导致 CTTypesetterCreateWithAttributedStringAndOptions() 返回NULL ; */ CT_EXPORT const CFStringRef kCTTypesetterOptionAllowUnboundedLayout; /** 常量：禁用 Bidi （文本流方向） * @discussion 值为CFBooleanRef 类型，默认值为false； * 通常，排版类使用 UAX #9 的 Unicode Bidirectional Algorithm 双向算法。 * 如果在创建排版类时将此选项设置为 true，则不执行方向性重新排序，并且忽略任何方向性控制字符。 */ CT_EXPORT const CFStringRef kCTTypesetterOptionDisableBidiProcessing; /** 常量：指定嵌入级别 * @discussion 值为CFNumberRef 类型，默认值为 unset；指定嵌入级别，则忽略任何方向性控制字符。 * 通常，排版类使用 UAX #9 的 Unicode Bidirectional Algorithm 双向算法。 */ CT_EXPORT const CFStringRef kCTTypesetterOptionForcedEmbeddingLevel; /** 根据富文本和一些额外配置创建一个排版类 * @param options 额外配置，可以传 NULL * @return 如果富文本需要进行不合理的操作而无法布局，则可能返回 NULL */ CTTypesetterRef _Nullable CTTypesetterCreateWithAttributedStringAndOptions(CFAttributedStringRef string,CFDictionaryRef _Nullable options); 1.2、 创建新行 CTLineRef /** 使用排版类创建一个新行 CTLineRef * @param offset 位置偏移量 * @param stringRange 排版类是根据一串富文本创建而来，因此创建 CTLine 时需要根据这串富文本的某段； * stringRange 就是需要使用的字符串范围，如果 range.length = 0，则该行截止到富文本末尾； * @note stringRange 的范围不能超过富文本的范围，否则调用将失败。 * @discussion CTLineRef 由按照正确的视觉顺序绘制的字形组成。 */ CTLineRef CTTypesetterCreateLineWithOffset(CTTypesetterRef typesetter,CFRange stringRange,double offset); /// 类似于 offset = 0.0 的 CTTypesetterCreateLineWithOffset() 函数 CTLineRef CTTypesetterCreateLine(CTTypesetterRef typesetter,CFRange stringRange); 1.3、 执行断行 /** 根据提供的宽度获取一个换行点 * @param width 请求的断行宽度 * @param offset 位置偏移量 * @param startIndex 换行计算的起始点：将从 startIndex 位置的字符开始，到指定宽度换行； * @return 返回 startIndex 到换行点之间的字符数量； * stringRange.location = startIndex && startIndex.length = 返回值，此时可以使用 CTTypesetterCreateLine() 创建一个新行； * @discussion 可以由富文本中的 '\\n' 等触发换行，也可以由指定的宽度触发换行 */ CFIndex CTTypesetterSuggestLineBreakWithOffset(CTTypesetterRef typesetter, CFIndex startIndex,double width,double offset); /// 类似于 offset = 0.0 的 CTTypesetterSuggestLineBreakWithOffset() 函数 CFIndex CTTypesetterSuggestLineBreak(CTTypesetterRef typesetter,CFIndex startIndex,double width); /// 根据提供的宽度获取一个换行点：可能截断一个字符 ! 类似于 NSLineBreakByCharWrapping CFIndex CTTypesetterSuggestClusterBreakWithOffset(CTTypesetterRef typesetter,CFIndex startIndex, double width,double offset); ///类似于 offset = 0.0 的 CTTypesetterSuggestClusterBreakWithOffset() 函数 CFIndex CTTypesetterSuggestClusterBreak(CTTypesetterRef typesetter,CFIndex startIndex,double width ); 1.4、 使用 CTTypesetterRef 排版 1.4.1、 使用 CTTypesetterRef 为 CTLine 排版 - (void)drawRect:(CGRect)rect{ //1.获取当前绘图上下文 CGContextRef context = UIGraphicsGetCurrentContext(); //2.旋转坐坐标系(默认和UIKit坐标是相反的) CGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置当前文本矩阵 CGContextTranslateCTM(context, 0, CGRectGetHeight(rect));//文本沿y轴移动 CGContextScaleCTM(context, 1.0, -1.0);//文本翻转成为CoreText坐标系 NSString *string = @\"The 1896 Cedar Keys hurricane was a powerful tropical cyclone that devastated much of the East Coast of the United States, starting with Florida's Cedar Keys, near the end of September. The storm's rapid movement allowed it to maintain much of its intensity after landfall, becoming one of the costliest United States hurricanes at the time. \"; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName: [UIFont fontWithName:@\"PingFang SC\" size:15],NSForegroundColorAttributeName: [UIColor colorWithRed:51/255.0 green:51/255.0 blue:51/255.0 alpha:1.0]}]; CTTypesetterRef typesetterRef = CTTypesetterCreateWithAttributedString((CFAttributedStringRef)attributedString);///排版类 CFIndex start = 0; CGPoint textPosition = CGPointMake(0, 55); double width = CGRectGetWidth(self.bounds); double height = CGRectGetHeight(self.bounds); BOOL isCharLineBreak = YES;//断行：是否断字符 BOOL isJustifiedLine = NO; //两端对齐：填充空白符，文字之间等间距 float flush = 0.5;//对齐：0 是左对齐，1 是右对齐，0.5 居中 while (start 2、排版生成类 CTFramesetterRef typedef const struct CF_BRIDGED_TYPE(id) __CTFramesetter * CTFramesetterRef; 排版生成类 CTFramesetterRef 是用来根据富文本生成一个CTFrameRef的工厂；每个CTFramesetterRef 内都会有一个 CTTypesetterRef来负责换行、字符处理等。 2.1、创建排版生成类 CTFramesetterRef 既可以根据一个排版类 CTTypesetterRef 创建，也可以根据一段富文本创建： /** 根据 typesetter 创建一个framesetter对象 * @param typesetter 用于构造 framesetter 的 typesetter * @result 返回对CTFramesetter对象的引用。 * @discussion 每个 framesetter 在内部使用一个 typesetter 来执行分行等工作； * 该函数允许使用使用 specific options 创建的typesetter * @memory 注意合适的时机释放 CFRelease(framesetter); */ CTFramesetterRef CTFramesetterCreateWithTypesetter(CTTypesetterRef typesetter); /** 获取 framesetter 正在使用的 typesetter 对象 * @param framesetter 向其请求的 framesetter * @memory 该函数获取对 CTTypesetter 对象的引用，调用者不必释放该对象； */ CTTypesetterRef CTFramesetterGetTypesetter(CTFramesetterRef framesetter); /** 根据富文本创建不可变的framesetter对象 * @param attrString 用于构造 framesetter 的富文本 * @result 返回对CTFramesetter对象的引用 * @discussion 生成的 framesetter 对象可用来被 CTFramesetterCreateFrame() 调用创建和填充文本 frames * @memory 注意合适的时机释放 CFRelease(framesetter); */ CTFramesetterRef CTFramesetterCreateWithAttributedString(CFAttributedStringRef attrString); CTFramesetterRef 使用完之后，要注意它的内存释放问题！ 2.2、创建布局CTFrameRef /** 计算 CTFramesetterRef 所占用的空间大小，方便 CTFramesetterCreateFrame() 所用的CGPath * @param stringRange 将应用 frame.size 的字符串范围。字符串范围是用于创建framesetter的字符串上的范围。 * 如果 range.length 被设置为 0，那么framesetter将一直添加 CTLineRef ，直到耗尽文本或空间 * @param frameAttributes 在这里指定 frame 填充过程的其他属性，如果没有则为 NULL * @param constraints 是目标区域的最大size，值为 CGFLOAT_MAX，表示不受限制； * @param fitRange 受 constrained 限制，最终填充的字符长度 * @result 返回显示字符串所需的实际空间大小 */ CGSize CTFramesetterSuggestFrameSizeWithConstraints(CTFramesetterRef framesetter,CFRange stringRange, CFDictionaryRef _Nullable frameAttributes,CGSize constraints,CFRange * _Nullable fitRange); /** 从 framesetter 创建一个 CTFrameRef * @param framesetter 用于创建 CTFrame 的 framesetter * @param stringRange 新frame将基于的字符串范围;字符串范围是用于创建framesetter的字符串上的范围。 * 如果 range.length 被设置为 0，那么framesetter将一直添加 CTLineRef ，直到耗尽文本或空间 * @param path 绘制局域，可以提供一个特殊形状的区域（如圆形、三角形区域等） * @param frameAttributes 在这里指定 frame 填充过程的其他属性，如果没有则为 NULL * @result 返回对一个新的CTFrame对象的引用 * @memory 注意合适的时机释放 CFRelease(frameRef); */ CTFrameRef CTFramesetterCreateFrame(CTFramesetterRef framesetter,CFRange stringRange, CGPathRef path,CFDictionaryRef _Nullable frameAttributes); 2.2.1、Demo_1：创建 CTFrame 根据富文本，以及待绘制区域，我们可以创建一个简单的CTFrame /** 获取 CTFrame * @param attrString 绘制内容 * @param rect 绘制区域 */ CTFrameRef getCTFrameWithAttrString(NSAttributedString *attrString, CGRect rect){ CGPathRef path = CGPathCreateWithRect(rect, nil);///绘制局域 CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString);//设置绘制内容 CTFrameRef frameRef = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, nil); CFRelease(framesetter); CGPathRelease(path); return frameRef; } 复杂点的，根据待绘制区域的大小限制，可以创建一个大小合适的CTFrame /** 获取 CTFrame * @param attrString 绘制内容 * @param sizeLimit 绘制区域的大小限制 * @param height 设置内容高度，可以用来约束展示内容的 view 的高度 */ CTFrameRef getCTFrameFitAttrString(NSAttributedString *attrString, CGSize sizeLimit,float *height){ CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString);//设置绘制内容 CGSize pageSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0, 0), NULL, sizeLimit, NULL); *height = pageSize.height; CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, sizeLimit.width, pageSize.height), nil);///绘制局域 CTFrameRef frameRef = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, nil); CFRelease(framesetter); CGPathRelease(path); return frameRef; } 2.2.2、Demo_2：获取 CTFrame大小 根据给出的富文本与宽度限制，我们计算出该富文本渲染在屏幕上所需要的高度： /** 获取指定内容大小 * @param attrString 内容 * @param widthLimit 宽度限制 */ CGSize getSizeWithAttributedString(NSAttributedString *attrString,CGFloat widthLimit){ CGSize size = CGSizeZero; if (attrString.length > 0){ CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString); size = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0, 0), NULL, CGSizeMake(widthLimit, CGFLOAT_MAX), NULL); CFRelease(framesetter);/// 释放资源 } return size; } 3、布局 CTFrameRef typedef const struct CF_BRIDGED_TYPE(id) __CTFrame * CTFrameRef; CTFrameRef由多个 CTLineRef 组成，有几行文字就有几行 CTLineRef； 3.1、布局属性 CTFrame~Attribute /// CTFrameRef 内 CTLineRef 的堆叠方式：水平或垂直堆叠； /// 垂直堆叠时，在绘图时将使线条逆时针旋转90度； /// 不同的堆叠方式，并不影响该 CTFrameRef 内字形的外观； typedef CF_ENUM(uint32_t, CTFrameProgression) { kCTFrameProgressionTopToBottom = 0, //对于水平文本，行是从上到下堆叠的 kCTFrameProgressionRightToLeft = 1, //垂直文本的行从右到左堆叠 kCTFrameProgressionLeftToRight = 2 //垂直文本的行从左到右堆叠 }; /// CTFrameRef 内 CTLineRef 的堆叠方式：默认值为 kCTFrameProgressionTopToBottom CT_EXPORT const CFStringRef kCTFrameProgressionAttributeName; /// 填充规则：当路径与自身相交时，指定填充规则来决定文本被绘制的区域 typedef CF_ENUM(uint32_t, CTFramePathFillRule) { kCTFramePathFillEvenOdd = 0, // 路径被给定到 CGContextEOFillPath kCTFramePathFillWindingNumber = 1 // 路径被给定到 CGContextFillPath }; /** 默认值为 kCTFramePathFillEvenOdd * @discussion 如果在 frameAttributes 字典的使用此属性，则为 CTFrameRef 指定填充规则; * 如果在 kCTFrameClippingPathsAttributeName 指定的数组中包含的字典中使用，则为剪切路径指定填充规则; */ CT_EXPORT const CFStringRef kCTFramePathFillRuleAttributeName; /** 默认值为 0 * @discussion 如果在 frameAttributes 字典的使用此属性，则为 CTFrameRef 指定宽度; * 如果在 kCTFrameClippingPathsAttributeName 指定的数组中包含的字典中使用，则为剪切路径指定宽度; */ CT_EXPORT const CFStringRef kCTFramePathWidthAttributeName; /// 指定 clip frame 的路径数组 CT_EXPORT const CFStringRef kCTFrameClippingPathsAttributeName; /// 指定 clipping path CT_EXPORT const CFStringRef kCTFramePathClippingPathAttributeName; /// 获取用于创建 CTFrameRef 的属性字典，如果没有则返回NULL CFDictionaryRef _Nullable CTFrameGetFrameAttributes(CTFrameRef frame); 3.1.1、 Demo：根据 CTFrame~Attribute 创建 CTFrameRef -(CFDictionaryRef)clippingPathsDictionary{ NSMutableArray *pathsArray = [[NSMutableArray alloc] init]; CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -self.bounds.size.height); int eFrameWidth=0; CFNumberRef frameWidth = CFNumberCreate(NULL, kCFNumberNSIntegerType, &eFrameWidth); int eFillRule = kCTFramePathFillEvenOdd; CFNumberRef fillRule = CFNumberCreate(NULL, kCFNumberNSIntegerType, &eFillRule); int eProgression = kCTFrameProgressionTopToBottom; CFNumberRef progression = CFNumberCreate(NULL, kCFNumberNSIntegerType, &eProgression); CFStringRef keys[] = { kCTFrameClippingPathsAttributeName, kCTFramePathFillRuleAttributeName, kCTFrameProgressionAttributeName, kCTFramePathWidthAttributeName}; CFTypeRef values[] = { (__bridge CFTypeRef)(pathsArray), fillRule, progression, frameWidth}; CFDictionaryRef clippingPathsDictionary = CFDictionaryCreate(NULL, (const void **)&keys, (const void **)&values, sizeof(keys) / sizeof(keys[0]), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks); return clippingPathsDictionary; } - (void)drawRect:(CGRect)rect{ CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -rect.size.height); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextConcatCTM(context, transform); CFAttributedStringRef attributedString = (__bridge CFAttributedStringRef)self.attributedString; CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString(attributedString); CFDictionaryRef attributesDictionary = [self clippingPathsDictionary]; CGPathRef path = CGPathCreateWithRect(rect, &transform); CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, self.attributedString.length), path, attributesDictionary); CFRelease(path); CFRelease(attributesDictionary); CTFrameDraw(frame, context); CFRelease(frameSetter); CFRelease(frame); } 3.2、获取字符范围 下述两个函数都可以获取 CTFrameRef 的字符范围，返回的 range.location 相同，区别在于 range.length ： CTFrameGetVisibleStringRange() 函数返回的 range.length 是该CTFrameRef内的字符长度； CTFrameGetStringRange() 函数返回的 range.length = 创建 CTFramesetterRef 使用的富文本的长度 - range.location； /** 获取 CTFrameRef 的字符范围 * 与 CTFrameGetVisibleStringRange() 返回的 range.location 相同，区别在于 range.length * 该函数返回的 range.length = 创建 CTFramesetterRef 使用的富文本的长度 - range.location */ CFRange CTFrameGetStringRange(CTFrameRef frame); /// 获取实际填充 CTFrameRef 的字符范围 CFRange CTFrameGetVisibleStringRange(CTFrameRef frame); 3.2.1、Demo：文本分页 根据绘制区域 rect 与该区域的 CTFrameRef，我们可以将很长的富文本分页展示： /** 根据页面 rect 将文本分页 * @param attrString 内容 * @param rect 显示范围 * @return 返回每页需要展示的 Range */ NSMutableArray *getPageRanges(NSAttributedString *attrString, CGRect rect){ NSMutableArray *rangeArray = [NSMutableArray array]; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attrString); CGPathRef path = CGPathCreateWithRect(rect, nil); CFRange range = CFRangeMake(0, 0); NSInteger rangeOffset = 0; do { CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(rangeOffset, 0), path, nil); range = CTFrameGetVisibleStringRange(frame); [rangeArray addObject:[NSValue valueWithRange:NSMakeRange(rangeOffset, range.length)]]; CFRelease(frame); rangeOffset += range.length; } while (range.location + range.length 文本分页模型 @interface YLPageModel : NSObject /// 当前页富文本 @property (nonatomic, strong) NSAttributedString *content; /// 当前页码 @property (nonatomic, assign) NSInteger page; /// 当前页文字范围 @property (nonatomic, assign) NSRange range; /// 当前页 CTFrame @property (nonatomic ,assign) CTFrameRef frameRef; /// 当前页高度 @property (nonatomic, assign) CGFloat contentHeight; @end 根据每页所能展示的字符范围 range，创建分页模型 /** 将内容分为多页 * @param attrString 展示的内容 * @prama rect 显示范围 */ NSMutableArray * getPageModels(NSMutableAttributedString *attrString, CGRect rect){ NSMutableArray *pageModels = [NSMutableArray array]; [getPageRanges(attrString, rect) enumerateObjectsUsingBlock:^(NSValue * _Nonnull value, NSUInteger idx, BOOL * _Nonnull stop) { YLPageModel *pageModel = [[YLPageModel alloc]init]; pageModel.range = value.rangeValue; pageModel.content = [attrString attributedSubstringFromRange:pageModel.range]; pageModel.page = idx; float height; pageModel.frameRef = getCTFrameFitAttrString(pageModel.content, rect.size, &height); pageModel.contentHeight = height; [YLCoreText setImageFrametWithCTFrame:pageModel.frameRef]; [pageModels addObject:pageModel]; }]; return pageModels; } 3.3、获取路径 CGPathRef ///获取用于创建 CTFrameRef 的路径 CGPathRef CTFrameGetPath(CTFrameRef frame); 3.4、获取布局CTFrameRef 中的行CTLineRef /// 获取组成 CTFrameRef 的所有行（CTLineRef 对象），可能返回空数组 CFArrayRef CTFrameGetLines(CTFrameRef frame); /** 拷贝 CTFrameRef 中指定范围的所有行的原点 origin * @param range 希望拷贝的范围。如果 range.length 设置为0，则将从 range.location 拷贝至最后一行 * @param origins 缓冲区，用于存储待复制的数据；缓冲区的长度至少要大于待拷贝的数据份数； * @note 当使用 origin 来计算 CTFrameRef 内容的字形度量时，请注意线的原点并不总是对应于线度量;例如，段落样式设置可以影响线条的 origin ； * @discussion 数组 origins 的最大存储量是行数组的计数； */ void CTFrameGetLineOrigins(CTFrameRef frame,CFRange range,CGPoint origins[_Nonnull]); 3.4.1、Demo：计算CTFrame的内容高度 通过遍历CTFrame上所有的 CTLine，可以计算出图文的纯高度，此时需要注意 coreText 的坐标系与 UIKit 的坐标系不统一问题： /** 获取 CTFrameRef 的内容高度 * @note CTFrameRef 的坐标系是以左下角为原点 */ CGFloat getHeightWithCTFrame(CTFrameRef frameRef){ CFArrayRef lines = CTFrameGetLines(frameRef); int lineCount = (int)CFArrayGetCount(lines); CGPoint origins[lineCount];//以左下角为原点的坐标系 for (int i = 0; i 3.5、绘制布局CTFrameRef /** 将 CTFrameRef 绘制到上下文 CGContext 中； * @note 该调用可能会使上下文处于任何状态，并且在绘制操作之后不会刷新它。 */ void CTFrameDraw(CTFrameRef frame,CGContextRef context); Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreText/CTLineRef的函数库及使用.html":{"url":"iOS开发/CoreText/CTLineRef的函数库及使用.html","title":"CTLineRef的函数库及使用","keywords":"","body":"CTLineRef 的函数库及使用 1、 CTLineRef 函数库 CTLineRef 可以看做渲染到屏幕上的一行字形，可以使用它处理 CoreText 的点击事件，还可以进行排版将文字对齐，一行文字显示不完时、截断文字使用省略号替代；当然，也能够获取该行的字形度量：上行高度、下行高度、行间距、行宽等！ typedef const struct CF_BRIDGED_TYPE(id) __CTLine * CTLineRef; 1.1、 CTLineRef 的创建 /** 根据一段富文本创建 CTLineRef 对象 * @discussion 该方法简单地创建一个行，无需通过排版类 CTTypesetterRef； */ CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString); /// 获取创建 CTLine 的字形的 rang ；失败则返回 empty range CFRange CTLineGetStringRange(CTLineRef line); 1.2、文字截断 当文字太长、一行明显不能显示完全时，通常使用省略号 ... 将文字截断，只显示一部分： //文字截断类型 typedef CF_ENUM(uint32_t, CTLineTruncationType) { kCTLineTruncationStart = 0, // 在开头截断 kCTLineTruncationEnd = 1, // 在结尾截断 kCTLineTruncationMiddle = 2 // 在中间截断 }; /** 将现有 CTLineRef 截断并返回一个新的对象 * @param width 截断宽度：如果行宽大于截断宽度，则该行将被截断 * @param truncationType 截断类型 * @param truncationToken 截断用的填充符号，通常是省略号 ... ，为Null时则只截断，不做填充 * 该填充符号的宽度必须小于截断宽度，否则该函数返回 NULL； */ CTLineRef _Nullable CTLineCreateTruncatedLine(CTLineRef line,double width, CTLineTruncationType truncationType,CTLineRef _Nullable truncationToken); 1.3、多行文字 CTLineRef 的对齐方式 /** 两端对齐：填充空白符，文字之间等间距 * @param line 需要对齐的行 * @param justificationFactor 调整系数，取值范围 [0,1] ； =1 时执行完全调整； * 假如文字长度是100，限定宽度是300，则填充的空白区域为 200*justificationFactor * @param justificationWidth 目标宽度，如果 line 的宽度超过了 justificationWidth ，那么文本将被压缩 * 或者返回NULL？ */ CTLineRef _Nullable CTLineCreateJustifiedLine(CTLineRef line,CGFloat justificationFactor,double justificationWidth); /** 对齐文本：通过偏移对齐 * @param flushFactor (0.0,1.0) 0表示靠左，1表示靠右，0.5表示居中; * @param flushWidth 对齐的宽度 */ double CTLineGetPenOffsetForFlush(CTLineRef line,CGFloat flushFactor,double flushWidth); 多行文字的对齐方式，常见有下面三种： 另外一种同样常见的排版方式是两端对齐（JustifiedLine） 1.4、获取 GlyphRuns 处理点击事件时，需要先找到点击的哪一行 CTLineRef，然后使用下述函数找到具体的 CTRunRef！ /// 获取字形数量 CFIndex CTLineGetGlyphCount(CTLineRef line); /// 获取所有的 glyphRuns CFArrayRef CTLineGetGlyphRuns(CTLineRef line); 1.5、 获取 CTLineRef的 size、bounds等信息 /** 枚举值 CTLineBoundsOptions ：传递0(没有选项)返回排版边界，包括排版前导和移位 * 允许其成员值按位组合。 */ typedef CF_OPTIONS(CFOptionFlags, CTLineBoundsOptions) { kCTLineBoundsExcludeTypographicLeading = 1 1.6、处理点击事件 行插入符号定位和高亮显示 /** 处理点击事件的字符串索引：传入行信息和位置信息，计算出该位置对应的字符索引 * @param position 点击相对于 line's origin 的位置 * @result 如果失败，返回kCFNotFound * @discussion 相对于该行的字符串范围，返回值将不小于第一个字符串索引，且不大于最后一个字符串索引 + 1 */ CFIndex CTLineGetStringIndexForPosition(CTLineRef line,CGPoint position); /** 计算当前行中，指定索引的字符的相对x坐标 * @param charIndex 待计算字符的字符串索引 * @param secondaryOffset 可以为 NULL，是 charIndex沿着基线的辅助偏移量 */ CGFloat CTLineGetOffsetForStringIndex(CTLineRef line, CFIndex charIndex,CGFloat * _Nullable secondaryOffset); /** 遍历一行中字符的脱字符偏移量 * @param block 偏移量 offset 是相对于 CTLineRef 原点；参数 leadingEdge 指的是逻辑顺序 */ void CTLineEnumerateCaretOffsets(CTLineRef line, void (^block)(double offset, CFIndex charIndex, bool leadingEdge, bool* stop)); 1.7、 绘制 CTLineRef /** CTLine 可以直接绘制 * @param line 待绘制的行 * @param context 上下文 * @discussion CGContextSetTextPosition() 设置的位置对CTFrameDraw()没有作用，但是和CTLineDraw() 配合使用则效果非常好 */ void CTLineDraw(CTLineRef line,CGContextRef context); 2、 CTLineRef 的使用 2.1、处理点击事件 当使用 CTFrame 绘制文字时，点击屏幕，需要获取触摸点所在的富文本信息，用于处理点击事件。 2.1.1、触摸行CTLine： 首先，需要计算出触摸了哪一行 CTLine： CTLineRef getTouchLine(CGPoint point,CTFrameRef frameRef){ CTLineRef line = nil; if (frameRef == nil) { return line; } CGPathRef path = CTFrameGetPath(frameRef); CGRect bounds = CGPathGetBoundingBox(path);/// 页面边界 CGFloat pageWidth = CGRectGetWidth(bounds);/// 页面宽度 CGFloat pageHeight = CGRectGetHeight(bounds);/// 页面高度 CFArrayRef lines = CTFrameGetLines(frameRef); int lineCount = (int)CFArrayGetCount(lines); if (lineCount 2.1.2、触摸字形 CTRunRef： 计算出 CTLine，然后在该行计算出触摸点的文本属性： /** 获取触摸点的 CTRunRef * @param point 触摸点 */ CTRunRef getTouchRun(CGPoint point,CTFrameRef frameRef){ CTRunRef getRun = NULL; CTLineRef lineRef = getTouchLine(point, frameRef); CFArrayRef glyphRuns = CTLineGetGlyphRuns(lineRef); int runCount = (int)CFArrayGetCount(glyphRuns); CGFloat startPoint = 0; for (int j = 0; j startPoint && point.x 获取 CTRunRef ，可以查看它的所有属性，是否可点击： /** 获取触摸点的 YLAttachment * @param point 触摸点 * @return 若没有，则返回 nil */ YLAttachment *getTouchAttachment(CGPoint point,CTFrameRef frameRef){ YLAttachment *getAttachment = nil; CTRunRef run = getTouchRun(point, frameRef); if (run) { CFDictionaryRef attributes = CTRunGetAttributes(run); if (attributes) { if (CFDictionaryContainsKey(attributes, kYLAttachmentAttributeName)) { YLAttachment *attachment = CFDictionaryGetValue(attributes, kYLAttachmentAttributeName);;//获取属性 if (attachment) { getAttachment = attachment; NSLog(@\"%@\", attachment); } } } } return getAttachment; } 2.1.3、其它点击信息 还可以根据触摸的所在行 CTLine，计算出触摸的字符串范围、字符串索引： /** 获得触摸位置那一行文字范围 Range * @param point 触摸点 */ NSRange getTouchLineRange(CGPoint point,CTFrameRef frameRef){ NSRange range = NSMakeRange(NSNotFound, 0); CTLineRef line = getTouchLine(point, frameRef); if (line) { CFRange lineRange = CTLineGetStringRange(line); range = NSMakeRange(lineRange.location == kCFNotFound ? NSNotFound : lineRange.location, lineRange.length); } return range; } /** 获得触摸位置文字的Location * @param point 触摸点 */ signed long getTouchLocation(CGPoint point,CTFrameRef frameRef){ signed long location = -1; CTLineRef line = getTouchLine(point,frameRef); if (line != nil) { location = CTLineGetStringIndexForPosition(line, point); } return location; } 2.2、 获取一行文本的 Size /** 获取指定 CTLine 高度与宽度 */ CGSize getSizeWithCTLine(CTLineRef lineRef){ if (lineRef == nil) { return CGSizeZero; } CGRect bounds = CTLineGetBoundsWithOptions(lineRef, kCTLineBoundsExcludeTypographicLeading); return bounds.size; } 还可以通过字形度量，计算出 Size ： CGSize getSizeWithCTLine(CTLineRef lineRef){ if (lineRef == nil) { return CGSizeZero; } CGFloat lineAscent = 0; //上行高度 CGFloat lineDescent = 0; //下行高度 CGFloat lineLeading = 0; //行距 CGFloat width = CTLineGetTypographicBounds(lineRef, &lineAscent, &lineDescent, &lineLeading);/// 获取CTLine的字形度量 CGFloat height = lineAscent + fabs(lineDescent) + lineLeading; return CGSizeMake(width,height); } 2.3、 获取一行文本的Rect /** 获取一行文本的Rect * @param line 所在行 * @param point 所在行的原点 * @note CTLineRef 没有函数可以直接获取该行的原点 * CTLineRef 的原点坐标是相对于整个 CTFrame 而言的，只有在 CTFrame 中，CTLine 才有原点坐标 * 因此 需要使用 CTFrame 函数求取 CTLineRef 的原点 */ + (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point { CGFloat ascent = 0.0f; CGFloat descent = 0.0f; CGFloat leading = 0.0f; CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &ascent, &descent, &leading); CGFloat height = ascent + fabs(descent) + leading; return CGRectMake(point.x, point.y - descent, width, height); } Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreText/CTRunRef与CTRunDelegate.html":{"url":"iOS开发/CoreText/CTRunRef与CTRunDelegate.html","title":"图文混排的关键：CTRunRef 与 CTRunDelegate","keywords":"","body":"图文混排的关键：CTRunRef 与 CTRunDelegate 1、文本属性 (Attributes) 的最小单元：CTRunRef /// 或者叫做 Glyph Run，是一组相同属性（Attributes）的字形的集合体 typedef const struct CF_BRIDGED_TYPE(id) __CTRun * CTRunRef; CTLineRef 是渲染到屏幕上的一行字形的集合，如果再细分，那么CTRunRef就是某一行 CTLineRef 上属性 Attributes 相同的字形的集合体；CTLineRef 是由一个或者多个CTRunRef组成！ 1.1、获取包含的字形 CTRunRef 是排版时属性 Attributes 相同的基础单位，包括一个或多个字形； /// 字形实际上是一个 unsigned short 的类型 typedef unsigned short CGGlyph; /// 获取 CTRunRef 包含的字形个数 CFIndex CTRunGetGlyphCount(CTRunRef run); /// 获取 CTRunRef 包含的字形 : 该数组长度等于 CTRunGetGlyphCount() 返回值 const CGGlyph * _Nullable CTRunGetGlyphsPtr(CTRunRef run); /** 将指定范围的字形复制到用户提供的缓冲区中 * @param range 指定范围；如果 range.location = 0 ，range.length = CTRunGetGlyphCount ,则全部复制 * 如果 range.length = 0 ,则从 range.location 开始复制到结尾； * @param buffer 缓冲区，长度要足够使用 */ void CTRunGetGlyphs(CTRunRef run,CFRange range,CGGlyph buffer[_Nonnull]); 1.1.1、 获取字符对应的坐标位置 CTRunRef 可以获取到每个字符对应的位置：相对于 CTLine 的原点的位置： /// 获取存储在 CTRunRef 中的每个字形的位置 const CGPoint * _Nullable CTRunGetPositionsPtr(CTRunRef run); /// 拷贝存储在 CTRunRef 中的指定范围的字形的位置 void CTRunGetPositions(CTRunRef run,CFRange range,CGPoint buffer[_Nonnull]); 1.1.2、获取字符对应的索引 获取 CTRunRef 每个字形的索引：映射到存储区中的字形 /// 获取在 CTRunRef 中存储的字形索引 const CFIndex * _Nullable CTRunGetStringIndicesPtr(CTRunRef run); /// 获取（拷贝）存储在 CTRunRef 中的指定范围的字形的索引 void CTRunGetStringIndices(CTRunRef run,CFRange range,CFIndex buffer[_Nonnull]); 1.1.3、获取字符对应的 advance 文字默认排版时，宽度由 advance width指定，但是仅靠 advances 并不足以在 CTLine 中正确地定位字形，因为 CTRunRef 可能具有非单位矩阵，或者 CTLine 的 origin 可能是非零原点！ /// 获取存储在 CTRunRef 中的每个字形的 advance const CGSize * _Nullable CTRunGetAdvancesPtr(CTRunRef run); /// 获取（拷贝）存储在 CTRunRef 中的指定范围的字形的 advance void CTRunGetAdvances(CTRunRef run,CFRange range,CGSize buffer[_Nonnull]); /** 获取（拷贝）存储在 CTRunRef 中的指定范围的字形的 advances 和 origins * @discussion CTRunRef 的 base advances 和 origins 决定字形的位置，在用于绘图之前需要进行额外的处理。 * 当前字形的实际位置由其原点从起始位置的偏移量决定，而下一个字形的位置由当前字形base advance 从起始位置的偏移量决定。 */ void CTRunGetBaseAdvancesAndOrigins(CTRunRef runRef,CFRange range, CGSize advancesBuffer[_Nullable],CGPoint originsBuffer[_Nullable]); 1.2、获取CTRunRef 的文字属性 获取的文字属性，可能来自 NSAttributeString，也可能来自于内部排版引擎的生成： /// 获取 CTRunRef 的属性 CFDictionaryRef CTRunGetAttributes(CTRunRef run); 1.3、获取CTRunRef 的文字范围 CTRunRef 可以获取生成时的Range，以便定位到这段文字在整体的位置； ///获取用于创建 CTRunRef 的字符范围 CFRange CTRunGetStringRange(CTRunRef run); 1.4、获取CTRunRef 的排版 size /** 获取 CTRunRef 的指定范围的字符的排版边界 * @param range 指定范围；如果 range.location = 0 ，range.length = CTRunGetGlyphCount ,则是整个 CTRunRef； * 如果 range.length = 0 ,则从 range.location 开始复制到结尾； * @param ascent 上行高度；回调函数，如果不需要，可以将其设置为NULL。 * @param descent 下行高度；基线距字体中最低的字形底部的距离，是一个负值 * @param leading 行距 * @result 排版宽度；如果 CTRunRef 或 CFRange 无效，则返回 0 * @discussion 行高 lineHeight = ascent + |descent| + linegap */ double CTRunGetTypographicBounds(CTRunRef run, CFRange range, CGFloat * _Nullable ascent, CGFloat * _Nullable descent,CGFloat * _Nullable leading); /** 计算 CTRunRef 中指定范围的字形绘制成图像所需要的 bounds ：一个紧密包含字形的边界 * @param context 计算图像 bounds 的上下文，可以传 NULL； * @discussion 计算这行文字绘制成图片所需要的最小 size，没有各种边距，是一种是尽可能小的理想状态的size * @result 如果行无效，将返回 CGRectNull； */ CGRect CTRunGetImageBounds(CTRunRef run,CGContextRef _Nullable context,CFRange range); 1.5、其它函数 /// 由 CTRunGetStatus() 传回的位字段，用于指示 CTRunRef 的处理 typedef CF_OPTIONS(uint32_t, CTRunStatus){ kCTRunStatusNoStatus = 0, /// 没有特殊的属性 attributes kCTRunStatusRightToLeft = (1 2、回调代理 CTRunDelegate CTRunDelegate是 CTRunRef 的代理回调，通过 Delegate 可以手动设置 CTRunRef 的Ascent、Descent、Width等属性，这是图文混排的基础；插入一个空白的字符，将其字符的大小设置为(width, height)，留出对应的大小空白区域，然后在排版结束完通过 CGContextDrawImage() 在对应的位置插入Image 就实现了图文混排的效果； typedef const struct CF_BRIDGED_TYPE(id) __CTRunDelegate * CTRunDelegateRef; 2.1、CTRunDelegate 回调函数 /** 当 CTRunDelegate 的保留计数达到 0 且CTRunDelegate 被释放时的回调函数 * @param refCon 创建 CTRunDelegate 的传入的参数，一般是关于 Ascent、Descent、Width 等度量信息； */ typedef void (*CTRunDelegateDeallocateCallback)(void * refCon); /// 上行高度的回调 typedef CGFloat (*CTRunDelegateGetAscentCallback)(void * refCon); /// 下行高度的回调 typedef CGFloat (*CTRunDelegateGetDescentCallback)(void * refCon); /// 宽度的回调 typedef CGFloat (*CTRunDelegateGetWidthCallback)(void * refCon); ///回调的版本号,作为参数传递给CTRunDelegateCreate() 函数 enum { kCTRunDelegateVersion1 = 1, kCTRunDelegateCurrentVersion = kCTRunDelegateVersion1 }; /** 包含 CTRunDelegate 的回调函数的结构 * @discussion 这些回调函数由开发者提供，用于在布局期间修改字形度量。 */ typedef struct{ CFIndex version; ///建议设置为 kCTRunDelegateCurrentVersion CTRunDelegateDeallocateCallback dealloc; // 设置为 NULL CTRunDelegateGetAscentCallback getAscent; // 设置为 NULL 时，默认为 0 CTRunDelegateGetDescentCallback getDescent; CTRunDelegateGetWidthCallback getWidth; } CTRunDelegateCallbacks; 2.2、创建代理 CTRunDelegate /** 创建一个代理 CTRunDelegate * @param callbacks 该代理的回调 * @refCon 一般是关于 Ascent、Descent、Width 等度量信息 * @discussion 该代理常用来占位：保留一片空白区域绘制图片 */ CTRunDelegateRef _Nullable CTRunDelegateCreate(const CTRunDelegateCallbacks* callbacks,void * _Nullable refCon); /// 获取创建 CTRunDelegate 的传入的 refCon：一般是关于 Ascent、Descent、Width 等度量信息 void * CTRunDelegateGetRefCon(CTRunDelegateRef runDelegate); 3、CTRunRef 函数使用 3.1、 图文混排中图片的处理 CoreText 实际上并没有相应API直接将一个图片转换为 CTRun 并进行绘制，它所能做的只是为图片预留响应的空白区域，而真正的绘制则是交由CoreGraphics完成。 NSAttributedStringKey const kYLAttachmentAttributeName = @\"com.yl.attachment\"; //富文本中的链接（图片、网页） @interface YLAttachment : NSObject //链接 @property (nonatomic ,copy) NSString *url; //网页的标题 @property (nonatomic ,copy) NSString *title; //图片的相关信息 @property (nonatomic ,strong) UIImage *image; @property (nonatomic ,assign) CGRect imageFrame; @end 3.1.1、文字排版时为图片的展示占位 ///上行高度 static CGFloat ascentCallback(void *ref){ YLAttachment *model = (__bridge YLAttachment *)ref; return model.imageFrame.size.height; } ///下行高度 static CGFloat descentCallback(void *ref){ return 0; } ///图片宽度 static CGFloat widthCallback(void *ref){ YLAttachment *model = (__bridge YLAttachment *)ref; return model.imageFrame.size.width; } /** 将图片处理为 CoreText * @param image 图片 * @param drawSize 画布的尺寸，图片的宽高不能超出 drawSize */ + (NSAttributedString *)parseImage:(UIImage *)image drawSize:(CGSize)drawSize{ /**************** 计算图片宽高 **************/ CGSize imageShowSize = image.size;//屏幕上展示的图片尺寸 if (image.size.width > drawSize.width) { imageShowSize = CGSizeMake(drawSize.width, image.size.height / image.size.width * drawSize.width); } YLAttachment *model = [[YLAttachment alloc]init]; model.image = image; model.imageFrame = CGRectMake(0, 0, imageShowSize.width, imageShowSize.height); //注意：此处返回的富文本，最主要的作用是占位！ //为图片的绘制留下空白区域 CTRunDelegateCallbacks callbacks; memset(&callbacks, 0, sizeof(CTRunDelegateCallbacks)); callbacks.version = kCTRunDelegateVersion1;//设置回调版本，默认这个 callbacks.getAscent = ascentCallback;//上行高度 callbacks.getDescent = descentCallback;//下行高度 callbacks.getWidth = widthCallback;//图片宽度 CTRunDelegateRef delegate = CTRunDelegateCreate(&callbacks, (__bridge void *)model); //使用0xFFFC作为空白占位符 unichar objectReplacementChar = 0xFFFC; NSString *content = [NSString stringWithCharacters:&objectReplacementChar length:1]; NSMutableAttributedString *placeholder = [[NSMutableAttributedString alloc] initWithString:content attributes:@{kYLAttachmentAttributeName:model}]; CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeholder, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); CFRelease(delegate); return placeholder; } 3.1.2、 矫正图片的坐标错位问题 绘制图片的时候实际上在一个 CTRunRef 中，以它坐标系为基准，以 origin 点作为原点进行绘制：使用 frameSetter 求出的 image 的坐标是不正确的，需要我们另行计算： /** 矫正 CTFrame 中的图片坐标 * 思路： 遍历 CTFrameRef 中的所有 CTRun，检查 CTRun 否绑定图片， * 如果是，根据 CTRun 所在 CTLine 的 origin 以及在 CTLine 中的横向偏移量计算出 CTRun 的原点， * 加上其尺寸即为该CTRun的尺寸 */ + (void)setImageFrametWithCTFrame:(CTFrameRef)frame{ CFArrayRef lines = CTFrameGetLines(frame); int lineCount = (int)CFArrayGetCount(lines); CGPoint points[lineCount]; CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points); for (int i = 0; i 3.1.3、 获取 CTFrameRef 中的所有图片插件 ///获取 CTFrameRef 中的所有图片插件 + (NSMutableArray *)getImagesWithCTFrame:(CTFrameRef)frame{ NSMutableArray *resultArray = [NSMutableArray array]; CFArrayRef lines = CTFrameGetLines(frame); int lineCount = (int)CFArrayGetCount(lines); CGPoint points[lineCount]; CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points); for (int i = 0; i 3.1.4、 绘制图片 - (void)drawRect:(CGRect)rect{ //1.获取当前绘图上下文 CGContextRef context = UIGraphicsGetCurrentContext(); //2.旋转坐坐标系(默认和UIKit坐标是相反的) CGContextSetTextMatrix(context, CGAffineTransformIdentity);//设置当前文本矩阵 CGContextTranslateCTM(context, 0, CGRectGetHeight(rect));//文本沿y轴移动 CGContextScaleCTM(context, 1.0, -1.0);//文本翻转成为CoreText坐标系 //3.绘制文字 CTFrameDraw(_frameRef, context); //4.绘制图片 [[YLCoreText getImagesWithCTFrame:_frameRef] enumerateObjectsUsingBlock:^(YLAttachment * _Nonnull attachment, NSUInteger idx, BOOL * _Nonnull stop) { CGContextDrawImage(context, attachment.imageFrame, attachment.image.CGImage); }]; } 阅读器点击链接 阅读器仿真翻页 阅读器覆盖翻页 阅读器其它翻页 Demo：小说阅读器的文字分页、图文混排 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreImage/图像特征CIFeature.html":{"url":"iOS开发/CoreImage/图像特征CIFeature.html","title":"图像特征CIFeature","keywords":"","body":"图像特征CIFeature CIFeature 继承自NSObject，表示在图像中检测到的显着特征的对象的抽象超类；它的子类包含该特征的附加信息。 只读属性 数据类型 描述 type NSString 发现的特征类型。 bounds CGRect 已发现特征位于图像中的坐标。 1、条码信息CIQRCodeFeature CIQRCodeFeature 有关在静止图像或视频图像中检测到的二维码或条形码信息。 QR码是使用ISO / IEC 18004：2006标准的二维条形码。该对象的属性标识图像透视图中条形码的角，并提供已解码的消息。 要检测图像或视频中的QR代码，在初始化CIDetector对象时选择CIDetectorTypeQRCode类型。 只读属性 数据类型 描述 bounds CGRect 图像中特征的坐标位置和范围。该属性标识包含检测到的条形码的图像的矩形区域，不一定是条形码的形状。检测到的条形码在空间中是矩形的，但可能在图像中以透视方式出现；使用在识别检测到的条码的角时列出的属性来查找在透视图中显示的条码的角。 messageString NSString 从检测到的条形码解码的字符串 symbolDescriptor CIQRCodeDescriptor 包含有效载荷，符号版本，掩码模式和纠错级别，因此可以复制QR码 topLeft CGPoint 位于图像坐标中，检测到的条形码的左上角 topRight CGPoint 位于图像坐标中，检测到的条形码的右上角 bottomLeft CGPoint 位于图像坐标中，检测到的条形码的左下角 bottomRight CGPoint 位于图像坐标中，检测到的条形码的右下角 2、人脸信息 CIFaceFeature CIFaceFeature 有关在静止图像或视频图像中检测到的人脸信息；该对象提供面部、眼睛、嘴巴的信息。 视频中的面部对象还可以具有跟踪其在时间跟踪ID和帧计数上的位置的属性。 2.1、找到面孔 只读属性 数据类型 描述 bounds CGRect 图像中面部的坐标位置和范围。 hasFaceAngle BOOL 有关面部旋转的信息是否可用。 faceAngle float 脸部的旋转；以度为单位逆时针测量旋转；零表示眼睛之间绘制的线相对于图像方向是水平的。 2.2、识别面部特征 只读属性 数据类型 描述 hasLeftEyePosition BOOL 是否找到了面部的左眼 hasRightEyePosition BOOL 是否找到了面部的右眼 hasMouthPosition BOOL 是否找到了面部的嘴 leftEyePosition CGPoint 图像中左眼坐标 rightEyePosition CGPoint 图像中右眼坐标 mouthPosition CGPoint 图像中嘴的坐标 hasSmile BOOL 是否在面部中检测到笑脸；使用检测器查找面部时需要设置CIDetectorSmile为YES。 leftEyeClosed BOOL 是否在面部中检测到闭合的左眼；使用检测器查找面部时需要设置CIDetectorEyeBlink为YES。 rightEyeClosed BOOL 是否在面部中检测到闭合的右眼；左、右是相对于原始（非镜像）图像方向，而不是与眼睛所有者相关。 2.3、跟踪视频中的不同面孔 只读属性 数据类型 描述 hasTrackingID BOOL CIFaceFeature是否具有trackingID。 trackingID int CIFaceFeature的标识符；CoreImage为在视频流中检测到的面部提供trackingID，可以使用该标识符来识别在一个视频帧中检测到的CIFaceFeature对象何时与先前视频帧中检测到的相同面部。只要面部在框架中并且不与特定面部相关联，该标识符就会持续存在；换句话说，如果面部移出视频帧并稍后返回到帧中，则分配另一个ID。 hasTrackingFrameCount BOOL CIFaceFeature是否具有trackingFrameCount。 trackingFrameCount int 面部的跟踪框数。 3、文本信息CITextFeature CITextFeature 有关可能包含静止图像或视频图像中检测到的文本的区域的信息。使用此类可以定位图像中的文本区域：例如，在执行自己的光学字符识别或其他处理任务之前，提取并透视校正图像的这些部分。 要检测图像或视频中的矩形，在初始化CIDetector对象时选择CIDetectorTypeText类型，并使用CIDetectorImageOrientation选项指定查找直立文本的所需方向。 只读属性 数据类型 描述 bounds CGRect 图像中文本区域的坐标位置和范围。 subFeatures NSArray 包含特征中检测到的其他特征的数组。文本检测器可以识别可能包含文本的主要区域以及该区域内可能包含单个文本特征的区域；这些功能可能是单个字符，密集字符组或整个单词。只有在检索功能时启用CIDetectorReturnSubFeatures选项，CoreImage才会填充此数组。 topLeft CGPoint 位于图像坐标中，检测到的文本区域的左上角 topRight CGPoint 位于图像坐标中，检测到的文本区域的右上角 bottomLeft CGPoint 位于图像坐标中，检测到的文本区域的左下角 bottomRight CGPoint 位于图像坐标中，检测到的文本区域的右下角 4、矩形区域CIRectangleFeature CIRectangleFeature 关于在静止图像或视频图像中检测到的矩形区域的信息。检测到的矩形特征在图像平面中不一定是矩形的; 在空间中该特征识别可以是矩形但在图像中以透视方式出现的形状：例如，桌子上的纸或书。 例如，可以将矩形特征检测与CIPerspectiveCorrection过滤器一起使用，以检测图像或视频中的矩形对象，并将它们转换为原始方向。 要检测图像或视频中的矩形，在初始化CIDetector对象时选择CIDetectorTypeRectangle类型，并使用CIDetectorAspectRatio和CIDetectorFocalLength选项指定要搜索的矩形要素的近似形状。探测器最多返回一个矩形特征，这是图像中最突出的特征。 只读属性 数据类型 描述 bounds CGRect 图像中矩形区域的坐标位置和范围。 topLeft CGPoint 位于图像坐标中，检测到的文本区域的左上角 topRight CGPoint 位于图像坐标中，检测到的文本区域的右上角 bottomLeft CGPoint 位于图像坐标中，检测到的文本区域的左下角 bottomRight CGPoint 位于图像坐标中，检测到的文本区域的右下角 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/CoreImage/图片检测CIDetector.html":{"url":"iOS开发/CoreImage/图片检测CIDetector.html","title":"图片检测CIDetector","keywords":"","body":"图片检测CIDetector CIDetector 继承自NSObject，是一种图像处理器，用于识别静止图像或视频中的显著特征，如：面部和条形码。检测到的特征由CIFeature对象表示，提供有关每个特征的更多信息。 1、创建检测器对象 + (nullable CIDetector *)detectorOfType:(NSString*)type context:(nullable CIContext *)context options:(nullable NSDictionary *)options 创建并返回已配置的检测器；该类方法有三个参数： 参数type：检测器类型。 参数context：检测器在分析图像时可以使用的核心图像。 参数options：包含有关如何配置检测器的详细信息的字典。 CIDetector类可以维护许多可能影响性能的状态变量；因此，为了获得最佳性能，需要重用该类实例，而不是创建新实例。 此外，在使用检测器对象处理图像时，如果用于初始化检测器的CIContext与用于处理CIImage对象的上下文相同，则应用程序的性能会更好。 1.1、检测器类型 检测器类型 描述 CIDetectorTypeFace 用于搜索静止图像或视频中的面部，返回CIFaceFeature对象。为了在面部检测中获得更好的准确性和性能，需要使用 - featuresInImage:options:方法，并使用CIDetectorImageOrientation键指定图像方向。 CIDetectorTypeRectangle 用于搜索静止图像或视频中的矩形区域，返回CIRectangleFeature对象。矩形检测器找到可能表示在图像中以透视方式出现的矩形对象的区域，例如在桌面上看到的纸张或书籍。 CIDetectorTypeQRCode 用于在静止图像或视频中搜索二维码或条形码，返回CIQRCodeFeature对象。 CIDetectorTypeText 用于搜索静止图像或视频中的文本，返回CITextFeature对象。文本检测器找到可能包含直立文本的区域，但不执行光学字符识别。 1.2、检测器配置 用于配置检测器的字典中使用的键。 键 描述 CIDetectorAccuracy 用于指定检测器所需精度 CIDetectorTracking 用于启用或禁用检测器的面部跟踪；如果要在视频中的帧中跟踪面，请使用此选项。 CIDetectorMinFeatureSize 用于指定探测器将识别为特征的最小大小的键；此键的值是一个取值范围0.0~1.0的NSNumber对象，表示小尺寸图像的一小部分。 CIDetectorNumberOfAngles 用于在视频输入中检测面部的透视数；此键的值是包含数字1,3,5,7,9或11的NSNumber对象。在更高的角度数量下，视频中的面部检测变得更准确，但计算成本更高。 CIDetectorMaxFeatureCount 表示检测器应返回的最大特征数。默认值为1.取值范围[1,256]。 关于键 CIDetectorAccuracy 表示检测器所需精度的值： 值CIDetectorAccuracyLow： 表示检测器应选择精度较低但可以更快速处理的技术。 值CIDetectorAccuracyHigh：表示检测器应选择精度更高的技术，即使它需要更多的处理时间。 2、使用检测器对象查找特征 - (NSArray *)featuresInImage:(CIImage *)image //根据指定的图像方向检测图像中的特征。 - (NSArray *)featuresInImage:(CIImage *)image options:(nullable NSDictionary *)options 一组CIFeature对象：每个对象代表图像中检测到的特征；上述方法的参数： 参数image：要检查的图像。 参数options：指定特征检测选项的字典。 2.1、特征检测键 用于特征检测选项的字典的键： 键 描述 CIDetectorSmile Core Image是否执行检测面部微笑的选项。 CIDetectorEyeBlink Core Image是否执行检测面部闭眼的选项。 CIDetectorAspectRatio 指定要搜索的矩形的宽高比（宽度除以高度），此键的值是NSNumber对象，其值为正浮点数。将此选项与CIDetectorTypeRectangle检测器类型一起使用可微调检测器的精度。 例如，要更准确地在图像中找到 3.5 x 2英寸的名片，可指定 3.5/2 = 1.75 的宽高比。 CIDetectorReturnSubFeatures 是否返回检测到的特征组件的特征信息;此键的值是具有布尔值的NSNumber对象。将此选项与CIDetectorTypeText检测器类型一起使用，以选择是仅检测可能包含文本的区域（NO，默认值）还是识别可能包含单个文本字符的子区域（YES）。 CIDetectorImageOrientation 设置要检测其特征的图像的显示方向，其值指示图像显示时像素坐标原点(0,0)应该出现在何处；其值为1到8之间的整数，默认值为 1 表示原点位于图像的左上角。Core Image仅检测其方向与图像的方向匹配的面部；如果要检测不同方向的面，则应为此键提供值 参阅详细信息kCGImagePropertyOrientation。 CIDetectorFocalLength 一种以像素为单位的识别焦距的选项；其值为浮点数，可以是0.0，-1.0或任何正值。将此选项与CIDetectorTypeRectangle检测器类型一起使用可控制CIDetectorAspectRatio选项对特征检测的影响。 关于识别焦距的键 CIDetectorFocalLength 其值可以是 0.0，-1.0 或任何正值： 默认值 -1.0 禁用返回矩形的宽高比测试。 特殊值 0.0 可以实现不太精确的高宽比测试，这种测试近似于正投影(非透视)投影。如果要通过CIDetectorAspectRatio选项指定矩形的宽高比，使用此值，但无法确定焦距的值，以像素为单位。 任何其他值指定相机焦距，允许宽高比规格考虑输入图像中矩形的透视失真。 如果知道相机的对角线视场(对角线角对场景角度的影响)，可以用下面的公式来计算一个近似的焦距(以像素为单位): //焦距像素 = (图像对角像素/2)/tan(FOV/2) focal_length_pixels = (image_diagonal_pixels/2)/tan(FOV/2) 在这个公式中，image_diagonal_pixels是相机传感器最大分辨率的图像对角线的长度(以像素为单位)。例如，3264 x 2448(800万像素)传感器的值是4080像素，4096x3024(1200万像素)传感器的值是5000像素。 为了测量对角视场，把相机放在一个三脚架上，使它垂直于一个表面，图像的中心朝向表面上的一个标记。测量从标记到图像一角点的距离(Y)，测量相机到表面的距离(Z)，视场为2*arctan(Y/Z)。 必须根据最大传感器分辨率指定此值。如果所提供的CIImage相对于最大传感器分辨率进行了缩放，那么所提供的焦距也必须进行类似的缩放。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal调试.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal调试.html","title":"Metal 实践","keywords":"","body":"调试 Metal 代码 1、使用 Metal Debugger 调试 Metal Xcode 通过帧捕获工具专门为 Metal 提供调试器： 可以通过 Metal Debugger 了解计算机如何运行 Metal 代码； 查找异常的渲染问题； 1.1、项目启用 Metal Debugger 在 Metal 渲染项目中，进入构建设置并更改 Metal 编译器选项 Produce debugging information : 将 Debug 设置为 Yes, include source code，以便调试着色器代码； 将 Release 设置为 No，因为线上版本不应包含调试信息； 1.2、捕捉一帧数据 Metal Debugger 与 Xcode 的 Metal 帧捕获功能结合使用： 首先运行 Metal 代码，进入渲染界面； 然后单击 Xocde 调试工具栏上的 M 图标 1.3、检查绘图命令 Xcode 捕获绘制命令以及程序中进行的所有其他函数调用，并将它们显示在 Debug 导航器中；如下图所示： 在命令编码器中查看渲染命令，该组命令是 Metal 为创建三角形而执行的命令： Xcode 记录了对设置视口、渲染管道、顶点着色器的参数、以及图元绘制命令的调用； 单击 Bound Resources 查看绘制的详细信息：Vertex、Fragment 和 Attachment等！ 1.4、检查顶点数据与顶点着色器 单击 Geometry 查看顶点数据，Xcode 在几何查看器中渲染顶点输出的线框； 在其下方，Xcode 在表格中列出了相同的数据； 单击线框中的一个顶点，Xcode 会在表中选择其对应的行； 单击表中的某一行，Xcode 会选中线框中的对应顶点； 通过以这种方式检查顶点信息，确保在视觉上和数字上，顶点输出看起来是正确的: 检查顶点坐标、顶点色值、顶点纹理等，确保数据正确； 如果渲染的一个或多个顶点在不正确的位置或颜色处渲染，则问题可能是由顶点着色器的错误引起的。要检查这种可能性，选择一个顶点并单击右下角的debug 按钮定位到着色器代码: 当代码打开时，确保它是要执行的顶点着色器，否则可能是使用了错误的渲染管道、或者在渲染管道配置了错误的顶点着色器！ 在每一行代码的右边，调试器显示 GPU 执行到该行时计算和存储的值；单击某一行的最右侧图标，Xcode 显示多个顶点的计算值！ 比较同一帧中顶点着色器处理的所有顶点数据，这样做可能会发现不一致，表明顶点着色器代码或输入数据中存在错误。 1.5、检查片段着色器 单击 Attachments 查看片段着色器如何处理特定片段； 移动鼠标查看具体某个像素； 单击 debug 按钮，Xcode 会定位到片段着色器 如果定位的着色器代码不是要执行的代码，可能是使用了错误的渲染管道、或者在渲染管道配置了错误的片段着色器！ 在每一行代码的右边，调试器显示 GPU 执行到该行时计算和存储的值；单击某一行的最右侧图标，Xcode 显示为此像素返回的颜色的可视化！ 如果片段着色器中有更多行，可以以类似的方式检查这些行，以了解每行如何影响输出像素颜色。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal的简单计算.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal的简单计算.html","title":"内核计算","keywords":"","body":"使用 Metal 并行计算 图形处理器 GPU 旨在快速渲染图形、并行计算数据；Metal 提供了一套与硬件 GPU 直接通信的 API ！ Demo 演示了如何使用 Metal 执行并行计算！ 针对两个数组对应位置的元素相加得到第三个数组： 常规做法是，遍历两个数组，拿到对应位置的元素，然后做加法，并赋值给第三个数组的对应位置； /// C 语言编写的两个数组元素相加 void add_arrays(const float* inA, const float* inB, float* result, int length) { for (int index = 0; index 在 Metal 中，在 GPU 上运行的代码称为 着色器! 而使用 Metal 执行上述计算，可以同时启用多条线程，每条线程处理一个索引处的元素加法，而非遍历数组！ 要在 GPU 上执行计算，需要使用 Metal Shading Language (MSL) 重写上述任务函数； MSL 是 C++ 的一种变体，专为 GPU 编程而设计； 在 Metal 中，在 GPU 上运行的代码称为 着色器，因为历史上它们首先用于计算 3D 图形中的颜色； /** for 循环被替换为一个线程集合，每个线程都调用这个函数 * @param index 每个线程的唯一索引，通过该索引，获取数组对应位置的元素 */ kernel void add_arrays(device const float* inA, device const float* inB, device float* result, uint index [[thread_position_in_grid]]) { result[index] = inA[index] + inB[index]; } MSL 函数使用关键字 kernel 来修饰，声明该函数为 public GPU 函数；在应用程序中是唯一的，不能被其它 MSL 函数调用。 1、寻找 GPU 设备中可能有多个 GPU ，开发者需要指定一个可用的 GPU ！ /// MTLDevice 是对 GPU 的抽象类，可以使用它与 GPU 进行通信。 /// 使用下述函数获取一个默认 GPU id device = MTLCreateSystemDefaultDevice(); 2、做一些准备工作 2.1、获取 Metal 函数的引用 编译程序时，Xcode 会编译 .metal 文件中的函数并将其嵌入到 Metal 的默认库中；开发者首先需要拿到 默认库 实例，再获取 MSL 函数对象。 /// 创建一个默认库对象，加载工程中的所有 .metal 文件 id defaultLibrary = [device newDefaultLibrary]; if (defaultLibrary == nil) { NSLog(@\"Failed to find the default library.\"); return nil; } /// 向资源库请求 MSL 函数的对象 id addFunction = [defaultLibrary newFunctionWithName:@\"add_arrays\"]; if (addFunction == nil) { NSLog(@\"Failed to find the adder function.\"); return nil; } 2.2、获取 Metal 函数的可执行代码 MTLFunction 对象仅仅作为代理，而非可执行代码；需要创建一个计算管道，将 MSL 代理转为可执行代码； 在 Metal 中，计算管道由 MTLComputePipelineState 实例表示； 创建 MTLComputePipelineState 实例时，MTLDevice 对象将为该 GPU 完成函数的编译； /// 同步创建一个 MTLComputePipelineState 对象 { id mAddFunctionPSO = [device newComputePipelineStateWithFunction:addFunction error:&error]; NSAssert(mAddFunctionPSO, @\"Failed to created pipeline state object, error %@.\", error); // 使用Xcode debug 程序时，默认开启 Metal API 验证，这样可以获取详细的出错信息 } 注意：MTLDevice 对函数的编译是一个耗时操作，建议异步创建 Metal 管道！ /// 异步创建一个 MTLComputePipelineState 对象 { [_device newComputePipelineStateWithFunction:addFunction completionHandler:^(id _Nullable computePipelineState, NSError * _Nullable error) { NSAssert(!error, @\"计算管道创建失败 : %@\",error); }]; } 2.3、创建一个命令队列 Metal 通过对命令队列的调度将任务发送到 GPU。 /// 通过 MTLDevice 实例来创建一个命令队列 id mCommandQueue = [device newCommandQueue]; NSAssert(mCommandQueue, @\"Failed to find the command queue.\"); 完成准备工作后，需要提供数据供 GPU 执行。 3、准备数据 3.1、专用GPU内存 与 共享GPU内存 GPU内存由 专用GPU内存 和 共享GPU内存 组成。 专用GPU内存： 就是只能被GPU使用的内存； 对于独显，专用GPU内存就是GPU显卡上自带的内存，特点是带宽大，延迟小； 对于集显，专用GPU内存是指BIOS从系统内存中分配给集显GPU专用的内存，也称为stolen memory。 共享GPU内存： 就是GPU和其他应用共享操作系统内存，其中，GPU的使用优先级最高； 共享GPU内存值的大小由操作系统根据系统内存大小来分配，开发者无法修改； 3.2、Metal 工作 Metal 和操作系统内核需要将数据存储在内存中供 GPU 使用。 MTLResource 抽象了内存管理， 是 GPU 在运行命令时可以访问的内存分配。 使用 MTLDevice 为其 GPU 创建 MTLBuffer 实例，MTLBuffer 是没有预定义格式的内存分配； Metal 将缓冲区作为一个不透明的字节集合进行管理； const unsigned int arrayLength = 1 mBufferA = [device newBufferWithLength:bufferSize options:MTLResourceStorageModeShared]; id mBufferB = [device newBufferWithLength:bufferSize options:MTLResourceStorageModeShared]; /// 不妨使用随机数据填充前两个缓冲区 [self generateRandomFloatData:mBufferA]; [self generateRandomFloatData:mBufferB]; /// 缓存 GPU 的运算结果 id mBufferResult = [device newBufferWithLength:bufferSize options:MTLResourceStorageModeShared]; } /// 使用随机数填充缓冲区，完成测试 - (void)generateRandomFloatData:(id) buffer { float* dataPtr = buffer.contents; for (unsigned long index = 0; index 注意： 着色器中使用的数据格式必须与缓冲区的数据格式保持一致！ 3.2.1、内存储存策略 /// CPU 或 GPU 是否可以访问该存储区的一种存储模式 typedef NS_OPTIONS(NSUInteger, MTLResourceOptions) { MTLResourceCPUCacheModeDefaultCache = MTLCPUCacheModeDefaultCache 4、调度任务 4.1、为队列创建一个命令缓冲区 id commandBuffer = [mCommandQueue commandBuffer]; assert(commandBuffer != nil); 4.2、创建命令编码器 要将命令写入命令​​缓冲区，还需要对命令编码： 创建命令编码器 MTLComputeCommandEncoder，对计算管道中的命令列表编码； 每个命令都会使 GPU 创建线程组以在 GPU 上执行。 id computeEncoder = [commandBuffer computeCommandEncoder]; assert(computeEncoder != nil); 要对命令进行编码，需要对编码器做一些配置： 设置要编码的计算管道 进行这些状态更改后，对命令进行编码以执行管道。 编码器将所有状态变化和命令参数写入命令缓冲区。 - (void)encodeAddCommand:(id)computeEncoder { /// 设置要编码的计算管道 [computeEncoder setComputePipelineState:_mAddFunctionPSO]; /// 偏移量 offset=0 表示命令将从缓冲区的开头访问数据 /// 还可以共同使用一个缓冲区来存储多个参数，为每个参数指定一个偏移量 [computeEncoder setBuffer:_mBufferA offset:0 atIndex:0]; [computeEncoder setBuffer:_mBufferB offset:0 atIndex:1]; [computeEncoder setBuffer:_mBufferResult offset:0 atIndex:2]; /// 数组的长度决定网格的大小 MTLSize gridSize = MTLSizeMake(arrayLength, 1, 1); NSUInteger threadGroupSize = _mAddFunctionPSO.maxTotalThreadsPerThreadgroup; if (threadGroupSize > arrayLength) { threadGroupSize = arrayLength; } MTLSize threadgroupSize = MTLSizeMake(threadGroupSize, 1, 1); [computeEncoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize]; } ### 4.2.1、指定一维网格的大小 Metal 可以创建 1D、2D 或 3D 网格，此处只需创建一维网格即可! /// 数组的长度决定网格的大小，创建大小为 1 x 1 的一维网格，Metal 从中生成 0 到 -1 之间的索引 MTLSize gridSize = MTLSizeMake(arrayLength, 1, 1); ### 4.2.2、指定线程组大小 需要决定为命令创建多大的线程组： * Metal 将网格细分为更小的网格，称为 __线程组__；每个线程组是单独计算的； * Metal 可以将线程组分派到 GPU 上的不同处理单元以加快处理速度； /// 计算管道给出线程组中允许的最大线程数：该数值取决于创建计算管道时传入的函数的复杂性； NSUInteger threadGroupSize = _mAddFunctionPSO.maxTotalThreadsPerThreadgroup; /// 如果该大小大于数据集的大小，则将其缩小 if (threadGroupSize > arrayLength) threadGroupSize = arrayLength; MTLSize threadgroupSize = MTLSizeMake(threadGroupSize, 1, 1); ### 4.2.3、对命令进行编码以执行线程 最后，对命令进行编码以调度线程组。 当 GPU 执行此命令时，会使用之前设置的状态和命令参数来调度线程执行计算。 [computeEncoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize]; 可以使用编码器按照上述步骤将多个命令编码到计算通道中； 例如，设置管道状态对象一次，然后为待处理的每个缓冲区集合设置参数并编码命令。 ## 4.3、停止编码 当没有更多命令添加到计算管道时，需要结束编码过程以关闭计算管道。 [computeEncoder endEncoding]; ## 4.4、命令缓冲区的命令提交 通过将命令缓冲区提交到队列来运行命令缓冲区中的命令。 [commandBuffer commit]; * 命令队列 `MTLCommandQueue` 创建了命令缓冲区，因此提交缓冲区总是将它放在该队列中； * 提交命令缓冲区后，Metal 异步准备要执行的命令，然后调度命令缓冲区在 GPU 上执行； * GPU 执行完命令缓冲区中的所有命令后，Metal 将命令缓冲区标记为完成； ## 4.5、计算完成的处理 GPU 异步处理提交的命令。这个示例不需要做任何额外的工作，所以它只是等待直到命令缓冲区完成。 [commandBuffer waitUntilCompleted]; 也可以在 Metal 处理完所有命令时收到通知： [commandBuffer addCompletedHandler:^(id _Nonnull) { /// 完成时做一些逻辑 }]; 还可以通过读取命令缓冲区的属性来检查命令缓冲区的状态： typedef NS_ENUM(NSUInteger, MTLCommandBufferStatus) { MTLCommandBufferStatusNotEnqueued = 0, MTLCommandBufferStatusEnqueued = 1, MTLCommandBufferStatusCommitted = 2, MTLCommandBufferStatusScheduled = 3, MTLCommandBufferStatusCompleted = 4, MTLCommandBufferStatusError = 5, } API_AVAILABLE(macos(10.11), ios(8.0)); commandBuffer.status; ## 4.6、从缓冲区读取结果 * 命令缓冲区调度完成后，GPU 将计算结果输出到缓冲区中； * 在程序中，需要从缓冲区读取结果并对其进行处理，例如在屏幕上显示结果或将它们写入文件。 该示例读取输出缓冲区的值，仅验证 CPU 和 GPU 计算结果是否相同： float a = _mBufferA.contents; float b = _mBufferB.contents; float* result = _mBufferResult.contents; for (unsigned long index = 0; index Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:18 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal绘制三角形.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal绘制三角形.html","title":"绘制三角形","keywords":"","body":"二维图形的绘制 Demo 通过对三角形的绘制，演示了如何绘制二维图形、如何插入色值等！ 1、Metal 的渲染管道 绘制图形需要对数据映射、变换等处理，将这一系列的步骤抽象成 渲染管道 ！ 渲染管道有许多阶段： 应用层的数据传递到顶点着色器 Vertex Shader ； 顶点着色器 Vertex Shader 采用控制反转，将数据的处理交给开发者； 在该阶段需要处理每个顶点的坐标：物体坐标 => 世界坐标 => 观察坐标 => 裁剪空间坐标； 将最终换算好的坐标注入渲染管道； 开发者通过对坐标的转换处理，可以绘制出各种炫彩的图案！ 接着进入图元组装 Primitives Assembly，将位置、索引等信息组成三角形； 两点成线、三点定面；三角形是最基本的图元； 光栅化 Rasterization 将三角形映射到 Fragment；光栅化可以对图元做 Cull、 Clip等操作； 超出视口、超出剪裁空间的顶点数据不被用户所感知，可以裁剪掉； 经过光栅化之后，三角形就变成了 Fragment；此时通过程序反转，让开发者调用 Fragment Shader，为每一个 Fragment 上色； 可以简单的为每个顶点设置一个颜色； 也可以贴上纹理； 开发者为每个 Fragment 上色之后，交由 Fragment Operation 着色； Fragment Operation 根据深度做出取舍，被遮挡的部分不会显示；或者颜色混合； 最后形成一个 Frame Buffer，写到内存中； GPU 从内存中读取 Frame Buffer 显示一帧图像； 在 Metal 中，在 GPU 上运行的代码称为 着色器 ！ Metal 的渲染管道主要侧重于三个阶段： 顶点着色器 Vertex Shader：转换坐标； 光栅化阶段 Rasterization：将三角形映射到 Fragment，并进行 Cull、 Clip 等操作； 片段着色器 Fragment Shader：为图元颜色； Metal Shading Language 是 C++ 的一种变体，专为 GPU 编程而设计，要在 GPU 上执行计算，需要使用 MSL 函数；开发者可以为顶点着色器与片段着色器编写 MSL 函数！ 渲染从绘制命令开始，其中包括顶点计数和要渲染的图元类型。 /// 绘制三角形 [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3]; 顶点着色器用于处理顶点数据；之后渲染管道会光栅化图元，确定渲染目标中的哪些像素位于图元的边界内。 片段着色器确定要写入这些像素的渲染目标的值。 /// 待渲染的图元类型，按传入顶点的先后顺序 typedef NS_ENUM(NSUInteger, MTLPrimitiveType) { /// 绘制顶点 MTLPrimitiveTypePoint = 0, /// 每两个点栅格化一条线，产生一系列未连接的线；如果顶点数量为奇数，则忽略最后一个顶点 MTLPrimitiveTypeLine = 1, /// 相邻顶点之间栅格化一条线，产生一系列连接的线；也称为折线 MTLPrimitiveTypeLineStrip = 2, /// 每三个顶点栅格化一个三角形；如果顶点数不是三的倍数，则忽略一个或两个顶点 MTLPrimitiveTypeTriangle = 3, /// 每三个相邻顶点，栅格化一个三角形； MTLPrimitiveTypeTriangleStrip = 4, }; 该示例将演示如何编写顶点和片段函数、如何创建渲染管道、如何使用绘制命令进行编码。 1.1、定义顶点数据 顶点着色器处理顶点数据，片段着色器为单个片段生成数据，开发者可以在顶点着色器或者片段着色器决定管道生成什么以及它如何生成这些结果。 决定将哪些数据传递到渲染管道以及将哪些数据传递到管道的后期阶段。通常可以在三个地方执行此操作： 管道的输入，由应用程序提供并传递到顶点着色器； 顶点着色器的输出，传递到光栅化阶段； 片段着色器的输入，由应用程序提供或由光栅化阶段生成； 在本例中，管道的输入数据包含三角形顶点位置以及颜色（注意：坐标需要适配 Metal 坐标系）。 #include /// 定义输入数据的类型为 SIMD 类型 typedef struct { vector_float2 position; /// 顶点位置 vector_float4 color; /// 颜色 } AAPLVertex; SIMD 类型在 Metal Shading Language 中很常见，该类型包含特定数据类型的多个通道： 位置有 x 和 y 坐标，有两个 32 位浮点值，声明类型为 vector_float2 ； 颜色有四个通道：red、green、blue、alpha，使用 vector_float4 存储； /// 使用常量数组指定输入的三角形数据 static const AAPLVertex triangleVertices[] = { // 2D (x,y) RGBA { { 250, -250 }, { 1, 0, 0, 1 } }, { { -250, -250 }, { 0, 1, 0, 1 } }, { { 0, 250 }, { 0, 0, 1, 1 } }, }; 顶点着色器需要生成顶点数据，因此需要提供颜色和变换位置；使用 SIMD 类型声明一个包含位置和颜色值的结构 ``` .metal 文件 /// 自定义“顶点着色器输出，片段着色器输入”的数据格式 struct RasterizerData { /// 经过顶点着色器处理之后的顶点位置 /// Metal 没有对字段命名有特殊约定，因此开发者需要告诉 Metal 光栅化数据中的哪个字段提供位置信息 /// 属性限定符 [[position]] 声明 position 字段保存输出位置 /// 位置信息必须定义为 vector_float4 float4 position [[position]]; float4 color; /// 光栅化阶段处理之后，将该值传递到片段着色器 }; 片段着色器只是将光栅化阶段的数据传递给后面阶段，因此它不需要任何额外的参数。 ## 1.2、顶点着色器 ![顶点着色器](assets/Metal_顶点着色器.PNG) * 每次调用顶点着色器产生一个顶点数据； * 如果有很多顶点需要计算，显卡有很多核，可以并行计算； ``` .metal 文件 /** 使用关键字 vertex 声明顶点着色器 * @param vertexID 顶点的唯一标识符，使用关键字 [vertex_id]] 修饰； * 每次调用顶点着色器产生一个顶点数据；执行渲染命令时，GPU 的多个核同时调用顶点着色器，并行计算顶点数据； * @param vertices 传递顶点数据的数组 * @param viewportSizePointer 为了将传入数据转换到Metal的坐标系，需要计算三角形的 viewport 大小(以像素为单位)， * 计算结果被存储在 viewportSizePointer 参数中； * @return 返回结构体 RasterizerData * @note 默认情况下，Metal 自动在参数表中为每个参数分配 slots； * 参数 2 与参数 3 使用属性限定符 [[buffer(n)]]，显示指定 Metal 要使用哪个 slot ； * 显式指定 slot 可以使修改着色器更容易，而不需要改变程序代码； */ vertex RasterizerData vertexShader(uint vertexID [[vertex_id]], constant AAPLVertex *vertices [[buffer(AAPLVertexInputIndexVertices)]], constant vector_uint2 *viewportSizePointer [[buffer(AAPLVertexInputIndexViewportSize)]]) { // 顶点着色器一般处理位置与颜色信息 RasterizerData out; // 根据索引 vertexID 获取当前顶点位置，单位为像素 (即值为100表示距离原点100个像素) float2 pixelSpacePosition = vertices[vertexID].position.xy; // 获取视口大小并转换为 vector_float2 vector_float2 viewportSize = vector_float2(*viewportSizePointer); /// 若要将像素空间中的位置转换为剪辑空间中的位置，需要像素坐标除以视口大小的一半 out.position = vector_float4(0.0, 0.0, 0.0, 1.0); out.position.xy = pixelSpacePosition / (viewportSize / 2.0); // 将输入的颜色直接传递给光栅格器 out.color = vertices[vertexID].color; return out; } 1.2.1、坐标转换 Metal 使用左手坐标系作为标准坐标系，并映射到视口的位置； 图元被剪切到视口坐标系中的裁剪空间{(-1.0，-1.0),(1.0,1.0)}中并光栅化； 正 z 值进入屏幕，z坐标的可见部分介于0.0(近剪切平面)和1.0(远剪切平面)之间； vector_float4(x, y, z, w); 将坐标从世界坐标系转换到观察坐标系： 因为这是一个 二维三角形，不需要齐次坐标系，所以输出默认坐标 vector_float4(0.0, 0.0, 0.0, 1.0)； 将二维坐标系的 {x, y} 转换为视口坐标系中剪辑空间中的位置，需要坐标 {x, y} 除以视口坐标系的 {vx,vy} 并乘以剪辑空间size； 使用 SIMD 类型执行计算，可以使用一行代码同时划分两个通道来执行除法，并将结果存储到 x 和 y 道中。 1.3、片段着色器 光栅化阶段会对图元进行Cull、Clip等操作，确定哪些像素被图元覆盖，像素中心在三角形内的片段才会被渲染。 Cull： 选择去掉一些图元； Clip：裁剪去掉图元的某些部分； 片段着色器处理光栅化后的信息，为每个片段上色！ 光栅化阶段为每个片段的参数计算值，并调用片段着色器上色。 光栅化阶段将其颜色参数计算为三角形顶点的混合颜色。 片段离顶点越近，顶点对最终颜色的贡献就越大。 ``` .metal 文件 /** 使用关键字 fragment 声明片段着色器 @param RasterizerData 使用属性限定符 [[stage_in]] 指示数据是由光栅化器生成的 @return 返回处理后的渲染目标 如果有多个渲染目标，需要声明一个结构体，包含所有渲染目标 */ fragment float4 fragmentShader(RasterizerData in [[stage_in]]) { return in.color; // 返回插入的颜色 } ``` 注意：Metal 并非按要求渲染片段着色器处理后的图元；每个 Fragment 有一个深度值，存储于深度缓冲区！在着色阶段，会对所有图元进行深度探测，深度更小、离用户更近的图元可能覆盖深度更大的图元！ 2、创建渲染管道 在 .metal 文件中自定义顶点着色器与片段着色器之后，需要创建渲染管道来使用自定义着色器！ 首先，获取默认库并为每个着色器获取 MTLFunction 对象： // 加载默认库，获取自定义的顶点着色器、片段着色器 id defaultLibrary = [_device newDefaultLibrary]; id vertexFunction = [defaultLibrary newFunctionWithName:@\"vertexShader\"]; id fragmentFunction = [defaultLibrary newFunctionWithName:@\"fragmentShader\"]; 接下来，创建渲染管道 MTLRenderPipelineState ，使用 MTLRenderPipelineDescriptor 来配置渲染管道的多个阶段。 // 渲染管道配置项 MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init]; pipelineStateDescriptor.label = @\"Simple Pipeline\"; pipelineStateDescriptor.vertexFunction = vertexFunction; pipelineStateDescriptor.fragmentFunction = fragmentFunction; pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat; // 根据配置项创建一个渲染管道 _pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&error]; 除了自定义顶点着色器和片段着色器，还可以声明渲染管道中所有待渲染目标的像素格式。 像素格式 MTLPixelFormat 定义了像素数据的内存布局，对于简单的格式，该定义包括每个像素的字节数、存储在像素中的数据通道数以及这些通道的位布局。 还需要注意渲染通道的像素格式兼容性；在本例只有一个渲染目标，并且它是由视图提供的，所以将视图的像素格式复制到渲染管道。 当Metal创建渲染管道时，管道被配置为将片段着色器输出的像素格式。 如果希望以不同的像素格式为渲染目标，则需要创建不同的渲染管道状；可以在针对不同像素格式的多个管道重用相同的着色器。 3、设置 Viewport 设置视口，让 Metal 知道想要绘制渲染目标的哪一部分。 typedef struct { double originX, originY, width, height, znear, zfar; } MTLViewport; // 设置绘制对象的区域 [renderEncoder setViewport:(MTLViewport){0.0, 0.0, _viewportSize.x, _viewportSize.y, 0.0, 1.0 }]; 表示物体的坐标系叫做世界坐标系 眼睛所在的位置会形成相对于眼睛的坐标系，叫做观察坐标系（三维坐标系，Z轴方向就是眼睛的方向）； 显示到屏幕上的内容叫做视口坐标系（二维坐标系） 那么一个顶点至少要经过两次变换 Metal 的渲染过程主要侧重于三个阶段： 顶点着色器 Vertex Shader：绘制顶点坐标； 光栅化阶段 Rasterization：将三角形映射到 Fragment，并进行 Cull、 Clip 等操作； 片段着色器 Fragment Shader：为 Fragment 设置颜色； 4、设置渲染管道状态 设置需要绘制的渲染管道。 [renderEncoder setRenderPipelineState:_pipelineState]; 5、将参数数据发送到顶点着色器 一般使用缓冲区 MTLBuffer 将数据传递给着色器。然而，当向顶点着色器传递少量数据时，可以直接将数据复制到缓冲区中。 /// 本例的数据量小，直接复制 [renderEncoder setVertexBytes:triangleVertices /// 顶点数据是从数组中复制 length:sizeof(triangleVertices) atIndex:AAPLVertexInputIndexVertices]; [renderEncoder setVertexBytes:&_viewportSize /// viewport 数据是从设置 viewport 的相同变量中复制 length:sizeof(_viewportSize) atIndex:AAPLVertexInputIndexViewportSize]; 在该示例中，片段着色器只使用它从光栅化器接收到的数据，所以没有参数要设置。 6、编码绘图命令 指定图元的种类、起始索引和顶点的数量。 当三角形被渲染时，顶点着色器将被调用，参数 vertexID 的值为 0，1 和 2。 // Draw the triangle. [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3]; 编码结束，将命令提交缓冲区。还可以使用同一组步骤编码更多的呈现命令。 最终的图像呈现为命令是按照指定的顺序处理的。(为了提高性能，GPU允许并行处理命令甚至部分命令，只要最终结果看起来是按顺序呈现的。) 7、尝试颜色插值 在该示例中颜色值被插入到三角形中，但有时需要一个值由一个顶点生成并且在整个图元中保持恒定。 为此，在顶点着色器的输出上指定属性限定符 flat。 float4 color [[flat]]; 此时渲染管道使用来自第一个顶点(称为激发顶点)的颜色值均匀地穿过三角形，它忽略来自其他两个顶点的颜色。 可以混合使用平面阴影值和插值值，只需在顶点函数的输出中添加或省略平面限定符。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:18 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/简单的纹理贴图.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/简单的纹理贴图.html","title":"纹理贴图","keywords":"","body":"纹理 1、简单介绍纹理 1.1、什么是纹理？ 纹理，也称为纹理贴图，就像是模型表面的皮肤，在没有光照计算的前提下为表面提供基础的色彩内容！纹理可以体现物体表面的性质，使物体看上去更加真实。 纹理贴图通常是一张二维的图片，纹理贴图将图像离散为一定数量的像素，称为纹素，纹素最终会映射到屏幕上的像素上。 那么如何将纹素映射到屏幕呢？需要告知渲染系统：为图元中的顶点指定恰当的纹理坐标！ 纹理坐标又称 uv，是在纹理自身的单位纹理空间中定义的，是一个二维坐标，取值范围通常是 [0, 1] ; 确定了模型顶点的纹理坐标后，可以替换不同的纹理，无需更改纹理坐标值； 单位化的纹理空间坐标最终通过变换映射到 (0,0)~(width,height) 的屏幕空间； Metal 中纹理空间的坐标系：原点在左上角； OpenGL中纹理空间的坐标系：原点在左下角； 不同纹理坐标系统的数据跨系统使用时，需要对数据做一次变换，否则可能会显示不正常； 纹理映射的基本思想： 首先为图元中的每个顶点指定恰当的纹理坐标； 然后通过纹理坐标在纹理贴图中确定可以选中的纹理区域； 最后将选中纹理区域中的内容根据纹理坐标映射到指定的图元上； 进行纹理映射的过程，实际就是为图元中的每个片元着色，用于着色的颜色需要从纹理贴图提取： 首先图元中的每个顶点都需要在顶点着色器中通过 out 变量，将纹理坐标传入片段着色器； 经过顶点着色器后渲染管道的固定功能部分会根据情况进行插值计算，产生对应每个片元的用于记录纹理坐标的 out 值； 最后每个片元在片段着色器中根据其接收到的纹理坐标，到纹理贴图中提出对应位置的颜色即可；提取颜色的过程一般称之为纹理采样； 在实际开发中，建议使用宽和高像素都为 2 的n次方的纹理贴图，这样做有助于提高处理效率！ 图片与待映射的物体不一定大小一样： 可能图片的多个像素对应物体的某个点，此时需要将多个像素合成一个； 1.2、纹理空间 而在上一章我们顶点的坐标空间原点是在中心，我们希望三角形第一个顶点对应纹理贴图的top-center位置，第二个顶点对应bottom-right位置，第三个顶点对应bottom-left位置，因此最终我们三角形三个顶点的uv坐标依次映射为： 顶点：(0,1.0) -------> uv：(0.5,0) 顶点：(1.0,-1.0) ----> uv：(1.0,1.0) 顶点：(-1.0,-1.0) ---> uv：(0,1.0) 1.3、Metal采样对象sampler 采样对器是一个配置纹理采样的对象，光栅化阶段光栅器会在顶点之间进行一系列的插值计算，包括纹理的插值计算，采样器则是我们控制纹理采样期间一些插值细节操作的对象。 另外采样对象还可设置特殊情况下纹理采样的寻址方式和纹理滤波模式。 sampler可以直接在着色器函数中创建： constexpr sampler textureSampler (filter::linear, address:repeat); 也可以在CPU上代码中创建sampler对象传递给着色器使用： MTLSamplerDescriptor *samplerDes = [[MTLSamplerDescriptor alloc] init]; samplerDes.magFilter = MTLSamplerMinMagFilterLinear; samplerDes.minFilter = MTLSamplerMinMagFilterLinear; samplerDes.rAddressMode = MTLSamplerAddressModeRepeat; samplerDes.sAddressMode = MTLSamplerAddressModeRepeat; id sampler = [_device newSamplerStateWithDescriptor:samplerDes]; 1.4、纹理滤波 Filtering 纹理贴图将图像离散为一定规模的纹素，但是绘制的时候，纹素的规模可能比屏幕分辨率大也可能比屏幕分辨率小，所以这些情况下都需要定义相应的模式来为屏幕像素选择合适的纹素颜色。纹理贴图在绘制到屏幕上的时候有两种过滤情况：magnification和minification，含义如下： magnification：当屏幕上的分辨率比纹理贴图的分辨率大，绘制的时候纹理实际尺寸比其原尺寸要大的情况； minification：当屏幕上的分辨率比纹理贴图的分辨率小，绘制的时候纹理实际尺寸比其原尺寸要小的情况； 根据屏幕绘制分辨率需求来伸缩纹理贴图，改变纹理贴图数据规模的过程就叫纹理过滤。 Metal中提供了两种纹理过滤的模式：linear 和 nearest。 linear：线性模式，这种模式下纹理过滤过程为：选择离纹理坐标最近的四个纹素，用按照距离加权平均的结果来填充像素颜色。这种模式下效果会更加自然平滑，但是效率会降低； nearest：这种模式下的纹理过滤会选择离纹理坐标最近的那个纹素来填充像素颜色。优点是速度快效率高，但是放大会有块状现象，颜色不平滑。 1.5、纹理寻址 纹理寻址解决的是纹理采样超出纹理边界时如何采样的问题。寻址模式有以下几种： repeat：repeat寻址模式下超出纹理空间后，回到纹理坐标0重复采样。寻址坐标重复模式为：[0～1][0～1][0~1]... mirrored_repeat：镜像重复寻址，也是超出后重复寻址采样，只是重复模式为：[0~1][1~0][0~1]... clamp_to_edge：默认的寻址模式，指的是超出边界重复纹理边缘的像素； clamp_to_zero：指的是超出边界使用黑色或者透明颜色填充； clamp_to_border：指的是超出边界使用纹理边框颜色填充. 1.6、Mipmaping Mip贴图，是预处理过滤的多个规模精度不同的子贴图，以应对不同精度的需求。靠近物体的时候使用精度高的贴图增加细节，远离物体的时候替换精度低的贴图，提高性能。 如下图所示，原贴图被依次缩小精度的到不同精度的子贴图，每张子贴图是之前贴图精度的一半。 Mip贴图通常是美术使用工具来制作的，但Metal中提供了方法来自动为一张原始贴图制作MipMap，在创建MTLTexture的时候可以配置MTLTextureDescriptor来开启Mipmap： MTLTextureDescriptor *texDes = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm width: image.width height: image.height mipmapped:YES]; texDes.mipmapLevelCount = 3; 其中mipmapLevelCount指的是生成Mip贴图的数量，若mipmapped设置为NO则默认mipmapLevelCount为1，表示不生成MipMap。 1.7、Metal 中的纹理表示 MTLTexture MTLTexture是Metal中保存贴图数据的一张纹理缓冲，可以理解为一个framebuffer，可通过配置设置贴图是否可读可写，贴图的尺寸，贴图保存的图像数据格式等。MTLTexture在创建的时候有其decriptor对象：MTLTextureDescriptor。可以设置MTLTextureDescriptor来配置纹理贴图的属性和操作，包括后期高级设置中的storgeMode来控制贴图在内存中的存储方式等。 MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init]; textureDescriptor.pixelFormat = MTLPixelFormatBGRA8Unorm; textureDescriptor.width = image.width; textureDescriptor.height = image.height; id texture = [_device newTextureWithDescriptor:textureDescriptor]; 1.8、纹理贴图的资源加载 MTKTextureLoader是MetalKit框架中的一个将普通图片加载解码为MTLTexture的对象，将普通的JPG、PNG、TIFF等格式的图片数据加载到MTLTexture对象中供在Metal中使用。 MTKTextureLoader *loader = [[MTKTextureLoader alloc] initWithDevice: device]; id texture = [loader newTextureWithContentsOfURL:url options:nil error:nil]; if(!texture) { NSLog(@\"Failed to create the texture from %@\", url.absoluteString); return nil; } 2、Demo：矩形的纹理贴图 3、Demo：球体的纹理贴图 4、Demo：读取绘制纹理中的像素数据 Metal 对纹理渲染做了很多优化，可以让 GPU 快速访问，但不允许 CPU 直接访问纹理数据！ 当我们需要改变或读取纹理数据时，可以使用 Metal 分配共享缓冲区，GPU 将纹理数据复制到共享缓存，CPU 从共享缓存访问纹理数据。 Demo 主要演示： 单击单个点或者拖出一个矩形来读取存储在该区域的像素数据，并保存到本地； 将物体坐标转换到裁剪空间坐标； 为读取权限配置可绘制纹理 默认情况下，MetalKit 视图创建可绘制纹理仅用于渲染，所以其他 Metal 命令不能访问纹理。 然而当用户选择演示视图的一部分时，我们需要获得该区域的纹理数据！ 通过配置 allowsNextDrawableTimeout = NO 使得 CAMetalLayer 无限期地等待新的绘制。 以达到读取纹理的目的！ _view.framebufferOnly = NO; ((CAMetalLayer*)_view.layer).allowsNextDrawableTimeout = NO; _view.colorPixelFormat = MTLPixelFormatBGRA8Unorm; 注意： 通过上述设置，可能会牺牲 Metal 的一些优化，导致渲染性能的下降； 因此除非必要，不要轻易更改渲染配置； 确定拷贝哪些像素 通过与用户交互，确定待拷贝区域，然后将该区域的视图坐标转为 Metal 的纹理坐标。 由于图形坐标系统和 API 的不同，在视图坐标和纹理坐标之间转换的代码因平台而异； 在macOS中，调用 -pointToBacking: 方法将一个位置转换为支持存储中的像素位置，然后应用坐标转换来调整原点和 Y 轴； CGPoint bottomUpPixelPosition = [_view convertPointToBacking:event.locationInWindow]; CGPoint topDownPixelPosition = CGPointMake(bottomUpPixelPosition.x, _view.drawableSize.height - bottomUpPixelPosition.y); 在iOS中，读取视图的 contentScaleFactor，并对视图坐标进行缩放变换； iOS 视图坐标和 Metal 纹理坐标相同，所以无需转换坐标系； - (CGPoint)pointToBacking:(CGPoint)point { CGFloat scale = _view.contentScaleFactor; CGPoint pixel; pixel.x = point.x * scale; pixel.y = point.y * scale; // 将像素值四舍五入，然后放在一个网格上 pixel.x = (int64_t)pixel.x; pixel.y = (int64_t)pixel.y; // 移动到像素中心 pixel.x += 0.5f; pixel.y += 0.5f; return pixel; } 渲染像素数据 当用户在视图中选择一个区域时，视图控制器调用 -renderAndReadPixelsFromView:withRegion 方法来渲染绘制的内容，并将它们复制到 Metal 缓冲区。 这创建了一个新的命令缓冲区，并调用一个方法来编码渲染管道！ 该 Demo 并不关注具体的渲染图像！ id commandBuffer = [_commandQueue commandBuffer]; /// 编码渲染管道，将图像渲染到 drawable 纹理 [self drawScene:view withCommandBuffer:commandBuffer]; 在对渲染管道编码后，调用另一个方法来对命令进行编码，以复制渲染纹理的某一部分。 程序选择在渲染 drawable 纹理之前拷贝像素数据，因为系统会在渲染纹理之后丢弃纹理的内容。 id readTexture = view.currentDrawable.texture; MTLOrigin readOrigin = MTLOriginMake(region.origin.x, region.origin.y, 0); MTLSize readSize = MTLSizeMake(region.size.width, region.size.height, 1); const id pixelBuffer = [self readPixelsWithCommandBuffer:commandBuffer fromTexture:readTexture atOrigin:readOrigin withSize:readSize]; 拷贝像素数据到缓冲区 封装了一个编码拷贝纹理命令的方法，将相同的命令缓冲区传给此方法，所以Metal在渲染之后编码这些新命令。 Metal 自动管理对目标纹理的依赖关系，并确保在拷贝纹理数据之前完成渲染。 首先，分配一个 Metal 缓冲区来保存像素数据； 计算缓冲区的大小：一个像素的字节大小乘以区域的宽度和高度； 类似地，计算每行的字节数，这是拷贝数据时所需要的； 该示例没有在行尾添加任何填充； 然后创建新的 Metal 缓冲区，指定共享存储模式，以便 CUPU 可以读取缓冲区的内容。 NSUInteger bytesPerPixel = sizeofPixelFormat(texture.pixelFormat); /// 一个像素的字节大小 NSUInteger bytesPerRow = size.width * bytesPerPixel; /// 每行的字节数 NSUInteger bytesPerImage = size.height * bytesPerRow; /// 计算总字节数 _readBuffer = [texture.device newBufferWithLength:bytesPerImage options:MTLResourceStorageModeShared]; 接着创建 MTLBlitCommandEncoder, 它提供在 Metal 资源之间复制数据、用数据填充资源以及执行其他类似的与资源相关的任务，这些任务不直接涉及计算或渲染。 程序编码一个 blit 命令，将纹理数据拷贝到新缓冲区的开头。 然后结束 blit 通道； id blitEncoder = [commandBuffer blitCommandEncoder]; [blitEncoder copyFromTexture:texture sourceSlice:0 sourceLevel:0 sourceOrigin:origin sourceSize:size toBuffer:_readBuffer destinationOffset:0 destinationBytesPerRow:bytesPerRow destinationBytesPerImage:bytesPerImage]; [blitEncoder endEncoding]; 最后提交命令缓冲区并调用 -waitUntilCompleted 来同步等待 GPU 完成渲染和 blit 命令; 调用方法之后，缓冲区将包含所请求的像素数据； 同步命令降低了CPU和GPU之间的并行性，在实际开发中建议使用异步命令； [commandBuffer commit]; // 同步等待GPU完成blit传递，才能从_readBuffer读取数据。 [commandBuffer waitUntilCompleted]; 从缓冲区读取像素 调用buffer.contents 来获取像素数据的指针。 AAPLPixelBGRA8Unorm *pixels = (AAPLPixelBGRA8Unorm *)pixelBuffer.contents; 使用 CPU 将缓冲区数据拷贝到 NSData 对象中，然后创建一个图像！ NSData *data = [[NSData alloc] initWithBytes:pixels length:pixelBuffer.length]; // 创建一个图像 AAPLImage *image = [[AAPLImage alloc] initWithBGRA8UnormData:data width:readSize.width height:readSize.height]; Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/CPU与GPU协调工作.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/CPU与GPU协调工作.html","title":"CPU与GPU协调工作","keywords":"","body":"CPU 与 GPU 的流水线工作 CPU 和 GPU 是独立的异步处理器。 Demo 绘制了一组帧动画：沿着正弦波连续渲染三角形： 在每一帧中，更新每个三角形顶点的位置，然后渲染一个新的图像； 这些动态数据更新创造了一种运动错觉，三角形似乎沿着正弦波移动； 代码中将 顶点数据 存储在CPU和GPU共享的缓冲区中；CPU 负责写入数据到缓冲区，GPU 读取数据负责渲染。 将一组资源拷贝到多个缓冲区，管理数据依赖关系，避免CPU和GPU工作之间的处理器停顿。 1、理解数据依赖和处理器暂停的解决方案 资源共享在处理器之间创建数据依赖关系：CPU 必须完成对资源的写入，GPU 才能读取资源： 如果GPU在CPU写入资源之前读取资源，则GPU读取未定义的资源数据； 如果GPU在写资源时读取资源，则GPU读取的资源数据错误； 这些数据依赖会在CPU和GPU之间造成处理器停滞：每个处理器在开始自己的工作之前必须等待另一个处理器完成它的工作。 每一帧图像都需要传给顶点着色器相同的参数，但这并不意味着需要引用相同的资源对象；可以创建一个资源的多个缓冲池，并在渲染每一帧时使用不同的缓冲。 CPU 将第 n+1 帧的顶点数据写入缓冲区，同时 GPU 从缓冲区中读取第 n 帧的顶点数据；通过使用一组数据的多个缓冲，CPU和GPU可以流水线工作，避免停顿。 2、使用CPU初始化数据 一个顶点数据，需要包含位置信息、颜色信息！ typedef struct { vector_float2 position; vector_float4 color; } AAPLVertex; 提供一个由三个顶点组成的默认三角形： + (const AAPLVertex *)vertices { const float TriangleSize = 64; static const AAPLVertex triangleVertices[] = { // 像素位置, RGBA colors { { -0.5*TriangleSize, -0.5*TriangleSize }, { 1, 1, 1, 1 } }, { { 0.0*TriangleSize, +0.5*TriangleSize }, { 1, 1, 1, 1 } }, { { +0.5*TriangleSize, -0.5*TriangleSize }, { 1, 1, 1, 1 } } }; return triangleVertices; } 使用位置与颜色初始化三角形顶点，并将它们存储在数组 _triangle 中: NSMutableArray *triangles = [[NSMutableArray alloc] initWithCapacity:NumTriangles]; // 初始化每个三角形 for(NSUInteger t = 0; t 3、分配缓冲区 计算三角形数据的存储容量：如渲染 50 个三角形，每个三角形有 3 个顶点，总共 150 个顶点，每个顶点的大小为 sizeof(AAPLVertex) 。 const NSUInteger triangleVertexCount = [AAPLTriangle vertexCount]; _totalVertexCount = triangleVertexCount * _triangles.count; const NSUInteger triangleVertexBufferSize = _totalVertexCount * sizeof(AAPLVertex); 初始化队列中的每个缓冲区：分配内存大小为 150 * sizeof(AAPLVertex)。 for(NSUInteger bufferIndex = 0; bufferIndex 4、使用CPU更新数据 在每一帧渲染开始时，使用 CPU 更新 -drawInMTKView: 的缓冲区内容！ // 当前三角形的顶点数据 AAPLVertex *currentTriangleVertices = _vertexBuffers[_currentBuffer].contents; // 更新每个三角形 for(NSUInteger triangle = 0; triangle 更新缓冲区后，不会在帧的其余部分使用 CPU 访问其数据。 注意：在提交命令缓冲区之前，必须完成对该缓冲区实例的所有 CPU 写入；否则，GPU 可能会在 CPU 仍在写入缓冲区时开始读取缓冲区数据。 5、编码GPU的命令 接下来，需要对渲染过程中引用缓冲区的命令进行编码： [renderEncoder setVertexBuffer:_vertexBuffers[_currentBuffer] offset:0 atIndex:AAPLVertexInputIndexVertices]; [renderEncoder setVertexBytes:&_viewportSize length:sizeof(_viewportSize) atIndex:AAPLVertexInputIndexViewportSize]; [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:_totalVertexCount]; 6、提交和执行GPU命令 在渲染结束时，调用 [commandBuffer commit] 将任务提交给 GPU ： [commandBuffer commit]; GPU 开始工作并从顶点着色器中的 vertices 缓冲区读取数据 vertex RasterizerData vertexShader(const uint vertexID [[ vertex_id ]], const device AAPLVertex *vertices [[ buffer(AAPLVertexInputIndexVertices) ]], constant vector_uint2 *viewportSizePointer [[ buffer(AAPLVertexInputIndexViewportSize) ]]) 7、重用缓冲区 对于每一帧数据，执行以下步骤： 将数据写入缓冲区 对 commandBuffer 进行编码 提交已编码的 commandBuffer 到 GPU GPU 从缓冲区读取数据 当 CPU 与 GPU 都完成工作时，一个完整帧的工作也就完成了。此时 CPU 和 GPU 不再需要该帧使用的缓冲区。 然而，缓冲区的丢弃与创建是一个昂贵开销；因此使用队列 _vertexBuffers 重用缓冲区。 队列中缓冲区实例的最大数量由 MaxFramesInFlight = 3 定义！ /// 注：使用 3 是有特别含义的 static const NSUInteger MaxFramesInFlight = 3; 在每一帧中，在渲染循环开始时，更新队列中的下一个缓冲区实例。按先进先出顺序循环遍历队列，每帧仅更新一个缓冲区；每隔三帧结束时，将返回到队列的头部！ // 循环重用 3 个创建的缓冲区 _currentBuffer = (_currentBuffer + 1) % MaxFramesInFlight; // 更新当前缓冲区数据 [self updateState]; Core Animation 提供可显示资源 drawables，供开发者渲染内容、并将其显示在屏幕上。 由于 Drawable 是高效但昂贵的系统资源，Core Animation 限制在应用程序中同时使用的 drawable 的数量； 限制值仅支持 2 和 3，默认限制为 3； 创建的缓冲区数量不能大于最大可绘制数量 maximumDrawableCount; 由于可绘制对象的最大数量为 3，因此本示例创建了 3 个缓冲区实例； 8、管理CPU和GPU工作速率 在Demo中 _vertexBuffers 持有三个缓冲区，可以让 CPU 处理第 n+1 帧的数据，而 GPU 处理第 n 帧的数据。 CPU 和 GPU 的流水线工作，可以大大的提高渲染效率；但是，开发者需要控制 CPU 和 GPU 的工作速率，避免缓冲区越界： 使用信号量等待一帧数据处理完成，以防 CPU 的工作速度比 GPU 快得多； 信号量用于控制 跨处理器 或 跨线程 的共享资源访问； 信号量关联一个计数值，-wait 递减或 -signal 递增该值； 通过该关联值，可以指示处理器是已开始还是已完成对资源的访问； /// 使用缓冲区总数量初始化信号量，表示在任何时间内最多可以同时处理 MaxFramesInFlight 帧 _inFlightSemaphore = dispatch_semaphore_create(MaxFramesInFlight); 渲染开始时，将信号量关联值减 1，表明已准备好处理新帧： 如果信号量关联值低于 0，信号量会使处于 CPU 等待状态； 关联值大于 0 时会唤醒 CPU 处理数据； dispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER); 注册 commandBuffer 的完成回调，当 GPU 完成 commandBuffer 的执行时立即调用 Block！ 在回调中，需要增加信号量关联值，表明已完成该帧的渲染工作； 因为每帧数据使用一个命令缓冲区，渲染结束表明这个缓冲区可以被回收或者被下一帧数据重用； __block dispatch_semaphore_t block_semaphore = _inFlightSemaphore; [commandBuffer addCompletedHandler:^(id buffer) { dispatch_semaphore_signal(block_semaphore); }]; 9、设置缓冲区的可变性 在Demo 中，所有帧的渲染都在一个线程中完成： 首先，使用 CPU 将数据写入缓冲区； 接着，对渲染命令进行编码； 最后，使用 GPU 执行 commandBuffer； 由于这些任务在单个线程上按此顺序处理，因此开发者需要保证在对 commandBuffer 进行编码之前，CPU 向缓冲区写入数据已经完成。 /// 标记缓冲区不可变 pipelineStateDescriptor.vertexBuffers[AAPLVertexInputIndexVertices].mutability = MTLMutabilityImmutable; Metal 针对缓冲区的不可变做了性能方面的优化，但没有优化可变缓冲区的性能。为获得最好的结果，建议使用不可变缓冲区。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:18 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/深度测试.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/深度测试.html","title":"深度测试","keywords":"","body":"深度测试 像素不止携带 RGBA 信息，还有深度值，模板值等。 1、概述 1.1、画家算法 画家算法：首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分！ 通常对于每一层layer，渲染器会遵循 画家算法，按次序输出到Framebuffer，后一层覆盖前一层，就能得到最终的显示结果。 针对复杂的 3D 场景，画家算法如何确定哪个场景远？哪个场景近？换句话说：当图元相互重叠时，画家算法如何选择要绘制的图元、如何确定要抛弃的图元？ 在图形学中使用 深度 来确定 从观察位置到特定像素的距离: 深度值越小，离用户越近，需要被渲染； 深度值越大，离用户越远，可以被抛弃； 在 Metal 中使用深度测试来确定每个图元在渲染时的可见性，实现复杂 3D 场景中物体的遮挡效果！如果没有深度测试，场景前边的物体不会挡住后边的物体；同一个物体前边的部分也不会挡住后边的部分，会使物体出现显示不全、闪烁等一些不好的现象。 1.2、缓冲区 帧缓冲区 由许多缓冲区构成，这些缓冲区大致分为： 颜色缓冲区：用于绘图的缓冲区，它包含了颜色索引或者RGBA颜色数据; 深度缓冲区：存储每个像素的深度值; 当启动深度测试时，片段像素深度值和深度缓冲区深度值进行比较，决定片段哪些像素点数据可以替换到颜色缓冲区中。 模板缓冲区：就像对缕空纸板喷漆一样，当启动 模板测试时，通过模板测试的片段像素点会被替换到颜色缓冲区中，从而显示出来，未通过的则不会保存到颜色缓冲区中，从而达到了过滤的功能。 累积缓冲区：累积缓冲区允许你把渲染到颜色缓冲区的值，拷贝到累积缓冲区。在多次拷贝操作到累积缓冲区时，可以用不同方式的把颜色缓冲区内容和当前累积缓冲区的内容进行重复混合 1.3、什么是深度测试？ 我们知道，一个3D物体的坐标需要经过 模型坐标 -> 世界坐标 -> 观察坐标 -> 投影坐标 -> 剪裁空间坐标 -> 屏幕坐标 的层层转换！ 像素的深度值本质就是 3D 物体在剪裁空间的 Z 值 [0, 1] （其中 0 是近剪裁平面、1 是远剪裁平面）！ 深度缓冲区存储着每个像素的深度值，渲染一个像素时会与深度缓冲区的深度值比较： 如果符合预设的比较结果，就认为测试通过，然后用当前像素的深度值替换深度缓冲中的像素值； 如果测试不通过，就丢弃当前像素的深度值； 通过深度测试决定重叠的图元哪些像素是可见的。 1.4、深度冲突 一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。 结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做 深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。 在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。 箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。 这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。 如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹！ 深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着粗粒度的精度）。 深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突。 1、永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。 2、尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。 3、使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突 1.5、在 Metal 中进行深度测试 在 Metal 中进行深度测试： 需要在渲染管道添加一个深度缓冲区或深度纹理 深度纹理存储像素深度值的方式与颜色纹理存储颜色值的方式相同； 在片段着色器决定如何计算深度值，通常是通过计算每个顶点的深度，并让硬件对这些深度值进行插值； GPU 会对当前片段与深度缓冲区的所有片段做深度测试，看它们是否比存储在深度纹理中的当前值更接近观看位置； 如果片段距离较远，GPU 会丢弃该片段； 当新的深度值小于深度纹理中目标像素的现有值时，深度测试通过，这表明片段比之前渲染的任何内容更接近查看者； 当深度测试通过时，GPU 将片段的颜色值写入颜色渲染附件，并将新的深度值写入深度附件。 1.5.1、配置测试策略 一般而言，越小深度值能通过深度测试，但这不是绝对的！可以通过配置比较策略，实现自定义的深度测试： /// 测试通过的比较策略 typedef NS_ENUM(NSUInteger, MTLCompareFunction) { MTLCompareFunctionNever = 0, /// 新值永远不会通过测试 MTLCompareFunctionLess = 1, /// 如果新值小于现有值，则新值通过测试 MTLCompareFunctionEqual = 2, /// 如果新值与现有值相等，则新值通过测试 MTLCompareFunctionLessEqual = 3, /// 如果新值小于或等于现有值，则新值通过测试 MTLCompareFunctionGreater = 4, /// 如果新值大于现有值，则新值通过测试 MTLCompareFunctionNotEqual = 5, /// 如果新值不等于现有值，则新值通过测试 MTLCompareFunctionGreaterEqual = 6, /// 如果新值大于或等于现有值，则新值通过测试 MTLCompareFunctionAlways = 7, /// 新值总是通过测试 }; 1.6、模版测试 渲染管道处理顺序：顶点着色器 —> 片元着色器 —> 模板测试 —> 深度测试 ！ 当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。 接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。 模板测试是根据另外一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。 深度测试使用的是深度缓冲(Depth buffer)，模板测试使用的是模板缓冲(Stencil buffer)。 在模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。 我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。 2、代码示例 这里使用一个简单的 Demo 通过更改三角形每个顶点的深度值来演示深度测试，不涉及渲染 3D 场景的概念： 每个片段的深度被插入到设定深度值之间，应用程序配置GPU来执行上面描述的深度测试； 渲染每帧数据时，清除深度纹理数据，然后在中点渲染一个灰色正方形； 最后渲染三角形，只有比灰色方块深度值更小的片段是可见的。 2.1、创建深度纹理 默认情况下，MTKView 不会创建深度纹理，需要开发者通过 MTKView.depthStencilPixelFormat 设置深度纹理的数据格式；然后由MTKView 自动创建和管理深度纹理。 /// 每个像素使用 32 位浮点值存储深度 mtkView.depthStencilPixelFormat = MTLPixelFormatDepth32Float; 2.2、在渲染管道中指定深度格式 如果进行深度测试，渲染管道需要关于深度纹理格式的信息，以便它可以读取或写入纹理中的值；在创建渲染管道时需要指定深度格式： MTLRenderPipelineDescriptor *descriptor = [[MTLRenderPipelineDescriptor alloc] init]; /// 与视图的深度纹理数据格式相同 pipelineStateDescriptor.depthAttachmentPixelFormat = mtkView.depthStencilPixelFormat; 在渲染管道中指定深度格式时，Metal 会在渲染管道上执行额外的操作流程（深度测试）： 2.3、深度测试的一些配置项 在 Metal 中，可以独立于渲染管道配置深度测试：深度测试由 MTLDepthStencilState 表示，类似于使用渲染管道，通常在初始化应用时创建这个对象。 MTLDepthStencilDescriptor *depthDescriptor = [MTLDepthStencilDescriptor new]; /// LessEqual 如果新值小于或等于现有值，则通过深度测试 depthDescriptor.depthCompareFunction = MTLCompareFunctionLessEqual; depthDescriptor.depthWriteEnabled = YES; _depthState = [_device newDepthStencilStateWithDescriptor:depthDescriptor]; Metal 将深度测试与模板测试相结合，后者使用为每个像素存储的计数执行类似的测试；通常是片段通过深度测试的次数。模板操作对于实现某些 3D 算法很有用。默认情况下，模板测试是禁用的，本示例未启用它。 2.4、在着色器中生成深度值 实现深度测试，需要提供剪裁空间坐标系下的 z 坐标值。 out.clipSpacePosition.z = vertices[vertexID].position.z; 当光栅化器计算要发送到片段着色器的数据时，它会在这些 z 值之间进行插值（由 GPU 负责，无需开发者处理） 开发者可以在片段着色器根据需要读取、忽略或修改 z 值： 如果不修改栅格化器计算的值，GPU 有时可以执行额外的优化：例如，它可以在运行片段着色器之前执行 z 测试，这样它就不会为隐藏的片段运行片段着色器； 如果在片段着色器中改变深度值，可能会导致性能下降，因为 GPU 必须先执行片段着色器； 2.5、在每帧渲染开始前清除深度值 渲染管道包括目标纹理列表，可配置的深度纹理等 视图自动配置描述符的深度渲染目标以指向深度纹理； 渲染管道在每帧开始时清除深度纹理值； 开发者需要提供一个默认的深度值 [0, 1]，在每帧开始前清除深度纹理值时使用！ /// 0 是近剪裁平面，离用户最近 /// 1 是远剪裁平面，离用户最远 mtkView.clearDepth = 1.0; 当 GPU 开始渲染时，深度纹理中的每个像素都被初始化为 1.0 。 2.6、编码绘图命令 在渲染命令编码器，还需要设置深度测试。 [renderEncoder setDepthStencilState:_depthState]; 该例子使用着色器编码两个绘制命令。 首先渲染一个 depth= 0.5 的四边形，因为所有这些值都小于默认值，四边形总是被绘制到渲染目标中，深度值总是被更新。 然后在用户界面中指定的深度值渲染一个三角形。 如果将三角形的某顶点深度值增加到 0.5 以上，该部分无法通过深度测试、就会消失。 3、API 3.1、模版测试 API 模板测试 MTLStencilDescriptor 是一个很实用的功能，可以做出很多有意思的效果！ 模板测试原理就是 掩码参考值与存储在模板缓冲区中的掩码值之间的比较，达到一定条件后，当前模版遮挡或者显示！ /// 参考值由 [MTLRenderCommandEncoder -setStencilReferenceValue:] 设置 /// 模版参考值与当前模板值的比较策略 typedef NS_ENUM(NSUInteger, MTLStencilOperation) { MTLStencilOperationKeep = 0, /// 保持当前的模板值 MTLStencilOperationZero = 1, /// 将模板值设置为零 MTLStencilOperationReplace = 2, /// 替换：拿参考值替代原有值 MTLStencilOperationIncrementClamp = 3, /// 当前的模板值增加1，但不溢出，如果到255，就不再加 MTLStencilOperationDecrementClamp = 4, /// 当前模板值减少1，但不溢出，值到0就不再减 MTLStencilOperationInvert = 5, /// 反转所有位，如果1就会变成254 MTLStencilOperationIncrementWrap = 6, /// 值增加1，会溢出，所以255变成0 MTLStencilOperationDecrementWrap = 7, /// 值减少1，会溢出，所以0变成255 }; @interface MTLStencilDescriptor : NSObject /// 比较策略：拿 ReferenceValue 参考值和当前像素缓存上的值进行比较 @property (nonatomic) MTLCompareFunction stencilCompareFunction; /// 第一步：模版测试，测试失败时的操作 @property (nonatomic) MTLStencilOperation stencilFailureOperation; /// 第二步：模版测试通过，做深度测试，深度测试失败时的操作 @property (nonatomic) MTLStencilOperation depthFailureOperation; /// 第三步：模版测试、深度测试都通过，接下来的操作 @property (nonatomic) MTLStencilOperation depthStencilPassOperation; /// 对当前模板值和参考值进行 & 操作，默认值 1，一般不用 @property (nonatomic) uint32_t readMask; /// 写入Mask操作，默认值 0 ，一般不用 @property (nonatomic) uint32_t writeMask; @end 3.2、深度测试 API 使用 MTLDepthStencilDescriptor 定义渲染管道的深度测试与模版测试的特定配置！ @interface MTLDepthStencilDescriptor : NSObject /// 默认为MTLCompareFuncAlways，新值总是通过测试 @property (nonatomic) MTLCompareFunction depthCompareFunction; /// 默认为 NO，不执行深度写入 @property (nonatomic, getter=isDepthWriteEnabled) BOOL depthWriteEnabled; /// 模板状态分前模和后模。通过给前后两者分配相同的 MTLStencilDescriptor，可以使前后两者跟踪相同的状态 @property (copy, nonatomic, null_resettable) MTLStencilDescriptor *frontFaceStencil; @property (copy, nonatomic, null_resettable) MTLStencilDescriptor *backFaceStencil; /// 标识符，用于调试程序 @property (nullable, copy, nonatomic) NSString *label; @end /// 设备指定的编译深度/模板状态对象 @protocol MTLDepthStencilState /// 标识符，用于调试程序 @property (nullable, readonly) NSString *label; /// 持有创建该资源的设备 @property (readonly) id device; @end Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/离屏渲染.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/离屏渲染.html","title":"自定义MTLRenderPassDescriptor","keywords":"","body":"自定义 MTLRenderPassDescriptor 渲染管道是一系列绘制纹理的渲染命令集合! 离屏渲染是复杂渲染器的基本构建块，例如： 光照和阴影算法需要离屏渲染管道来渲染阴影信息，然后需要第二个通道来计算最终场景的光照； 当对不需要显示在屏幕上的数据执行批处理时，离屏渲染管道也很有用； Demo 使用两个渲染管道来渲染视图： 第一个渲染管道是 离屏渲染管道，配置一个自定义的 MTLRenderPassDescriptor，渲染的样本为普通纹理； 第二个渲染管道使用由 MTKView 对象提供的渲染管道描述符来渲染和显示最终的图像，使用离屏渲染的纹理作为源数据； 为离屏渲染管道创建一个纹理 MTKView 对象自动创建 currentDrawable.textures 来渲染： 在离屏渲染管道中，样本也需要一个纹理来渲染； 为了创建这个纹理，首先创建一个 MTLTextureDescriptor 对象配置纹理的一些属性； MTLTextureDescriptor *texDescriptor = [MTLTextureDescriptor new]; texDescriptor.textureType = MTLTextureType2D; texDescriptor.width = 512; texDescriptor.height = 512; texDescriptor.pixelFormat = MTLPixelFormatRGBA8Unorm; /// 访问纹理的策略： /// 需要在离屏渲染管道中将数据渲染到纹理中； /// 还需要将读取里屏渲染的纹理，作为其它渲染通道的源数据 texDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead; 精确地设置 MTLTextureUsage 可以提高渲染性能，因为 Metal 需要为指定纹理策略的配置底层数据。 创建渲染管道 渲染管道指定如何执行绘图命令，包括要执行的顶点着色器和片段着色器，以及它所作用的任何渲染目标的像素格式。 在 Demo 中： 创建的离屏渲染通道，必须使用相同的像素格式； 为每个 MTLRenderPassDescriptor 创建一个渲染管道； 使用下述代码实现离屏渲染管道； pipelineStateDescriptor.label = @\"Offscreen Render Pipeline\"; pipelineStateDescriptor.sampleCount = 1; pipelineStateDescriptor.vertexFunction = [defaultLibrary newFunctionWithName:@\"simpleVertexShader\"]; pipelineStateDescriptor.fragmentFunction = [defaultLibrary newFunctionWithName:@\"simpleFragmentShader\"]; /// 需要保证像素格式的匹配 pipelineStateDescriptor.colorAttachments[0].pixelFormat = _renderTargetTexture.pixelFormat; _renderToTextureRenderPipeline = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&error]; 注意: 在该例子中，需要保证渲染管道的像素格式一致！ 设置离屏渲染管道描述符 为了渲染离屏纹理，在 Demo 中配置了一个新的 MTLRenderPassDescriptor 对象并配置纹理属性，简单起见将 colorAttachment[0] 指向离屏纹理，渲染为单一颜色纹理！ _renderToTextureRenderPassDescriptor.colorAttachments[0].texture = _renderTargetTexture; 还必须为 Demo 中 MTLRenderPassDescriptor 对象配置 loadAction 和一个 storeAction。 在 GPU 执行任何绘制命令之前，loadAction 决定了渲染管道开始时纹理的初始内容; storeAction 在渲染管道完成后运行，决定 GPU 是否将最终图像写入纹理； Demo /// 配置 loadAction 来删除渲染目标的内容 _renderToTextureRenderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear; _renderToTextureRenderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(1, 1, 1, 1); /// 配置 storeAction 将渲染数据存储回纹理 _renderToTextureRenderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore; /// 这一配置是必要的，因为第二个渲染通道中的绘图命令将对该数据进行采样 Metal 使用loadAction 和 storeAction 来优化 GPU 管理纹理数据的方式。 大型纹理会消耗大量内存，处理这些纹理会消耗大量内存带宽； 正确设置渲染目标 action 可以减少 GPU 用于访问纹理的内存带宽，提高性能和电池寿命。 渲染到离屏纹理 该示例具有编码两个渲染通道所需的所有内容。在看到示例如何编码渲染通道之前，理解Metal如何在GPU上调度命令是很重要的。 理解 Metal 如何在 GPU 上调度命令是很重要的 ： 当应用程序向命令队列提交一个命令缓冲区时，默认情况下 Metal 必须按照顺序执行命令； 为了提高性能和更好地利用 GPU, Metal 可以同时运行多个命令，只要这样做不会产生与顺序执行不一致的结果； 为了实现这一点，当一个 pass 写入资源、而另一个 pass 读取资源时，Metal 会检测依赖关系并自动延迟后一个pass的执行，直到第一个pass完成； 因此，不像 同步CPU和GPU工作 CPU 和 GPU 需要显式同步，该例子不需要做任何特殊的事情；它只是按顺序对两个传递进行编码，Metal 确保它们按顺序运行。 在 Demo 中将两个渲染管道编码到一个命令缓冲区中，从离屏渲染通道开始。 id renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:_renderToTextureRenderPassDescriptor]; renderEncoder.label = @\"Offscreen Render Pass\"; [renderEncoder setRenderPipelineState:_renderToTextureRenderPipeline]; /// 完成编码过程 [renderEncoder endEncoding]; 多个通渲染管道必须按顺序编码到命令缓冲区中，因此必须在开始下一个渲染管道之前完成第一个渲染管道的编码 [renderEncoder endEncoding]。 渲染到Drawable.Texture 第二个渲染管道需要渲染出最终图像。片段着色器从纹理中采样数据作为最终的颜色: // Fragment shader that samples a texture and outputs the sampled color. fragment float4 textureFragmentShader(TexturePipelineRasterizerData in [[stage_in]], texture2d texture [[texture(AAPLTextureInputIndexColor)]]) { sampler simpleSampler; float4 colorSample = texture.sample(simpleSampler, in.texcoord); return colorSample; } 使用视图的渲染通道描述符来创建第二个渲染管道，并编码绘图命令来渲染一个纹理四边形。它指定离屏纹理作为命令的纹理参数。 id renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:drawableRenderPassDescriptor]; renderEncoder.label = @\"Drawable Render Pass\"; [renderEncoder setRenderPipelineState:_drawableRenderPipeline]; [renderEncoder setVertexBytes:&quadVertices length:sizeof(quadVertices) atIndex:AAPLVertexInputIndexVertices]; [renderEncoder setVertexBytes:&_aspectRatio length:sizeof(_aspectRatio) atIndex:AAPLVertexInputIndexAspectRatio]; // Set the offscreen texture as the source texture. [renderEncoder setFragmentTexture:_renderTargetTexture atIndex:AAPLTextureInputIndexColor]; 当提交命令缓冲区时，Metal 依次执行两个渲染传递。在这种情况下： Metal 检测到第一个渲染管道写入离屏纹理，第二个管道读取它； 当 Metal 检测到这种依赖时，它会阻止后续的 pass 执行，直到GPU完成第一个 pass 的执行。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:18 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal简介.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/Metal简介.html","title":"Metal API","keywords":"","body":"Metal 图形处理器 GPU 可以快速渲染图形并执行数据并行计算; 使用 Metal 框架可以直接与设备上可用的 GPU 通信: 如渲染 3D 游戏、视频处理程序、数据处理程序等场景； 使用 MetalKit 简化渲染流程； 通过 Metal 框架的使用，提高程序性能、优化用户体验！ 1、图像渲染 1.1、渲染管道 绘制图形需要对数据映射、变换等处理，将这一系列的步骤抽象成 渲染管道 ！ 渲染管道有许多阶段： 应用层的数据传递到顶点着色器 Vertex Shader ； 顶点着色器 Vertex Shader 采用控制反转，将数据的处理交给开发者； 顶点着色器计算每个顶点的最终坐标，然后将计算好的数据注入渲染管道； 接着进入图元组装 Primitives Assembly，将位置、索引等信息组成三角形； 光栅化 Rasterization 将三角形映射到 Fragment；光栅化可以对图元做 Cull、 Clip等操作； 经过光栅化之后，三角形就变成了 Fragment；此时通过程序反转，让开发者调用 Fragment Shader，为每一个 Fragment 上色； 开发者为每个 Fragment 上色之后，交由 Fragment Operation 着色； Fragment Operation 根据深度做出取舍，被遮挡的部分不会显示；或者颜色混合； 最后形成一个 Frame Buffer，写到内存中； GPU 从内存中读取 Frame Buffer 显示一帧图像； Metal 的渲染管道 侧重于 三个阶段： 顶点着色器 Vertex Shader：转换坐标； 光栅化阶段 Rasterization：将三角形映射到 Fragment，并进行 Cull、 Clip 等操作； 片段着色器 Fragment Shader：为 Fragment 设置纹理或者颜色； 开发者可以为 Vertex Shader 与 Fragment Shader 编写 MSL 函数！ Metal Shading Language 是 C++ 的一种变体，专为 GPU 编程而设计，要在 GPU 上执行计算，需要使用 MSL 函数； 在 Metal 中，在 GPU 上运行的代码称为 着色器； 1.2、视口 设置视口，让 Metal 知道想要绘制渲染目标的哪一部分。 typedef struct { double originX, originY, width, height, znear, zfar; } MTLViewport; 1.3、不同坐标系的转换 在整个渲染管线中，一个顶点可能会经历一下六种坐标空间之间的转换： 1、模型坐标：模型坐标表示的是模型中所有点相对于模型本身原点的一个坐标系；属于右手坐标系； 2、世界坐标：世界坐标是指模型中每个点，相对于世界坐标系原点的一个坐标位置；属于右手坐标系； 3、观察坐标（相机坐标或者人眼坐标）：在世界坐标中的模型，相对于观察坐标的映射；右手或者左手坐标系； 4、投影坐标：投影的最终目的是将一个三维物体展示在 二维平面的剪裁空间 里；属于左手坐标系； 如果是正交投影，可以将剪裁空间想象为一个立方体空间； 如果是透视投影，则剪裁空间是一个锥体，物体呈现方式就是近大远小的效果； 5、NDC坐标：将剪裁空间坐标系的结果进行归一化；属于左手坐标系； 在 Metal 中(x,y) 取值范围 [-1,1], z 取值范围 [0,1]（近剪裁平面 -> 远剪裁平面）； 在 OpenGL 中，Z 轴的取值范围为 [-1,1] 且使用右手坐标系 6、屏幕坐标：所有顶点最终会转换成在屏幕坐标系上的一个坐标 下图表示 Metal 的 NDC 坐标系！ 将坐标映射到 NDC 坐标系，还需要以下转换！ 2、GPU 的选择 2.1、MTLDevice 协议 MTLDevice 是对 GPU 的抽象，用于绘制图形或进行并行计算的 Metal 接口。 定义了 GPU 的接口； MTLDevice 创建的对象昂贵但持久；可以初始化一次并在应用程序的生命周期中重复使用； 2.2、获取默认 GPU 要使用 Metal 框架，首先要获得一个 GPU 设备。iOS 和 tvOS 设备只有一个 GPU，即系统的默认 GPU 设备！ guard let device = MTLCreateSystemDefaultDevice() else { fatalError(\"获取系统默认设备失败\") } 在使用多个 GPU 构建的 macOS 设备（如 Macbook）上，系统默认为独立 GPU。 2.3、mac OS 中的 GPU 选择 通过考虑 GPU 功能、功率或性能特征，选择一个或多个 GPU 来运行 Metal 代码。 3、Metal 如何在 GPU 上执行命令？ 绘图渲染、并行计算或资源管理等工作，都是基于 客户端-服务器 的设计模式： Metal 应用程序是客户端、GPU是服务器； 通过向 GPU 发送命令的方式来发出请求； 处理完命令后，GPU 可以在准备好进行更多工作时通知我们的应用。 要将命令发送到 GPU，需要使用命令编码器 MTLCommandEncoder 将命令编码到命令缓冲区； 将命令缓冲区添加到命令队列，一切准备妥当后就可以提交缓冲区命令让 Metal 执行； 在命令缓冲区、入队和提交命令缓冲区中放置命令的顺序很重要，因为它会影响 Metal 执行命令的感知顺序。 以下部分涵盖了设置工作命令结构的步骤，按照创建与 Metal 交互的对象的方式进行排序。 3.1、初始化某些全局对象 在初始化时创建了一些 Metal 对象，通常会无限期地保留它们： 如设备 MTLDevice、命令队列 MTLCommandQueue、渲染管道 MTLRenderPipelineState等; 由于这些实例的创建属于高开销；因此只创建一次，快速重用。 3.2、创建命令队列 使用下述方法从设备中创建一个命令队列： @protocol MTLDevice // 该方法创建的命令队列最多只允许 64个 未完成的命令缓冲区 - (nullable id )newCommandQueue; @end 使用命令队列来存储命令缓冲区，如下所示： 3.3、创建一个或多个管道对象 管道对象封装了 Shader 函数，告诉 Metal 如何处理命令： 编写处理数据的 Shader 函数； 创建一个包 含Shader 函数 的管道对象； 当准备使用Shader 函数时，启用管道； 进行图形绘制、并行计算； Metal 不会立即执行图形绘制或并行计算； 需要使用 命令编码器 封装这些命令并插入到命令缓冲区中； 命令缓冲区 提交命令后，Metal 将 编码后的命令 发送到 GPU 并使用 管道对象 来处理其这些命令; 3.4、向 GPU 发出命令 设置命令队列和管道后，是时候向 GPU 发出命令了： 创建命令缓冲区； 用命令填充缓冲区； 将命令缓冲区提交给 GPU； 如果将动画作为渲染循环的一部分执行，则对动画的每一帧都执行此操作。还可以按照此过程执行一次性图像处理或机器学习任务。 3.4.1、创建命令缓冲区 @protocol MTLCommandQueue - (nullable id )commandBuffer; @end 通过调用命令队列创建命令缓冲区： guard let commandBuffer = commandQueue.makeCommandBuffer() else { return } 对于单线程应用程序，可以创建一个命令缓冲区: 3.4.2、将命令添加到命令缓冲区 在编码器上调用 Shader 函数时（如图形绘制、并行计算），编码器会将对应命令放入命令缓冲区。 编码器对命令进行编码以包含 GPU 在运行时处理任务所需的一切： 针对不同的任务，可以使用 MTLCommandEncoder 的具体子类对实际命令进行编码： 渲染命令 MTLRenderCommandEncoder； 并行计算命令 MTLComputeCommandEncoder； 资源管理命令 MTLBlitCommandEncoder； 3.4.3、提交命令缓冲区 将命令缓冲区提交到 GPU 执行命令： commandBuffer.commit() 在命令缓冲区提交命令后，GPU 不会立即运行其命令。 如果没有显式地对命令缓冲区的命令插队，Metal 会按入队顺序处理 命令队列 中的命令； 命令缓冲区不能被重用，但可以选择通知它的调度、完成或查询它的状态。 虽然 Metal 在处理某些命令之前可能对它们重新排序，但这通常发生在性能提升且没有其他可感知影响的情况下！ 3.5、后台运行 Metal 为保证前台应用的性能，iOS 和 tvOS 限制后台应用对 GPU 的访问。 如果在应用进入后台移动后命令队列尝试安排命令缓冲区，系统会阻止这些命令执行； 因此当 UIKit 通知应用被暂停或移入后台时，我们需要限制 Metal 的使用； 3.5.1、禁用命令缓冲区提交新的代码 当应用被停用时，停止向 Metal 发送工作，仅在应用程序重新激活后启用该代码。 在系统通知应用程序被停用后，需要限制应用程序使用 Metal； 如果该工作对于准备应用程序处于后台状态至关重要，可以安排其他命令； 同样，如果应用程序已经在编码命令的中间，通常可以在禁用之前完成当前任务； 例如，应用正在将动画帧渲染到屏幕上、并且正在为新的一帧编码命令时收到通知，则可以在禁用渲染代码之前完成对该帧的编码。 3.5.2、确保禁用之前的所有工作都安排好执行 当 UIKit 调用应委托方法 -applicationDidEnterBackground: 时： 在应用程序将控制权返回给系统之前，需要确保 Metal 已经调度了所有已经提交的命令； 在每个命令队列上，如果队列的最后一个命令缓冲区尚未安排或完成，则通过 -waitUntilScheduled 来强制调度它。 如果正在对一个新的命令缓冲区进行编码，可以结合使用这些步骤。完成编码命令并提交命令缓冲区，然后调用 -waitUntilScheduled 。 当应用程序移到后台后，如果 Metal 又收到一个新的命令缓冲区，这将返回一个错误，而不是调度命令缓冲区。 通过添加 -addCompletedHandler: 来监测错误；检查状态和错误属性。 3.6、后台运行 Metal 通过测量应用中的 GPU 统计信息来提高性能。 GPU 跟踪有关它们执行的命令信息，例如 每个命令何时开始或结束； GPU 调用每个着色器的次数； 或者命令如何使用 GPU 硬件的不同部分。 使用 Xcode 捕获和分析 GPU 计数器数据，当然也可以直接在应用程序中测量和显示性能数据。例如，在游戏引擎中屏幕上显示 GPU 性能数据作为每个动画帧的一部分，并突出显示不符合性能目标的帧。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTKView.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTKView.html","title":"MTKView API","keywords":"","body":"MTKView MTKView ! MTKView创建、配置和渲染 Metal 内容的专用视图，提供了常见的渲染场景，设置Metal绘制纹理的功能！ 使用MTKView来渲染图形并在屏幕上显示它们 当被调用时，视图提供一个指向纹理的对象 MTLRenderPassDescriptor，以便您将新内容呈现到其中。 MTKView 还可以创建深度和模板纹理！ 视图使用 CAMetalLayer 来管理 Metal 绘制对象。 配置绘图行为 MTKView 类支持三种绘图模式： 默认定时更新：基于内部计时器重新绘制其内容，此时需要将paused和enableSetNeedsDisplay设置为NO。 该模式适用于定期更新的游戏和其他动画内容。 绘制通知：数据改变使其内容无效时，视图会重新绘制自己；通常是因为调用 -setNeedsDisplay 或其他一些视图相关的行为； 传统的绘制工作流程，此时需要将paused和enableSetNeedsDisplay设置为YES。 显式绘制：仅当显式调用 -draw 时，视图才会重绘其内容； 使用此模式可以自定义工作流程，需要配置paused = YES，enableSetNeedsDisplay = NO。 绘制视图内容 不管绘图模式如何，当视图需要更新其内容时： 如果 -drawRect: 方法被子类重写，则调用该方法； 如果子类没有重写，调用 delegate 的 -drawInMTKView:； 开发者需要至少在上述一个场景中自定义渲染内容，而不是什么都不做！ @protocol MTKViewDelegate /// 当视图的 drawableSize 发生变化时调用，重新计算视图和投影矩阵或重新生成任何缓冲区，size以像素为单位 - (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size; /// 当 delegate 被要求渲染到视图中时调用 - (void)drawInMTKView:(nonnull MTKView *)view; @end 在渲染图形时，需要获取 MTLRenderPassDescriptor，将其渲染到其中，然后呈现相关的可绘制对象。 获取 Drawable 每个MTKView都持有一个CAMetalLayer支持。 - (void)drawInMTKView:(nonnull MTKView *)view { // 开始编码屏幕渲染通道 => 获取从绘制纹理生成的渲染通道描述符 MTLRenderPassDescriptor* onscreenDescriptor = view.currentRenderPassDescriptor; /// 注意⚠️：最好尽可能晚的获取描述符，最好是在编码渲染通道之前 /// 视图使用默认的存储和加载操作配置渲染管道 /// 在使用该描述符创建编码器 MTLRenderCommandEncoder 之前，都可以修改配置描述符的某些选项 } 读取 view.currentRenderPassDescriptor 时， Core Animation 会隐式获取当前帧的一个可绘制对象，并将其存储在 currentDrawable 属性中; 然后它配置一个渲染通道描述符来绘制到绘图中，包括深度测试、模板测试等。 注册绘图命令 在编码渲染命令之后，需要将编码后的绘图命令注册到 Drawable 以更新视图的内容。 - (void)drawInMTKView:(nonnull MTKView *)view { MTLRenderPassDescriptor *descriptor = view.currentRenderPassDescriptor; /// 判断描述符如果无效，则无法进入渲染工作 if (descriptor != nil) { id commandBuffer = [_commandQueue commandBuffer]; commandBuffer.label = @\"命令缓冲区\"; id renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:descriptor]; renderEncoder.label = @\"渲染命令编码器\"; /// 设置渲染状态和资源 /// 渲染的调用 [renderEncoder endEncoding]; // 结束编码 /// 将编码后的绘图命令注册到 Drawable [commandBuffer presentDrawable:view.currentDrawable]; //完成屏幕上的 CPU 工作，并将命令缓冲区提交给GPU [commandBuffer commit]; } } 当 commandQueue 安排一个 commandBuffer 执行时，可绘制对象在该命令缓冲区中跟踪自身的所有渲染或写入请求。 直到命令执行完毕，操作系统才会将绘图显示在屏幕上。 通过要求命令缓冲区显示可绘制对象，可以保证在命令队列调度了该命令缓冲区之后进行显示。 不要等到命令缓冲区完成执行后才注册可绘制对象的显示。 注意：为了更好的性能，只在准备渲染内容时检索渲染通道描述符，并尽可能少地保留它和相关的可绘制对象。一旦你完成了它就释放它。 初始化视图 - (nonnull instancetype)initWithFrame:(CGRect)frameRect device:(nullable id)device; - (nonnull instancetype)initWithCoder:(nonnull NSCoder *)coder; 配置 Metal 设备 /// 描述 GPU 的设备对象，默认为 nil；必须显式设置 @property (nonatomic, retain, nullable) id device; /** 系统建议该视图使用的 GPU 对象，由 CAMetalLayer 决定： * 在只有一个GPU的系统上,返回默认设备 MTLCreateSystemDefaultDevice * 在具有多个GPU的系统上,返回用于合成和呈现视图内容的 GPU 对象 * * @note 该对象通常对应于与显示视图的屏幕相关联的GPU，如果设置 view.device 为该对象， * 将减少 Core Animation 为了在屏幕上呈现视图内容而必须制作的跨 GPU 纹理副本的数量。 */ @property(nullable, readonly) id preferredDevice; 配置颜色渲染目标 /// 绘制纹理的像素格式，需要支持 CAMetalLayer, 默认值 MTLPixelFormatBGRA8Unorm @property (nonatomic) MTLPixelFormat colorPixelFormat; /** 每一渲染帧的颜色空间 * 默认值为 nil，则没有颜色匹配； * 如果设置为不同的颜色空间，Core Animation 会在合成视图内容时执行必要的颜色转换。 */ @property (nonatomic, nullable) CGColorSpaceRef colorspace; /** 绘制的纹理(currentDrawable)是否只用于渲染(YES)，还是可以用于采样或纹理读取操作(NO)？ * 默认值 YES，CAMetalLayer 会优化显示的纹理；使其不适合采样，不能取样、读取或写入这些纹理； * 如果该值为NO，则可以对纹理进行取样或执行读写操作，但会牺牲部分性能。 */ @property (nonatomic) BOOL framebufferOnly; /** 可绘制纹理的像素宽高：默认当前视图的大小 * * 如果 autoResizeDrawable 是YES，这个属性会在视图的大小改变时自动更新 * 如果 autoResizeDrawable 是NO，必须显式设置 drawableSize 来改变纹理对象的大小 * * 该值的改变，将调整视图创建的任何颜色、深度、模板和纹理的大小 */ @property (nonatomic) CGSize drawableSize; /// 在视图改变大小时, 是否自动调整 drawableSize 的大小 @property (nonatomic) BOOL autoResizeDrawable; /// 推荐尺寸：使用 KVO 监听 drawableSize 是否改变 @property (nonatomic, readonly) CGSize preferredDrawableSize; /// 清空色，用于擦除颜色缓冲；默认擦写为黑色 (0.0,0.0,0.0,1.0) @property (nonatomic) MTLClearColor clearColor; CAMetalLayer 支持的像素格式 typedef NS_ENUM(NSUInteger, MTLPixelFormat) { MTLPixelFormatBGRA8Unorm = 80, /// 普通格式, 按 BGRA 顺序由四个8位无符号整数组成 MTLPixelFormatBGRA8Unorm_sRGB = 81, /// 普通格式, 按 BGRA 顺序由四个8位无符号整数组成, 在sRGB和线性空间之间进行转换 MTLPixelFormatRGB10A2Unorm = 90, /// 一种32位压缩像素格式:10位红色、10位绿色、10位蓝色和2位 alpha MTLPixelFormatBGR10A2Unorm = 94, /// 一种32位压缩像素格式:10位蓝色、10位绿色、10位红色和2位 alpha MTLPixelFormatRGBA16Float = 115, /// 普通格式，按 RGBA 顺序包含四个16位浮点值 /// 以下四种支持 宽色域显示设备上显示高质量的宽色域图像 MTLPixelFormatBGRA10_XR = 552, /// 一种64位扩展像素格式:10位蓝色、10位绿色、10位红色和10位 alpha MTLPixelFormatBGRA10_XR_sRGB = 553, /// 一种64位扩展像素格式:10位蓝色、10位绿色、10位红色和10位 alpha MTLPixelFormatBGR10_XR = 554, /// 一种32位扩展像素格式:10位蓝色、10位绿色和10位红色 MTLPixelFormatBGR10_XR_sRGB = 555, /// 一种32位扩展像素格式:10位蓝色、10位绿色和10位红色 } alpha 值在采样、渲染和写入操作中总是固定在 [0.0,1.0] 范围内，只有在宽色域显示设备上才能显示 alpha 在 [0.0,1.0] 范围以外的颜色值！ 擦写色 用于颜色像素的RGBA值。 typedef struct { double red; double green; double blue; double alpha; } MTLClearColor; 配置渲染目标属性 /** 用于创建 deepthstenciltexture 的 pixelFormat * 默认值是 MTLPixelFormatInvalid，这意味着视图不会创建深度和模板纹理 * 如果设置为指定格式，视图会自动创建这些纹理，并将它们配置到渲染通道 */ @property (nonatomic) MTLPixelFormat depthStencilPixelFormat; /** 视图在创建深度和模板纹理时，使用纹理的策略 * 默认值与推荐值是 MTLTextureUsageRenderTarget * 更改此值将重新创建 depthStencilAttachment，当前 depthStencilAttachment 中的数据将丢失 */ @property (nonatomic) MTLTextureUsage depthStencilAttachmentTextureUsage; /** 用于生成 currentRenderPassDescriptor 的清除深度值，创建渲染通道时需要设置，默认值为1.0 * 如果指定了深度纹理，视图会配置任何渲染通道来使用该深度纹理， */ @property (nonatomic) double clearDepth; /** 在创建渲染通道描述符时，用于清除模板目标的模板值，默认值为1.0 * 如果指定了模板纹理，视图将配置任何渲染通道来使用模板纹理 */ @property (nonatomic) uint32_t clearStencil; 纹理的使用策略 /// MTLTextureUsage 声明纹理在其生命周期内将如何使用，可以多个值按位组合使用 typedef NS_OPTIONS(NSUInteger, MTLTextureUsage) { MTLTextureUsageUnknown = 0x0000, /// 纹理使用的选项是未知的 MTLTextureUsageShaderRead = 0x0001, /// 指示着色器在渲染的任何阶段可以读取纹理 MTLTextureUsageShaderWrite = 0x0002, /// 指示纹理将被计算着色器写入 MTLTextureUsageRenderTarget = 0x0004, /// 指示纹理将在渲染通道中用作颜色、深度或模板渲染目标 MTLTextureUsagePixelFormatView = 0x0010, /// 指示纹理将用于创建新纹理的值 }; 配置多重采样 /** 用于生成 multisampleColorTexture 对象的样本计数；默认值为1 * * @discussion 不同的设备可能支持不同的样本计数值。 * 调用 [MTLDevice -supportsTextureSampleCount:] 来确定设备是否支持指定的样本计数； * @discussion 如果 sampleCount > 1 ： * 视图会创建并配置一个多样本纹理； * currentDrawable 的纹理将被设置为 currentRenderPassDescriptor 中的解析纹理 * 存储操作将被设置为 MTLStoreActionMultisampleResolve */ @property (nonatomic) NSUInteger sampleCount; /** multisampleColorAttachment 的纹理使用策略 * 默认值与推荐值是 MTLTextureUsageRenderTarget * 更改此值将重新创建 multisampleColorAttachment，当前 multisampleColorAttachment 中的数据将丢失 */ @property (nonatomic) MTLTextureUsage multisampleColorAttachmentTextureUsage; 检索渲染目标信息 /** 获取当前渲染通道描述符，由 currentDrawable 的纹理和视图深度、模板、采样缓冲区和清除值生成 * 如果 view.device = nil || currentDrawable = nil，则该属性为 nil； */ @property (nonatomic, readonly, nullable) MTLRenderPassDescriptor *currentRenderPassDescriptor; /** 用于绘制当前帧的 drawable； * @note 如果所有 drawable 都在使用中，则该值为nil; 所以在使用之前需要判断是否为 nil * @更新时机： 在代理方法 -drawInMTKView 结束后，更新 currentDrawable * 在子类重写的 -drawRect: 结束后，更新 currentDrawable * @流程 使用命令编码器 MTLRenderCommandEncoder 将命令编码到 currentDrawable 的纹理中 * 并通过 [commandBuffer -presentDrawable:] 注册 * @性能 尽量减少从获取可绘制对象到提交使用它的命令缓冲区之间的时间间隔。 */ @property (nonatomic, readonly, nullable) id currentDrawable; /** 与 currentDrawable 对相关联的深度测试和模板纹理，被附加到 MTLRenderPassDescriptor * 纹理格式由 depthStencilPixelFormat 的值决定的，如果指定像素格式是 MTLPixelFormatInvalid，则该值是nil。 * 默认值为 nil */ @property (nonatomic, readonly, nullable) id depthStencilTexture; /** 用于渲染的多样本颜色样本纹理，将被解析为currentDrawable的纹理，默认值为 nil * @discussion 纹理格式由 colorPixelFormat 和 sampleCount 决定 * 如果 colorPixelFormat = MTLPixelFormatInvalid || sampleCount multisampleColorTexture; 配置渲染通道 配置渲染通道的一些策略： 1、如果没有使用多重采样 { MTLRenderPassDescriptor *descriptor = [[MTLRenderPassDescriptor alloc] init]; descriptor.colorAttachments[0].texture 指向 currentDrawable 的纹理 descriptor.colorAttachments[0].loadAction = MTLLoadActionClear; descriptor.colorAttachments[0].storeAction = MTLStoreActionStore; } 2、如果使用多重采样 { MTLRenderPassDescriptor *descriptor = [[MTLRenderPassDescriptor alloc] init]; descriptor.colorAttachments[0].texture 指向 multisampleTexture descriptor.colorAttachments[0].resolveTexture 指向 multisampleTexture descriptor.colorAttachments[0].loadAction = MTLLoadActionClear; descriptor.colorAttachments[0].storeAction = MTLStoreActionMultisampleResolve; } 3、如果已经指定了深度或模板目标，渲染通道配置的目标需要满足： { MTLRenderPassDescriptor *descriptor = [[MTLRenderPassDescriptor alloc] init]; descriptor.colorAttachments[0].loadAction = MTLLoadActionClear; descriptor.colorAttachments[0].storeAction = MTLStoreActionDontCare; } 配置绘制行为 /** 视图重新绘制其内容的速率，默认值为每秒 60 帧 * 如果设置 preferredFrameRate，视图将根根据屏幕性能 选择一个尽可能接近的帧率 * @note 建议设置一个它可以持续保持的帧率，视图设置的最高帧率为 60 帧 * @discussion 设置的帧率，是屏幕的最大刷新率的一个影响因素 * 例如屏幕的最大刷新率是60帧/秒，如果设置了较低的帧率，视图可能会选择30、20、15帧每秒或其他因素作为实际的帧率。 */ @property(nonatomic) NSInteger preferredFramesPerSecond; /** 指示绘制循环是否已暂停，默认值为 NO * 如果该值为NO，则视图以 preferredFramesPerSecond 设置的帧速率周期性地重新绘制内容 * 如果为 YES，将在 delegate 将调用 -drawInMTKView: 或者子类重写 -drawRect: 后，重绘其内容 */ @property (nonatomic, getter=isPaused) BOOL paused; /** 指示视图是否响应 -setNeedsDisplay，默认值为 NO * 如果 (enableSetNeedsDisplay && paused) = YES，则响应对 -setNeedsDisplay 的调用 * 此时视图的内部绘制循环被暂停，更新由事件驱动 */ @property (nonatomic) BOOL enableSetNeedsDisplay; /** 立即驱动视图内容的重绘 * 该方法间接调用子类的 -drawRect: 或者 [delegate -drawInMTKView:] * @note 不要在绘图函数中调用该方法 */ - (void)draw; /** 是否使用 Core Animation 事务呈现其内容，默认值为 NO * 确定视图是否将其自身内容的更新与 Core Animation 中的其他内容更改同步 * @discussion 当为 NO 时，layer 的渲染缓冲区的变化会与普通层的更新同步出现在屏幕上。 * 当 YES 时，对 Metal 内容的更改将通过 CATransaction 机制发送到屏幕。 */ @property (nonatomic) BOOL presentsWithTransaction; 释放内存 /// 由于创建的纹理会消耗大量的内存 /// 所以程序进入后台、或者很长时间不显示绘制内容，调用该方法释放 depthStencilTexture 和 multisampleColorTexture 对象 /// 视图在下一次访问 depthStencilTexture 和 multisampleColorTexture 属性时，需要重新创建 - (void)releaseDrawables; Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:18 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLDevice.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLDevice.html","title":"MTLDevice API","keywords":"","body":"MTLDevice MTLDevice 用于绘制图形或进行并行计算的 GPU 接口！ 获取设备 /** 获取系统推荐使用的 Metal device * 在 MacOS 系统会切换到高功率 GPU，支持自动图形切换； * 在其他支持多个GPU的系统上，它将与主显示相关联 */ id __nullable MTLCreateSystemDefaultDevice(void); /** 获取系统中的所有 Metal 设备 * @discussion 这个 API 不会导致系统切换 GPU 设备，应用程序选择合适的标准来决定使用哪个GPU */ NSArray > *MTLCopyAllDevices(void); /** 获取可用的 Metal 设备列表，并为列表的更改(增加，删除等)注册一个通知观察者 * @param observer 接收设备通知的对象，观察者对象由 Metal 保留（retainCount +1 ）！ * 调用 MTLRemoveDeviceObserver() 函数，移除观察者 * @param handler 当收到设备通知时调用的代码块 */ NSArray > *MTLCopyAllDevicesWithObserver(id __nullable __strong * __nonnull observer, MTLDeviceNotificationHandler handler); // 移除之前安装的设备更改通知观察者 void MTLRemoveDeviceObserver(id observer); /** 根据指定标识符获取显示器 * @note 当自动图形切换开启时，返回的设备可能随时改变 */ id CGDirectDisplayCopyCurrentMetalDevice(CGDirectDisplayID display); 查询 GPU 属性 /** 在性能良好的情况下，该设备可以使用多少内存（单位是字节） * @note 如果设备过度使用，导致超过这个阈值，会出现性能损失； * 因此需要保持与此设备对象关联的所有资源小于这个阈值 */ @property (readonly) uint64_t recommendedMaxWorkingSetSize; /** 指示 GPU 是否与 CPU 共享其内存 * @return YES 有些 GPU 没有专用的本地内存，需要与 CPU 共享CPU内存 * @return NO 表示 GPU 有自己的专用内存，此时同步托管资源或将数据复制到与此GPU相关的私有资源可能需要额外的时间 */ @property (readonly) BOOL hasUnifiedMemory; /** 系统 RAM 和专用 GPU内存(VRAM)之间的最高理论传输速率，单位为字节/秒 * @note 对于内置 GPU，这个值是 0 * @discussion 这是由原始数据时钟速率导出的，因此在真实世界的条件下可能无法达到。 */ @property (readonly) uint64_t maxTransferRate; /// 厂商设备的全名 @property (nonnull, readonly) NSString *name; /** 指示设备是否被配置为 headless, 仅在 MacOS 上可用 * @return YES 在包含多个GPU的系统上，该设备不附加任何显示信息 */ @property (readonly, getter=isHeadless) BOOL headless; /** 是否是低功耗的 GPU 设备 * @discussion 有些 Mac 包含多个 GPU，运行时具有不同的性能和能量特征，可以选择符合需求和当前 CPU 状态的 GPU * 如果 MacBook Pro 是靠电池供电运行，又对性能的要求不高，则选择低功耗的 GPU * M1芯片只有一个GPU，运行时兼具高性能和低功耗，因此返回 NO * 通常情况下，对于集成GPU属性是 YES，对于离散GPU属性是 NO */ @property (readonly, getter=isLowPower) BOOL lowPower; /** GPU 是否可移动 * 如果GPU在没有警告的情况下被移除，API 可能会在 MTLDeviceWasRemovedNotification 通知发布之前调用失败 */ @property (readonly, getter=isRemovable) BOOL removable; /** 设备的注册表 ID 值 * 该值对所有任务都是全局的，可以用来跨任务边界标识 GPU * @discussion Metal 设备的 registryID 值对所有任务都是全局的，可以用来跨任务边界识别 GPU */ @property (readonly) uint64_t registryID; /// 枚举值，指明 GPU 相对于主机的位置 @property (readonly) MTLDeviceLocation location; /** GPU位置的更详细说明符：表示图形处理器绑定的槽位或 Thunderbolt 端口 * 对于内置GPU，当GPU为低功耗(lowPower)时，该值为0，否则为 1 * 多个 GPU 有可能有相同的位置和位置号，比如一个卡有多个 GPU，或者多个 eGPU 连接在同一个Thunderbolt端口 */ @property (readonly) NSUInteger locationNumber; /// 枚举 GPU 在 macOS 上的位置 typedef NS_ENUM(NSUInteger, MTLDeviceLocation) { MTLDeviceLocationBuiltIn = 0, /// GPU内置在设备中 MTLDeviceLocationSlot = 1, /// GPU连接到计算机内部的一个插槽 MTLDeviceLocationExternal = 2, /// GPU通过外部接口连接，比如 Thunderbolt MTLDeviceLocationUnspecified = NSUIntegerMax, /// GPU位置未指定或无法确定 }; 创建着色器库 工程中构建的所有 .metal 文件都会被编译到一个默认库中！ /// 获取 mainBundl 的默认库； 如果找不到默认库，返回nil - (nullable id )newDefaultLibrary; /// 获取指定 NSBundle 的默认库 - (nullable id )newDefaultLibraryWithBundle:(NSBundle *)bundle error:(__autoreleasing NSError **)error; /// 获取指定路径的库（加载指定的 .metal 文件） - (nullable id )newLibraryWithFile:(NSString *)filepath error:(__autoreleasing NSError **)error; - (nullable id )newLibraryWithURL:(NSURL *)url error:(__autoreleasing NSError **)error; /// 从 dispatch_data_t 中加载一个.metal 文件 - (nullable id )newLibraryWithData:(dispatch_data_t)data error:(__autoreleasing NSError **)error; /** 从编译指定源字符串中加载一个.metal 文件 * @param source 包含一个或多个Metal函数源代码的字符串。 * @param options 影响源代码编译的选项 * @param completionHandler 当库加载完成时调用的代码块 */ - (nullable id )newLibraryWithSource:(NSString *)source options:(nullable MTLCompileOptions *)options error:(__autoreleasing NSError **)error; - (void)newLibraryWithSource:(NSString *)source options:(nullable MTLCompileOptions *)options completionHandler:(MTLNewLibraryCompletionHandler)completionHandler; 创建缓冲区 创建一个 MTLBuffer 对象！ /// 缓冲区的最大字节数 @property (readonly) NSUInteger maxBufferLength; /** 创建一个指定长度的缓冲区，以 0 填充该块内存 * @param length 指定缓冲区的字节数 * @param options 缓冲策略（CPU或GPU访问） */ - (nullable id )newBufferWithLength:(NSUInteger)length options:(MTLResourceOptions)options; /// 创建一个指定长度的缓冲区，将指定数据复制到该块内存 - (nullable id )newBufferWithBytes:(const void *)pointer length:(NSUInteger)length options:(MTLResourceOptions)options; /** 创建一个指定长度的缓冲区，持有指定数据的地址指针（而非复制该块内存） * @param 该缓冲区被释放时调用的代码块；如果不需要执行操作，则传递 nil； * @note1 地址指针指向的内存块必须是页对齐的；不同的硬件可能具有不同的页面大小，不应该假设总是4千字节； * 通常使用 vm_allocate 或 mmap 分配，不能使用 malloc 分配的内存； * @note2 在释放 MTLBuffer 对象并调用 deallocator 之前，不能释放内存,只能在 deallocator 中释放该块内存； */ - (nullable id )newBufferWithBytesNoCopy:(void *)pointer length:(NSUInteger)length options:(MTLResourceOptions)options deallocator:(void (^ __nullable)(void *pointer, NSUInteger length))deallocator; 创建渲染管道 MTLRenderPipelineState 是 Metal 提供的渲染管道 API ！ /// 同步创建并编译一个新的渲染管道 - (nullable id )newRenderPipelineStateWithDescriptor:(MTLRenderPipelineDescriptor *)descriptor error:(__autoreleasing NSError **)error; typedef void (^MTLNewRenderPipelineStateCompletionHandler)(id __nullable renderPipelineState, NSError * __nullable error); /// 异步创建并编译一个新的渲染管道 - (void)newRenderPipelineStateWithDescriptor:(MTLRenderPipelineDescriptor *)descriptor completionHandler:(MTLNewRenderPipelineStateCompletionHandler)completionHandler; /// 当创建渲染管道的逻辑完成时调用的代码块: 返回渲染管道，反射信息，或者错误信息 typedef void (^MTLNewRenderPipelineStateWithReflectionCompletionHandler)(id __nullable renderPipelineState, MTLRenderPipelineReflection * __nullable reflection, NSError * __nullable error); /** 创建并编译一个新的渲染管道，并返回额外的 reflection 信息 * @param reflection 指针指向的位置将被一个新对象填充，包含顶点函数、片段函数的反射数据、函数参数的详细信息。 * 如果管道状态不能被编译，则返回nil */ - (nullable id )newRenderPipelineStateWithDescriptor:(MTLRenderPipelineDescriptor *)descriptor options:(MTLPipelineOption)options reflection:(MTLAutoreleasedRenderPipelineReflection * __nullable)reflection error:(__autoreleasing NSError **)error; - (void)newRenderPipelineStateWithDescriptor:(MTLRenderPipelineDescriptor *)descriptor options:(MTLPipelineOption)options completionHandler:(MTLNewRenderPipelineStateWithReflectionCompletionHandler)completionHandler; /** 为瓦片渲染器创建渲染管道，相关的反射信息 * @param descriptor 包含瓦片函数的描述符对象 * @param options 要返回的反射信息的类型 */ - (void)newRenderPipelineStateWithTileDescriptor:(MTLTileRenderPipelineDescriptor *)descriptor options:(MTLPipelineOption)options completionHandler:(MTLNewRenderPipelineStateWithReflectionCompletionHandler)completionHandler; - (nullable id )newRenderPipelineStateWithTileDescriptor:(MTLTileRenderPipelineDescriptor*)descriptor options:(MTLPipelineOption)options reflection:(MTLAutoreleasedRenderPipelineReflection * __nullable)reflection error:(__autoreleasing NSError **)error; typedef NS_OPTIONS(NSUInteger, MTLPipelineOption) { MTLPipelineOptionNone = 0, /// 不需提供任何 reflection 信息 /// 提供了MTLArgument的所有属性，除了bufferStructType和bufferPointerType为 nil /// 要获得这些详细的缓冲区类型属性，还必须设置 MTLPipelineOptionBufferTypeInfo MTLPipelineOptionArgumentInfo = 1 创建纹理 /// 创建一个纹理, 使用私有存储存储纹理数据, 已经为纹理图像数据分配了存储空间 - (nullable id )newTextureWithDescriptor:(MTLTextureDescriptor *)descriptor; /** 创建一个纹理, 使用 IOSurface 存储纹理数据 * @param iosurface 用于纹理存储的 IOSurface 引用 * @param plane 在 IOSurface中使用的平面 */ - (nullable id )newTextureWithDescriptor:(MTLTextureDescriptor *)descriptor iosurface:(IOSurfaceRef)iosurface plane:(NSUInteger)plane; /** 创建一个可以跨进程共享的纹理 * @discussion 可共享纹理必须使用私有存储模式 MTLResourceStorageModePrivate 创建 * 通过创建一个纹理句柄 MTLSharedTextureHandle 并将其传递给其他进程，实现进程共享； * 但不能在不同的 GPU 之间共享 */ - (nullable id )newSharedTextureWithDescriptor:(MTLTextureDescriptor *)descriptor; /** 从接收到的纹理句柄 sharedHandle 重新创建共享的纹理 * @param sharedHandle 进程空间共享纹理的句柄 (但仍然在相同的 GPU 范围内) * @note 这个方法应该在共享纹理最初创建的 MTLDevice 上调用。 * 要确定它是哪个设备，可以使用 MTLSharedTextureHandle 对象的设备属性 */ - (nullable id )newSharedTextureWithHandle:(MTLSharedTextureHandle *)sharedHandle; 创建命令队列 /// 创建一个新的命令队列 : 此方法创建的命令队列最多只允许 64 个未完成的命令缓冲区 - (nullable id )newCommandQueue; /// 设置命令队列的最大缓冲区数量 - (nullable id )newCommandQueueWithMaxCommandBufferCount:(NSUInteger)maxCommandBufferCount; 创建计算管道 /// @param MTLComputePipelineDescriptor 创建计算管道的描述符 /// @param reflection 指定反射信息的类型 /// @param completionHandler 完成计算管道的创建时，调用的代码块 /// @param MTLFunction 要编译到计算管道的函数对象 /// 同步创建并编译计算管道 - (nullable id )newComputePipelineStateWithFunction:(id )computeFunction error:(__autoreleasing NSError **)error; - (nullable id )newComputePipelineStateWithFunction:(id )computeFunction options:(MTLPipelineOption)options reflection:(MTLAutoreleasedComputePipelineReflection * __nullable)reflection error:(__autoreleasing NSError **)error; - (nullable id )newComputePipelineStateWithDescriptor:(MTLComputePipelineDescriptor *)descriptor options:(MTLPipelineOption)options reflection:(MTLAutoreleasedComputePipelineReflection * __nullable)reflection error:(__autoreleasing NSError **)error; /// 异步创建并编译计算管道 - (void)newComputePipelineStateWithFunction:(id )computeFunction completionHandler:(MTLNewComputePipelineStateCompletionHandler)completionHandler; - (void)newComputePipelineStateWithFunction:(id )computeFunction options:(MTLPipelineOption)options completionHandler:(MTLNewComputePipelineStateWithReflectionCompletionHandler)completionHandler; - (void)newComputePipelineStateWithDescriptor:(MTLComputePipelineDescriptor *)descriptor options:(MTLPipelineOption)options completionHandler:(MTLNewComputePipelineStateWithReflectionCompletionHandler)completionHandler; typedef void (^MTLNewComputePipelineStateCompletionHandler)(id __nullable computePipelineState, NSError * __nullable error); typedef void (^MTLNewComputePipelineStateWithReflectionCompletionHandler)(id __nullable computePipelineState, MTLComputePipelineReflection * __nullable reflection, NSError * __nullable error); 查找连接的 GPU 组 /** 同一对等体组的64位唯一标识符 * 如果该值为0，表示该GPU不属于对等体组；否则属于对等体组 * @discussion 一些 Mac 有多个GPU直接连接，允许数据从一个GPU传输到另一个GPU，而不需要先进入系统内存。 * 使用这种方式连接GPU时，它们属于同一对等体组。 */ @property (readonly) uint64_t peerGroupID; /// 对等体组中的设备总数 @property (readonly) uint32_t peerCount; /// 所有属于同一对等体组的金属设备在组内都有一个从 0 到 peerCount - 1 的唯一索引值 @property (readonly) uint32_t peerIndex; 在连接的 GPU 组之间传输数据 在连接的 GPU 组之间使用高速连接，可以快速传输数据。 从 macOS 10.15 开始，一些Mac系统直接将图形处理器 GPU 相互连接，允许您在它们之间快速传输数据。 这些连接不仅速度更快，而且还避免了使用CPU和GPU之间的内存总线，让它可以用于其他任务。 如果你的应用程序使用多个GPU，测试它们是否连接，当它们连接时，使用这里描述的传输机制。 当GPU相互连接时，它们被称为在同一个对等组中。通过读取设备对象的 peerGroupID 来确定GPU是否在对等组中。非零值表示该GPU在对等体组中。 bool isMemberOfAnyPeerGroup(id device) { return (device.peerGroupID != 0); } 同一对等体组中的GPU共享相同的 peerGroupID bool areMembersOfSamePeerGroup(id deviceA, id deviceB) { return (isMemberOfAnyPeerGroup(deviceA) && deviceA.peerGroupID == deviceB.peerGroupID); } 通过对该ID进行过滤，可以获得与对等体组相关联的所有设备列表。 NSArray>* devicesInPeerGroup(uint64_t peerGroupID) { if (peerGroupID == 0) { return @[]; } return [MTLCopyAllDevices() filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@\"SELF.peerGroupID == %uul\", peerGroupID]]; } 将资源拷贝到需要访问资源的GPU上 在Metal中，资源是由设备对象创建的，并且总是与创建它们的设备对象相关联。 对等体组不会改变这种联系。如果一个资源与一个设备对象相关联，而你想在另一个设备对象上访问它，你需要将数据复制到与第二个设备对象相关联的资源中。 要在一个对等组的成员之间复制数据，在连接到你想要复制的资源的第二个GPU上创建一个remote view。 remote view 是一个资源对象，它不包含自己的存储;它引用了原始GPU上的存储。 您只能使用remote view来复制数据;在其他Metal命令中使用它们会导致错误。 创建资源的 RemoteBufferView 要创建资源的 RemoteBufferView，创建资源视图的设备对象必须与创建资源的设备对象共享相同的peerGroupID。 另外，该资源必须使用 MTLStorageModePrivate 存储模式，或者需要 IOSurface 支持。 要创建一个缓冲区视图，调用 -newRemoteBufferViewForDevice: 方法 : id remoteBufferView = [sourceBuffer newRemoteBufferViewForDevice:otherDevice]; 类似地，要创建一个纹理视图，调用 -newRemoteTextureViewForDevice: 方法 id remoteTextureView = [sourceTexture newRemoteTextureViewForDevice:otherDevice]; 在已连接的 GPU 之间复制数据 创建一个 MTLBlitCommandEncoder 并编码一个复制命令。这个复制命令的源是远程视图对象: id blitEncoder = [commandBuffer blitCommandEncoder]; [blitEncoder copyFromBuffer:remoteBufferView sourceOffset:0 toBuffer:destinationBuffer destinationOffset:0 size:remoteBufferView.allocatedSize]; [blitEncoder copyFromTexture:remoteTextureView toTexture:destinationTexture]; [blitEncoder endEncoding]; 如下图所示，有三个资源对象:包含数据的原始资源、引用数据的远程视图和接收数据的资源。 同步资源访问 点对点传输中使用的Blit命令遵循所有GPU上的同步规则。然而，它们不会自动与源GPU上运行的任何命令同步。 如果编码了修改源资源的命令，在执行blit命令将数据传输到其他GPU之前，请确保这些命令已经完成。 这与通过系统内存在GPU之间传输资源时所做的相同。 要在不同设备对象之间同步命令，需要使用共享事件！ 确定线程组限制 调用计算管道时 Metal 选择在 1D、2D 或 3D 网格上执行内核计算函数；网格中的每个点代表内核函数的一个实例，称为线程。 多个线程被组织成 线程组 一起执行，线程组之间共享一块内存。 一个 GPU 支持的线程组大小与线程数是有限制的！ /// 可用的线程组最大内存，以字节为单位 @property (readonly) NSUInteger maxThreadgroupMemoryLength; /// 每个线程组中的最大线程数 @property (readonly) MTLSize maxThreadsPerThreadgroup; 创建深度测试或模板测试 渲染管道处理顺序：顶点着色器 —> 片段着色器 —> 模板测试 —> 深度测试 ！ /// 创建包含深度测试和模板测试的对象 - (nullable id )newDepthStencilStateWithDescriptor:(MTLDepthStencilDescriptor *)descriptor; 查询特征集和 GPU 系列 /*! @method supportsFamily: @abstract Returns TRUE if the GPU Family is supported by this MTLDevice. */ - (BOOL)supportsFamily:(MTLGPUFamily)gpuFamily API_AVAILABLE(macos(10.15), ios(13.0)); /// 是否支持指定功能集 - (BOOL)supportsFeatureSet:(MTLFeatureSet)featureSet; typedef NS_ENUM(NSInteger, MTLGPUFamily) { MTLGPUFamilyApple1 = 1001, MTLGPUFamilyApple2 = 1002, MTLGPUFamilyApple3 = 1003, MTLGPUFamilyApple4 = 1004, MTLGPUFamilyApple5 = 1005, MTLGPUFamilyApple6 = 1006, MTLGPUFamilyApple7 = 1007, MTLGPUFamilyMac1 = 2001, MTLGPUFamilyMac2 = 2002, MTLGPUFamilyCommon1 = 3001, MTLGPUFamilyCommon2 = 3002, MTLGPUFamilyCommon3 = 3003, MTLGPUFamilyMacCatalyst1 = 4001, MTLGPUFamilyMacCatalyst2 = 4002, } API_AVAILABLE(macos(10.15), ios(13.0)); typedef NS_ENUM(NSUInteger, MTLFeatureSet) { MTLFeatureSet_iOS_GPUFamily1_v1 API_AVAILABLE(ios(8.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 0, MTLFeatureSet_iOS_GPUFamily2_v1 API_AVAILABLE(ios(8.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 1, MTLFeatureSet_iOS_GPUFamily1_v2 API_AVAILABLE(ios(9.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 2, MTLFeatureSet_iOS_GPUFamily2_v2 API_AVAILABLE(ios(9.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 3, MTLFeatureSet_iOS_GPUFamily3_v1 API_AVAILABLE(ios(9.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 4, MTLFeatureSet_iOS_GPUFamily1_v3 API_AVAILABLE(ios(10.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 5, MTLFeatureSet_iOS_GPUFamily2_v3 API_AVAILABLE(ios(10.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 6, MTLFeatureSet_iOS_GPUFamily3_v2 API_AVAILABLE(ios(10.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 7, MTLFeatureSet_iOS_GPUFamily1_v4 API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 8, MTLFeatureSet_iOS_GPUFamily2_v4 API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 9, MTLFeatureSet_iOS_GPUFamily3_v3 API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 10, MTLFeatureSet_iOS_GPUFamily4_v1 API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 11, MTLFeatureSet_iOS_GPUFamily1_v5 API_AVAILABLE(ios(12.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 12, MTLFeatureSet_iOS_GPUFamily2_v5 API_AVAILABLE(ios(12.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 13, MTLFeatureSet_iOS_GPUFamily3_v4 API_AVAILABLE(ios(12.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 14, MTLFeatureSet_iOS_GPUFamily4_v2 API_AVAILABLE(ios(12.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 15, MTLFeatureSet_iOS_GPUFamily5_v1 API_AVAILABLE(ios(12.0)) API_UNAVAILABLE(macos, macCatalyst, tvos) = 16, MTLFeatureSet_macOS_GPUFamily1_v1 API_AVAILABLE(macos(10.11)) API_UNAVAILABLE(ios) API_UNAVAILABLE(macCatalyst) = 10000, MTLFeatureSet_OSX_GPUFamily1_v1 API_AVAILABLE(macos(10.11)) API_UNAVAILABLE(ios) = MTLFeatureSet_macOS_GPUFamily1_v1, // deprecated MTLFeatureSet_macOS_GPUFamily1_v2 API_AVAILABLE(macos(10.12)) API_UNAVAILABLE(ios) API_UNAVAILABLE(macCatalyst) = 10001, MTLFeatureSet_OSX_GPUFamily1_v2 API_AVAILABLE(macos(10.12)) API_UNAVAILABLE(ios) = MTLFeatureSet_macOS_GPUFamily1_v2, // deprecated MTLFeatureSet_macOS_ReadWriteTextureTier2 API_AVAILABLE(macos(10.12)) API_UNAVAILABLE(ios) = 10002, MTLFeatureSet_OSX_ReadWriteTextureTier2 API_AVAILABLE(macos(10.12)) API_UNAVAILABLE(ios) = MTLFeatureSet_macOS_ReadWriteTextureTier2, // deprecated MTLFeatureSet_macOS_GPUFamily1_v3 API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios) API_UNAVAILABLE(macCatalyst) = 10003, MTLFeatureSet_macOS_GPUFamily1_v4 API_AVAILABLE(macos(10.14)) API_UNAVAILABLE(ios) API_UNAVAILABLE(macCatalyst) = 10004, MTLFeatureSet_macOS_GPUFamily2_v1 API_AVAILABLE(macos(10.14)) API_UNAVAILABLE(ios) API_UNAVAILABLE(macCatalyst) = 10005, MTLFeatureSet_tvOS_GPUFamily1_v1 API_AVAILABLE(tvos(9.0)) API_UNAVAILABLE(macos, ios) = 30000, MTLFeatureSet_TVOS_GPUFamily1_v1 API_AVAILABLE(tvos(9.0)) API_UNAVAILABLE(macos, ios) = MTLFeatureSet_tvOS_GPUFamily1_v1, // deprecated MTLFeatureSet_tvOS_GPUFamily1_v2 API_AVAILABLE(tvos(10.0)) API_UNAVAILABLE(macos, ios) = 30001, MTLFeatureSet_tvOS_GPUFamily1_v3 API_AVAILABLE(tvos(11.0)) API_UNAVAILABLE(macos, ios) = 30002, MTLFeatureSet_tvOS_GPUFamily2_v1 API_AVAILABLE(tvos(11.0)) API_UNAVAILABLE(macos, ios) = 30003, MTLFeatureSet_tvOS_GPUFamily1_v4 API_AVAILABLE(tvos(12.0)) API_UNAVAILABLE(macos, ios) = 30004, MTLFeatureSet_tvOS_GPUFamily2_v2 API_AVAILABLE(tvos(12.0)) API_UNAVAILABLE(macos, ios) = 30005, } API_AVAILABLE(macos(10.11), ios(8.0), tvos(9.0)); 查询参数缓冲区支持 /*! @property argumentBuffersSupport @abstract Query support tier for Argument Buffers. @return MTLArgumentBuffersTier enum value. */ @property (readonly) MTLArgumentBuffersTier argumentBuffersSupport API_AVAILABLE(macos(10.13), ios(11.0)); /*! @property maxArgumentBufferSamplerCount @abstract The maximum number of unique argument buffer samplers per app. @discussion This limit is only applicable to samplers that have their supportArgumentBuffers property set to true. A MTLSamplerState object is considered unique if the configuration of its originating MTLSamplerDescriptor properties is unique. For example, two samplers with equal minFilter values but different magFilter values are considered unique. */ @property (readonly) NSUInteger maxArgumentBufferSamplerCount API_AVAILABLE(macos(10.14), ios(12.0)); 查询计数器采样支持 /*! @property counterSets @abstract Returns the set of Counter Sets exposed by the device. */ @property (readonly, nullable) NSArray>* counterSets API_AVAILABLE(macos(10.15), ios(14.0)); /*! @method supportsCounterSampling: @abstract Query device for counter sampling points support. @param samplingPoint Query index @return BOOL value. If YES, the device supports counter sampling at given point. */ - (BOOL)supportsCounterSampling:(MTLCounterSamplingPoint)samplingPoint API_AVAILABLE(macos(11.0), ios(14.0)); /*! @enum MTLCounterSamplingPoint @abstract MTLCounterSamplingPoint determines type of sampling points that are supported on given device. @constant MTLCounterSamplingPointAtStageBoundary Counter sampling points at render, compute, and blit command encoder stage boundary are supported. @constant MTLCounterSamplingPointAtDrawBoundary Counter sampling at draw boundary is supported, render encoder method sampleCountersInBuffer can be used for sampling. @constant MTLCounterSamplingPointAtDispatchBoundary Counter sampling at compute dispatch boundary is supported, compute encoder method sampleCountersInBuffer can be used for sampling. @constant MTLCounterSamplingPointAtTileDispatchBoundary Counter sampling at tile shader dispatch boundary is supported. @constant MTLCounterSamplingPointAtBlitBoundary Counter sampling at blit boundary is supported, blit encoder method sampleCountersInBuffer can be used for sampling. */ typedef NS_ENUM(NSUInteger, MTLCounterSamplingPoint) { MTLCounterSamplingPointAtStageBoundary, MTLCounterSamplingPointAtDrawBoundary, MTLCounterSamplingPointAtDispatchBoundary, MTLCounterSamplingPointAtTileDispatchBoundary, MTLCounterSamplingPointAtBlitBoundary } API_AVAILABLE(macos(11.0), ios(14.0)); 查询动态库和函数支持 /*! @property supportsDynamicLibraries @abstract Query device support for compiling dynamic libraries. @return BOOL value. If YES, the device supports compiling dynamic libraries. If NO, the devices does not. */ @property(readonly) BOOL supportsDynamicLibraries API_AVAILABLE(macos(11.0), ios(14.0)); @property (readonly) BOOL supportsFunctionPointers API_AVAILABLE(macos(11.0), ios(14.0)); @property(readonly) BOOL supportsFunctionPointersFromRender; 查询光线追踪支持 @property (readonly) BOOL supportsRaytracing; @property(readonly) BOOL supportsRaytracingFromRender; 查询渲染特性支持 /*! @property barycentricsSupported @abstract Query device for Barycentric coordinates support; deprecated, use supportsShaderBarycentricCoordinates @return BOOL value. If YES, the device barycentric coordinates */ @property(readonly, getter=areBarycentricCoordsSupported) BOOL barycentricCoordsSupported API_AVAILABLE(macos(10.15)) API_UNAVAILABLE(ios); /*! @property programmableSaplePositionsSupported @abstract Query device for programmable sample position support. @return BOOL value. If YES, the device supports programmable sample positions. If NO, the device does not. */ @property (readonly, getter=areProgrammableSamplePositionsSupported) BOOL programmableSamplePositionsSupported API_AVAILABLE(macos(10.13), ios(11.0)); /*! @method getDefaultSamplePositions:count: @abstract Retrieve the default sample positions. @param positions The destination array for default sample position data. @param count Specifies the sample count for which to retrieve the default positions, the length of the positions array, and must be set to a valid sample count. */ - (void)getDefaultSamplePositions:(MTLSamplePosition *)positions count:(NSUInteger)count API_AVAILABLE(macos(10.13), ios(11.0)); /*! @property rasterOrderGroupsSupported @abstract Query device for raster order groups support. @return BOOL value. If YES, the device supports raster order groups. If NO, the device does not. */ @property (readonly, getter=areRasterOrderGroupsSupported) BOOL rasterOrderGroupsSupported API_AVAILABLE(macos(10.13), ios(11.0)); /*! @property supports32BitMSAA @abstract Query device for 32-bit MSAA texture support. Specifically, added support for allocating 32-bit Integer format textures (R32Uint, R32Sint, RG32Uint, RG32Sint, RGBA32Uint, and RGBA32Sint) and resolving 32-bit Float format textures (R32Float, RG32Float, and RGBA32Float). @return BOOL value. If YES, the device supports these additional 32-bit MSAA texture capabilities. If NO, the devices does not. */ @property(readonly) BOOL supports32BitMSAA API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property supportsPullModelInterpolation @abstract Query device for pull model interpolation support which allows a fragment shader to compute multiple interpolations (at center, at centroid, at offset, at sample) of a fragment input. @return BOOL value. If YES, the device supports pull model interpolation. If NO, the device does not. */ @property(readonly) BOOL supportsPullModelInterpolation API_AVAILABLE(macos(11.0),ios(14.0)); /*! @property supportsShaderBarycentricCoordinates @abstract Query device for Barycentric Coordinates support. @return BOOL value. If YES, the device supports barycentric coordinates. If NO, the device does not. */ @property (readonly) BOOL supportsShaderBarycentricCoordinates API_AVAILABLE(macos(10.15)) API_UNAVAILABLE(ios); /*! @property supportsVertexAmplificationCount: @abstract Query device for vertex amplification support. @param count The amplification count to check @return BOOL value. If YES, the device supports vertex amplification with the given count. If NO, the device does not. */ - (BOOL)supportsVertexAmplificationCount:(NSUInteger)count API_AVAILABLE(macos(10.15.4), ios(13.0), macCatalyst(13.4)); 查询纹理和采样器支持 /*! @property depth24Stencil8PixelFormatSupported @abstract If YES, device supports MTLPixelFormatDepth24Unorm_Stencil8. */ @property (readonly, getter=isDepth24Stencil8PixelFormatSupported) BOOL depth24Stencil8PixelFormatSupported API_AVAILABLE(macos(10.11), macCatalyst(13.0)) API_UNAVAILABLE(ios); /*! @property supports32BitFloatFiltering @abstract Query device for 32-bit Float texture filtering support. Specifically, R32Float, RG32Float, and RGBA32Float. @return BOOL value. If YES, the device supports filtering 32-bit Float textures. If NO, the device does not. */ @property(readonly) BOOL supports32BitFloatFiltering API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property supportsBCTextureCompression @abstract Query device for BC Texture format support @return BOOL value. If YES, the device supports compressed BC Texture formats. If NO, the device does not. */ @property (readonly) BOOL supportsBCTextureCompression API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property supportsQueryTextureLOD @abstract Query device for whether it supports the `calculate_clampled_lod` and `calculate_unclamped_lod` Metal shading language functionality. @return BOOL value. If YES, the device supports the calculate LOD functionality. If NO, the device does not. */ @property (readonly) BOOL supportsQueryTextureLOD API_AVAILABLE(macos(11.0), ios(14.0)); /*! @method supportsTextureSampleCount: @brief Query device if it support textures with a given sampleCount. @return BOOL value. If YES, device supports the given sampleCount for textures. If NO, device does not support the given sampleCount. */ - (BOOL)supportsTextureSampleCount:(NSUInteger)sampleCount API_AVAILABLE(macos(10.11), ios(9.0)); /*! @property readWriteTextureSupport @abstract Query support tier for read-write texture formats. @return MTLReadWriteTextureTier enum value. */ @property (readonly) MTLReadWriteTextureTier readWriteTextureSupport API_AVAILABLE(macos(10.13), ios(11.0)); /*! @method minimumLinearTextureAlignmentForPixelFormat: @abstract Returns the minimum alignment required for offset and rowBytes when creating a linear texture. An error is thrown for queries with invalid pixel formats (depth, stencil, or compressed formats). */ - (NSUInteger)minimumLinearTextureAlignmentForPixelFormat:(MTLPixelFormat)format API_AVAILABLE(macos(10.13), ios(11.0)); /*! @method minimumTextureBufferAlignmentForPixelFormat: @abstract Returns the minimum alignment required for offset and rowBytes when creating a texture buffer from a buffer. */ - (NSUInteger)minimumTextureBufferAlignmentForPixelFormat:(MTLPixelFormat)format API_AVAILABLE(macos(10.14), ios(12.0)); 为光线追踪创建加速结构 - (MTLAccelerationStructureSizes)accelerationStructureSizesWithDescriptor:(MTLAccelerationStructureDescriptor *)descriptor API_AVAILABLE(macos(11.0), ios(14.0)); - (nullable id )newAccelerationStructureWithSize:(NSUInteger)size API_AVAILABLE(macos(11.0), ios(14.0)); - (nullable id )newAccelerationStructureWithDescriptor:(MTLAccelerationStructureDescriptor *)descriptor API_AVAILABLE(macos(11.0), ios(14.0)); /** * @brief Describes the memory requirements for an acceleration structure */ typedef struct { /** * @brief The required size, in bytes, of the built acceleration structure */ NSUInteger accelerationStructureSize; /** * @brief The required size, in bytes, of the scratch buffer used to build the acceleration structure */ NSUInteger buildScratchBufferSize; /** * @brief The required size, in bytes, of the scratch buffer used to refit the acceleration structure */ NSUInteger refitScratchBufferSize; } MTLAccelerationStructureSizes; 创建参数缓冲区编码器 /*! * @method newArgumentEncoderWithArguments:count: * @abstract Creates an argument encoder for an array of argument descriptors which will be encoded sequentially. */ - (nullable id )newArgumentEncoderWithArguments:(NSArray *)arguments; 创建二进制着色器档案 /*! @method newBinaryArchiveWithDescriptor:error: @abstract Creates a MTLBinaryArchive using the configuration in the descriptor. @see MTLBinaryArchive @param descriptor The descriptor for the configuration of the binary archive to create. @param error If an error occurs during creation, this parameter is updated to describe the failure. @return On success, the created MTLBinaryArchive. On failure, nil. */ - (nullable id) newBinaryArchiveWithDescriptor:(MTLBinaryArchiveDescriptor*)descriptor error:(NSError**)error API_AVAILABLE(macos(11.0), ios(14.0)); 创建计数器样本缓冲区 /*! @method newCounterSampleBufferWithDescriptor:error: @abstract Given a counter sample buffer descriptor, allocate a new counter sample buffer. This may return nil if the counters may not all be collected simultaneously. @param descriptor The descriptor to create a sample buffer for @param error An error return on failure. */ - (nullable id) newCounterSampleBufferWithDescriptor:(MTLCounterSampleBufferDescriptor*)descriptor error:(NSError**)error API_AVAILABLE(macos(10.15), ios(14.0)); 创建动态着色器库 /*! @method newDynamicLibrary:error: @abstract Creates a MTLDynamicLibrary by compiling the code in a MTLLibrary. @see MTLDynamicLibrary @param library The MTLLibrary from which to compile code. This library must have .type set to MTLLibraryTypeDynamic. @param error If an error occurs during creation, this parameter is updated to describe the failure. @return On success, the MTLDynamicLibrary containing compiled code. On failure, nil. */ - (nullable id) newDynamicLibrary:(id)library error:(NSError **) error API_AVAILABLE(macos(11.0), ios(14.0)); /*! @method newDynamicLibraryWithURL:error: @abstract Creates a MTLDynamicLibrary by loading compiled code from a file. @see MTLDynamicLibrary @param url The file URL from which to load. If the file contains no compiled code for this device, compilation is attempted as with newDynamicLibrary:error: @param error If an error occurs during creation, this parameter is updated to describe the failure. @return On success, the MTLDynamicLibrary containing compiled code (either loaded or compiled). On failure, nil. */ - (nullable id) newDynamicLibraryWithURL:(NSURL *)url error:(NSError **) error API_AVAILABLE(macos(11.0), ios(14.0)); 创建事件 /*! @method newEvent @abstract Returns a new single-device non-shareable Metal event object */ - (nullable id )newEvent API_AVAILABLE(macos(10.14), ios(12.0)); /*! @method newSharedEvent @abstract Returns a shareable multi-device event. */ - (nullable id )newSharedEvent API_AVAILABLE(macos(10.14), ios(12.0)); /*! @method newSharedEventWithHandle @abstract Creates a shareable multi-device event from an existing shared event handle. */ - (nullable id )newSharedEventWithHandle:(MTLSharedEventHandle *)sharedEventHandle API_AVAILABLE(macos(10.14), ios(12.0)); 创建栅栏 MTLFence 对象用于跨命令编码器跟踪和管理子分配的资源依赖性。资源依赖性随着资源由不同命令生成和使用而出现，无论这些命令是编码到同一队列还是不同队列。 MTLFence 捕获GPU工作到特定时间点；当GPU遇到MTLFence时，它必须等到所有捕获的工作完成后再继续执行。 /// 创建栅栏: 主要用于跟踪目的，仅支持GPU内部跟踪，而不支持CPU和GPU之间的跟踪 /// MTLFence 可以重复更新，硬件管理 MTLFence 更新以防止死锁 - (nullable id )newFence; 创建间接命令缓冲区 /*! * @method newIndirectCommandBufferWithDescriptor:maxCommandCount:options * @abstract Creates a new indirect command buffer with the given descriptor and count. * @param descriptor The descriptor encodes the maximum logical stride of each command. * @param maxCount The maximum number of commands that this buffer can contain. * @param options The options for the indirect command buffer. * @discussion The returned buffer can be safely executed without first encoding into (but is wasteful). */ - (nullable id )newIndirectCommandBufferWithDescriptor:(MTLIndirectCommandBufferDescriptor*)descriptor maxCommandCount:(NSUInteger)maxCount options:(MTLResourceOptions)options; 创建光栅化率图 /*! @method supportsRasterizationRateMapWithLayerCount: @abstract Query device for variable rasterization rate support with the given number of layers. @param layerCount The number of layers for which to query device support. @return YES if the device supports creation of rendering using a MTLRasterizationRateMap with the given number of layers. */ -(BOOL)supportsRasterizationRateMapWithLayerCount:(NSUInteger)layerCount API_AVAILABLE(macos(10.15.4), ios(13.0), macCatalyst(13.4)); /*! @method newRasterizationRateMapWithDescriptor: @abstract Creates a new variable rasterization rate map with the given descriptor. @discussion If '[self supportsRasterizationRateMapWithLayerCount:descriptor.layerCount]' returns NO, or descriptor.screenSize describes an empty region, the result will always be nil. @return A MTLRasterizationRateMap instance that can be used for rendering on this MTLDevice, or nil if the device does not support the combination of parameters stored in the descriptor. */ -(nullable id)newRasterizationRateMapWithDescriptor:(MTLRasterizationRateMapDescriptor*)descriptor API_AVAILABLE(macos(10.15.4), ios(13.0), macCatalyst(13.4)); 创建资源堆 /*! @method heapTextureSizeAndAlignWithDescriptor: @abstract Determine the byte size of textures when sub-allocated from a heap. @discussion This method can be used to help determine the required heap size. */ - (MTLSizeAndAlign)heapTextureSizeAndAlignWithDescriptor:(MTLTextureDescriptor *)desc API_AVAILABLE(macos(10.13), ios(10.0)); /*! @method heapBufferSizeAndAlignWithLength:options: @abstract Determine the byte size of buffers when sub-allocated from a heap. @discussion This method can be used to help determine the required heap size. */ - (MTLSizeAndAlign)heapBufferSizeAndAlignWithLength:(NSUInteger)length options:(MTLResourceOptions)options API_AVAILABLE(macos(10.13), ios(10.0)); /*! @method newHeapWithDescriptor: @abstract Create a new heap with the given descriptor. */ - (nullable id )newHeapWithDescriptor:(MTLHeapDescriptor *)descriptor API_AVAILABLE(macos(10.13), ios(10.0)); 创建采样器 /// 创建一个采样器 - (nullable id )newSamplerStateWithDescriptor:(MTLSamplerDescriptor *)descriptor; 管理 GPU 内存 /// 在此当前 GPU 上为此进程分配的所有资源的字节大小 @property (readonly) NSUInteger currentAllocatedSize; 读取时间戳 #if defined(MTL_TIMESTAMP_AS_NSUINTEGER) && MTL_TIMESTAMP_AS_NSUINTEGER typedef NSUInteger MTLTimestamp; #else typedef uint64_t MTLTimestamp; #endif /*! @method sampleTimestamps:gpuTimestamp: @abstract Sample the CPU and GPU timestamps as closely as possible. @param cpuTimestamp The timestamp on the CPU @param gpuTimestamp The timestamp on the GPU */ -(void)sampleTimestamps:(MTLTimestamp *)cpuTimestamp gpuTimestamp:(MTLTimestamp *)gpuTimestamp API_AVAILABLE(macos(10.15), ios(14.0)); 使用稀疏纹理平铺 //Keep around to keep building /*! * @method sparseTileSizeWithTextureType:pixelFormat:sampleCount: * @abstract Returns tile size for sparse texture with given type, pixel format and sample count. */ -(MTLSize) sparseTileSizeWithTextureType:(MTLTextureType)textureType pixelFormat:(MTLPixelFormat)pixelFormat sampleCount:(NSUInteger)sampleCount API_AVAILABLE(macos(11.0), macCatalyst(14.0), ios(13.0)); /*! @property sparseTileSizeInBytes @abstract Returns the number of bytes required to map one sparse texture tile. */ @property (readonly) NSUInteger sparseTileSizeInBytes API_AVAILABLE(macos(11.0), macCatalyst(14.0), ios(13.0)); @optional /*! * @method convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions: * @abstract Converts regions in pixels to regions in sparse tiles using specified alignment mode. Tile size can be obtained from tileSizeWithTextureType:pixelFormat:sampleCount: method. */ -(void) convertSparsePixelRegions:(const MTLRegion[_Nonnull])pixelRegions toTileRegions:(MTLRegion[_Nonnull])tileRegions withTileSize:(MTLSize)tileSize alignmentMode:(MTLSparseTextureRegionAlignmentMode)mode numRegions:(NSUInteger)numRegions API_AVAILABLE(macos(11.0), macCatalyst(14.0), ios(13.0)); /*! * @method convertSparseTileRegions:toPixelRegions:withTileSize:numRegions: * @abstract Convertes region in sparse tiles to region in pixels Tile size can be obtained from tileSizeWithTextureType:pixelFormat:sampleCount: method. */ -(void) convertSparseTileRegions:(const MTLRegion[_Nonnull])tileRegions toPixelRegions:(MTLRegion[_Nonnull])pixelRegions withTileSize:(MTLSize)tileSize numRegions:(NSUInteger)numRegions API_AVAILABLE(macos(11.0), macCatalyst(14.0), ios(13.0)); /*! @enum MTLSparseTextureRegionAlignmentMode @abstract MTLSparseTextureRegionAlignmentMode determines type of alignment used when converting from pixel region to tile region. */ typedef NS_ENUM(NSUInteger, MTLSparseTextureRegionAlignmentMode) { MTLSparseTextureRegionAlignmentModeOutward = 0, MTLSparseTextureRegionAlignmentModeInward = 1, } API_AVAILABLE(macos(11.0), macCatalyst(14.0), ios(13.0)); 实例属性 @property(readonly) BOOL supportsPrimitiveMotionBlur; @property(readonly) BOOL supportsRenderDynamicLibraries; 实例方法 - (id)newLibraryWithStitchedDescriptor:(MTLStitchedLibraryDescriptor *)descriptor error:(NSError * _Nullable *)error; - (void)newLibraryWithStitchedDescriptor:(MTLStitchedLibraryDescriptor *)descriptor completionHandler:(MTLNewLibraryCompletionHandler)completionHandler; /*! @brief Type for device notifications */ typedef NSString *MTLDeviceNotificationName NS_STRING_ENUM API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios); /*! @brief This notification is posted when a new Metal device is added to the system */ MTL_EXTERN MTLDeviceNotificationName const MTLDeviceWasAddedNotification API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios); /*! @brief This notification is posted when the user has requested that applications cease using a particular device. Applications should assume that the device will be removed (terminated) imminently. Additionally, the device will be removed from the internal device array prior to this notification being posted. Applications should immediately begin the process of releasing all resources created on the given device, as well as any references to the device itself. */ MTL_EXTERN MTLDeviceNotificationName const MTLDeviceRemovalRequestedNotification API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios); /*! @brief This notification is posted if the device is removed while there are still outstanding references to it, due to either a surprise or forced disconnect by the user. Applications must expect that any attempt to use the device after this point will fail. */ MTL_EXTERN MTLDeviceNotificationName const MTLDeviceWasRemovedNotification API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios); /*! @brief Block signature for device notifications */ typedef void (^MTLDeviceNotificationHandler)(id device, MTLDeviceNotificationName notifyName) API_AVAILABLE(macos(10.13)) API_UNAVAILABLE(ios); /*! @enum MTLReadWriteTextureTier @abstract MTLReadWriteTextureTier determines support level for read-write texture formats. */ typedef NS_ENUM(NSUInteger, MTLReadWriteTextureTier) { MTLReadWriteTextureTierNone = 0, MTLReadWriteTextureTier1 = 1, MTLReadWriteTextureTier2 = 2, } API_AVAILABLE(macos(10.13), ios(11.0)); /*! @enum MTLArgumentBuffersTier @abstract MTLArgumentBuffersTier determines support level for argument buffers. */ typedef NS_ENUM(NSUInteger, MTLArgumentBuffersTier) { MTLArgumentBuffersTier1 = 0, MTLArgumentBuffersTier2 = 1, } API_AVAILABLE(macos(10.13), ios(11.0)); /*! @abstract Represent a memory size and alignment in bytes. */ typedef struct { NSUInteger size; NSUInteger align; } MTLSizeAndAlign; /* Convenience typedefs that make it easy to declare storage for certain return types. */ typedef __autoreleasing MTLRenderPipelineReflection * __nullable MTLAutoreleasedRenderPipelineReflection; typedef __autoreleasing MTLComputePipelineReflection * __nullable MTLAutoreleasedComputePipelineReflection; typedef void (^MTLNewLibraryCompletionHandler)(id __nullable library, NSError * __nullable error); /*! * @class MTLArgumentDescriptor * @abstract Represents a member of an argument buffer */ MTL_EXPORT API_AVAILABLE(macos(10.13), ios(11.0)) @interface MTLArgumentDescriptor : NSObject /*! * @method argumentDescriptor * @abstract Create an autoreleased default argument descriptor */ + (MTLArgumentDescriptor *)argumentDescriptor; /*! * @property dataType * @abstract For constants, the data type. Otherwise, MTLDataTypeTexture, MTLDataTypeSampler, or * MTLDataTypePointer. */ @property (nonatomic) MTLDataType dataType; /*! * @property index * @abstract The binding point index of the argument */ @property (nonatomic) NSUInteger index; /*! * @property arrayLength * @abstract The length of an array of constants, textures, or samplers, or 0 for non-array arguments */ @property (nonatomic) NSUInteger arrayLength; /*! * @property access * @abstract Access flags for the argument */ @property (nonatomic) MTLArgumentAccess access; /*! * @property textureType * @abstract For texture arguments, the texture type */ @property (nonatomic) MTLTextureType textureType; /*! @property constantBlockAlignment @abstract if set forces the constant block to be aligned to the given alignment @discussion Should only be set on the first constant of the block and is only valid if a corresponding explicit \"alignas\" is applied to the constant in the metal shader language. */ @property (nonatomic) NSUInteger constantBlockAlignment; @end Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MDLMesh.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MDLMesh.html","title":"MDLMesh API","keywords":"","body":"MDLMesh 可以理解为一个缓冲区，包含顶点的相关信息，如子网格数据，该子网格具有索引缓冲区和纹理信息等！ 一个网格包含一个或多个MDLSubmesh对象。 每个子网格都包含索引缓冲区数据，这些数据描述了网格的顶点应该如何组合以进行绘图和参考描述子网格预期表面外观的材料信息。 通常，您可以通过遍历对象的对象层次结构来获取网格MDLAsset，但您也可以根据自己的顶点数据创建网格或创建参数化网格。的MDLMesh类也支持处理网格以生成顶点属性或烘烤照明信息。 一个网格包含一个或多个MDLSubmesh对象。 每个子网格都包含索引缓冲区数据，用来描述网格顶点在绘图时应该如何组合，以及描述子网格预期表面外观的参考材料信息。 通常，您可以通过遍历MDLAsset对象的对象层次结构来获取网格，但您也可以从自己的顶点数据或创建参数网格来创建网格。 MDLMesh类还支持处理网格以生成顶点属性或烘烤光照信息。 @interface MDLVertexAttributeData : NSObject @property (nonatomic, retain) MDLMeshBufferMap *map; @property (nonatomic) void *dataStart; @property (nonatomic) NSUInteger stride; @property (nonatomic) MDLVertexFormat format; @property (nonatomic) NSUInteger bufferSize; @end 自定义网格 /// 一个包含顶点相关数据的缓冲区：包含子网格数据，该子网格具有索引缓冲区和纹理信息 @interface MDLMesh : MDLObject /** 用顶点缓冲区和一组子网格初始化对象 @abstract Initialize object with a vertex buffer and a collection of submeshes @return Initialized mesh or nil if descriptor's layout array does not describe a single buffer @param vertexBuffer MDLMeshBuffer object containing all vertex data for the mesh @param vertexCount Number of vertices in the vertexBuffer @param descriptor VertexDescriptor specifying how to interpret vertex data @param submeshes Array of submeshes with index buffers referencing vertex data and/or materials to be applied to mesh */ - (instancetype)initWithVertexBuffer:(id)vertexBuffer vertexCount:(NSUInteger)vertexCount descriptor:(MDLVertexDescriptor *)descriptor submeshes:(NSArray *)submeshes; /*! @method initWithVertexBuffer:vertexCount:descriptor:submeshes: @abstract Initialize object with an array of vertex buffers (Structure of Arrays) and a collection of submeshes @return Initialized mesh or nil if descriptor's layout array is incompatible with vertexBuffers array @param vertexCount Number of vertices in vertexBuffers @param descriptor VertexDescriptor specifying how to interpret vertex data @param submeshes Array of submeshes with index buffers referencing vertex data and/or materials to be applied to mesh @discussion Allows initialization with the layout of the vertexBuffers in a structure-of-arrays form, in other words, non-interleaved vertex attributes */ - (instancetype)initWithVertexBuffers:(NSArray> *)vertexBuffers vertexCount:(NSUInteger)vertexCount descriptor:(MDLVertexDescriptor *)descriptor submeshes:(NSArray *)submeshes; /// 初始化一个空网格 - (instancetype)initWithBufferAllocator:(nullable id)bufferAllocator; + (nullable instancetype)newSubdividedMesh:(MDLMesh*)mesh submeshIndex:(NSUInteger)submeshIndex subdivisionLevels:(NSUInteger)subdivisionLevels; @end 顶点数据 @interface MDLMesh : MDLObject @end 生成几何数据 @interface MDLMesh : MDLObject @end Generating Ambient Occlusion Data @interface MDLMesh : MDLObject @end 生成灯光映射数据 @interface MDLMesh : MDLObject @end Creating Parametric Meshes @interface MDLMesh : MDLObject @end 从 SceneKit 导入网格对象 @interface MDLMesh : MDLObject @end 实例方法 /// 一个包含顶点相关数据的缓冲区：包含子网格数据，该子网格具有索引缓冲区和纹理信息 @interface MDLMesh : MDLObject /*! @method vertexAttributeDataForAttributeNamed: @abstract convenience selector to get quick access to vertex attribute data @discussion the vertex buffer will remain mapped until the MDLVertexAttributeData is freed. */ - (nullable MDLVertexAttributeData*)vertexAttributeDataForAttributeNamed:(NSString*)name; /*! @method vertexAttributeDataForAttributeNamed:asFormat @abstract convenience selector to get quick access to vertex attribute data reformatted to the requested format if necessary. @discussion If the desired format has less elements than the source attribute elements, excess elements will be discarded. If the desired format has more elements than the source attribute, then the destination elements will be set to zero. The vertex buffer will remain mapped until the MDLVertexAttributeData is freed. */ - (nullable MDLVertexAttributeData*)vertexAttributeDataForAttributeNamed:(NSString*)name asFormat:(MDLVertexFormat)format; /*! @property boundingBox @abstract Bounding box encompasing the mesh @discussion Calculated by iterating through MDLVertexAttributePosition to find min and max bounds. If no attribute is named MDLVertexAttributePosition this will be a invalid bounds where maxBounds is less than minBounds. */ @property (nonatomic, readonly) MDLAxisAlignedBoundingBox boundingBox; /*! @property vertexDescriptor @abstract Immutable vertex descriptor for interpreting data in vertexBuffers @discussion Setting this applies the new layout in 'vertexBuffers' thus is a heavyweight operation as structured copies of almost all vertex buffer data could be made. Additionally, if the new vertexDescriptor does not have an attribute in the original vertexDescriptor, that attribute will be deleted. If the original vertexDescriptor does not have an attribute in the new vertexDescriptor, the data for the added attribute set as the added attribute's initializationValue property. The allocator associated with each original meshbuffer is used to reallocate the corresponding resultant meshbuffer. */ @property (nonatomic, readwrite, copy) MDLVertexDescriptor *vertexDescriptor; /*! @property vertexCount @abstract Number of vertices in the vertexBuffers @discussion The size of vertex data in each buffer can be computed by multiplying this value with the stride of the buffer in the vertexDescriptor's layout */ @property (nonatomic, readwrite) NSUInteger vertexCount; /*! @property vertexBuffers @abstract Array of buffers containing vertex data @discussion The vertex buffers in this array are indexed by the vertex descriptor. */ @property (nonatomic, readwrite, retain) NSArray> *vertexBuffers; /*! @property submeshes @abstract Array of submeshes containing an indexbuffer referencing the vertex data and material to be applied when the mesh is rendered */ @property (nonatomic, copy, nullable) NSMutableArray *submeshes; /*! @property allocator @abstract allocator used to allocate contained mesh buffers */ @property (nonatomic, readonly, retain) id allocator; @end @interface MDLMesh (Modifiers) /*! @method addAttributeWithName:format @abstract Convenience method to add an attribute @discussion The mesh's allocator will be used to create storage for the new attribute. */ - (void)addAttributeWithName:(NSString*)name format:(MDLVertexFormat)format; /*! @method addAttributeWithName:format:type:data:stride @abstract Create a new vertex attribute including an associated buffer with a copy of the supplied data, and update the vertex descriptor accordingly @param name The name the attribute can be found by @param format Format of the data, such as MDLVertexFormatFloat3 @param type The usage of the attribute, such as MDLVertexAttributePosition @param data Object containing the data to be used in the new vertex buffer @param stride The increment in bytes from the start of one data entry to the next. */ -(void)addAttributeWithName:(NSString *)name format:(MDLVertexFormat)format type:(NSString *)type data:(NSData *)data stride:(NSInteger)stride; /*! @method addAttributeWithName:format:type:data:stride:time @abstract Create a new vertex attribute including an associated buffer with a copy of the supplied data, and update the vertex descriptor accordingly @param name The name the attribute can be found by @param format Format of the data, such as MDLVertexFormatFloat3 @param type The usage of the attribute, such as MDLVertexAttributePosition @param data Object containing the data to be used in the new vertex buffer @param stride The increment in bytes from the start of one data entry to the next. @param time The time the attribute is to be invoked at. @discussion Adding an attribute, such as position data, at multiple times will result in attributes being created for each of those times. Attributes corresponding to multiple times can be retrieved from the vertex descriptor. */ -(void)addAttributeWithName:(NSString *)name format:(MDLVertexFormat)format type:(NSString *)type data:(NSData *)data stride:(NSInteger)stride time:(NSTimeInterval)time; /*! @method addNormalsWithAttributeNamed:creaseThreshold: @abstract Calculate and add vertex normal data @param attributeName Name is the attribute name of vertex normal attribute. If nil, vertex normals will be added with the MDLVertexAttributeNormal name string @param creaseThreshold Threshold of the dot product between the 2 triangles after which their face normal will be smoothed out. Therefore, a threshold of 0 will smooth everything and a threshold of 1 won't smooth anything. @discussion Uses the attribute named MDLVertexAttributePosition to calculate vertex normals. If the mesh does not have an attribute with 'attributeName', it will be added, otherwise the attribute name will be overwritten with vertex normal data. 'vertexDescriptor' will be updated to reflect the new attribute. */ - (void)addNormalsWithAttributeNamed:(nullable NSString *)attributeName creaseThreshold:(float)creaseThreshold; /*! @method addTangentBasisForTextureCoordinateAttributeNamed:tangentAttributeNamed:bitangentAttributeNamed @abstract Create a shader basis where the tangent and bitangent span the uv -> object space transform @param textureCoordinateAttributeName Name of texture coordinates to use in calculations @param tangentAttributeName Name of vertex tangent attribute. @param bitangentAttributeName Name of vertex bitangent attribute. @discussion Uses the attribute named MDLVertexAttributePosition and textureCoordinateAttributeName to calculate tangent and bitangent attributes. The mesh's vertexDescriptor will be updated to reflect the new attributes if necessary. The basis may not be orthogonal; to gaurantee an orthogonal tangent basis please use addOrthTanBasisForTextureCoordinateAttibuteNamed selector. */ - (void)addTangentBasisForTextureCoordinateAttributeNamed:(NSString*)textureCoordinateAttributeName tangentAttributeNamed:(NSString *)tangentAttributeName bitangentAttributeNamed:(nullable NSString *)bitangentAttributeName; /*! @method addTangentBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed @abstract Create tangents which are orthogonal to the normal @param textureCoordinateAttributeName texture coordinates to use in calculations @param normalAttributeName normals to use in calculations @param tangentAttributeName Name of a four component vertex tangent attribute. @discussion Uses the attribute named MDLVertexAttributePosition and textureCoordinateAttributeName and the specified normals to calculate tangent information. The mesh's vertexDescriptor will be updated to reflect the new attribute if necessary. Note that this method does NOT produce a T.w component which is used in B = (N x T) * T.w Please use addOrthTanBasisForTextureCoordinateAttributeNamed. */ - (void)addTangentBasisForTextureCoordinateAttributeNamed:(NSString*)textureCoordinateAttributeName normalAttributeNamed:(NSString*)normalAttributeName tangentAttributeNamed:(NSString *)tangentAttributeName; /* @method addOrthTanBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed @abstract Create an orthonormal tangent basis with tangent specified @param textureCoordinateAttributeName texture coordinates to use in calculations @param normalAttributeName normals to use in calculations @param tangentAttributeName Name of a three/four component vertex tangent attribute. @discussion Uses the attribute named MDLVertexAttributePosition and textureCoordinateAttributeName and the specified normals to calculate tangent information. The mesh's vertexDescriptor will be updated to reflect the new attribute if necessary. Note that the bitangent can be calculated from the normal and tangent by B = (N x T) * T.w */ - (void)addOrthTanBasisForTextureCoordinateAttributeNamed:(NSString *)textureCoordinateAttributeName normalAttributeNamed:(NSString *)normalAttributeName tangentAttributeNamed:(NSString *)tangentAttributeName API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0)); /*! @method addTextureCoordinatesForAttributeNamed:textureCoordinateAttributeName @abstract Creates texture coordinates by unwrapping the mesh @param textureCoordinateAttributeName texture coordinates to modify or create @discussion Uses the attribute named MDLVertexAttributePosition and if available, the attribute named MDLVertexAttributeNormal to calculate texture coordinates */ - (void)addUnwrappedTextureCoordinatesForAttributeNamed:(NSString*)textureCoordinateAttributeName; /*! @method flipTextureCoordinatesInAttributeNamed: @abstract Flips texture coordinates by performing the operation (u,v) = (u, 1-v) @param textureCoordinateAttributeName texture coordinates to modify @discussion Many application generate model files with texture coordinate mapping assuming a bottom left bitmap origin. It can be more convenient to have texture coordinates corresponding to an upper left bitmap origin. This selector will perform the flip operation if the requested texture coordinate attribute exists on the mesh. An exception will be raised if the attribute cannot be found */ - (void)flipTextureCoordinatesInAttributeNamed:(NSString*)textureCoordinateAttributeName API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0)); /*! @method makeVerticesUnique: @abstract Deindexes the vertex array @discussion If any vertices are shared on multiple faces, duplicate those vertices so faces do not share vertices. The vertex buffer and index buffers on submeshes may grow to accomadate any vertices added. */ - (void)makeVerticesUnique NS_DEPRECATED(10.11,10.13,9.0,11.0); /*! @method makeVerticesUniqueAndReturnError: @abstract Deindexes the vertex array @discussion If any vertices are shared on multiple faces, duplicate those vertices so faces do not share vertices. The vertex buffer and index buffers on submeshes may grow to accomadate any vertices added. */ - (BOOL)makeVerticesUniqueAndReturnError:(NSError **)error API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0)); /*! @method replaceAttributeNamed:withData @abstract replace existing attribute data with new attribute data retaining the format of the replacement data. @discussion If the specified attribute does not already exist, it will be created. */ - (void)replaceAttributeNamed:(NSString*)name withData:(nonnull MDLVertexAttributeData*)newData; /*! @method updateAttributeNamed:withData @abstract update existing attribute data with new attribute data retaining the format of the existing data. @discussion If the specified attribute does not already exist, it will be created with the same format as the newData. */ - (void)updateAttributeNamed:(NSString*)name withData:(nonnull MDLVertexAttributeData*)newData; /*! @method removeAttributeNamed: @abstract remove an attribute @discussion if the named attribute does not exist, nothing happens. */ - (void)removeAttributeNamed:(NSString*)name; @end @interface MDLMesh (Generators) /*! @method initBoxMeshWithExtent:segments:inwardNormals:geometryType:allocator: @abstract Factory method for generating a mesh with a cube shape @return MDLMesh box with desired attributes @param extent size of the box in each dimension @param segments Number of slices in each dimension @param inwardNormals Generated Normal point inward @param geometryType Can be MDLGeometryTypeLines, MDLGeometryTypeQuads, or MDLGeometryTypeTriangles @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Assembled with triangle or quad primitives. Specifying inward normals is useful for generating a skybox. The center of the box is at(0, 0, 0). Will raise an exception if an unsupported geometry type is passed in. */ - (instancetype)initBoxWithExtent:(vector_float3)extent segments:(vector_uint3)segments inwardNormals:(BOOL)inwardNormals geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator; /*! @method initSphereWithExtent:segments:inwardNormals:geometryType:allocator @abstract Factory method for generating a mesh with an ellipsoid shape @return MDLMesh epllipsoid with desired attributes @param geometryType Must be MDLGeometryTypeTriangles or MDLGeometryTypeLines @param inwardNormals If true, generated normals will face inwards. Useful for generating a skydome. actual nubmer of vertical slices will be half of 'vertical' segments @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Specifying inward normals and hemisphere is useful for generating a skydome. Specifying equal X, Y, and Z radii will generate a sphere. Specifying a y radius of 0.0 will generate a disc. Will raise an exception if radialSegments is )allocator; - (instancetype)initHemisphereWithExtent:(vector_float3)extent segments:(vector_uint2)segments inwardNormals:(BOOL)inwardNormals cap:(BOOL)cap geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator; /*! @method initCylinderWithExtent:segments:inwardNormals:topCap:bottomCap:geometryType:allocator @abstract Factory method for generating a mesh with a cylindrical shape @return MDLMesh cylinder with desired attributes @param geometryType Must be MDLGeometryTypeTriangles or MDLGeometryTypeLines @param inwardNormals Normals point toward center of cylinder @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Center of cylinder at (0, 0, 0) with a top at +Y and bottom at -Y. Specifying equal X and Z radia will generate a true cylinder. Specifying a height of 0.0 and verticalSegments of 0 will generate a disc. Will raise an exception if radialSegments is [ ] \\___/ [ ] [ ] [_____] [ ] \\___/ )allocator; /*! @method initCapsuleWithExtent:cylinderSegments:hemisphereSegments:inwardNormals:geometryType:allocator @abstract Factory method for generating a mesh with a capsule shape; a cylinder with hemispheres for caps. @return MDLMesh capsule with desired attributes @param extent Dimension of bounding box for capsule. @param hemisphereSegments Number of slices through hemisphere caps along Y axis @param geometryType Must be MDLGeometryTypeTriangles or MDLGeometryTypeLines @param inwardNormals Normals point toward center of cylinder @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Center of capsule at (0, 0, 0) with a top at +Y and bottom at -Y. The height of hemisphere cap is specified by the minimum of X and Z Specifying equal X and Z radii will generate a true capsule. Specifying a height that is less than the twice of min of the X and Z radii or verticalSegments of 0 will generate a sphere. The full height of the capsule will also incorporate the hemisphere caps. Will raise an exception if radialSegments is [-----] [ ] [ ] [_____] [ ] \\___/ )allocator; /*! @method initConeWithExtent:segments:inwardNormals:cap:geometryType:allocator @abstract Factory method for generating a mesh with an ellipticalCone shape. @return MDLMesh cone with desired attributes @param geometryType Must be MDLGeometryTypeTriangles or MDLGeometryTypeLines @param inwardNormals Normals point toward center of ellipticalCone @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Point of cone at (0, 0, 0) while base of cone is -Y. Will raise an exception if radialSegments is [ ] [ ] [_____] [ ] \\___/ )allocator; /*! @method initPlaneWithExtent:segments:geometryType:allocator @abstract Factory method for generating a mesh with an planar shape @return MDLMesh plane with desired attributes @param extent extent of the plane @param segments Number of segements in the X and Y dimensions @param geometryType Can be MDLGeometryTypeLines, MDLGeometryTypeQuads, or MDLGeometryTypeTriangles @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Creates a plane spanning the greatest dimensions of extent. Will raise an exception if an unsupported geometry type is passed in. */ - (instancetype)initPlaneWithExtent:(vector_float3)extent segments:(vector_uint2)segments geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator; /*! @method initIcosahedronWithExtent:inwardNormals:geometryType:allocator @abstract Factory method for generating a mesh icosahedron @return MDLMesh icosahedron with desired attributes @param inwardNormals Generated normals will face towards the center of the mesh @param allocator A mesh buffer allocator used to allocate memory to back buffers for the returned mesh. If nil, a default allocator will be used @discussion Creates an icosahedron with center at (0, 0, 0). */ - (instancetype)initIcosahedronWithExtent:(vector_float3)extent inwardNormals:(BOOL)inwardNormals geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator; /*! @method initMeshBySubdividingMesh:submeshIndex:subdivisionLevels:allocator @abstract Factory method that generates a subdivided mesh from a source mesh @param mesh Mesh from which to generate a subdivided mesh @param submeshIndex Index of submesh in Mesh's submesh array from which to generate a subdivided mesh @param subdivisionLevels The number of levels to subdivide mesh @discussion Subdivision levels over four are likely to generate more triangles than can be reasonably displayed. Index and vertex data will use the same allocator used for the source mesh. Loading an asset using the topology preservation flag set to YES will result in the best subdivision results. @return Returns a mesh subdivided to index level, unless subdivision is impossible. */ - (instancetype)initMeshBySubdividingMesh:(MDLMesh*)mesh submeshIndex:(int)submeshIndex subdivisionLevels:(unsigned int)subdivisionLevels allocator:(nullable id)allocator; + (instancetype)newBoxWithDimensions:(vector_float3)dimensions segments:(vector_uint3)segments geometryType:(MDLGeometryType)geometryType inwardNormals:(BOOL)inwardNormals allocator:(nullable id)allocator; + (instancetype)newEllipsoidWithRadii:(vector_float3)radii radialSegments:(NSUInteger)radialSegments verticalSegments:(NSUInteger)verticalSegments geometryType:(MDLGeometryType)geometryType inwardNormals:(BOOL)inwardNormals hemisphere:(BOOL)hemisphere allocator:(nullable id)allocator; + (instancetype)newCylinderWithHeight:(float)height radii:(vector_float2)radii radialSegments:(NSUInteger)radialSegments verticalSegments:(NSUInteger)verticalSegments geometryType:(MDLGeometryType)geometryType inwardNormals:(BOOL)inwardNormals allocator:(nullable id)allocator; + (instancetype)newCapsuleWithHeight:(float)height radii:(vector_float2)radii radialSegments:(NSUInteger)radialSegments verticalSegments:(NSUInteger)verticalSegments hemisphereSegments:(NSUInteger)hemisphereSegments geometryType:(MDLGeometryType)geometryType inwardNormals:(BOOL)inwardNormals allocator:(nullable id)allocator API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0)); + (instancetype)newEllipticalConeWithHeight:(float)height radii:(vector_float2)radii radialSegments:(NSUInteger)radialSegments verticalSegments:(NSUInteger)verticalSegments geometryType:(MDLGeometryType)geometryType inwardNormals:(BOOL)inwardNormals allocator:(nullable id)allocator; + (instancetype)newPlaneWithDimensions:(vector_float2)dimensions segments:(vector_uint2)segments geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator; + (instancetype)newIcosahedronWithRadius:(float)radius inwardNormals:(BOOL)inwardNormals geometryType:(MDLGeometryType)geometryType allocator:(nullable id)allocator API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0)); + (instancetype)newIcosahedronWithRadius:(float)radius inwardNormals:(BOOL)inwardNormals allocator:(nullable id)allocator; @end @interface MDLMesh (MDLLightBaking) /*! @method generateAmbientOcclusionTextureWithSize: @abstract Creates an Ambient Occlusion texture, returns true upon success, false upon failure @param textureSize Texture Size in which to bake the ambient occlusion @param raysPerSample Number of rays to be sent out of every texture texel against the object for potential occlusion. @param attenuationFactor Float between 0 to 1 that defines how to attenuate the AO value. 0 doesn't change it, and at 1, all AO values are white except if they are originally completely black. Quadratic attenuation in between. @param objectsToConsider NSArray of MDLMeshes containing the objects to raytrace against @param vertexAttributeName NSString of the MDLVertexAttribute where the vertex texture UVs will be stored. Creates it if it doesn't exist, otherwise overwrites current values. @param materialPropertyName NSString of the MDLMaterialProperty that will store the texture in the Mesh. @result Success or failure of the baking process. */ - (BOOL)generateAmbientOcclusionTextureWithSize:(vector_int2)textureSize raysPerSample:(NSInteger)raysPerSample attenuationFactor:(float)attenuationFactor objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName materialPropertyNamed:(NSString *)materialPropertyName; /*! @method generateAmbientOcclusionTextureWithQuality: @abstract Creates an Ambient Occlusion texture, returns true upon success, false upon failure @param bakeQuality Float between 0 and 1 that defines quality of the bake process. 0 is of lower quality but bakes faster and uses less memory, where 1 is of higher quality. @param attenuationFactor Float between 0 to 1 that defines how to attenuate the AO value. 0 doesn't change it, and at 1, all AO values are white except if they are originally completely black. Quadratic attenuation in between. @param objectsToConsider NSArray of MDLMeshes containing the objects to raytrace against @param vertexAttributeName NSString of the MDLVertexAttribute where the vertex texture UVs will be stored. Creates it if it doesn't exist, otherwise overwrites current values. @param materialPropertyName NSString of the MDLMaterialProperty that will store the texture in the Mesh. @result Success or failure of the baking process. */ - (BOOL)generateAmbientOcclusionTextureWithQuality:(float)bakeQuality attenuationFactor:(float)attenuationFactor objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName materialPropertyNamed:(NSString *)materialPropertyName; - (BOOL)generateAmbientOcclusionVertexColorsWithRaysPerSample:(NSInteger)raysPerSample attenuationFactor:(float)attenuationFactor objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName; - (BOOL)generateAmbientOcclusionVertexColorsWithQuality:(float)bakeQuality attenuationFactor:(float)attenuationFactor objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName; - (BOOL)generateLightMapTextureWithTextureSize:(vector_int2)textureSize lightsToConsider:(NSArray*)lightsToConsider objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName materialPropertyNamed:(NSString *)materialPropertyName; - (BOOL)generateLightMapTextureWithQuality:(float)bakeQuality lightsToConsider:(NSArray*)lightsToConsider objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName materialPropertyNamed:(NSString *)materialPropertyName; - (BOOL)generateLightMapVertexColorsWithLightsToConsider:(NSArray*)lightsToConsider objectsToConsider:(NSArray*)objectsToConsider vertexAttributeNamed:(NSString *)vertexAttributeName; @end NS_ASSUME_NONNULL_END Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTKModel.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTKModel.html","title":"MTKMesh API","keywords":"","body":"网格数据 1、3D 模型 要渲染三维物体，需要一个由网格、相机、光线、纹理等数据组成的场景： 前面案例的 3D 立方体或者球体采用 直接给出顶点坐标值或者基于数学公式用程序生成坐标值 的方法，这在一些简单的场景中肯能够使用了； 但如果构建更加复杂、更加逼真的场景，需要采用的物体及其几何形状可能会很复杂而且不能直接用数学公式描述，如城市模型、汽车模型等！ 这种复杂的三维场景，一般使用 3D 建模工具（如 3ds Max、Maya 等）建立物体模型，然后导出成特定格式的模型文件在程序中加载渲染！常见的 3D 模型文件有 obj、 3ds、 fbx 等！ 1.1、Obj 模型文件 Obj 文件是最简单的一种 3D 模型文件，其本质就是具有固定格式的文本文件！Obj 文件中将顶点坐标、三角形坐标、纹理坐标等信息已固定格式的文本字符串表示： v 649.6328 -5.4034 791.5802 v 568.9182 -5.4034 851.4427 # 14291 vertices vn -0.0000 1.0000 -0.0000 vn -0.0000 1.0000 0.0000 # 12848 vertex normals vt 0.5884 0.3337 0.0000 vt 0.4619 0.4226 0.0000 # 2798 texture coords g cage_stairs_01 usemtl structure s 1 f 1/1/1 2/2/2 3/3/3 f 3/3/3 4/4/4 1/1/1 # 27664 faces 从上述 Obj 文件片段可以看出，其内容是以行为为基本单位进行组织的，每种不同前缀开头的有不同的含义： # 号开头用于注释，在程序加载过程中略过； v 开头用于存放顶点坐标，其后面的 3 个数值分别表示一个顶点的 x, y, z 坐标； vt 开头用于存放顶点纹理坐标，其后面的 3 个数值分别表示纹理坐标的 S, T, P 分量； S, T 分量就是纹理二维坐标； P 分量指的是深度纹理坐标，主要用于 3D 纹理的采样！ vn 开头用于存放顶点法向量，其后面的 3 个数值分别表示一个顶点的法向量在 X, Y, Z 轴的分量； g 开头的一行表示一组的开始，后面的字符串为此组的名称； 所谓组是由顶点组成的一些面的集合； 只包含 g 的行表示一组的结束，与 g 开头的行成对应关系； f 开头的行表示组中的一个面； 如果是三角形，则后面有 3 组用空格分割的数据，代表三角形的三个顶点； 每组数据包含 3 个数值，用 / 分割，依次表示顶点坐标索引、顶点纹理索引、顶点法向量索引； 计算行号时，各种不同的前缀是独立计算的：如文本中的第 5 行为 v 开头的第 2 行! f 200/285/300 196/280/399 195/260/350 /// 三角形的三个顶点坐标分别来自 v 开头的第 200、196、195 行 /// 三个顶点的纹理坐标分别来自 vt 开头的第 285、280、260 行 /// 三个顶点的法向量分别来自 vn 开头的第 300、399、350 行 注意：Obj 文件中一般顶点坐标与面坐标（索引）的数据是必须提供的，而法向量与纹理数据是可选的！ 1.2、Obj 模型文件的加载 Metal 使用框架 ModelIO 加载 Obj 模型文件！此时加载的资源不能直接在 Metal 中使用，还需要一步步转为 Metal 所能理解和使用的资源！ 使用顶点描述符 MTLVertexDescriptor 来定义顶点的读取方式及其属性：如位置，纹理坐标，法线和颜色； 当 GPU 获取顶点缓冲区时，MTLRenderCommandEncoder 会告知 GPU 是否对缓冲区建立索引； 如果缓冲区未编入索引，则GPU假定缓冲区是一个数组，并按顺序一次读入一个元素。 此索引很重要，因为顶点被缓存以供重用：例如，立方体有十二个三角形和八个顶点，如果不进行索引，则必须为每个三角形指定顶点并向GPU发送三十六个顶点。 这可能听起来不是很多，但在具有几千个顶点的模型中，顶点缓存很重要！ 还有用于顶点着色器的缓存，以便多次访问的顶点仅被着色一次。着色顶点是已应用颜色的顶点。但这种情况发生在下一阶段。 一个名为Scheduler的特殊硬件单元将顶点及其属性发送到顶点着色器； 2、API 2.1、缓冲区分配器 MTKMeshBufferAllocator 分配器 MTKMeshBufferAllocator 用于缓冲区的创建：分配一块内存传递给 MDLAsset，将顶点数据和索引数据加载到 Metal 缓冲区。 @interface MTKMeshBufferAllocator : NSObject - (nonnull instancetype)init NS_UNAVAILABLE; /// 初始化分配器：用于缓冲区的创建 - (nonnull instancetype)initWithDevice:(nonnull id) device; @property (nonatomic, readonly, nonnull) id device; @end 代码示例 { /// 创建一个分配器 MTKMeshBufferAllocator *bufferAllocator = [[MTKMeshBufferAllocator alloc] initWithDevice:device]; /// 使用分配器将指定路径的文件加载到一块内存中 MDLAsset *asset = [[MDLAsset alloc] initWithURL:url vertexDescriptor:nil bufferAllocator:bufferAllocator]; NSAssert(asset, @\"无法打开指定路径的模型文件: %@\", url.absoluteString); } 2.2、网格缓冲区 MTKMeshBuffer 当 Model I/O 需要存储顶点数据或索引数据时，使用分配器 MTKMeshBufferAllocator 分配的网格缓冲区 MTKMeshBuffer。 这些缓冲区的内存支持 Metal 缓冲区；Model I/O 将从模型资源中直接加载索引数据和顶点数据到 Metal 缓冲区。 @interface MTKMeshBuffer : NSObject - (nonnull instancetype)init NS_UNAVAILABLE; /// 缓冲区分配的字节大小 @property (nonatomic, readonly) NSUInteger length; /** 用于创建此缓冲区的分配器 * 持有该分配器，以便 Model I/O 可以使用它进行复制和转发操作(例如当一个新的顶点描述符被应用到顶点缓冲区时)。 */ @property (nonatomic, readonly, nonnull) MTKMeshBufferAllocator *allocator; /** 创建缓冲区的内存块，如果它是从一个区域创建的 * 为每个区域分配一个单独的 MetalBuffer；每个区域可以有许多 MTKMeshBuffers，每个都有自己的偏移量。 * 如果使用 MTKMeshBufferAllocator，Model I/O 将尝试将单个网格的所有顶点和索引数据加载到单个区域。 * 这允许 GPU 在绘制网格时获得更高的缓存命中率；因此，尽管一个 Model 可能有许多 MTKMeshBuffers，但它们将由相同的相邻的 MetalBuffer 支持。 */ @property (nonatomic, readonly, nullable) id zone; /** Metal 缓冲区：支持顶点数据与索引数据； * 顶点数据与索引数据可以存储在两个缓冲区；也可以存储在同一个缓冲区，通过设置偏移量来区分！ */ @property (nonatomic, readonly, nonnull) id buffer; /// Metal 缓冲区内数据的字节偏移量 @property (nonatomic, readonly) NSUInteger offset; /// 缓冲区的预期类型 @property (nonatomic, readonly) MDLMeshBufferType type; @end 代码示例 网格缓冲区由系统分配，开发者只需关注它的某些属性即可！ - (void)drawInMTKView:(nonnull MTKView *)view { ... for (MTKMesh *mesh in _meshes) { // 设置网格的顶点缓冲区数据 for (NSUInteger bufferIndex = 0; bufferIndex 2.3、顶点描述符 顶点描述符 MTLVertexDescriptor 描述 如何将存储在内存中的顶点数据映射到顶点着色器中的属性上。 @interface MTLVertexDescriptor : NSObject /// 创建顶点描述符 + (MTLVertexDescriptor *)vertexDescriptor; /// 描述当渲染图元时，顶点着色器如何获取数据 @property (readonly) MTLVertexBufferLayoutDescriptorArray *layouts; /// 描述顶点属性数据如何存储在内存中，并映射到顶点着色器的对应参数 @property (readonly) MTLVertexAttributeDescriptorArray *attributes; /// 重置顶点描述符的默认状态 /// 重置后，数组 attributes 的每个元素都有一个默认的顶点属性描述符 /// 数组 layouts 的每个元素都有一个默认的顶点缓冲区布局描述符 - (void)reset; @end 2.3.1、内存布局 MTLVertexBufferLayoutDescriptor 用于配置渲染管道如何获取要发送给顶点着色器的数据! /// 用于配置渲染管道如何获取要发送给顶点着色器的数据 @interface MTLVertexBufferLayoutDescriptor : NSObject /// 缓冲区中两个顶点的属性数据之间的距离，以字节为单位 /// 必须是4字节的倍数；默认值为0 @property (assign, nonatomic) NSUInteger stride; /// 顶点及其属性呈现给着色器的情况；默认值为 MTLVertexStepFunctionPerVertex @property (assign, nonatomic) MTLVertexStepFunction stepFunction; /// 顶点着色器处理顶点数据的频率；默认值为 1 /// stepRate 与 stepFunction 共同决定顶点着色器获取新属性数据的频率。 /// 当 stepFunction=MTLVertexStepFunctionPerInstance时，取决于 stepRate 取值 /// 如果 stepRate=1，则为每个实例获取新属性数据; /// 如果 stepRate=2，则每两个实例就会获取新的属性数据 /// ... 以此类推 @property (assign, nonatomic) NSUInteger stepRate; @end /// 渲染管道如何获取发送给顶点着色器数据的一组配置 @interface MTLVertexBufferLayoutDescriptorArray : NSObject /// 根据索引获取对应的布局信息 - (MTLVertexBufferLayoutDescriptor *)objectAtIndexedSubscript:(NSUInteger)index; /// 根据索引设置置位置的索引 - (void)setObject:(nullable MTLVertexBufferLayoutDescriptor *)bufferDesc atIndexedSubscript:(NSUInteger)index; @end 2.3.2、属性映射 MTLVertexAttributeDescriptor 描述了 如何在内存中存储属性数据并将其映射到顶点着色器的参数中！ 描述符将内存位置映射到属性位置：它支持对多个属性(如顶点坐标、UV 法线和纹理坐标)的访问，这些属性交叉分布在同一个缓冲区中！ /// 如何在内存中存储属性数据并将其映射到顶点着色器的参数中； /// 描述符将内存位置映射到属性位置：它支持对多个属性(如顶点坐标、UV 法线和纹理坐标)的访问，这些属性交叉分布在同一个缓冲区中； @interface MTLVertexAttributeDescriptor : NSObject /// 指定顶点属性的数据类型：对应于顶点着色器的输入参数 @property (assign, nonatomic) MTLVertexFormat format; /// 一个属性在顶点数据中的位置，由字节偏移量决定；偏移量必须是 4 的倍数； @property (assign, nonatomic) NSUInteger offset; /// 关联顶点缓冲区参数表中的索引 @property (assign, nonatomic) NSUInteger bufferIndex; @end @interface MTLVertexAttributeDescriptorArray : NSObject - (MTLVertexAttributeDescriptor *)objectAtIndexedSubscript:(NSUInteger)index; - (void)setObject:(nullable MTLVertexAttributeDescriptor *)attributeDesc atIndexedSubscript:(NSUInteger)index; @end 2.3.3、代码示例 MTLRenderPipelineDescriptor 封装了图形渲染管道的状态，包括着色器、混合、多次采样和可见性测试等； 对于每个渲染管道，仅持有一个顶点描述符； 如果在渲染管道描述符 MTLRenderPipelineDescriptor 上配置顶点描述符，那么构建的顶点内存布局就会应用于渲染管道相关的函数中去； /// 顶点属性的索引 typedef enum VertexAttribute { VertexAttributePosition = 0, /// 顶点的位置信息 VertexAttributeTexcoord = 1, /// 顶点的纹理信息 } MeshVertexAttribute; 配置顶点描述 { /// 创建一个顶点描述符 MTLVertexDescriptor *vertexDescriptor = [[MTLVertexDescriptor alloc] init]; /// 顶点位置信息：三维坐标需要 Float3 vertexDescriptor.attributes[VertexAttributePosition].format = MTLVertexFormatFloat3; vertexDescriptor.attributes[VertexAttributePosition].offset = 0; /// 内存偏移量为 0 vertexDescriptor.attributes[VertexAttributePosition].bufferIndex = 0; /// 顶点纹理信息：纹理空间坐标为二维坐标 Float2 vertexDescriptor.attributes[VertexAttributeTexcoord].format = MTLVertexFormatFloat2; vertexDescriptor.attributes[VertexAttributeTexcoord].offset = 12; /// 内存偏移量 4字节 * 3个 = 12字节 vertexDescriptor.attributes[VertexAttributeTexcoord].bufferIndex = 0; /// 设置布局信息 vertexDescriptor.layouts[0].stride = 20; /// 一个顶点的内存大小：位置+纹理 = 12 + 8 = 20 /// 规定顶点着色器每次处理一个顶点数据 vertexDescriptor.layouts[0].stepRate = 1; vertexDescriptor.layouts[0].stepFunction = MTLVertexStepFunctionPerVertex; } 着色器 顶点描述符规定的位置数据与纹理数据，必须与着色器中的位置数据与纹理数据一一对应！ struct Vertex { float3 position [[attribute(VertexAttributePosition)]]; float2 texCoord [[attribute(VertexAttributeTexcoord)]]; }; struct ColorInOut { float4 position [[position]]; float2 texCoord; }; /// 顶点着色器 /// 使用 [[ stage_in ]] 接收每个顶点数据：可以读取顶点的 位置坐标、纹理坐标 vertex ColorInOut vertexShader(const Vertex in [[ stage_in ]]) { ColorInOut out; float4 position = vector_float4(in.position, 1.0); out.position = position; out.texCoord = in.texCoord; return out; } 着色器的参数列表 除了顶点数据，还可以通过下述方法向着色器中传送一些其他数据资源，例如：纹理、其他数据缓冲、采样器等等。 @protocol MTLRenderCommandEncoder - (void)setVertexBuffer:(nullable id )buffer offset:(NSUInteger)offset atIndex:(NSUInteger)index; - (void)setFragmentBufferOffset:(NSUInteger)offset atIndex:(NSUInteger)index; - (void)setFragmentTexture:(nullable id )texture atIndex:(NSUInteger)index; @end Argument Tables 就是各种资源的列表，每个顶点着色器和片段着色器都对应一个这样的资源列表，通过上述方法传入。 2.3.4、顶点属性数据如何在内存中布局 MTLVertexFormat 指定顶点属性的数据类型：对应于顶点着色器的输入参数；可以在以下指定的限制条件下转换为着色器参数中的数据类型（无效的类型转换会导致编译错误） 对不同长度的向量进行转换是有效的： 向量长度可以缩短：例如，MTLVertexFormatInt4 数据在着色器参数中被简化为一个 int，并且向量的最后三个值被丢弃； 向量可以展开：例如，扩展 MTLVertexFormatInt 到一个 int4 着色器参数是有效的；展开时，用 (0,0,0,1) 对应的分量填充多余的分量。 整数 MTLVertexFormat 的符号不能被转换为具有不同符号的整数类型的着色器参数。 例如，将有符号的 MTLVertexFormatInt 与无符号的 MTLVertexFormatUInt 互相转换均是无效的； 不支持整数截断。例如，将 MTLVertexFormatInt 转换为 short 是无效的。但是，将 MTLVertexFormatShort2 转换为 int 值的向量是有效的。 强制转换规范化的 MTLVertexFormat 类型(例如 MTLVertexFormatShort2Normalized )仅对 float 或 half 有效； /// 指定顶点属性数据如何在内存中布局 typedef NS_ENUM(NSUInteger, MTLVertexFormat) { MTLVertexFormatInvalid = 0, MTLVertexFormatUChar2 = 1, MTLVertexFormatUChar3 = 2, MTLVertexFormatUChar4 = 3, MTLVertexFormatChar2 = 4, MTLVertexFormatChar3 = 5, MTLVertexFormatChar4 = 6, MTLVertexFormatUChar2Normalized = 7, MTLVertexFormatUChar3Normalized = 8, MTLVertexFormatUChar4Normalized = 9, MTLVertexFormatChar2Normalized = 10, MTLVertexFormatChar3Normalized = 11, MTLVertexFormatChar4Normalized = 12, MTLVertexFormatUShort2 = 13, MTLVertexFormatUShort3 = 14, MTLVertexFormatUShort4 = 15, MTLVertexFormatShort2 = 16, MTLVertexFormatShort3 = 17, MTLVertexFormatShort4 = 18, MTLVertexFormatUShort2Normalized = 19, MTLVertexFormatUShort3Normalized = 20, MTLVertexFormatUShort4Normalized = 21, MTLVertexFormatShort2Normalized = 22, MTLVertexFormatShort3Normalized = 23, MTLVertexFormatShort4Normalized = 24, MTLVertexFormatHalf2 = 25, MTLVertexFormatHalf3 = 26, MTLVertexFormatHalf4 = 27, MTLVertexFormatFloat = 28, MTLVertexFormatFloat2 = 29, MTLVertexFormatFloat3 = 30, MTLVertexFormatFloat4 = 31, MTLVertexFormatInt = 32, MTLVertexFormatInt2 = 33, MTLVertexFormatInt3 = 34, MTLVertexFormatInt4 = 35, MTLVertexFormatUInt = 36, MTLVertexFormatUInt2 = 37, MTLVertexFormatUInt3 = 38, MTLVertexFormatUInt4 = 39, MTLVertexFormatInt1010102Normalized = 40, MTLVertexFormatUInt1010102Normalized = 41, MTLVertexFormatUChar4Normalized_BGRA API_AVAILABLE(macos(10.13), ios(11.0)) = 42, MTLVertexFormatUChar API_AVAILABLE(macos(10.13), ios(11.0)) = 45, MTLVertexFormatChar API_AVAILABLE(macos(10.13), ios(11.0)) = 46, MTLVertexFormatUCharNormalized API_AVAILABLE(macos(10.13), ios(11.0)) = 47, MTLVertexFormatCharNormalized API_AVAILABLE(macos(10.13), ios(11.0)) = 48, MTLVertexFormatUShort API_AVAILABLE(macos(10.13), ios(11.0)) = 49, MTLVertexFormatShort API_AVAILABLE(macos(10.13), ios(11.0)) = 50, MTLVertexFormatUShortNormalized API_AVAILABLE(macos(10.13), ios(11.0)) = 51, MTLVertexFormatShortNormalized API_AVAILABLE(macos(10.13), ios(11.0)) = 52, MTLVertexFormatHalf API_AVAILABLE(macos(10.13), ios(11.0)) = 53, } API_AVAILABLE(macos(10.11), ios(8.0)); 2.3.5、顶点及其属性呈现给顶点着色器的类型 /// 顶点及其属性呈现给顶点着色器的类型 typedef NS_ENUM(NSUInteger, MTLVertexStepFunction) { /// 顶点着色器只获取一次属性数据，该属性数据用于每个顶点；stepRate 必须设置为 0 MTLVertexStepFunctionConstant = 0, /// 顶点着色器将基于属性限定符 [[vertex_id]] 获取新的属性数据 /// 每当处理一个新的顶点时，顶点着色器都会获取新的属性数据 /// stepRate 必须设置为 1 MTLVertexStepFunctionPerVertex = 1, /// 顶点着色器将根据属性限定符 [[instance_id]] 获取新的属性数据。 /// 在这种情况下，stepRate 必须大于0，stepRate 决定了 顶点着色器 获取新属性数据的频率 MTLVertexStepFunctionPerInstance = 2, MTLVertexStepFunctionPerPatch = 3, MTLVertexStepFunctionPerPatchControlPoint API_AVAILABLE(macos(10.12), ios(10.0)) = 4, }; 2.3、网格 MTKMesh MTKMesh 对顶点数据的封装 模型 I/O 网格顶点数据的容器，适用于 Metal 应用程序。 用于渲染网格和子网格的顶点数据的容器。 @interface MTKMesh : NSObject - (nonnull instancetype)init NS_UNAVAILABLE; /** 初始化网格和它的子网格 * @param mesh 给定的 Model I/O 网格数据，从而生成 Metal 网格 * @param device 用于创建网格资源的 Metal 设备 * @discussion 这并不初始化 Model I/O 网格的任何子网格，只初始化给定网格的部分子网格。 * 如果给定网格中的vertexBuffer 和子网格的 indexBuffer 没有使用 MTKMeshBufferAllocator 创建，则会引发异常。 * 如果使用了使用MDLGeometryTypeQuads或MDLGeometryTypeTopology的子网格，该子网格将被复制， * 并在此例程创建 MTKSubmesh 之前重新创建以使用 MDLGeometryTypeTriangles */ - (nullable instancetype)initWithMesh:(nonnull MDLMesh *)mesh device:(nonnull id)device error:(NSError * __nullable * __nullable)error; /** 初始化 Model I/O 资源中的所有网格 * @param asset 生成 Metal 网格的 Model I/O 资源 * @param device 用于创建网格资源的 Metal 设备 * @param sourceMeshes 双指针数组，获取对应的 Model I/O 网格 * @discussion 从 Model I/O 资源中的每个 MDLMesh 创建 MTKMesh。 * MDLMesh 从参数 sourceMeshes 传回，而 MTKMesh 从返回值返回； * 资源中每个 MDLMesh 的 vertexBuffer 和它的子网格的 indexBuffer 必须使用 MTKMeshBufferAllocator 创建 */ + (nullable NSArray*)newMeshesFromAsset:(nonnull MDLAsset *)asset device:(nonnull id)device sourceMeshes:(NSArray* __nullable * __nullable)sourceMeshes error:(NSError * __nullable * __nullable)error; /** 子网格：用于渲染网格顶点 * 子网格还可能包含在渲染网格对象时应用的纹理 */ @property (nonatomic, readonly, nonnull) NSArray *submeshes; /** 顶点描述符：指定顶点缓冲区中的数据布局 * @discussion 通过读取该信息来确定渲染状态，或者描述 vertexBuffers 中的数据布局 * @note 改变该描述符的信息不能达到更改数据布局的预期！只能在创建 MDLVertexDescriptor 时确定数据布局 */ @property (nonatomic, readonly, nonnull) MDLVertexDescriptor *vertexDescriptor; /** 顶点数据所在的缓冲区数组：使用 vertexDescriptor 描述的布局填充缓冲区数据 * 如果vertexDescriptor没有为给定的索引指定buffer中的元素，这个数组中的元素可以是 [NSNull null] */ @property (nonatomic, readonly, nonnull) NSArray *vertexBuffers; /// 顶点缓冲区的顶点数量 @property (nonatomic, readonly) NSUInteger vertexCount; /// 标识符：用于在各种场景、世界、渲染器等调试 @property (nonatomic, copy, nonnull) NSString *name; @end 2.4、子网格 MTKSubmesh 子网格 MTKSubmesh 属于网格的一部分，包含用来渲染该部分的属性！ 可以在单个绘制调用中渲染数据的容器， 1:1映射到MDLSubmesh 。 每个子网格都包含一个 indexBuffer ，父网格数据可以用它来渲染。 实际的顶点数据驻留在父网格 MTKMesh 中。 @interface MTKSubmesh : NSObject - (nonnull instancetype)init NS_UNAVAILABLE; /// 图元类型：用于 [MTLRenderCommandEncoder drawIndexedPrimitives] 调用中传递； @property (nonatomic, readonly) MTLPrimitiveType primitiveType; /// 索引缓冲区的索引类型；用于 [MTLRenderCommandEncoder drawIndexedPrimitives] 调用中传递； @property (nonatomic, readonly) MTLIndexType indexType; /// 索引缓冲区；用于 [MTLRenderCommandEncoder drawIndexedPrimitives] 调用中传递； @property (nonatomic, readonly, nonnull) MTKMeshBuffer *indexBuffer; /// 索引缓冲区的索引个数; 用于 [MTLRenderCommandEncoder drawIndexedPrimitives] 调用中传递； @property (nonatomic, readonly) NSUInteger indexCount; /// 父网格：包含顶点数据；在调用 [MTLRenderCommandEncoder drawIndexedPrimitives] 之前应该在编码器中设置这个父网格的缓冲区。 @property (nonatomic, readonly, weak, nullable) MTKMesh *mesh; /// 源自 MDLSubmesh 的名称；用于识别 renderer/scene/world. @property (nonatomic, copy, nonnull) NSString *name; @end 2.5、Metal 顶点 与 Model I/O 顶点的互相转换 /** 将 Metal 顶点描述符转换为 Model I/O 的顶点描述符 * @param error 如果非空，则打印详细的错误信息 * @discussion 通过该函数获取的 Model I/O 顶点描述符只能设置 顶点格式、偏移量、bufferIndex、stride信息；不能添加 attributes 等语义信息； * Names 需要在获取的 Model I/O 顶点描述符设置，然后应用到网格 */ MDLVertexDescriptor* __nonnull MTKModelIOVertexDescriptorFromMetal(MTLVertexDescriptor* __nonnull metalDescriptor); MDLVertexDescriptor* __nonnull MTKModelIOVertexDescriptorFromMetalWithError(MTLVertexDescriptor* __nonnull metalDescriptor, NSError * __nullable * __nullable error); /** 将 Model I/O 顶点描述符转换 为Metal 顶点描述符 * @discussion 通过该函数获取的 Metal 顶点描述符只能设置 顶点格式、偏移量、bufferIndex、stride信息；它只是将属性 1 复制为 1； * 因此，给定 Model I/O 顶点描述符中的属性必须按照正确的顺序排列，以便最终描述符能够正确地将网格数据映射到顶点着色器； * MTLVertexDescriptor 的布局函数 stepFunction 与 stepRates 也必须由应用程序设置。 */ MTLVertexDescriptor* __nullable MTKMetalVertexDescriptorFromModelIO(MDLVertexDescriptor* __nonnull modelIODescriptor); MTLVertexDescriptor* __nullable MTKMetalVertexDescriptorFromModelIOWithError(MDLVertexDescriptor* __nonnull modelIODescriptor, NSError * __nullable * __nullable error); /// 将 Metal 顶点格式转换为模型I/O顶点格式;如果不存在匹配的模型I/O顶点格式，则返回 MDLVertexFormatInvalid MDLVertexFormat MTKModelIOVertexFormatFromMetal(MTLVertexFormat vertexFormat); /// 将模型I/O顶点格式转换为 Metal 顶点格式；如果不存在匹配的 Metal 顶点格式，则返回 MTLVertexFormatInvalid MTLVertexFormat MTKMetalVertexFormatFromModelIO(MDLVertexFormat vertexFormat); 3、代码示例 3.1、网格数据的加载 从本地的 .obj 文件加载一组网格数据 NSArray *_meshes; - (void)loadAssetsWithMetalKitView:(nonnull MTKView*)mtkView { MDLVertexDescriptor *modelIOVertexDescriptor = MTKModelIOVertexDescriptorFromMetal(_vertexDescriptor); modelIOVertexDescriptor.attributes[VertexAttributePosition].name = MDLVertexAttributePosition; modelIOVertexDescriptor.attributes[VertexAttributeTexcoord].name = MDLVertexAttributeTextureCoordinate; NSURL *modelFileURL = [[NSBundle mainBundle] URLForResource:@\"Temple.obj\" withExtension:nil]; NSAssert(modelFileURL,@\"Could not find model file (%@) in bundle\",modelFileURL.absoluteString); MTKMeshBufferAllocator *bufferAllocator = [[MTKMeshBufferAllocator alloc] initWithDevice:mtkView.device]; MDLAsset *asset = [[MDLAsset alloc] initWithURL:modelFileURL vertexDescriptor:nil bufferAllocator:bufferAllocator]; NSAssert(asset, @\"Failed to open model file with given URL: %@\", url.absoluteString); MTKTextureLoader *textureLoader = [[MTKTextureLoader alloc] initWithDevice:mtkView.device]; NSMutableArray *newMeshes = [[NSMutableArray alloc] init]; for(MDLObject* object in asset) { NSMutableArray *assetMeshes = [[NSMutableArray alloc] init]; if ([object isKindOfClass:[MDLMesh class]]) { MDLMesh* mesh = (MDLMesh*)object; ... [newMeshes addObject:newMesh]; } [newMeshes addObjectsFromArray:assetMeshes]; } _meshes = newMeshes; NSAssert(_meshes, @\"Could not create sphere meshes: %@\", error); } 3.2、网格数据的编码 NSArray *_meshes; - (void)drawInMTKView:(nonnull MTKView *)view { MTLRenderPassDescriptor *descriptor = view.currentRenderPassDescriptor; if (descriptor == nil) return; id commandBuffer = [_commandQueue commandBuffer]; commandBuffer.label = @\"命令缓冲区\"; id renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:descriptor]; renderEncoder.label = @\"命令编码器\"; [renderEncoder setRenderPipelineState:_renderPipeline]; [renderEncoder setCullMode:MTLCullModeBack]; for (MTKMesh *metalKitMesh in _meshes) { // 1、设置父网格的顶点缓冲区数据 for (NSUInteger bufferIndex = 0; bufferIndex Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MDLVertexDescriptor.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MDLVertexDescriptor.html","title":"MDLVertexDescriptor API","keywords":"","body":" /*! @group Default MDLVertexAttribute Names @abstract Default names for common vertex attribute types @discussion These are names that are created during 3d asset file loading to correspond to data found in those files. */ /*! The attribute data describes the degree to which a surface’s appearance changes in appearance when rotated about its normal vector. */ MDL_EXPORT NSString * const MDLVertexAttributeAnisotropy; /*! The normal to a curve at a vertex position */ MDL_EXPORT NSString * const MDLVertexAttributeBinormal; /*! The vector completing a tangent basis at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeBitangent; /*! Color of a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeColor; /*! A crease value along an edge to be applied during subdivision. A zero value indicates an edge is smooth, one is sharply creased. */ MDL_EXPORT NSString * const MDLVertexAttributeEdgeCrease; /*! Indices of joints in an animation rig corresponding to weighting information */ MDL_EXPORT NSString * const MDLVertexAttributeJointIndices; /*! Weights corresponding to joints for the purpose of blending animation */ MDL_EXPORT NSString * const MDLVertexAttributeJointWeights; /*! The direction of a normal at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeNormal; /*! A value indicating the degree to which a vertex is occluded by surrounding geometry */ MDL_EXPORT NSString * const MDLVertexAttributeOcclusionValue; /*! The position of a vertex */ MDL_EXPORT NSString * const MDLVertexAttributePosition; /*! The u direction of a shading basis at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeShadingBasisU; /*! The v direction of a shading basis at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeShadingBasisV; /*! Stencil values for subdivision at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeSubdivisionStencil; /*! A vector tangent to a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeTangent; /*! Texture coordinate mapping at a vertex */ MDL_EXPORT NSString * const MDLVertexAttributeTextureCoordinate; /*! @enum MDLVertexFormat @abstract Describes the format of a an attribute in a vertex buffer @discussion Designed to be very similar to MTLVertexDescriptor to ease the translation from one to the other. Values are chosen such that packed types would all be less than 0x1000 and the bottom 5 bits can be used to determine the number of channels/components in the format. */ typedef NS_ENUM(NSUInteger, MDLVertexFormat) { MDLVertexFormatInvalid = 0, MDLVertexFormatPackedBit = 0x1000, MDLVertexFormatUCharBits = 0x10000, MDLVertexFormatCharBits = 0x20000, MDLVertexFormatUCharNormalizedBits = 0x30000, MDLVertexFormatCharNormalizedBits = 0x40000, MDLVertexFormatUShortBits = 0x50000, MDLVertexFormatShortBits = 0x60000, MDLVertexFormatUShortNormalizedBits = 0x70000, MDLVertexFormatShortNormalizedBits = 0x80000, MDLVertexFormatUIntBits = 0x90000, MDLVertexFormatIntBits = 0xA0000, MDLVertexFormatHalfBits = 0xB0000, MDLVertexFormatFloatBits = 0xC0000, MDLVertexFormatUChar = MDLVertexFormatUCharBits | 1, MDLVertexFormatUChar2 = MDLVertexFormatUCharBits | 2, MDLVertexFormatUChar3 = MDLVertexFormatUCharBits | 3, MDLVertexFormatUChar4 = MDLVertexFormatUCharBits | 4, MDLVertexFormatChar = MDLVertexFormatCharBits | 1, MDLVertexFormatChar2 = MDLVertexFormatCharBits | 2, MDLVertexFormatChar3 = MDLVertexFormatCharBits | 3, MDLVertexFormatChar4 = MDLVertexFormatCharBits | 4, MDLVertexFormatUCharNormalized = MDLVertexFormatUCharNormalizedBits | 1, MDLVertexFormatUChar2Normalized = MDLVertexFormatUCharNormalizedBits | 2, MDLVertexFormatUChar3Normalized = MDLVertexFormatUCharNormalizedBits | 3, MDLVertexFormatUChar4Normalized = MDLVertexFormatUCharNormalizedBits | 4, MDLVertexFormatCharNormalized = MDLVertexFormatCharNormalizedBits | 1, MDLVertexFormatChar2Normalized = MDLVertexFormatCharNormalizedBits | 2, MDLVertexFormatChar3Normalized = MDLVertexFormatCharNormalizedBits | 3, MDLVertexFormatChar4Normalized = MDLVertexFormatCharNormalizedBits | 4, MDLVertexFormatUShort = MDLVertexFormatUShortBits | 1, MDLVertexFormatUShort2 = MDLVertexFormatUShortBits | 2, MDLVertexFormatUShort3 = MDLVertexFormatUShortBits | 3, MDLVertexFormatUShort4 = MDLVertexFormatUShortBits | 4, MDLVertexFormatShort = MDLVertexFormatShortBits | 1, MDLVertexFormatShort2 = MDLVertexFormatShortBits | 2, MDLVertexFormatShort3 = MDLVertexFormatShortBits | 3, MDLVertexFormatShort4 = MDLVertexFormatShortBits | 4, MDLVertexFormatUShortNormalized = MDLVertexFormatUShortNormalizedBits | 1, MDLVertexFormatUShort2Normalized = MDLVertexFormatUShortNormalizedBits | 2, MDLVertexFormatUShort3Normalized = MDLVertexFormatUShortNormalizedBits | 3, MDLVertexFormatUShort4Normalized = MDLVertexFormatUShortNormalizedBits | 4, MDLVertexFormatShortNormalized = MDLVertexFormatShortNormalizedBits | 1, MDLVertexFormatShort2Normalized = MDLVertexFormatShortNormalizedBits | 2, MDLVertexFormatShort3Normalized = MDLVertexFormatShortNormalizedBits | 3, MDLVertexFormatShort4Normalized = MDLVertexFormatShortNormalizedBits | 4, MDLVertexFormatUInt = MDLVertexFormatUIntBits | 1, MDLVertexFormatUInt2 = MDLVertexFormatUIntBits | 2, MDLVertexFormatUInt3 = MDLVertexFormatUIntBits | 3, MDLVertexFormatUInt4 = MDLVertexFormatUIntBits | 4, MDLVertexFormatInt = MDLVertexFormatIntBits | 1, MDLVertexFormatInt2 = MDLVertexFormatIntBits | 2, MDLVertexFormatInt3 = MDLVertexFormatIntBits | 3, MDLVertexFormatInt4 = MDLVertexFormatIntBits | 4, MDLVertexFormatHalf = MDLVertexFormatHalfBits | 1, MDLVertexFormatHalf2 = MDLVertexFormatHalfBits | 2, MDLVertexFormatHalf3 = MDLVertexFormatHalfBits | 3, MDLVertexFormatHalf4 = MDLVertexFormatHalfBits | 4, MDLVertexFormatFloat = MDLVertexFormatFloatBits | 1, MDLVertexFormatFloat2 = MDLVertexFormatFloatBits | 2, MDLVertexFormatFloat3 = MDLVertexFormatFloatBits | 3, MDLVertexFormatFloat4 = MDLVertexFormatFloatBits | 4, MDLVertexFormatInt1010102Normalized = MDLVertexFormatIntBits | MDLVertexFormatPackedBit | 4, MDLVertexFormatUInt1010102Normalized = MDLVertexFormatUIntBits | MDLVertexFormatPackedBit | 4 }; MDLVertexBufferLayout /*! @class MDLVertexBufferLayout @abstract Describes a vertex buffer's layout */ API_AVAILABLE(macos(10.11), ios(9.0), tvos(9.0)) MDL_EXPORT @interface MDLVertexBufferLayout : NSObject - (instancetype) initWithStride:(NSUInteger) stride; /*! @property stride @abstract stride in bytes of each vertex element in the buffer. @discussion - If you store multiple attributes interleaved in the vertex buffer, the stride will be the sum of sizes of each attribute (and any padding). - If you store multiple attributes non-interleaved (back to back), the stride will be the size of an attribute (and all attributes are required to have the same size). */ @property (nonatomic, readwrite) NSUInteger stride; @end MDLVertexAttribute /*! @class MDLVertexAttribute @abstract Structure with properties of a vertex attribute */ API_AVAILABLE(macos(10.11), ios(9.0), tvos(9.0)) MDL_EXPORT @interface MDLVertexAttribute : NSObject /*! @method initWithName:format:offset:bufferIndex @abstract Initialize attribute object with all properties */ - (instancetype) initWithName:(NSString *)name format:(MDLVertexFormat)format offset:(NSUInteger)offset bufferIndex:(NSUInteger)bufferIndex; /*! @property name @abstract Identifying name of the attribute derived from model file, or one of the predefined MDLVertexAttribute strings */ @property (nonatomic, copy) NSString *name; /*! @property format @abstract Format (including number of components) of the attribute @discussion If the value is MDLVertexFormatInvalid. Other values of this object will be ignored when setting the MDLVertexDescriptor object in a Mesh. The initial value is MDLVertexFormatInvalid. */ @property (nonatomic, readwrite) MDLVertexFormat format; /*! @property offset @abstract offset in bytes of the attrbute in each element of the vertex buffer */ @property (nonatomic, readwrite) NSUInteger offset; /*! @property bufferIndex @abstract index of the buffer in mesh's vertexBuffer array in which this attribute resides */ @property (nonatomic, readwrite) NSUInteger bufferIndex; /*! @property time @abstract the time the attribute is intended for. @discussion morph targets would store their times here */ @property (nonatomic, readwrite) NSTimeInterval time; /*! @property initializationValue @abstract Value to initialize the attribute to in the vertex buffer if no values @discussion This values of this vector will be set in attribute in the vertex attribute if the attribute did not previously exist in the mesh when setting the MDLVertexDescriptor in the mesh. Components of this vector will also be set in The initial value of initializationValue is (0, 0, 0, 1). */ @property (nonatomic, readwrite) vector_float4 initializationValue; @end MDLVertexDescriptor /*! @class MDLVertexDescriptor @abstract Describes the layout of vertex buffers in MDLMesh objects @discussion This object is a property of MDLMesh describing the current state of attributes and buffer layouts of the vertex buffers in the mesh. This must be immutable otherwise even small changes could cause the buffers to be out of sync with the layout described here. Designed to be very similar to MTLVertexDescriptor to ease creation of one from the other */ API_AVAILABLE(macos(10.11), ios(9.0), tvos(9.0)) MDL_EXPORT @interface MDLVertexDescriptor : NSObject /*! @method initVertexDescriptor: @abstract Initializes the object with values from supplied vertexDescriptor @discussion This performs a deep copy of all data in the supplied descriptor. */ -(instancetype) initWithVertexDescriptor:(MDLVertexDescriptor *)vertexDescriptor; /*! @method attributeNamed: @abstract Retrieves the attribute with the given name @return The attribute with the supplied name or nil if attribute with the given name does not exist in the descriptor object */ -(nullable MDLVertexAttribute *)attributeNamed:(NSString*)name; /*! @method addOrReplaceAttribute: @abstract Replace any attribute with the same name and time, or add it if it does not already exist. */ - (void)addOrReplaceAttribute:(nonnull MDLVertexAttribute*)attribute; /*! @method removeAttributeNamed: @abstract Remove the named attribute if it exists */ - (void)removeAttributeNamed:(NSString*)name; /*! @property attributes @abstract An array of MDLVertexAttribute objects @discussion ay describing the current attribute state of vertex buffers in an MDLMesh mesh */ @property (nonatomic, retain) NSMutableArray *attributes; /*! @property layouts @abstract An array of MDLVertexBufferLayout @discussion An array describing the current layout state of vertex buffers in an MDLMesh mesh */ @property (nonatomic, retain) NSMutableArray *layouts; /*! @method reset @abstract Tesets the descriptor to initial values */ - (void)reset; /*! @method setPackedStrides @abstract Sets the stride in each VertexBufferLout in the layouts array to the minimum value encompassing all attributes in the vertex buffer */ - (void)setPackedStrides; /*! @method setPackedOffsets @abstract Sets the stride in each VertexAttribute in the attributes array to the minimum value to pack each attribute next to each other in its vertexbuffer */ - (void)setPackedOffsets; @end Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLRenderPass.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLRenderPass.html","title":"MTLRenderPass API","keywords":"","body":"MTLRenderPassDescriptor MTLRenderPassDescriptor 包含一组附件，这些附件用作渲染管道渲染生成像素的渲染目标！MTLRenderPassDescriptor 对象还为渲染管道生成的可见性信息设置目标缓冲区。 当配置一个与附件一起使用的MTLTextureDescriptor对象时，如果您已经知道要在附件中使用生成的MTLTexture对象，则将其用法值设置为MTLTextureUsageRenderTarget。这可能会显著提高应用在特定硬件上的性能。 typedef NS_ENUM(NSUInteger, MTLLoadAction) { MTLLoadActionDontCare = 0, MTLLoadActionLoad = 1, MTLLoadActionClear = 2, }; typedef NS_ENUM(NSUInteger, MTLStoreAction) { MTLStoreActionDontCare = 0, MTLStoreActionStore = 1, MTLStoreActionMultisampleResolve = 2, MTLStoreActionStoreAndMultisampleResolve = 3, MTLStoreActionUnknown = 4, MTLStoreActionCustomSampleDepthStore = 5, }; typedef NS_OPTIONS(NSUInteger, MTLStoreActionOptions) { MTLStoreActionOptionNone = 0, MTLStoreActionOptionCustomSamplePositions = 1 /// 此附件的纹理对象 @property (nullable, nonatomic, strong) id texture; /// 用于渲染的纹理的mipmap级别；默认为 0 @property (nonatomic) NSUInteger level; /// 用于渲染的纹理切片；默认为 0 @property (nonatomic) NSUInteger slice; /// 用于渲染的纹理的深度平面；默认为 0 @property (nonatomic) NSUInteger depthPlane; /// 用于多样本解析操作的纹理；仅在 storeAction=MTLStoreActionMultisampleResolve 时使用 @property (nullable, nonatomic, strong) id resolveTexture; /// 用于多样本解析的纹理的mipmap级别；默认为 0 @property (nonatomic) NSUInteger resolveLevel; /// 用于多样本解析的纹理切片；默认为 0 @property (nonatomic) NSUInteger resolveSlice; /// 用于多样本解析的解析纹理的纹理深度平面；默认为 0 @property (nonatomic) NSUInteger resolveDepthPlane; /// 在渲染管道开始时用这个附件执行的动作，默认 MTLLoadActionDontCare @property (nonatomic) MTLLoadAction loadAction; /// 在渲染管道的末尾用这个附件执行的动作；默认 MTLStoreActionDontCare @property (nonatomic) MTLStoreAction storeAction; /// 可选配置，用于在渲染管道的末尾使用此附件执行的存储操作；默认 MTLStoreActionOptionNone @property (nonatomic) MTLStoreActionOptions storeActionOptions; @end @interface MTLRenderPassColorAttachmentDescriptor : MTLRenderPassAttachmentDescriptor /// 当 loadAction=MTLLoadActionClear 时使用的擦写色 @property (nonatomic) MTLClearColor clearColor; @end /** 控制 MSAA 深度解析操作：支持iOS GPU Family 3及以上版本 * @discussion MSAA 是 MultiSampling Anti-Aliasing 的英文缩写，指多重采样抗锯齿， * 原理是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上; */ typedef NS_ENUM(NSUInteger, MTLMultisampleDepthResolveFilter) { MTLMultisampleDepthResolveFilterSample0 = 0, MTLMultisampleDepthResolveFilterMin = 1, MTLMultisampleDepthResolveFilterMax = 2, }; @interface MTLRenderPassDepthAttachmentDescriptor : MTLRenderPassAttachmentDescriptor /// 当 loadAction=MTLLoadActionClear 时，要使用的擦除深度值 @property (nonatomic) double clearDepth; /// 用于深度多样本解析的过滤器。默认为 MTLMultisampleDepthResolveFilterSample0 @property (nonatomic) MTLMultisampleDepthResolveFilter depthResolveFilter; @end /// 控制MSAA模板解析操作 typedef NS_ENUM(NSUInteger, MTLMultisampleStencilResolveFilter) { /// 默认行为，模板样本对应于样本0 MTLMultisampleStencilResolveFilterSample0 = 0, /// 深度解析过滤器选择的深度样本对应的模板样本。如果深度解析未启用，则根据深度解析过滤器的选择选择模板样本。 MTLMultisampleStencilResolveFilterDepthResolvedSample = 1, }; @interface MTLRenderPassStencilAttachmentDescriptor : MTLRenderPassAttachmentDescriptor /// loadAction=MTLLoadActionClear 是使用的 clear 模板值 @property (nonatomic) uint32_t clearStencil; /// 用于模板多样本解析的过滤器。默认为 MTLMultisampleStencilResolveFilterSample0 @property (nonatomic) MTLMultisampleStencilResolveFilter stencilResolveFilter; @end @interface MTLRenderPassColorAttachmentDescriptorArray : NSObject /// 单个附件状态访问 - (MTLRenderPassColorAttachmentDescriptor *)objectAtIndexedSubscript:(NSUInteger)attachmentIndex; /// 这总是使用'copy'语义。将任何合法索引上的附件状态设置为nil是安全的，这将将附件描述符状态重置为默认值。 - (void)setObject:(nullable MTLRenderPassColorAttachmentDescriptor *)attachment atIndexedSubscript:(NSUInteger)attachmentIndex; @end @interface MTLRenderPassSampleBufferAttachmentDescriptor : NSObject /*! @property sampleBuffer @abstract The sample buffer to store samples for the render-pass defined samples. If sampleBuffer is non-nil, the sample indices will be used to store samples into the sample buffer. If no sample buffer is provided, no samples will be taken. If any of the sample indices are specified as MTLCounterDontSample, no sample will be taken for that action. */ @property (nullable, nonatomic, retain) id sampleBuffer API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property startOfVertexSampleIndex @abstract The sample index to use to store the sample taken at the start of vertex processing. Setting the value to MTLCounterDontSample will cause this sample to be omitted. @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported, this sample index is invalid and must be set to MTLCounterDontSample or creation of a render pass will fail. */ @property (nonatomic) NSUInteger startOfVertexSampleIndex API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property endOfVertexSampleIndex @abstract The sample index to use to store the sample taken at the end of vertex processing. Setting the value to MTLCounterDontSample will cause this sample to be omitted. @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported, this sample index is invalid and must be set to MTLCounterDontSample or creation of a render pass will fail. */ @property (nonatomic) NSUInteger endOfVertexSampleIndex API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property startOfFragmentSampleIndex @abstract The sample index to use to store the sample taken at the start of fragment processing. Setting the value to MTLCounterDontSample will cause this sample to be omitted. @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported, this sample index is invalid and must be set to MTLCounterDontSample or creation of a render pass will fail. */ @property (nonatomic) NSUInteger startOfFragmentSampleIndex API_AVAILABLE(macos(11.0), ios(14.0)); /*! @property endOfFragmentSampleIndex @abstract The sample index to use to store the sample taken at the end of fragment processing. Setting the value to MTLCounterDontSample will cause this sample to be omitted. @discussion On devices where MTLCounterSamplingPointAtStageBoundary is unsupported, this sample index is invalid and must be set to MTLCounterDontSample or creation of a render pass will fail. */ @property (nonatomic) NSUInteger endOfFragmentSampleIndex API_AVAILABLE(macos(11.0), ios(14.0)); @end MTL_EXPORT API_AVAILABLE(macos(11.0), ios(14.0)) @interface MTLRenderPassSampleBufferAttachmentDescriptorArray : NSObject /* Individual attachment state access */ - (MTLRenderPassSampleBufferAttachmentDescriptor *)objectAtIndexedSubscript:(NSUInteger)attachmentIndex; /* This always uses 'copy' semantics. It is safe to set the attachment state at any legal index to nil, which resets that attachment descriptor state to default vaules. */ - (void)setObject:(nullable MTLRenderPassSampleBufferAttachmentDescriptor *)attachment atIndexedSubscript:(NSUInteger)attachmentIndex; @end /// 表示用于创建具体渲染命令编码器的附件集合 @interface MTLRenderPassDescriptor : NSObject /// 创建一个自动释放的默认帧缓冲区描述符 + (MTLRenderPassDescriptor *)renderPassDescriptor; @property (readonly) MTLRenderPassColorAttachmentDescriptorArray *colorAttachments; @property (copy, nonatomic, null_resettable) MTLRenderPassDepthAttachmentDescriptor *depthAttachment; @property (copy, nonatomic, null_resettable) MTLRenderPassStencilAttachmentDescriptor *stencilAttachment; /// 缓冲区，通过深度测试和模板测试的样本被存储到其中 @property (nullable, nonatomic, strong) id visibilityResultBuffer; /// 活跃图层的数量 @property (nonatomic) NSUInteger renderTargetArrayLength; /// renderPass 中最大的显式imageblock布局的每个样本大小(以字节为单位)。 @property (nonatomic) NSUInteger imageblockSampleLength; /// 线程组内存分配的每块大小(以字节为单位) @property (nonatomic) NSUInteger threadgroupMemoryLength; /// 贴图的像素宽度：默认为 0 表示Metal选择适合本地内存的宽度 @property (nonatomic) NSUInteger tileWidth; /// 贴图的像素高度：默认为 0 表示Metal选择适合本地内存的高度 @property (nonatomic) NSUInteger tileHeight; /// 当没有附件时，渲染管道的光栅样本计数 @property (nonatomic) NSUInteger defaultRasterSampleCount; /// 要约束渲染目标的像素宽度；默认值为0。否则该值必须小于或等于所有附件的最小宽度。 @property (nonatomic) NSUInteger renderTargetWidth; /// 要约束渲染目标的像素高度。默认值为0，否则该值必须小于或等于所有附件的最小高度 @property (nonatomic) NSUInteger renderTargetHeight; /** 设置自定义样本位置，用于MSAA渲染(即当样本计数> 1) * @param positions 用于自定义样本位置数据的源数组 * @param count 指定位置数组的长度，并且必须是有效的样本计数或0(为了禁用自定义样本位置)。 */ - (void)setSamplePositions:(const MTLSamplePosition * _Nullable)positions count:(NSUInteger)count; /*! @method getSamplePositions:count: @abstract Retrieve the previously configured custom sample positions. The positions input array will only be modified when count specifies a length sufficient for the number of previously configured positions. @param positions The destination array for custom sample position data. @param count Specifies the length of the positions array, which must be large enough to hold all configured sample positions. @return The number of previously configured custom sample positions. */ - (NSUInteger)getSamplePositions:(MTLSamplePosition * _Nullable)positions count:(NSUInteger)count API_AVAILABLE(macos(10.13), ios(11.0)); /** @property rasterizationRateMap @abstract The variable rasterization rate map to use when rendering this pass, or nil to not use variable rasterization rate. @discussion The default value is nil. Enabling variable rasterization rate allows for decreasing the rasterization rate in unimportant regions of screen space. */ @property (nullable, nonatomic, strong) id rasterizationRateMap API_AVAILABLE(macos(10.15.4), ios(13.0), macCatalyst(13.4)); /// 一个数组：样本缓冲区和相关样本索引 @property (readonly) MTLRenderPassSampleBufferAttachmentDescriptorArray * sampleBufferAttachments; @end // 内联函数 MTL_INLINE MTLClearColor MTLClearColorMake(double red, double green, double blue, double alpha) { MTLClearColor result; result.red = red; result.green = green; result.blue = blue; result.alpha = alpha; return result; } Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLFunction.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLFunction.html","title":"MTLFunction API","keywords":"","body":"Shader函数 NSErrorDomain const MTLLibraryErrorDomain; /// Shader 函数类型 typedef NS_ENUM(NSUInteger, MTLFunctionType) { MTLFunctionTypeVertex = 1, /// 适用于渲染管道的顶点着色器 MTLFunctionTypeFragment = 2, /// 适用于渲染管道的片段着色器 MTLFunctionTypeKernel = 3, /// 适用于计算管道的计算函数 MTLFunctionTypeVisible API_AVAILABLE(macos(11.0), ios(14.0)) = 5, MTLFunctionTypeIntersection API_AVAILABLE(macos(11.0), ios(14.0)) = 6, } API_AVAILABLE(macos(10.11), ios(8.0)); /// Shader 函数的一些描述常量 @interface MTLFunctionConstant : NSObject @property (readonly) NSString *name; @property (readonly) MTLDataType type; @property (readonly) NSUInteger index; @property (readonly) BOOL required; @end /// Shader函数句柄，用于计算管道或者渲染管道；只能与创建它的设备一起使用 @protocol MTLFunction /// 标识符 @property (nullable, copy, atomic) NSString *label; /// 创建该资源的设备；只能在此设备上使用 @property (readonly) id device; /// Shader函数类型 @property (readonly) MTLFunctionType functionType; /*! @property patchType @abstract Returns the patch type. MTLPatchTypeNone if it is not a post tessellation vertex shader. */ @property (readonly) MTLPatchType patchType; /// 如果未在着色器中指定，则返回-1 @property (readonly) NSInteger patchControlPointCount; @property (nullable, readonly) NSArray *vertexAttributes; /// 描述属性 @property (nullable, readonly) NSArray *stageInputAttributes; /// 函数名 @property (readonly) NSString *name; /// Shader函数信息 @property (readonly) NSDictionary *functionConstantsDictionary; /// 创建一个参数编码器，它将编码与绑定点索引的参数缓冲区布局匹配的参数 - (id )newArgumentEncoderWithBufferIndex:(NSUInteger)bufferIndex; - (id )newArgumentEncoderWithBufferIndex:(NSUInteger)bufferIndex reflection:(MTLAutoreleasedArgument * __nullable)reflection; /// 创建函数时使用的一些配置 @property (readonly) MTLFunctionOptions options; @end typedef NS_ENUM(NSUInteger, MTLLanguageVersion) { MTLLanguageVersion1_0 API_AVAILABLE(ios(9.0)) API_UNAVAILABLE(macos, macCatalyst) = (1 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLLibrary.html":{"url":"计算机基础/计算机图形学/Graphics_Metal/MetalDocument/MTLLibrary.html","title":"MTLLibrary API","keywords":"","body":"资源库 MTLLibrary /// 创建库实例的一些常见错误 typedef NS_ENUM(NSUInteger, MTLLibraryError) { MTLLibraryErrorUnsupported = 1, MTLLibraryErrorInternal = 2, MTLLibraryErrorCompileFailure = 3, MTLLibraryErrorCompileWarning = 4, MTLLibraryErrorFunctionNotFound API_AVAILABLE(macos(10.12), ios(10.0)) = 5, MTLLibraryErrorFileNotFound API_AVAILABLE(macos(10.12), ios(10.0)) = 6, } API_AVAILABLE(macos(10.11), ios(8.0)); @protocol MTLLibrary /// 标识符 @property (nullable, copy, atomic) NSString *label; /// 库资源只能在创建它的设备上使用 @property (readonly) id device; /// 同步获取一个函数指针，如果在库中找不到该函数则返回 nil - (nullable id )newFunctionWithName:(NSString *)functionName; - (nullable id )newFunctionWithDescriptor:(nonnull MTLFunctionDescriptor *)descriptor error:(__autoreleasing NSError **)error; - (nullable id )newFunctionWithName:(NSString *)name constantValues:(MTLFunctionConstantValues *)constantValues error:(__autoreleasing NSError **)error; - (nullable id )newIntersectionFunctionWithDescriptor:(nonnull MTLIntersectionFunctionDescriptor *)descriptor error:(__autoreleasing NSError **)error; /// 异步获取一个函数指针 - (void)newFunctionWithName:(NSString *)name constantValues:(MTLFunctionConstantValues *)constantValues completionHandler:(void (^)(id __nullable function, NSError* __nullable error))completionHandler; - (void)newFunctionWithDescriptor:(nonnull MTLFunctionDescriptor *)descriptor completionHandler:(void (^)(id __nullable function, NSError* __nullable error))completionHandler; - (void)newIntersectionFunctionWithDescriptor:(nonnull MTLIntersectionFunctionDescriptor *)descriptor completionHandler:(void (^)(id __nullable function, NSError* __nullable error))completionHandler; /// 库中所有的函数 @property (readonly) NSArray *functionNames; /** 创建的库类型 * MTLLibraryTypeExecutable 可以获取函数指针 * MTLLibraryTypeDynamic 库可用于解析来自其他 MTLLibrary 的外部引用 */ @property (readonly) MTLLibraryType type; /// 创建动态库时提供的 installName； @property (readonly, nullable) NSString* installName; @end Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/杂记/iOS渲染机制初窥.html":{"url":"iOS开发/杂记/iOS渲染机制初窥.html","title":"iOS渲染机制初窥","keywords":"","body":"iOS渲染机制初窥 1、渲染与成像 1.1、CPU 与 GPU 处理器 对于现代计算机系统，简单来说可以大概视作三层架构：硬件、操作系统与进程。对于移动端来说，进程就是 App，而 CPU 与 GPU 是硬件层面的重要组成部分。CPU 与 GPU 提供了计算能力，通过操作系统被 App 调用。 区别 CPU Central Processing Unit GPU Graphics Processing Unit 名称 中央处理器，系统的运算核心、控制核心 图形处理器 工作范围 大都在软件层面，适用于串行计算 大都在硬件层面，适用于并行计算 设计目的 低时延，更多的高速缓存，更快速地处理逻辑分支 更强的计算能力，基于大吞吐量而设计 工作场景 需要很强的通用性来处理各种不同的类型数据，同时又要逻辑判断又会引入大量的分支跳转和中断处理 面对类型高度统一的、相互无依赖的大规模数据和不需要被打断纯净的计算环境 架构 CPU的内部结构异常复杂，拥有更多的缓存空间以及复杂的控制单元 GPU 基于大吞吐量而设计，拥有更多的计算单元 Arithmetic Logic Unit GPU 优秀的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。 1.2、CPU+GPU 渲染流水线 图像渲染流程粗粒度地大概分为下面这些步骤： 除了第一阶段 Application 由CPU负责，后续主要都由 GPU 负责： 一个简单的三角形绘制就需要大量的 GPU 资源来计算；针对更多更复杂的顶点、颜色、纹理信息，其计算量是难以想象的。这也是为什么 GPU 更适合于渲染。 详细分析渲染流水线中各个阶段的具体任务： Ⅰ、Application 应用处理阶段：得到图元 该阶段具体指的是图像在 App 中被处理的阶段，此时还处于 CPU 负责的时期。 在该阶段 App 会对图像进行一系列的操作或者改变，最终将新的图像信息传给下一阶段。 这部分信息被叫做图元，通常是三角形、线段、顶点等。 Ⅱ、Geometry 几何处理阶段：处理图元 这个阶段以及之后的阶段，主要由 GPU 负责。 此时 GPU 可以拿到 Application 阶段传递下来的图元信息、并对这部分图元进行处理，然后输出新的图元。 这一系列阶段包括： 顶点着色器 Vertex Shader：将图元中的顶点信息进行视角转换、添加光照信息、增加纹理等操作； 形状装配 Shape Assembly：图元中的三角形、线段、点分别对应三个顶点、两个顶点、一个顶点；这个阶段会将顶点连接成相应的形状； 几何着色器Geometry Shader：添加额外的顶点，将原始图元转换成新图元，以构建一个不一样的模型。简单来说就是基于三角形、线段和点构建更复杂的几何图形。 Ⅲ、Rasterization 光栅化阶段：图元转换为像素 光栅化的主要目的是将几何渲染之后的图元信息，转换为一系列的像素，以便后续显示在屏幕上。 这个阶段中会根据图元信息，计算出每个图元所覆盖的像素信息等，从而将像素划分成不同的部分。 一种简单的划分就是根据中心点：如果像素的中心点在图元内部，那么这个像素就属于这个图元。如上图所示，深蓝色的线就是图元信息所构建出的三角形；而通过是否覆盖中心点，可以遍历出所有属于该图元的所有像素，即浅蓝色部分。 Ⅳ、Pixel 像素处理阶段：处理像素，得到位图 经过光栅化阶段，可以得到图元所对应的像素；此时，需要给这些像素填充颜色和效果。所以最后这个阶段就是给像素填充正确的内容，最终显示在屏幕上。 这些经过处理、蕴含大量信息的像素点集合，被称作 位图 bitmap 。也就是说，Pixel 阶段最终输出的结果就是位图，过程具体包含： 片段着色器Fragment Shader：也叫做 Pixel Shader，这个阶段的目的是给每一个像素 Pixel 赋予正确的颜色。颜色的来源就是之前得到的顶点、纹理、光照等信息。由于需要处理纹理、光照等复杂信息，所以这通常是 整个系统的性能瓶颈。 测试与混合Tests and Blending：也叫做 Merging 阶段 ，这个阶段主要处理片段的前后位置以及透明度。这个阶段会检测各个着色片段的深度值 z 坐标，从而判断片段的前后位置，以及是否应该被舍弃。同时也会计算相应的透明度 alpha 值，从而进行片段的混合，得到最终的颜色。 这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。只要有足够多的不同色彩的像素，就可以制作出色彩丰富的图象，逼真地表现自然界的景象。缩放和旋转容易失真，同时文件容量较大。 1.3、屏幕成像 在图像渲染流程结束之后，接下来就需要将得到的 bitmap 信息显示在物理屏幕上了。 CPU 计算好显示内容提交至 GPU，GPU 渲染结束后将 bitmap 信息缓存在 帧缓冲区 Framebuffer 中； 显示控制器 VideoController 收到 VSync 信号后逐帧读取 Framebuffer 中的数据，经过 数模转换 传递给 显示器Monitor 进行显示。完整的流程如下图所示： 1.4、显示器原理 显示器的电子束从上到下逐行扫描，扫描完成后显示器就呈现一帧画面；然后电子束回到初始位置进行下一次扫描。 为了同步显示器的显示过程和系统的显示控制器，显示器会用硬件时钟产生一系列的定时信号： 水平同步信号horizonal synchronization，简称 HSync：当电子束换行进行扫描时，显示器会发出一个HSync信号； 垂直同步信号vertical synchronization，简称VSync： 当一帧画面绘制完成后，电子束回复到原位，准备画下一帧前，显示器会发出一个 VSync 信号； 电子束扫描的过程中，屏幕就能呈现出对应的结果，每次整个屏幕被电子束扫描完一次后，就相当于呈现了一帧完整的图像。屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。而这个屏幕刷新的频率，就是 帧率（Frame per Second，FPS）。由于人眼的视觉暂留效应，当屏幕刷新频率足够高时（FPS 通常是 50 到 60 左右），就能让画面看起来是连续而流畅的。对于 iOS 而言，App 应该尽量保证 60 FPS 才是最好的体验。 1.5、屏幕撕裂 Screen Tearing CPU+GPU 的渲染流程是一个非常耗时的过程。 在单一缓存的模式下，理想情况是：每次电子束从头开始新的一帧的扫描时，CPU+GPU 对于该帧的渲染流程已经结束，渲染好的 bitmap 已经放入Framebuffer中。但这种完美的情况是非常脆弱的，很容易产生屏幕撕裂： 如果在电子束开始扫描新的一帧时，bitmap 还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入Framebuffer中； 那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成 屏幕撕裂 。 1.6、垂直同步 Vsync + 双缓冲机制 Double Buffering iOS 设备会始终使用 Vsync + Double Buffering 的策略。 解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号 Vsync 与双缓冲机制 Double Buffering。 使用 Vsync信号给 Framebuffer 加锁：只有当显示控制器接收到 Vsync信号时，才会将Framebuffer中的bitmap更新为下一帧，这样就能保证每次显示的都是同一帧的画面，也就避免了屏幕撕裂。 这种情况下要求显示控制器在接受到 Vsync 信号后将下一帧的bitmap传入；这意味着整个 CPU+GPU 的渲染流程都要在一瞬间完成，这明显是不现实的。 使用 双缓冲机制 会增加一个新的 备用缓冲区 BackBuffer：渲染结果会预先保存在 BackBuffer 中；在接收到 Vsync 信号的时候，显示控制器会将 BackBuffer 中的内容置换到 Framebuffer 中，此时就能保证置换操作几乎在一瞬间完成（实际上是交换了内存地址）。 1.7、屏幕卡顿的本质：掉帧 Jank 屏幕刷新频率必须要足够高才能流畅 使用 Vsync 信号以及双缓冲机制之后，能够解决屏幕撕裂的问题，但是会引入新的问题：掉帧。 如果在接收到 Vsync 之时 CPU 和 GPU 还没有渲染好新的位图，显示控制器就不会去替换Framebuffer 中的bitmap；这时屏幕就会重新扫描呈现出上一帧的画面；两个周期显示同一 bitmap，这就是所谓 掉帧 的情况。 如图所示，A、B 代表两个Framebuffer，当 B 没有渲染完毕时就接收到了 Vsync 信号，所以屏幕只能再显示相同帧 A，这就发生了第一次的掉帧。 App 卡顿的直接原因：CPU 和 GPU 渲染流水线耗时过长，导致掉帧 。对于 iPhone 手机来说，屏幕最大的刷新频率是 60 FPS，一般只要保证 50 FPS 就已经是较好的体验了。如果掉帧过多，导致刷新频率过低，就会造成不流畅的使用体验。 1.8、三缓冲 Triple Buffering 在上述策略中发生掉帧的时候，CPU 和 GPU 有一段时间处于闲置状态：当 A 的内容正在被扫描显示在屏幕上，而 B 的内容已经被渲染好，此时 CPU 和 GPU 就处于闲置状态。 如果再增加一个帧缓冲区，就可以利用这段时间进行下一步的渲染，并将渲染结果暂存于新增的帧缓冲区。 如图所示，由于增加了新的帧缓冲区，可以一定程度上地利用掉帧的空档期，合理利用 CPU 和 GPU 性能，从而减少掉帧的次数。 在Android4.1系统开始，引入了三缓冲+垂直同步的机制。由于多加了一个 Buffer，实现了 CPU 跟 GPU 并行，便可以做到了只在开始掉一帧，后续却不掉帧。 缓冲机制 意义 Vsync 与双缓冲 强制同步屏幕刷新，以掉帧为代价解决屏幕撕裂问题 三缓冲 合理使用 CPU、GPU 渲染性能，减少掉帧次数 2、 iOS 的渲染 了解了计算机的大致渲染流程后，我们回到主题，iOS App 的渲染大致是一个怎样的过程呢？ 2.1、iOS 的渲染框架 iOS App 的图形渲染依然符合渲染流水线的基本架构；在硬件基础之上，使用了 CoreGraphics、CoreAnimation、CoreImage 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系；但都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。 UIKit ：是 iOS 开发者最常用的框架，通过设置 UIKit 组件的布局以及相关属性来绘制界面。 事实上， UIKit 并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件响应的传递大体是经过 视图树 逐层的遍历实现的。 GPU Driver：软件框架最终通过 OpenGL 连接到 GPU Driver，GPU Driver 是直接和 GPU 交流的代码块，直接与 GPU 连接。 OpenGL：是一个提供了 2D 和 3D 图形渲染的 API，它能和 GPU 密切的配合，高效利用 GPU 能力实现硬件加速渲染。OpenGL的高效实现（利用了图形加速硬件）一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。OpenGL 之上扩展出很多东西，如 CoreGraphics 等最终都依赖于 OpenGL，有些情况下为了更高的效率，比如游戏程序，甚至会直接调用 OpenGL 的接口。 Metal 类似于 OpenGL，也是一套第三方标准，具体实现由苹果实现。大多数开发者仅仅间接的使用 Metal。CoreAnimation、CoreImage、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。 CoreAnimation：源自于 LayerKit，是一个复合引擎，主要职责包含：渲染、构建和实现动画；可视内容可被分解成独立的图层CALayer，这些图层会被存储在一个叫做 图层树 的体系之中，这个树是 iOS 应用程序中所能在屏幕上看见的一切的基础。 CoreAnimation 是 AppKit 和 UIKit 完美的底层支持，是 App 界面渲染和构建的最基础架构。 CoreGraphics：基于 Quartz 高级绘图引擎，主要用于 运行时绘制图像，在运行时实时计算、绘制一系列图像帧来实现动画 ；是一个强大的二维图像绘制引擎，用来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。常用的 CGRect 就定义在这个框架下。 CoreImage： 一个高性能的图像处理分析的框架，它拥有一系列现成的图像滤镜，能对 已存在的图像 进行高效的处理。 CoreAnimation 动画 CoreAnimation 动画是基于事务的动画，是最常见的动画实现方式。动画执行者是专门负责渲染的渲染进程 Render Server，操作的是呈现树。 开发者应该尽量使用 CoreAnimation 来控制动画，因为 CoreAnimation 是充分优化过的；基于Layer的绘图过程中，CoreAnimation 通过硬件操作位图（变换、组合等），产生动画的速度比软件操作的方式快很多。 基于 View 的绘图过程中，view 被改动时会触发的 -drawRect: 方法来重新绘制位图，但是这种方式需要 CPU 在主线程执行，比较耗时。而 CoreAnimation 则尽可能的操作硬件中已缓存的位图，来实现相同的效果，从而减少了资源损耗。 非CoreAnimation 动画 非 CoreAnimation 动画执行者是当前进程，操作的是模型树；常见的有定时器动画和手势动画： 定时器动画是在定时周期触发时修改模型树的图层属性； 手势动画是手势事件触发时修改模型树的图层属性。 两者都能达到视图随着时间不断变化的效果，即实现了动画。 非 CoreAnimation 动画过程中实际上不断改动的是模型树，而呈现树仅仅成了模型树的复制品，状态与模型树保持一致。整个过程中，主要是CPU在主线程不断调整图层属性、布局计算、提交数据，没有充分利用到 CoreAnimation 强大的动画控制功能。 2.2、iOS App 的渲染流水线 App 本身并不负责渲染，渲染由一个独立的进程 Render Server负责。 App 使用 CPU 处理触摸事件、显示内容的前置计算；然后通过 进程间通信 将渲染任务及相关数据提交给 Render Server；Render Server 处理完数据后，再传递至 GPU；最后由 GPU 调用 iOS 的图像设备进行显示。 渲染流水线可以分为下述步骤： App 处理 Handle Events事件，如用户的点击操作；在此过程中 App 可能需要更新 视图树 ，相应地 图层树 也会被更新； App 的 Commit Transaction：App 通过 CPU 处理显示内容的前置计算，如：视图创建、布局计算、图片解码、文本绘制等任务；之后将计算好的图层打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。 解码 Decode：打包好的图层被传输到 Render Server 之后，首先会进行解码。注意完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。 Draw Calls：解码完成后，CoreAnimation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。 渲染阶段 Render：这一阶段主要由 GPU 在物理层上完成了对图像的渲染。 显示阶段 Display：需要等 render 结束的下一个 RunLoop 触发显示。 2.2.1、Commit Transaction 都做了那些工作？ 一般而言，开发者能接触并影响到的就是 Handle Events 和 Commit Transaction 这两个阶段。 Handle Events 就是处理触摸事件，而 Commit Transaction 主要进行的是：Layout、Display、Prepare、Commit 等四个具体的操作。 Ⅰ、 Layout：构建视图 这个阶段主要处理视图的构建和布局，具体步骤包括： 调用重载的 -layoutSubviews 方法； 创建视图，并通过 -addSubview: 方法添加子视图； 计算视图布局，即所有的 Layout Constraint； 由于这个阶段是在 CPU 中进行，通常是 CPU 限制或者 IO 限制，所以应尽量高效、轻量地操作，减少这部分的时间，比如减少非必要的视图创建、简化布局计算、减少视图层级等。 Ⅱ、Display：绘制视图 这个阶段主要是交给 CoreGraphics 进行视图的绘制，得到 图元 数据： 根据上一阶段 Layout 的结果创建得到图元信息； 如果重写了 -drawRect: 方法，那么会调用重载的 -drawRect: 方法，在该方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制； 注意正常情况下 Display 阶段只会得到图元信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 -drawRect: 方法，这个方法会直接调用 CoreGraphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap。 由于重写了 -drawRect: 方法，绘制过程从 GPU 转移到了 CPU，会导致一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。 Ⅲ、 Prepare：CoreAnimation 额外的工作 这一步主要是：图片解码和转换 Ⅳ、 Commit：打包并发送 这一步主要是：图层打包并发送到 Render Server。 注意 Commit 操作是依赖图层树递归执行的，所以如果图层树过于复杂，Commit 的开销就会很大。这也是开发者减少视图层级，从而降低图层树复杂度的原因。 2.3、 视图UIView 与 图层CALayer 2.3.1、图层 CALayer 图层 CALayer 是用户所能在屏幕上看见的一切的基础，用来存放 位图 Bitmap 。 CALayer 有这样一个属性 contents：保存了由设备渲染流水线渲染好的位图 bitmap（通常也被称为 backing store），而当设备屏幕进行刷新时，会从 CALayer 中读取生成好的 bitmap，进而呈现到屏幕上。 /** 该属性提供了图层 CALayer 的内容，是一个指针类型 * 在 iOS 中的类型就是 CGImageRef ；在 OS X 10.6 及更高版本上还可以是 NSImage * 默认值为 nil * @note contents 属性赋予任何值，App 均可以编译通过；但如果 content 的值不是 CGImageRef ，得到的图层将是空白； * 本质上，contents 指向一块缓存区域，称为 backing store，可以存放 bitmap 数据 **/ @property(nullable, strong) id contents; 图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成 纹理），也支持直接使用 纹理（图片） 进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 手动绘制；另一种是 使用图片: 使用图片contents image ： 赋值 CGImageRef 类型的图片； 手动绘制：custom drawing：使用 CoreGraphics 直接绘制 寄宿图；实际开发中，一般通过继承 UIView 并实现 -drawRect: 方法来自定义绘制； // 注意 CGImage 和 CGImageRef 的关系： // typedef struct CGImage CGImageRef; layer.contents = (__bridge id)image.CGImage;** 虽然 -drawRect: 是一个 UIView 方法，但事实上都是底层的 CALayer 完成了重绘工作并保存了产生的图片。下图所示为 -drawRect: 绘制定义寄宿图的基本原理 UIView 有一个关联图层，即 CALayer； CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate 协议。UIView 作为 CALayer 的代理实现了 CALayerDelegae 协议； 当需要重绘时，即调用 -drawRect:，CALayer 请求其代理给予一个寄宿图来显示； CALayer 首先会尝试调用 -displayLayer: 方法，此时代理可以直接设置 contents 属性。 如果代理没有实现 -displayLayer: 方法，CALayer 则会尝试调用 -drawLayer:inContext: 方法。在调用该方法前，CALayer 会创建一个空的寄宿图（尺寸由 bounds 和 contentScale 决定）和一个 CoreGraphics 的绘制上下文，为绘制寄宿图做准备，作为 context 参数传入。 最后，由 CoreGraphics 绘制生成的寄宿图会存入 backing store。 2.3.2、视图 UIView UIView 是 iOS App 中的基本组成结构，定义了一些统一的规范；它会负责内容的渲染、交互事件的处理。 Drawing and animation：绘制与动画 Layout and subview management：布局与子 view 的管理 Event handling：点击事件处理 2.3.3、 UIView 与 CALayer 的关系 CALayer 是 UIView 的属性之一，负责渲染和动画，提供可视内容的呈现。 UIView的职责是 创建并管理 CALayer，以确保当子视图在层级关系中 添加或被移除 时，其关联的图层在图层树中也有相同的操作，即保证视图树和图层树在结构上的 一致性 。 相同的层级结构： UIView 层级拥有 视图树 的树形结构，由于每个 UIView 都对应 CALayer 负责页面的绘制，所以 CALayer 也具有相应的 图层树 的树形结构。 部分效果的设置： UIView 只对 CALayer 的部分功能进行了封装；而另一部分如圆角、阴影、边框等特效都需要通过调用 CALayer 属性来设置； 是否响应点击事件：CALayer 不负责点击事件，所以不响应点击事件，而 UIView 会响应； 不同继承关系：CALayer 继承自 NSObject，UIView 由于要负责交互事件，所以继承自 UIResponder； 2.3.4、为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？ 这样设计的主要原因就是为了 职责分离，拆分功能，方便代码的复用。 iOS 平台基于多点触控的用户界面 和 Mac OS X 平台基于鼠标键盘的交互有着本质的区别；这就是为什么 iOS 有 UIKit 和 UIView，对应 Mac OS X 有 AppKit 和 NSView 的原因；它们在功能上很相似，但是在实现上有着显著的区别。 通过 CoreAnimation 框架来负责可视内容的呈现，这样在 iOS 和 Mac OS X 上都可以使用 CoreAnimation 进行渲染。 3、离屏渲染 3.1、什么是离屏渲染？ 正常的渲染流程如下图所示： App 通过 CPU 与 GPU 的合作，不停地将内容渲染完成放入 Framebuffer 中，而显示器不断地从 Framebuffer 中获取内容，显示实时的内容。如果有时因为面临一些限制，无法把渲染结果直接写入Framebuffer，而是先暂存在另外的内存区域，之后再写入Framebuffer，那么这个过程被称之为离屏渲染。 离屏渲染需要先额外创建离屏渲染缓冲区 OffScreen Buffer，将提前渲染好的内容放入其中，等到合适的时机再将 OffScreen Buffer 中的内容进一步叠加、渲染，完成后将结果切换到 Framebuffer 中。 3.2、 CPU 离屏渲染？ 通过CPU渲染就是俗称的 软件渲染，而真正的离屏渲染发生在 GPU。 如果在 UIView 中实现了 -drawRect: 方法，就算它的函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作。 类似这种 新开一块 CGContext 来画图 的操作，称之为 CPU离屏渲染（因为像素数据是暂时存入了CGContext，而不是存入Framebuffer）。进一步来说，其实所有CPU进行的光栅化操作如文字渲染、图片解码等，都无法直接绘制到由GPU掌管的Framebuffer ，只能暂时先放在另一块内存之中，说起来都属于 离屏渲染 。 自然我们会认为，因为CPU不擅长做这件事，所以我们需要尽量避免它，就误以为这就是需要避免离屏渲染的原因。但是根据苹果工程师的说法，CPU渲染并非真正意义上的离屏渲染。另一个证据是，如果你的view实现了 -drawRect:，此时打开 Xcode 调试的 Color Off-Screen Rendered 开关，你会发现这片区域不会被标记为黄色，说明 Xcode 并不认为这属于离屏渲染。 3.3、 GPU 离屏渲染 画家算法：首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分！ 通常对于每一层layer，Render Server 会遵循 画家算法，按次序输出到Framebuffer，后一层覆盖前一层，就能得到最终的显示结果。 然而有些场景并没有那么简单。作为 画家 的GPU虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来 擦除/改变 其中的某个部分——因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着， 对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作 。 比如：cornerRadius+clipsToBounds！对于多层layer的绘制，上层的 sublayer 会覆盖下层的 sublayer，下层 sublayer 绘制完之后就可以抛弃了，从而节约空间提高效率；所有 layer 依次绘制完毕之后，整个绘制过程完成，就可以进行后续的呈现了。 设置 layer.masksToBounds=YES 之后，要求它的所有子图层裁剪圆角；这就意味着所有的 sublayer 在第一次被绘制完之后，并不能立刻被丢弃，而必须要被保存在 OffScreen buffer 中等待下一轮圆角裁剪，这也就诱发了离屏渲染，具体过程如下： 3.3.1、GPU 离屏渲染的效率问题 GPU的操作是高度流水线化的：本来所有计算工作都在有条不紊地正在向 FrameBuffer 输出，此时突然收到指令，需要输出到另一块内存 OffScreen Buffer， 那么流水线中正在进行的一切都不得不被丢弃，将某些渲染结果保存到 OffScreen Buffer； 等到完成以后再次清空，再回到向 FrameBuffer输出的正常流程； 上述两步关于 buffer 的切换代价都非常大： OffScreen Buffer 本身就需要额外的空间，大量的离屏渲染可能早能内存的过大压力； OffScreen Buffer 的总大小也有限，不能超过屏幕总像素的 2.5 倍； 可见离屏渲染的开销非常大，一旦需要离屏渲染的内容过多，很容易造成掉帧的问题。所以大部分情况下，我们都应该尽量避免离屏渲染。 eg：在 UITableView 或者 UICollectionView 中，滚动的每一帧变化都会触发每个 cell 的重新绘制，因此一旦存在离屏渲染，上面提到的上下文切换就会每秒发生 60 次，并且很可能每一帧有几十张的图片要求这么做，对于GPU的性能冲击可想而知（GPU非常擅长大规模并行计算，但频繁的上下文切换显然不在其设计考量之中） 3.3.2、善用离屏渲染：光栅化 虽然离屏渲染开销很大，但如果无法避免它的时候，可以想办法把性能影响降到最低。优化思路也很简单：将花费大量资源裁出圆角的图片缓存下来，那么下一帧渲染就可以复用该缓存，不需要再重新画一遍了。 /** 表示是否开启光栅化 * 开启光栅化后，会触发离屏渲染: * Render Server 会强制将 CALayer 的渲染位图 bitmap 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。 * 保存的 bitmap 包含 layer 的 subLayer、圆角、阴影、组透明度等 * 所以如果 layer 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。 */ @property BOOL shouldRasterize; 开启光栅化的时候需要注意以下几点： 如果 layer 不能被复用，则没有必要打开光栅化； 如果 layer 不是静态，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率； 离屏渲染缓存内容有时间限制，缓存内容 100ms 内如果没有被使用，那么就会被丢弃，无法进行复用； 离屏渲染缓存空间有限，超过 2.5 倍屏幕像素大小的话也会失效，无法复用； 3.3.3、iOS 开发中常见的离屏渲染 cornerRadius+clipsToBounds：上文提过； 设置阴影 shadow：虽然 layer 本身是一块矩形区域，但是 shadow 默认是作用在其中 非透明区域 的，而且需要显示在所有 layer 内容的下方，因此根据 画家算法 必须被渲染在先。但矛盾在于此时 shadow 的本体 layer 都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？这样一来又只能另外申请一块内存，把本体内容都先画好，再根据渲染结果的形状，添加阴影到 FrameBuffer，最后把内容画上去。 设置 allowsGroupOpacity：opacity 并不是分别应用在每一层 layer 之上，而是只有到整个 图层树 画完之后，再统一加上opacity，最后和底下其他 layer 的像素进行组合；显然也无法通过一次遍历就得到最终结果。 将一对蓝色和红色 layer 叠在一起，然后在父 layer上设置 opacity=0.5，并复制一份在旁边作对比。左边关闭 allowsGroupOpacity，右边保持默认，然后打开 Xcode 调试的 Color Off-Screen Rendered 开关，会发现右边的那一组确实是离屏渲染了。 注意：从iOS7开始，如果没有显式指定，allowsGroupOpacity会默认为 YES ！ 设置蒙版 mask：mask 是应用在layer和其所有子sublayer的组合之上的，而且可能带有透明度；最终的内容是由 多层渲染结果叠加 ，所以必须要利用额外的内存空间对中间的渲染结果进行保存，因此系统会默认触发离屏渲染。 设置模糊特效 UIBlurEffectView：首先渲染需要模糊的内容本身；接着对内容进行缩放；然后分别对上一步内容进行横纵方向的模糊操作，最后一步用模糊后的结果叠加合成，最终实现完整的模糊特效。这也会触发离屏渲染。 其他还有一些，类似绘制了文字的 layer (UILabel,CATextLayer,CoreText 等)。 注意 ： 重写 -drawRect: 方法触发 CPU 软件渲染，而非 GPU 离屏渲染。 3.3.4、一些引发离屏渲染的优化 引起离屏渲染的本质是 多层渲染结果叠加，导致对 layer 以及所有 sublayer 进行多次处理。为避免对 layer 的多次处理，可以提前预处理，绘制时仅一次处理完成渲染。 对于图片的圆角：不经由容器来做剪切，而是预先使用 CoreGraphics 为图片裁剪圆角； 对于视频的圆角：由于实时剪切非常消耗性能，提前创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果； 对于view的圆形边框：如果没有 backgroundColor，可以放心使用 cornerRadius 来做； 对于所有的阴影：使用 shadowPath 来规避离屏渲染； 对于特殊形状的view：使用 layer.mask 并打开 shouldRasterize来对渲染结果进行缓存； 对于模糊效果：不采用系统提供的 UIVisualEffect，而是另外实现模糊效果CIGaussianBlur，并手动管理渲染结果； 3.4、什么时候需要 CPU 渲染？ 渲染性能的调优，其实始终是在做一件事：平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作。 一般情况下，得益于GPU针对图形处理的优化，我们都会倾向于让GPU来完成渲染任务，而给CPU留出足够时间处理各种各样复杂的App逻辑。为此 Core Animation 做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如 layer composition，设置 backgroundColor等等）。 但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片 ImageIO 渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。 这里有几个需要注意的点： 渲染不是CPU的强项，调用CoreGraphics会消耗其相当一部分计算时间，并且也不能因此阻塞用户操作，因此一般来说CPU渲染都在后台线程完成，然后再回到主线程上，把渲染结果传回 CoreAnimation。这样一来，多线程间数据同步会增加一定的复杂度 ； 同样因为CPU渲染速度不够快，因此只适合渲染静态的元素，如文字、图片； 作为渲染结果的bitmap数据量较大（形式上一般为解码后的UIImage），消耗内存较多，所以应该在使用完及时释放，并在需要的时候重新生成，否则很容易导致内存用完； 如果选择使用CPU来做渲染，那么就没有理由再触发GPU的离屏渲染了，否则会同时存在两块内容相同的内存，而且CPU和GPU都会比较辛苦； 一定要使用 Instruments 的不同工具来测试性能，而不是仅凭猜测来做决定； 参考文章 iOS 渲染原理解析 关于iOS离屏渲染的深入研究 iOS下的图像渲染原理 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/杂记/响应链.html":{"url":"iOS开发/杂记/响应链.html","title":"响应链","keywords":"","body":"iOS响应链 当用户点击屏幕时：屏幕接收点击信号将点击位置转换成具体坐标，然后本次点击被包装成一个点击事件 UIEvent；最终会在某个视图响应本次事件进行处理，而为 UIEvent 查找响应视图的过程被称为响应链查找。 一个点击事件是如何从屏幕传递到处理视图？响应链又是什么呢？ 1、响应者 UIResponder 响应者是响应链中的一个节点，是可以处理事件的具体对象，一个响应者应当是UIResponder 或其子类的实例对象。从API设计上来看，UIResponder 主要提供了三类接口： 向上查询响应者的接口nextResponder ； 用户操作的处理接口，包括touch、press 和 remote 三类事件的处理； 是否具备处理action的能力，以及为其找到target 的能力； 1.1、由nextResponder 指针构成的链表 每个UIResponder 都有nextResponder ，这些nextResponder指针指向下一个UIResponder，由此构成树状结构。打印 Demo 界面上所有控件的nextResponder： 当前responder AppDelegate ============ nextResponder (null) 当前responder UIApplication ============ nextResponder AppDelegate 当前responder UIWindow : 10 ============ nextResponder UIApplication 当前responder UIView : 20 ============ nextResponder ViewController 当前responder UILabel : 11 ============ nextResponder UIWindow : 10 当前responder UIButton : 12 ============ nextResponder UIWindow : 10 当前responder ViewController ============ nextResponder UIWindow : 10 当前responder UIButton : 21 ============ nextResponder UIView : 20 当前responder UIButton : 22 ============ nextResponder UIView : 20 当前responder UILabel : 23 ============ nextResponder UIView : 20 分析打印结果： AppDelegate 没有 nextResponder； UIApplication 的 nextResponder 是 AppDelegate； UIWindow 的 nextResponder 是 UIApplication； window.rootViewController 的 nextResponder 是 UIWindow； UIViewController.view 的 nextResponder 是 UIViewController； 子视图的nextResponder 是父视图； 这些UIResponder 由 nextResponder 指针构成一个树状结构，如下如所示： 1.2、响应链是否由 UIResponder构成？ 由 nextResponder 组成的链表是不是响应链呢？ 假如nextResponder 组成响应链，那么点击 lable 与 button 的重叠部分，应该是 lable.superView 响应事件。但实际却是 button 响应点击事件。 所以由 nextResponder 组成的链表并不是响应链的全部！ 1.3、nextResponder 使用 利用 nextResponder ，可以获取 UIView 所在的 UIViewController： - (UIViewController *)viewController{ UIResponder *nextVC = self.nextResponder; while ([nextVC isKindOfClass:UIViewController.class] == NO) nextVC = nextVC.nextResponder; return [nextVC isKindOfClass:UIViewController.class] ? (UIViewController *)nextVC : nil; } 2、视图 UIView 虽然 UIResponder 提供了处理响应事件的能力，但它无法被用户观察到；换句话说，用户无法点击这些有处理能力的对象。 UIView 继承 UIResponder，是展示在界面上的可视元素，包括不限于文本、按钮、图片等可见样式。既展示了界面元素，又具有与用户交互的能力： 视图树结构。虽然 UIResponder 也存在相同的树状结构，但其必须依托于可视载体进行表达； 可视化内容。通过 frame 等属性决定 UIView 在屏幕上的可视范围，提供了点击坐标和响应可视对象的关联能力； 内容布局重绘。视图渲染到屏幕上虽然很复杂，但不同的布局方式提供了不同阶段的重绘调起接口，使得子类具有很强的定制性 实际上，查找响应者就是查找点击坐标落点位置在其可视范围内且其具备处理事件能力的对象；也就是既要Responder 又要View 的对象。UIView 提供了两个重要的方法用于查找响应视图： /* 获取响应视图 * 该方法内部可以分为三大步骤： * @step1 判断视图是否可交互 userInteractionEnabled=NO,alpha 2.1、-hitTest:withEvent:方法 通过方法交换exchang，打印一些关键信息： - (BOOL)l_pointInside:(CGPoint)point withEvent:(UIEvent *)event{ NSLog(@\"当前视图 pointInside ======== %@ : %ld\",self.class,self.tag); BOOL pointInside = [self l_pointInside:point withEvent:event]; if (pointInside) { NSLog(@\"当前视图范围内 ====== %@ : %ld \",self.class,self.tag); }else{ NSLog(@\"当前视图范围外 ====== %@ : %ld \",self.class,self.tag); } return pointInside; } - (UIView *)l_hitTest:(CGPoint)point withEvent:(UIEvent *)event{ NSLog(@\"当前视图 hitTest -------- %@ : %ld\",self.class,self.tag); UIView *responserView = [self l_hitTest:point withEvent:event]; if (responserView) { NSLog(@\"当前视图 %@ : %ld -- 响应视图 %@ : %ld \",self.class,self.tag,responserView.class,(long)responserView.tag); }else{ NSLog(@\"当前视图 %@ : %ld -- 响应视图 查找不到\",self.class,self.tag); } return responserView; } 运行Demo，点击 ViewController.view 空白区域，观察上述方法的打印日志： 通过打印数据，分析 -hitTest:withEvent: 的内部实现： 1、首先判断 UIView能否与用户交互： userInteractionEnabled=NO、hidden=YES、alpha；如果不能与用户交互，那么-hitTest:withEvent: 直接返回nil，不再查找其子视图。 （在打印数据第10行与第11行，-hitTest:withEvent: 内部没有调用-pointInside: withEvent:） 2、接着，如果UIView 能与用户交互，那么调用-pointInside:withEvent: 判断点击点是否在其范围内。如果用户点击点不在视图范围内，返回nil，不再查找其子视图。 （打印数据第5行~第8行表明 window子视图 tag=12 的button 能与用户交互，但是它不在点击区域内，所以-hitTest:withEvent:返回nil，不再查找其子视图。） 3、如果-pointInside:withEvent: 返回YES，说明在点击范围内，接着 倒序 遍历UIView 的所有子视图。 采用倒序查询优化查找速度，毕竟后添加的视图在上方易于被用户点击 （打印数据第1行~第18行，因为window label 11 、window button 12、ViewController.view.tag=20 都是 window 的子视图，根据添加顺序看出子视图是倒序遍历。） 4、倒序遍历UIView 对象的所有子视图：每个子视图调用 -hitTest:withEvent: 方法执行步骤 1~2，判断该子视图是否可交互且在点击范围内，如果该子视图不在，接着下一个子视图判断。 5、如果 UIView 对象的所有子视图调用 -hitTest:withEvent: 都返回 nil，那么 UIView对象会返回自身。 （打印数据第30行，ViewController.view.tag=20 遍历了它所有的子视图结果都是 nil，于是返回它自身） 6、如果所有子视图调用 -hitTest:withEvent: 有一个子视图返回 UIView，那么遍历将结束。返回的 UIView 就是对用户点击做出响应的view。 （打印数据第1行~第31行，window 最终遍历到ViewController.view 时，判断出ViewController.view.tag=20 是响应视图，因此[window hitTest:withEvent:] 最终返回ViewController.view） 7、至此，程序已经找到了最终响应视图。 2.2、尝试重写 -hitTest:withEvent: - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{ ///第一步：判断视图是否可交互 if (self.userInteractionEnabled == NO || self.alpha 2.3、-hitTest:withEvent: 方法使用 此方法可实现点击穿透、点击下层视图等功能： eg1：一般来说，子视图在父视图之外区域的触摸操作不会被识别；重写父视图的 -pointInside:withEvent: 识别该视图返回 YES，则可以相应该操作; eg2：扩大button 的点击区域; 3、事件处理 通过对-hitTest:withEvent:方法的分析，我们知道事件的传递过程。那么最终 UIView 能够处理该次点击事件嘛？ //UIResponder 提供了四个方法用于处理事件： - (void)touchesBegan:(NSSet *)touches withEvent:(nullable UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(nullable UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(nullable UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(nullable UIEvent *)event; 如果需要最终视图处理事件，重写ViewController的上述方法： - (void)touchesBegan: (NSSet *)touches withEvent: (UIEvent *)event { [super touchesBegan:touches withEvent:event]; NSLog(@\"began --- %ld\",(long)self.tag); } - (void)touchesEnded: (NSSet *)touches withEvent: (UIEvent *)event { NSLog(@\"ended ---- %ld\",(long)self.tag); } /* 点击空白区域的打印数据： began --- 10 began --- 20 ended ---- 20 ended ---- 10 */ ViewController 和 UIWindow 都处理事件了；注释//[super touchesBegan:touches withEvent:event]; 再次执行程序： began --- 20 ended ---- 20 这次只有 ViewController处理事件。 -hitTest:withEvent: 返回的 UIView 对象是最可能处理事件的对象，但该对象并不一定处理事件。这时，需要逆着查找链找到能处理该事件的对象。 3、响应链 响应链可以分为事件的传递链、事件的响应链： 事件的传递链：由系统向离用户最近的view传递。AppDelegate –> UIApplication –> UIWindow –> ……–> 合适的view 事件的响应链：从找到view 开始，沿着 nextResponder 回溯！如果某个 responder 做出响应，并且没有调用下一个 UIResponder的 -touch，则响应链到此结束！如果所有的 responder 不做响应，则一直传递到顶层UIApplication，UIApplication 默认不做响应，事件被丢弃！ 事件处理完毕后，主线程的 Runloop 开始休眠，等待下一个事件！ 引用iOS触摸事件的流动的一张流程图： Demo 参考文章 hitTest:withEvent:方法流程 分析实现-聊聊响应链 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/并发编程.html":{"url":"iOS开发/杂记/并发编程.html","title":"并发编程","keywords":"","body":"并发编程 并发编程是指在一台处理器上 某个时间片 处理多个任务；它的目标是充分的利用处理器的每一个核，以达到更高的处理性能。 1、并发处理 与 顺序处理 顺序处理：按照先后顺序处理逻辑控制流（即逐个处理） 并发处理：同时处理多个逻辑控制流 并发处理相对于顺序处理的优势： 增加应用程序的吞吐量：应用程序的吞吐量是指在一段时间内应用程序能够完成的任务数；并发程序同时处理多个任务，会比顺序处理完成更多任务。 提高系统的利用率：以并发方式执行多个任务，可以更集中、更高效的利用系统资源。 提高应用程序的整体响应性：如果某个任务正在等待，使用并发模式，可以让其它任务继续进行，减少程序的整体闲置时间，提高程序的响应性。 更好的与问题领域契合：在处理某些问题时，可以将这些任务创建为同时处理的任务集合，以并发方式处理。 并发处理意味着同时执行多个任务。但实际上，利用并发机制的程序是否真的并发执行多个任务，取决于运行程序的计算机系统。这里引出了两条概念：并发计算（concurrent computing）与 并行计算（Parallel Computing）。 2、并发计算与 并行计算 并行：当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行。 并发：当有多个线程在操作时，如果系统只有一个CPU，则它不能同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。 从广义上来说：并发计算是软件层面的，与设计相关；并行计算是硬件层面的，与多核CPU相关。 并行计算 ：指计算机同时执行多个操作或任务。执行并行计算的能力直接取决于计算机硬件，如多核 CPU 同时执行多条指令 并发计算：指一个程序被设计同时执行多个操作或任务。如果程序使用并发编程设计并实现的，那么它就会根据计算机硬件的能力，以并发的方式运行。 要发挥并发处理的优势，必须以并发编程设计并实现程序，并在能够支持并行处理的硬件运行它。 3、实现并发处理 在了解了并发处理的优势后，我们要学会如何利用它。在计算机系统中，实现并发处理的方式有很多： 分布式计算：多个任务被分给多台网络相连的计算机执行，这些计算机通过消息传递来实现通信； 并行编程：由多核CPU和可编程GPU进行大量的并行计算； 多进程：多个任务被分给一台计算机的多个进程，每个进程都拥有由操作系统管理的独立资源和地址空间； 多线程：多个任务与多个线程对应，这些线程被配置为并发方式执行。这些线程是在单个进程的环境中执行的，它们共享地址空间和内存。 4、CPU 与 GPU 上文提到 CPU 与 GPU ，那么什么是 CPU ？什么是 GPU ？CPU 与 GPU 的区别是什么？ CPU 是中央处理器，所做的工作都在软件层面； GPU 是图形处理器，所做的工作都在硬件层面； CPU 擅长处理具有复杂计算步骤和复杂数据依赖的计算任务，如分布式计算，数据压缩，人工智能，物理模拟，以及其他很多很多计算任务等。 区别： CUP 和 GPU 之所以大不相同，是由于其设计目的的不同，它们分别针对了两种不同的应用场景： CPU 需要很强的通用性来处理各种不同的类型数据，同时又要逻辑判断又会引入大量的分支跳转和中断处理。这些都使得CPU的内部结构异常复杂。 GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断纯净的计算环境。 5、进程 与 线程 进程与进程都是操作系统的基本概念： 进程：正在运行的、拥有独立地址空间和系统资源的计算机程序；是系统进行资源分配和调度的基本单位，是操作系统结构的基础，主要管理资源。 线程：在某个进程环境中执行的逻辑控制流，它是可以独立执行的指令序列。线程也被称为轻量级进程，它是进程的基本执行单元，多个线程共享一个地址空间； 多线程：在同一时刻，一个 CPU 只能处理 1 条线程，但 CPU 可以在多条线程之间快速的切换，只要切换的足够快，就造成了多线程一同执行的假象。多线程通过提高资源使用率来提高系统总体的效率。但是也不要开启太多线程，当线程过多时，会消耗大量 CPU 资源，且每开一条线程本身也是有开销的（在iOS中，主线程站 1 MB 的内存空间，子线程占用 512 KB，可以使用 stackSize 设置线程占用空间，最小是 16 KB，线程创建时间是 90 ms），可能导致卡顿问题。 协程：一串比函数粒度还要小的可手动控制的过程；并不是 线程，不会参与 CPU 时间调度，并没有均衡分配到时间。 进程可能包含多个线程，这些线程可以按顺序执行、以并发方式执行，或者混合使用这两种方式执行。 在 Objective-C 语言中，使用 NSTask 与NSThread 管理进程与线程。 5.1、NSTask 创建并管理进程 使用NSTask 可以在 Objective-C 运行时系统中创建并管理进程，NSTask 作为独立进程进行操作，不与其它进程共享内存，包括创建它的进程。一个NSTask 对象只能运行一次，而且其环境需要在它运行以前配置好。 NSTask *task = [[NSTask alloc] init];//使用 init 初始化一个 task [task setLaunchPath:@\"/Users/longlong/Library/Developer/CoreSimulator/Devices/DD8DCEB3-16B7-412A-9F9E-0315A427A638/data/Containers/Bundle/Application/2CDEA0BD-BCB1-40A9-957A-EDE732AE1072/Demo.app/Demo\"];//设置启动的程序目录 [task setArguments:@[@\"/Users/longlong/Library/Developer/CoreSimulator/Devices/DD8DCEB3-16B7-412A-9F9E-0315A427A638/data/Containers/Bundle/Application/2CDEA0BD-BCB1-40A9-957A-EDE732AE1072/Demo.app/Demo\"]];//设置启动需要的参数 [task launch];//启动该进程 NSLog(@\"isRunning == %d\",[task isRunning]);//使用 isRunning 查询 task 的状态 5.2、NSThread 创建并管理线程 线程是一种操作系统机制，用以并行方式执行多个指令序列。同一个进程中的线程可以共享计算机的内存和其他资源。 使用NSThread 可以创建和控制线程： NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(startChildThread) object:nil]; thread.stackSize = 16;//设置线程占用空间，最小是 16 KB， thread.name = @\"demo.thread2\";//设置线程名字 thread.threadPriority = 1.0;//设置线程优先级 [thread start];//开启线程 6、并发处理带来的困难 虽然并发处理有如此多优点，但要正确实现它并不容易，它主要有以下几个难点： 共享信息：在控制不同线程中的相关操作时需要实现同步，而在线程之间进行通信就必须实现信息共享； 因为要同时执行多个线程，所以整个程序的执行顺序是不确定的，使用不同的执行顺序执行同一程序得到不同的结果，这会导致并发程序中的bug 难以检测和修复。 我们可以使用共享内存与消息传递 来处理上述问题。共享内存编程模式会实现共享状态，多个线程都可以访问某些数据。 7、共享内存 与 消息传递 7.1、共享内存 共享内存模式需要一种机制来协调多个线程共用的数据，通常使用同步机制来实现这一目标，如 锁或者判定条件。 锁：是一种控制多线程间数据同步访问和资源共享的一种机制。 条件：它使线程一直处于等待状态直到指定条件出现，条件变量通常用锁来实现。 锁实施是一种互斥策略，避免受保护的数据和资源被多个线程同时访问。使用锁协调对共享数据的访问时，很有可能引发死锁、活锁、资源匮乏等问题，这些问题导致程序中断： 死锁：指两个或多个线程互相阻塞的情况，每个线程都等待其他线程释放锁，导致所有线程都处于等待状态。典型的例子就是循环等待； 活锁：指一个线程因为要回应其它线程，而导致自身无法执行的情况。活锁的线程没有被阻塞，它将所有的计算时间用于回应其它线程，以恢复正常的操作。 资源匮乏：指线程无法正常访问共享资源的情况，通常是共享资源被其它线程占用。当一个或多个线程占用共享资源的时间过长，就会引发这种问题。活锁也是资源匮乏的一种形式。 7.2、消息传递 线程能够通过交换消息进行同步和通信，消息传递避免了互斥问题，并与多核、多处理器系统契合。使用消息传递既可以执行同步通信，也可以执行异步通信。在进行同步消息传递时，发送者和接收者会直接连接；消息传递操作完成后，发送者和接收者会断开连接。异步消息传递通过队列传输消息，如图所示 消息不是在队列之间直接传递，而是通过 消息队列 进行交换。因此，发送者和接收者并不会配对，发送者将消息发给队列后也无需断开连接。使用异步消息传递可以实现并发编程。 框架Foundation 中的NSObject 含有许多方法，这些方法使用消息传递模式，通过线程调用对象的方法。该线程可以是主线程，也可以是分线程 @interface NSObject (NSThreadPerformAdditions) //waitUntilDone: 参数设置了同步/异步操作 - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray *)array; - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; // equivalent to the first method with kCFRunLoopCommonModes - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); // equivalent to the first method with kCFRunLoopCommonModes - (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 上述方法，参数 waitUntilDone: 设置了同步YES/异步NO操作。 8、运行循环RunLoop RunLoop 是一种基于线程的机制，用于调度任务和协调收到的输入事件。如果程序的线程需要回应入栈事件，就必须将之附到运行循环中，以在新事件出现时唤醒该线程。 9、在 Objective-C 中实现并发编程 在Objective-C中实现并发编程有以下几种方式： 线程 NSThread 操作队列 NSOperationQueue：基于Objective-C的消息传递机制，通过亦不涉及方法实现并发编程； 分派队列 GCD：基于 C 语言的一系列语言特性和运行时服务，用于通过异步和并发执行任务； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/OC之Thread.html":{"url":"iOS开发/杂记/OC之Thread.html","title":"线程NSThread","keywords":"","body":"NSThread NSThread 面向对象，是对 pthread 的 OC 封装，解决了 C 语言使用不方便的问题,，但仍然需要程序员手动管理线程生命周期、处理线程同步等问题。是一个轻量级的多线程编程方法（相对GCD 和 NSOperation）。 1、NSThread API 1.1、创建分线程 /* 创建一个 NSThread * @note 实例方法创建 NSThread，可以获取实例对象，使用该对象调用 -start 开启分线程； * @note 类方法创建的 NSThread，默认开启分线程。不可以获取实例对象，也就不用 -start ； * @note 如果开辟的线程是程序中第一个分线程，系统发送通知 NSWillBecomeMultiThreadedNotification； */ - (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument ; - (instancetype)initWithBlock:(void (^)(void))block ; + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; + (void)detachNewThreadWithBlock:(void (^)(void))block; /* 异步开辟一条线程，此时 executing=YES ，在新线程调用 -main 方法。 * @note 仅仅被实例方法创建的对象调用 */ - (void)start; 1.2、线程休眠 /* 当前线程休眠到指定时间； * @param date 截止时间 * @note 当线程休眠时，runloop 不会发生 */ + (void)sleepUntilDate:(NSDate *)date; + (void)sleepForTimeInterval:(NSTimeInterval)ti; 1.3、线程停止 /* 终止当前线程： * @note 线程退出之前没有机会清除线程中分配的内存，不建议调用； * @note 触发通知 NSThreadWillExitNotification；同步发送，观察者在线程退出之前都能收到通知。 */ + (void)exit; /* 取消操作 * @note 仅仅将属性 cancelled 改为 YES，NSThread 会定期查询 cancelled 的状态 * 线程取消：CFRunLoopStop(CFRunLoopGetCurrent()); //停止当前线程的runLoop */ - (void)cancel; 1.4、线程主体 /* 线程的主体，封装的操作 * @note 子类化 NSThread，将待执行任务封装在 -main 方法中； * 此时不需要调用 [super main]，否则将实现初始化的 target 与 selector */ - (void)main; 1.5、 线程状态 //thread 是否正在执行 @property (readonly, getter=isExecuting) BOOL executing; //thread 是否完成了执行 @property (readonly, getter=isFinished) BOOL finished; //thread 是否被取消。 @property (readonly, getter=isCancelled) BOOL cancelled; 1.6、 主线程相关 //当前线程是否是主线程 @property (readonly) BOOL isMainThread; @property (class, readonly) BOOL isMainThread ; //获取主线程对象 @property (class, readonly, strong) NSThread *mainThread; 1.7、 查询线程环境 /* 判断应用程序是否是多线程的 * 如果使用 NSThread 将开启一个分线程，则该方法返回 YES； * 如果在应用程序中使用非cocoa API(如 POSIX 或 Multiprocessing Services API)开启一个分线程，该方法将返回 NO */ + (BOOL)isMultiThreaded; //获取当前正在执行的线程的对象 @property (class, readonly, strong) NSThread *currentThread; // 调用堆栈返回地址 的数组：每个元素都是包含NSUInteger值的NSNumber对象 @property (class, readonly, copy) NSArray *callStackReturnAddresses ; /* 调用堆栈符号的数组：描述在调用此方法时当前线程的调用堆栈回溯 ； * 每个元素都是一个NSString对象，其值的格式由 backtrace_symbols() 函数确定。 */ @property (class, readonly, copy) NSArray *callStackSymbols; //使用该字典来存储特定于线程的数据。该字典在任何对NSThread对象的操作中都不使用——它只是一个可以存储趣数据的地方。例如，Foundation 使用它存储线程的默认NSConnection和NSAssertionHandler实例。可以为字典自定义其键值。 @property (readonly, retain) NSMutableDictionary *threadDictionary; //线程的名字 @property (nullable, copy) NSString *name; //thread 的堆栈大小（这个值必须以字节为单位，并且是4KB的倍数）。要更改堆栈大小，必须在启动线程之前设置此属性。在线程启动后设置堆栈大小会更改属性大小(stackSize方法反映了这一点)，但不会影响为线程预留的页面的实际数量。 @property NSUInteger stackSize; 1.8、优先级 /* 线程的优先级：当存在资源争用时，设置更高优先级获得更多的资源 * NSQualityOfServiceUserInteractive：最高优先级，主要用于提供交互UI的操作，比如处理点击事件，绘制图像到屏幕上 * NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务 * NSQualityOfServiceDefault：线程默认优先级 * NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务 * NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务 */ @property NSQualityOfService qualityOfService; + (double)threadPriority; @property double threadPriority; //设置线程的优先级 + (BOOL)setThreadPriority:(double)p; 1.9、相关通知 //由当前线程派生出第一个其他线程时发送，一般一个线程只发送一次 NSString * const NSWillBecomeMultiThreadedNotification; //目前没有使用，可以忽略 NSString * const NSDidBecomeSingleThreadedNotification; // 线程退出之前发送通知 NSString * const NSThreadWillExitNotification; 思考一下： 如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒? 2、线程间通信 /* 使用指定 modes 在指定 thread 执行 aSelector * @param thread ：指定的线程，用于执行 aSelector ； * @param aSelector ：在指定的线程中执行的任务； * @param modes ：执行模式，默认为 kCFRunLoopCommonModes； * 如果为该参数指定nil或空数组，则不会执行 aSelector； * @param wait ：是否阻塞当前线程，直到 aSelector 执行完毕； * 如果当前线程也是主线程，并且 wait 指定YES，则消息将立即被发送和处理； * @note 该方法一旦被分发到主线程队列，就不能再被取消执行 */ @interface NSObject (NSThreadPerformAdditions) //回到主线程执行 aSelector - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray *)array; - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; //在指定线程上执行 aSelector - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray *)array; - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait; - (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; @end 2.1、回到主线程 假如数据关联性特别强，需要在分线程操作一些耗时任务，然后回到主线程更新UI，接着根据更新UI的结果接着往下处理数据，我们应如何在线程间通信呢？我们来看以下程序： - (void)newChileThread{ //先监听线程退出的通知，以便知道线程什么时候退出 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(threadExitNotice:) name:NSThreadWillExitNotification object:nil]; if (@available(iOS 10.0, *)){ [NSThread detachNewThreadWithBlock:^{ NSThread.currentThread.name = @\"数据线程\"; [NSThread sleepForTimeInterval:10];//处理耗时任务 NSLog(@\"---------- 处理数据了 ----------- %@\",[NSDate date]); [self performSelectorOnMainThread:@selector(backMainThreadClick:) withObject:@{@\"data\":@\"handle data\"} waitUntilDone:YES]; NSLog(@\"---------- 再次处理数据了 ----------- %@\",[NSDate date]); [NSThread sleepUntilDate:[[NSDate date] dateByAddingTimeInterval:10]];//z接着处理耗时任务 NSLog(@\"---------- 处理数据完毕 ----------- %@\",[NSDate date]); }]; } } - (void)backMainThreadClick:(id)userInfo{ NSLog(@\"刷新UI --- %@\",userInfo); [NSThread sleepForTimeInterval:3];//阻塞主线程 3s } 我们开辟了一条新线程用来处理耗时任务，并且监听该线程的退出；中途由于关于界面的数据已经处理完毕，这时我们可以回到主线程刷新 UI，调用-performSelectorOnMainThread: withObject: waitUntilDone:方法，参数waitUntilDone设置为YES,我们来看控制台的打印结果： 2018-07-03 19:17:48.759882+0800 ThreadDemo[967:43885] ---------- 处理数据了 ----------- 2018-07-03 11:17:48 +0000 2018-07-03 19:17:48.760508+0800 ThreadDemo[967:43826] 刷新UI --- { data = \"handle data\"; } 2018-07-03 19:17:51.762262+0800 ThreadDemo[967:43885] ---------- 再次处理数据了 ----------- 2018-07-03 11:17:51 +0000 2018-07-03 19:18:01.763943+0800 ThreadDemo[967:43885] ---------- 处理数据完毕 ----------- 2018-07-03 11:18:01 +0000 2018-07-03 19:18:01.764444+0800 ThreadDemo[967:43885] threadExitNotice ------------ {number = 3, name = 数据线程} 我们可以看到：系统先在分线程处理了一个耗时任务，然后立即回到主线程刷新UI，此处的分线程一直等到主线程处理完UI事件，才接着在该分线程处理任务，直到任务处理完毕，退出该线程 思考一下: 假如分线程的任务可以独立执行处理，我们还需要在等到主线程的方法执行完再接着处理下面的任务嘛？这显然耽误了时间，浪费了效率。 还是上述程序，我们将参数waitUntilDone传为NO, 2018-07-03 19:19:38.867522+0800 ThreadDemo[1000:45692] ---------- 处理数据了 ----------- 2018-07-03 11:19:38 +0000 2018-07-03 19:19:38.868219+0800 ThreadDemo[1000:45638] 刷新UI --- { data = \"handle data\"; } 2018-07-03 19:19:38.868225+0800 ThreadDemo[1000:45692] ---------- 再次处理数据了 ----------- 2018-07-03 11:19:38 +0000 2018-07-03 19:19:48.869657+0800 ThreadDemo[1000:45692] ---------- 处理数据完毕 ----------- 2018-07-03 11:19:48 +0000 2018-07-03 19:19:48.870864+0800 ThreadDemo[1000:45692] threadExitNotice ------------ {number = 3, name = 数据线程} 我们可以看到：系统在回到主线程刷新UI的同时，接着处理分线程后面的任务。 2.2、 线程间通信 我们希望开辟一条分线程，用来处理数据，同时和主线程进行通信：代码如下所示： - (void)newChileThread{ if (@available(iOS 10.0, *)){ [NSThread detachNewThreadWithBlock:^{ NSThread.currentThread.name = @\"数据线程\"; [self performSelector:@selector(newChileThreadTask:) withObject:@{@\"data\":@\"A\"}]; }]; } } - (void)newChileThreadTask_A:(id)userInfo{ NSLog(@\"userInfo =========== %@\",userInfo); if ([userInfo[@\"data\"] isEqualToString:@\"A\"]){ [NSThread sleepForTimeInterval:10];//处理耗时任务 NSLog(@\"处理数据A ======= %@\",NSThread.currentThread); //任务A处理完毕，回调主线程执行某些操作，并阻塞当前线程直至主线程的操作完成 [self performSelectorOnMainThread:@selector(backMainThreadClick:) withObject:@{@\"result\":@\"1\",@\"thread\":NSThread.currentThread} waitUntilDone:YES]; } NSLog(@\"处理完毕A ===========\"); } - (void)newChileThreadTask_B:(id)userInfo{ [NSThread sleepForTimeInterval:10];//处理耗时任务 NSLog(@\"处理数据B ----------- %@\",NSThread.currentThread); } - (void)backMainThreadClick:(id)userInfo{ NSLog(@\"userInfo ---------- %@\",userInfo); NSThread *thread = userInfo[@\"thread\"]; [NSThread sleepForTimeInterval:3];//阻塞主线程 3s if ([userInfo[@\"result\"] isEqualToString:@\"1\"]){ NSLog(@\"currentThread ----- %@\",NSThread.currentThread); [self performSelector:@selector(newChileThreadTask_B:) onThread:thread withObject:@{@\"data\":@\"B\"} waitUntilDone:NO]; } } 根据以上代码：我们在新开辟的分线程执行- performSelector: withObject:，转到 -newChileThreadTask_A: 方法执行处理数据 A 的耗时任务，在此耗时10s后，将一段数据传至主线程，由于参数 waitUntilDone 为 YES，系统在此处阻塞当前线程直至 -backMainThreadClick: 方法里执行完毕才会接着执行分线程下面的代码，我们期望接下来执行处理数据B的任务； 我们来看下打印结果: 10:50:35.719040+0800 userInfo =========== { data = A; } 10:50:45.727849+0800 处理数据A ======= {number = 7, name = 数据线程} 10:50:45.728304+0800 userInfo ---------- { result = 1;thread = \"{number = 7, name = \\U6570\\U636e\\U7ebf\\U7a0b}\";} 10:50:48.728859+0800 currentThread ----- {number = 1, name = main} 10:50:48.729764+0800 处理完毕A =========== 疑问： -newChileThreadTask_B: 方法没有被执行，为什么？ 3、RunLoop 与 Thread Runloop 是通过内部维护的事件循环来对事件\\消息进行管理的一个对象！ 事件循环：没有消息处理时，休眠以避免资源占用； 用户态 -> 内核态 有消息需要处理时，立即被唤醒； 用户态 内核态 RunLoop 寄生于线程：一个线程只能有唯一对应的RunLoop，但这个根RunLoop里可以嵌套子RunLoop，主线程的RunLoop自动创建，子线程的 RunLoop 默认不创建，在子线程中调用NSRunLoop.current 获取 RunLoop 对象的时候，就会创建RunLoop . 3.1、为什么 main() 函数不会退出程序？ int main(int argc, char * argv[]) { NSString * appDelegateClassName; @autoreleasepool { appDelegateClassName = NSStringFromClass([AppDelegate class]); } return UIApplicationMain(argc, argv, nil, appDelegateClassName); } 在 main() 函数中调用的 UIApplicationMain() 函数内部会启动主线程的 Runloop; Runloop 是对事件循环的一个维护机制； 没有消息处理时，休眠以避免资源占用；有消息需要处理时，立即被唤醒 3.2、 Runloop的数据结构 NSRunLoop 是对 CFRunLoop 的面向对象的封装 CFRunLoop CFRunLoopMode Source/Timer/Observer 3.3、RunLoop 的创建 static CFMutableDictionaryRef __CFRunLoops = NULL; static pthread_t kNilPthreadT = (pthread_t)0; // t==0 is a synonym for \"main thread\" that always works //当t==0时代表主线程 CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) { if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); } //进行加锁操作 CFLock(&loopsLock); if (!CFRunLoops) { CFUnlock(&loopsLock); // 第一次进入时，初始化全局dict，并先为主线程创建一个 RunLoop。并将mainLoop添加到dict中 CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = CFRunLoopCreate(pthread_main_thread_np()); CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void volatile )&CFRunLoops)) { CFRelease(dict); } CFRelease(mainLoop); CFLock(&loopsLock); } //通过线程直接从dict中获取loop CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(CFRunLoops, pthreadPointer(t)); CFUnlock(&loopsLock); if (!loop) { //如果获取失败，通过线程创建一个loop， CFRunLoopRef newLoop = CFRunLoopCreate(t); CFLock(&loopsLock); loop = (CFRunLoopRef)CFDictionaryGetValue(CFRunLoops, pthreadPointer(t)); if (!loop) { //再次确认没有loop，就添加到dict中。 CFDictionarySetValue(CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it CFUnlock(&loopsLock); CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { // 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(CFTSDKeyRunLoop, (void )loop, NULL); if (0 == _CFGetTSD(CFTSDKeyRunLoopCntr)) { _CFSetTSD(CFTSDKeyRunLoopCntr, (void )(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void ()(void ))__CFFinalizeRunLoop); } } return loop; } //获取当前线程的RunLoop CFRunLoopRef CFRunLoopGetCurrent(void) { CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self()); } //获取主线程的RunLoop CFRunLoopRef CFRunLoopGetMain(void) { CHECK_FOR_FORK(); static CFRunLoopRef main = NULL; // no retain needed if (!main) main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return main; } 整体的流程可以概括为以下几步： * 通过 `_CFRunLoopGet0()`函数传入一条线程。 * 判断线程是否为主线程并且判断是否已经存在 `__CFRunLoops()`（全局字典 `CFMutableDictionaryRef`）。 * 如果不存在，说明第一次进入，初始化全局 `dict`，并为主线程创建一个 `RunLoop`, 将 `mainLoop`添加到 `dict` 中。 * 如果 `__CFRunLoops` 存在，在全局的 `__CFRunLoops` 中查找对应的 `RunLoop`，键是当前线程。 * 如果对应 `RunLoop` 不存在，会创建一个新的 `RunLoop`，并添加到 `__CFRunLoops` 中。 * 注册一个回调，当线程销毁时，顺便也销毁其对应的 `RunLoop`。 只能通过 `CFRunLoopGetMain()`函数或者 `CFRunLoopGetCurrent()`函数来获取`RunLoop`，通过上面的源代码我们发现，无论是 `CFRunLoopGetMain()` 函数还是`CFRunLoopGetCurrent()` 函数，都是通过对应的线程获取对应的`RunLoop`，线程和 `RunLoop` 是一一对应的，不会重复创建。在主线程，系统会帮我们创建 `RunLoop` 来处理事件。而子线程`RunLoop` 并不会默认开启。子线程操作完成后，线程就被销毁了，如果我们想线程不被销毁，需要主动获取一个 `RunLoop`，并且在`RunLoop` 中添加 `Timer/Source/Observer` 其中的一个。 ## 3.4、使用 `RunLoop` 常驻线程 * 1、为当前线程开启一个`RunLoop`； * 2、向该`RunLoop`中添加一个 `NSMachPort /Source`等维持 `RunLoop` 的事件循环； * 3、启动 `RunLoop` 首先，我们添加一个通知监听线程退出的事件 //在适当的位置添加通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(threadExitNotice:) name:NSThreadWillExitNotification object:nil]; //通知响应的方法 (void)threadExitNotice:(NSNotification *)notification { NSLog(@\" threadExitNotice ------------ %@\",notification.object); } ``` 这时，我们开启一个线程： - (void)residentThread { if (@available(iOS 10.0, *)) { //常驻线程 [NSThread detachNewThreadWithBlock:^{ NSThread.currentThread.name = @\"常驻线程\"; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; NSLog(@\"---------- 此处代码不被执行 -----------\"); }]; } } 然后我们运行程序，可以发现，在新开启的分线程里，代码执行到[runLoop run]; 就不再往后执行了，也就是说线程阻塞了。而且没有收到线程退出的通知。 参考文章： iOS多线程篇：NSThread 小笨狼漫谈多线程：NSThread 多线程实现方案之一 : NSThread RunLoop(从源码分析到Demo分析到mainLoop log分析) Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/OC之NSOperation.html":{"url":"iOS开发/杂记/OC之NSOperation.html","title":"任务队列NSOperation","keywords":"","body":"操作队列 NSOperation 操作单元 NSOperation 与 操作队列 NSOperationQueue 是苹果提供的一套面向对象的基于 GCD 封装的多线程解决方案。 1、操作单元 NSOperation NSOperation 是与单个任务关联的代码和数据的抽象类，任务封装在 NSOperation 实例里，可以简单地认为 NSOperation 是单个的工作单元。 它在使用上，更加符合面向对象的思想，更加方便的为任务添加依赖关系，提供表示当前任务执行状态的四个属性cancelled、executing、finished、ready，支持 KVO 。NSOperation内部对这四个状态行为作了预处理，根据任务的不同状态这四个属性的值会自动改变。 1.1、NSOperation属性与方法 1.1.1、执行操作 方法 方法描述 -start 开始执行操作 -main 执行的非并发任务 注意： 调用 -start 方法之前必须确认操作准备就绪（即ready的值为 YES ），否则调用 -start会出现异常Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[__NSOperationInternal _start:]: receiver is not yet ready to execute' :如下图所示 属性 值描述 completionBlock 可读可写，当 finished 的值更改为 YES 时，将执行该代码块。 completionBlock通常是一个子线程执行；因此，不应该使用这个块来做刷新UI。 finished=YES可能因为它被取消或者因为它完成任务而结束；在编写代码块时，应该考虑到这一点。 completionBlock 类似于GCD的函数 dispatch_block_notify() ，监听 dispatch_block 完成时 dispatch_queue 调用 notification_block 1.1.2、取消操作 方法 方法描述 -cancel 通知 NSOperation停止执行其任务。不会强制停止；它更新NSOperation的内部cancelled以反映状态的变化。如果已经完成执行，调用该方法无实际意义；可以调用该方法取消在操作队列中但尚未执行的操作。 属性 值描述 cancelled 指示操作是否已被取消，默认为NO。调用-cancel将此该值设置为 YES ，此时finished 的值更改为 YES。 1.1.3、获取操作状态 属性 值描述 ready 指示现在是否可以执行该操作。默认值 YES 表示 operation 可执行；当为 NO时，表示它依赖的 operation 未完成。只有在[operation start]之前使用- addDependency:方法给这个操作添加一个依赖，ready 值才会改为 NO ；当添加的依赖操作 finished 属性为 YES 即依赖操作完成或者取消时，这个操作的 ready 改为 YES 。注意： ready 为 NO 的操作还没准备就绪，此时不能调用 -start ，否则异常终止NSInvalidArgumentException。 executing 指示操作是否正在执行。在实现并发操作对象时，必须重写此属性的实现，以便返回操作的执行状态；对于非并发操作，不需要重新实现此属性。 finished 指示操作是否已完成任务或者被取消。一个操作对象直到finished=YES时，才会清除依赖。同样地，操作队列直到finished=YES时才会将一个NSOperation移除队列。在实现并发操作对象时，必须重写此属性的实现，以便返回操作的完成状态；对于非并发操作，不需要重新实现此属性。 cancelled 指示操作是否已被取消，默认为NO。调用-cancel将该值设置为YES，此时finished 的值更改为 YES。 concurrent 指示操作是否异步执行其任务，默认为NO。已被asynchronous属性替代。 asynchronous 指示操作是否异步执行其任务，默认为NO。在实现异步操作对象时，必须实现此属性并返回YES。 name 一个读写属性的字符串，为操作对象分配一个名称，以方便在调试期间识别它。 1.1.4、依赖关系管理 方法 方法描述 -addDependency: 设置依赖保证执行顺序，如一定要让操作A执行完后,才能执行操作B。如果该操作已经在执行其任务，那么添加依赖关系没有实际效果。这个方法可以改变此操作的isReady和dependencies属性。不能创建循环依赖（不能A依赖于B，B又依赖于A），这样做可能导致操作之间的死锁。 -removeDependency: 移除对指定操作的依赖操作。这个方法可以改变此操作的isReady和dependencies属性。 属性 值描述 dependencies 表示在当前对象开始执行之前必须完成执行的operation数组。要向这个数组添加对象，需要使用-addDependency:方法。在完成执行操作时，不会从这个依赖项列表中删除操作。可以使用这个列表来跟踪所有依赖的操作，包括那些已经完成执行的操作。从列表中删除操作的唯一方法是使用-removeDependency:方法。 1.1.5、配置执行优先级 属性 值描述 queuePriority 操作队列中操作的执行优先级，这个值用于影响操作退出队列和执行的顺序。如果没有显式设置优先级，该方法返回NSOperationQueuePriorityNormal。 qualityOfService NSOperation对象访问系统资源(如CPU时间、网络资源、磁盘资源等)的优先级，反映有效执行NSOperation所需的最低服务级别，默认值是NSQualityOfServiceBackground。服务质量较高的NSOperation优先于系统资源，因此可以更快地执行任务。想要了解更多可以阅读Energy Efficiency Guide for iOS Apps 1.1.6、等待操作对象 -waitUntilFinished：阻塞当前线程的执行，直到操作对象完成其任务；常用于将操作提交到队列后，调用此方法，等待该操作完成。 注意：操作对象永远不能在自身上调用此方法，并且应该避免在提交给与自身相同的操作队列的任何操作上调用它，这样做会导致操作死锁。相反，应用程序的其他部分可以根据需要调用此方法，以防止其他任务在目标操作对象完成之前完成。对于位于不同操作队列中的操作调用此方法通常是安全的，尽管如果每个操作都在另一个操作队列上等待，仍然可以创建死锁。 NSOperation默认是非并发的(non-concurrent)；执行它的任务一次，就不能再次执行； 1.2、单独执行一个任务NSOperation 因为NSOperation是抽象的，所以不能直接使用这个类。可以使用系统提供的子类NSInvocationOperation/NSBlockOperation，或者自定义它的子类。 虽然操作对象通常通过操作对列执行，但是我们也可以手动启动操作对象： 1.2.1、使用NSInvocationOperation @interface NSInvocationOperation : NSOperation - (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg; - (instancetype)initWithInvocation:(NSInvocation *)inv NS_DESIGNATED_INITIALIZER; @property (readonly, retain) NSInvocation *invocation; @property (nullable, readonly, retain) id result; @end 使用NSInvocationOperation创建一个任务: - (void)invocationOperationMethod{ NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperationHandleTask:) object:@{}]; invocationOperation.completionBlock = ^{ NSLog(@\"监听回调：taskA ------- %@\",NSThread.currentThread); }; [invocationOperation start]; } - (void)invocationOperationHandleTask:(id)object{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); } 运行程序，分析打印结果： 10:09:51 开始处理 -------- {number = 1, name = main} 10:09:51 开始执行：taskA ======= {number = 1, name = main} 10:09:54 结束执行：taskA ------- {number = 1, name = main} 10:09:54 结束处理 -------- {number = 1, name = main} 10:09:54 监听回调：taskA ------- {number = 3, name = (null)} 通过打印结果可以看到： NSInvocationOperation在当前线程执行任务，会堵塞当前线程直到任务执行完毕。 如果想要开辟一条线程执行任务，可以在指定的处理方法里开辟一条线程；当然这样做显得多余，不符合NSInvocationOperation的适用场景。 NSInvocationOperation任务完成之后的回调completionBlock处理在分线程中。 1.2.2、使用NSBlockOperation 我们使用NSBlockOperation快速创建一个任务，然后使用-addExecutionBlock:额外添加了一个任务： - (void)blockOperationMethod{ NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }]; [blockOperation addExecutionBlock:^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:6];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }]; blockOperation.completionBlock = ^{ NSLog(@\"监听回调： ------- %@\",NSThread.currentThread); }; [blockOperation start]; } 运行程序，分析打印结果： 10:11:52 开始处理 -------- {number = 1, name = main} 10:11:52 开始执行：taskA ======= {number = 1, name = main} 10:11:52 开始执行：taskB ======= {number = 3, name = (null)} 10:11:55 结束执行：taskA ------- {number = 1, name = main} 10:11:58 结束执行：taskB ------- {number = 3, name = (null)} 10:11:58 结束处理 -------- {number = 1, name = main} 10:11:58 监听回调： ------- {number = 3, name = (null)} 通过打印结果可以看到： 相对于NSInvocationOperation，NSBlockOperation可以使用-addExecutionBlock:追加多个任务； 对于taskA，NSBlockOperation在当前线程执行任务；对于taskB，NSBlockOperation新开辟一条线程并发执行任务； 也就是说NSBlockOperation封装的操作数 > 1，就会异步并发执行操作；如果 = 1，就会同步执行操作。 NSBlockOperation会堵塞当前线程，直到封装的所有任务处理完毕，当前线程代码才会接着向下执行； NSBlockOperation任务完成之后的回调completionBlock处理在分线程中。 1.2.3、自定义NSOperation同步执行 我们已经使用NSOperation的系统定义子类NSInvocationOperation与NSBlockOperation来单独处理耗时任务，知道这两个子类默认在当前线程处理，会堵塞当前线程直到所有任务全部处理完毕，不会开辟新的线程。我们不妨自定义一个NSOperation的子类，来了解内部的工作机制： 1.2.3.1、非并发类OperationSync 我们定义一个同步执行的OperationSync操作类，重写- main方法；可以研究下非并发操作对象的内部实现： @interface OperationSync : NSOperation @end @implementation OperationSync @synthesize completionBlock = _completionBlock; - (void)main{ //该自动释放池可以防止相关线程发生内存泄漏 @autoreleasepool{ //使用 try-catch 语句防止出现超出这个线程范围的异常情况 @try{ //检查操作是否被取消,在取消操作时尽可能快地退出 if (self.isCancelled == NO) { NSLog(@\"耗时任务执行中 ------- %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 if (_completionBlock){ self.completionBlock(); } } }@catch (NSException *exception){} } } @end 1.2.3.2、使用OperationSync类 我们将耗时操作封装在OperationSync的-mian方法中， - (void)customSyncOperationTaskAMethod{ OperationSync *taskA = [[OperationSync alloc] init]; taskA.completionBlock = ^{ NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }; NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [taskA start]; } 运行程序，分析打印结果： 10:43:31 开始处理 -------- {number = 1, name = main} 10:43:31 开始执行：taskA ======= {number = 1, name = main} 10:43:31 耗时任务执行中 ------- {number = 1, name = main} 10:43:34 结束执行：taskA ------- {number = 1, name = main} 10:43:34 结束处理 -------- {number = 1, name = main} 运行程序，可以看到： OperationSync同步执行任务，阻塞当前线程； 由于completionBlock回调执行在当前线程，而上文NSInvocationOperation与NSBlockOperation的completionBlock回调都在分线程处理；我们可以推断：系统新开辟了一条线程用来处理NSInvocationOperation与NSBlockOperation的completionBlock回调； 1.2.4、自定义NSOperation异步执行 在上文，我们自定义一个NSOperation的子类OperationSync来同步处理耗时任务，了解了内部的工作机制。现在我们不妨来实现一个并发执行任务的NSOperation的子类： 1.2.4.1、并发类OperationAsync 将操作编写为并发，异步执行它，必须添加许多额外功能: 重写 -start 方法：将该方法更新为以异步方式执行操作，通常通过在新线程调用操作对象的 -main方法来做到这一点； 重写 -main方法（可选）：该方法实现与操作关联的任务，也可以直接在 start 方法实现该任务； 配置和管理操作的执行环境：并发操作必须设置本身的环境，并向客户端报告其状态。尤其是 -isExecuting、 -isFinished 和 -isAsynchronous 方法必须返回与操作状态有关的值，而且这 3 个方法必须具备线程安全性，当这些值改变时，还必须生成适当的键值观察通知(KVO)。 @interface OperationAsync : NSOperation @end @implementation OperationAsync @synthesize finished = _finished; @synthesize executing = _executing; @synthesize completionBlock = _completionBlock; - (instancetype)init{ self = [super init]; if (self){ _finished = NO; _executing = NO; } return self; } - (void)start{ //检查操作是否被取消,在取消操作时尽可能快地退出 if (self.isCancelled){ //重写start方法，当operation执行完成或者被取消的时候，必须重写这个finished属性以及生成KVO通知 [self willChangeValueForKey:@\"isFinished\"]; _finished = YES; [self didChangeValueForKey:@\"isFinished\"]; //重写start方法，当operation执行完成或者被取消的时候，根据需要调用completionBlock if (_completionBlock){ self.completionBlock(); } return; } //重写start方法，当operation改变了执行状态时，必须重写这个executing属性以及生成KVO通知。 [self willChangeValueForKey:@\"isExecuting\"]; [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil]; _executing = YES; [self didChangeValueForKey:@\"isExecuting\"]; } - (void)main{ //该自动释放池可以防止相关线程发生内存泄漏 @autoreleasepool{ //使用 try-catch 语句防止出现超出这个线程范围的异常情况 @try{ //检查操作是否被取消,在取消操作时尽可能快地退出 if (self.isCancelled == NO) { NSLog(@\"耗时任务执行中 ------- %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 [self willChangeValueForKey:@\"isFinished\"]; [self willChangeValueForKey:@\"isExecuting\"]; _finished = YES; _executing = YES; [self didChangeValueForKey:@\"isExecuting\"]; [self didChangeValueForKey:@\"isFinished\"]; //重写main方法，当operation执行完成或者被取消的时候，根据需要调用completionBlock if (_completionBlock){ self.completionBlock(); } } }@catch (NSException *exception){} } } - (BOOL)isAsynchronous{ return YES; } - (BOOL)isExecuting{ return _executing; } - (BOOL)isFinished{ return _finished; } @end 1.2.4.2、使用OperationAsync类 我们使用并发操作OperationAsync - (void)customAsyncOperationTaskAMethod{ OperationAsync *taskA = [[OperationAsync alloc] init]; taskA.completionBlock = ^{ NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }; NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [taskA start]; } 运行程序，分析打印结果： 10:44:12 开始处理 -------- {number = 1, name = main} 10:44:12 开始执行：taskA ======= {number = 1, name = main} 10:44:12 结束处理 -------- {number = 1, name = main} 10:44:12 耗时任务执行中 ------- {number = 3, name = (null)} 10:44:15 结束执行：taskA ------- {number = 3, name = (null)} 运行程序，可以看到： OperationAsync异步执行任务，开辟一条新线程，不会阻塞当前线程； 由于completionBlock在新开辟的分线程被调用，所以回调处理也在分线程被执行； 1.3、NSOperation生命周期 我们知道NSOperation 有多个操作状态，那么这些操作状态之间有什么联系呢？NSOperation的生命周期是什么？ 我们通过下面程序来探究下： - (void)operationLifeCycleMethod{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSBlockOperation *blockOperationA = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }]; blockOperationA.name = @\"com.demo.taskA\"; [blockOperationA addObserver:self forKeyPath:@\"ready\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationA)]; [blockOperationA addObserver:self forKeyPath:@\"cancelled\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationA)]; [blockOperationA addObserver:self forKeyPath:@\"executing\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationA)]; [blockOperationA addObserver:self forKeyPath:@\"finished\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationA)]; NSBlockOperation *blockOperationB = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }]; blockOperationB.name = @\"com.demo.taskB\"; [blockOperationB addObserver:self forKeyPath:@\"ready\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationB)]; [blockOperationB addObserver:self forKeyPath:@\"cancelled\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationB)]; [blockOperationB addObserver:self forKeyPath:@\"executing\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationB)]; [blockOperationB addObserver:self forKeyPath:@\"finished\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:(__bridge void * _Nullable)(blockOperationB)]; NSLog(@\"blockOperationA.ready --- %d\",blockOperationA.ready); NSLog(@\"blockOperationB.ready --- %d\",blockOperationB.ready); [blockOperationA addDependency:blockOperationB]; NSLog(@\"blockOperationA.ready === %d\",blockOperationA.ready); NSLog(@\"blockOperationB.ready === %d\",blockOperationB.ready); [queue addOperation:blockOperationA]; [queue addOperation:blockOperationB]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{ id task = (__bridge id)(context); NSLog(@\"%@ ----- %@ === %@\",task,keyPath,change[NSKeyValueChangeNewKey]); } 运行程序，分析打印数据： 11:42:09 开始处理 -------- {number = 1, name = main} 11:42:09 blockOperationA.ready --- 1 11:42:09 blockOperationB.ready --- 1 11:42:09 {name = 'com.demo.taskA'} ----- ready === 0 11:42:09 blockOperationA.ready === 0 11:42:09 blockOperationB.ready === 1 11:42:09 结束处理 -------- {number = 1, name = main} 11:42:09 {name = 'com.demo.taskB'} ----- executing === 1 11:42:09 开始执行：taskB ======= {number = 3, name = (null)} 11:42:11 结束执行：taskB ------- {number = 3, name = (null)} 11:42:11 {name = 'com.demo.taskA'} ----- executing === 1 11:42:11 {name = 'com.demo.taskA'} ----- ready === 1 11:42:11 开始执行：taskA ======= {number = 4, name = (null)} 11:42:11 {name = 'com.demo.taskB'} ----- executing === 0 11:42:11 {name = 'com.demo.taskB'} ----- finished === 1 11:42:13 结束执行：taskA ------- {number = 4, name = (null)} 11:42:13 {name = 'com.demo.taskA'} ----- executing === 0 11:42:13 {name = 'com.demo.taskA'} ----- finished === 1 分析打印数据： 通过blockOperation.ready可以看到，NSOperation的属性ready值默认为YES，处于准备就绪状态；当给该NSOperation添加一个依赖后，属性ready变为 NO，处于未准备状态。 taskB结束执行后该操作属性finished变为 YES；这时taskA操作的属性ready值改为YES，表示taskA的操作已经准备就绪，可以开始执行； 操作taskA的属性executing变为 YES，表示正在执行；taskA执行完毕之后，executing变为 NO，finished变为 1。 我们通过KVO监听操作taskA的各属性变化，可以得出NSOperation的生命周期： 1.4、NSOperation只能调用-start一次 我们已经知道，NSOperation的从准备任务到完成任务生命周期历程；那么start调用一次后，再次调用还能执行任务嘛？答案是否定的！我们不妨来看一段程序： - (void)startMuchMethod{ NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }]; [blockOperation start]; NSLog(@\"再次执行：taskA ======= %@\",NSThread.currentThread); [blockOperation start]; } 运行程序，分析打印结果： 09:38:10 开始处理 -------- {number = 1, name = main} 09:38:10 开始执行：taskA ======= {number = 1, name = main} 09:38:12 结束执行：taskA ------- {number = 1, name = main} 09:38:12 再次执行：taskA ======= {number = 1, name = main} 09:38:12 结束处理 -------- {number = 1, name = main} 从打印结果可以看到：NSOperation的任务只执行了一次，就好比生命只有一次：从出生到死亡的历程。这点不同于dispatch_block_t，我们dispatch_block_create()创建了一个dispatch_block_t，可以多次调用dispatch_block_perform()方法来执行这个任务。 2、操作队列NSOperationQueue NSOperationQueue 是一个管理操作执行的队列。 当NSOperation配合NSOperationQueue使用时，Queue会监听所有Operation的状态从而分配任务的启动时机。NSOperation隐藏了很多内部细节，让开发者无需关心任务的各种状态。 使用 NSOperationQueue 时控制任务数量会并不总是有效，原因何在？利用 NSOperation 封装异步代码有什么需要注意的地方？是否有更好的方法来控制任务的并发数量？为此，我们需要深入了解 NSOperation 的运作机制，现在我们从实际应用场景出发探讨这些问题。 2.1、NSOperationQueue的属性与方法 2.1.1、访问特定操作队列 属性 值描述 mainQueue 获取绑定到主线程的默认操作队列；该队列在应用程序的主线程上每次执行一个操作。（class修饰，由类对象调用） currentQueue 获取当前操作队列。从运行操作的上下文外部调用此方法通常会返回nil。（class修饰，由类对象调用） 2.1.2、管理队列中的操作 我们不妨先运行几个程序，体验下操作队列的方法使用 2.1.2.1、程序一 我们使用NSBlockOperation创建了一个耗时操作；创建了两个操作队列使用NSOperationQueue的实例方法- addOperation:将操作添加到这两个操作操作队列： - (void)addOperationMethod{ NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行 ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:5];//模拟耗时任务 NSLog(@\"结束执行 ------- %@\",NSThread.currentThread); }]; [queue1 addOperation:blockOperation]; [queue2 addOperation:blockOperation]; } 运行这段代码，发现程序异常终止：-[NSOperationQueue addOperation:]: operation is already enqueued on a queue'操作已经加入到队列中: *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSOperationQueue addOperation:]: operation is already enqueued on a queue' *** First throw call stack: ( 0 CoreFoundation 0x00000001052e21e6 __exceptionPreprocess + 294 1 libobjc.A.dylib 0x0000000104977031 objc_exception_throw + 48 2 CoreFoundation 0x0000000105357975 +[NSException raise:format:] + 197 3 Foundation 0x0000000104386f4c __addOperations + 1186 4 OperationQueueDemo 0x00000001040632c4 -[OperationQueueTableViewController addOperationMethod] + 212 5 OperationQueueDemo 0x00000001040618c7 -[OperationQueueTableViewController tableView:didSelectRowAtIndexPath:] + 583 6 UIKit 0x0000000106253e89 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1813 7 UIKit 0x00000001062540a4 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 8 UIKit 0x00000001061204b3 _runAfterCACommitDeferredBlocks + 318 9 UIKit 0x000000010610f71e _cleanUpAfterCAFlushAndRunDeferredBlocks + 388 10 UIKit 0x000000010613dea5 _afterCACommitHandler + 137 11 CoreFoundation 0x0000000105284607 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 12 CoreFoundation 0x000000010528455e __CFRunLoopDoObservers + 430 13 CoreFoundation 0x0000000105268b81 __CFRunLoopRun + 1537 14 CoreFoundation 0x000000010526830b CFRunLoopRunSpecific + 635 15 GraphicsServices 0x000000010b54ea73 GSEventRunModal + 62 16 UIKit 0x0000000106115057 UIApplicationMain + 159 17 OperationQueueDemo 0x000000010405dfaf main + 111 18 libdyld.dylib 0x00000001096f5955 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException (lldb) -addOperation:将指定的操作添加到操作队列。如果操作已经在另一个队列中，该方法将抛出一个NSInvalidArgumentException异常。 还记得上文提过的NSOperation在ready状态为 NO 时调用-start方法导致程序抛出NSInvalidArgumentException异常嘛？类似地，如果NSOperation正在执行（executing=YES）或已经执行完毕（finished=YES），-addOperation:方法也会抛出NSInvalidArgumentException异常。 异常终止：operation is executing and cannot be enqueued 异常终止：operation is finished and cannot be enqueued 注意： NSOperation 的 ready = NO 时，不能调用 -start； NSOperation 只能添加到一个NSOperationQueue，不能再次添加到另一个NSOperationQueue； NSOperation 的 executing = YES 时，不能加入队列 NSOperationQueue； NSOperation 的 finished = YES 时，不能加入队列 NSOperationQueue； 2.1.2.2、程序二 我们使用NSBlockOperation创建了操作A，操作B，操作C，操作D；使用NSOperationQueue的实例方法-addOperation:将操作A、操作C、操作D添加到操作队列，使用-addOperations: waitUntilFinished:方法将操作B添加至操作队列；在添加操作C与操作D之间使用- waitUntilAllOperationsAreFinished堵塞当前线程。 - (void)waitUntilFinishedMethod{ NSOperationQueue *queue = [[NSOperationQueue alloc] init]; NSBlockOperation *blockOperationA = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:5];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }]; blockOperationA.name = @\"com.demo.taskA\"; NSBlockOperation *blockOperationB = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }]; blockOperationB.name = @\"com.demo.taskB\"; NSBlockOperation *blockOperationC = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskC ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskC ------- %@\",NSThread.currentThread); }]; blockOperationC.name = @\"com.demo.taskC\"; NSBlockOperation *blockOperationD = [NSBlockOperation blockOperationWithBlock:^{ NSLog(@\"开始执行：taskD ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskD ------- %@\",NSThread.currentThread); }]; blockOperationD.name = @\"com.demo.taskD\"; [queue addOperation:blockOperationA]; [queue addOperations:@[blockOperationB] waitUntilFinished:YES]; NSLog(@\"queue.operations === 1 === %@\",queue.operations); [queue addOperation:blockOperationC]; NSLog(@\"queue.operations === 2 === %@\",queue.operations); [queue waitUntilAllOperationsAreFinished]; [queue addOperation:blockOperationD]; NSLog(@\"queue.operations === 3 === %@\",queue.operations); } 我们运行程序，分析打印数据： 10:21:58 开始处理 -------- {number = 1, name = main} 10:21:58 开始执行：taskA ======= {number = 3, name = (null)} 10:21:58 开始执行：taskB ======= {number = 4, name = (null)} 10:22:01 结束执行：taskB ------- {number = 4, name = (null)} 10:22:01 queue.operations === 1 === ( \"{name = 'com.demo.taskA'}\" ) 10:22:01 queue.operations === 2 === ( \"{name = 'com.demo.taskA'}\", \"{name = 'com.demo.taskC'}\" ) 10:22:01 开始执行：taskC ======= {number = 4, name = (null)} 10:22:03 结束执行：taskA ------- {number = 3, name = (null)} 10:22:04 结束执行：taskC ------- {number = 4, name = (null)} 10:22:04 queue.operations === 3 === ( \"{name = 'com.demo.taskD'}\" ) 10:22:04 开始执行：taskD ======= {number = 3, name = (null)} 10:22:04 结束处理 -------- {number = 1, name = main} 10:22:07 结束执行：taskD ------- {number = 3, name = (null)} 通过打印数据： taskB执行完毕之后，才开始执行taskC：这是因为-addOperations: waitUntilFinished:方法的第二个参数wait如果YES，则阻塞当前线程，直到该组NSOperation执行完毕；如果为NO，则不会堵塞当前线程。 taskC执行完毕之后，才调用结束处理这句代码：这是因为-waitUntilAllOperationsAreFinished方法会阻塞当前线程，直到队列中所有Operation执行完成；在此期间，当前线程不能向队列添加Operation，但其他线程可以。 通过queue.operations === 1 ===可以看到此时的操作队列只有操作com.demo.taskA：这是因为执行完毕的 Operation已经被移除操作队列； 方法 方法描述 - addOperation: 将 NSOperation 添加到操作队列，当 NSOperation.finished = YES 时从操作队列移除。一个NSOperation只能在一个操作队列中，添加到第二个队列时抛出NSInvalidArgumentException异常。类似地，如果NSOperation正在执行或已经执行完毕，也不能添加到队列。 -addOperations: waitUntilFinished: 将一组NSOperation添加到操作队列中；该组NSOperation完成后，从操作队列移除。参数wait如果YES，则阻塞当前线程，直到该组ops执行完毕才接着往下执行；如果为NO，则不会堵塞当前线程。 -addOperationWithBlock: 在Operation 中包装指定的块并将其添加到队列。 -waitUntilAllOperationsAreFinished 阻塞当前线程，直到队列中所有NSOperation.finished = YES。 -cancelAllOperations 对队列中的所有Operations调用-cancel方法。该方法不会直接 将Operations从队列中删除或停止当前正在执行的NSOperation。对于未执行的Operations，队列仍然尝试执行Operations，然后识别Operations.cancelled=YES并将Operations.finished 改为YES 。对于已经执行的Operations，Operations本身检查是否取消，并停止正在执行的Operations，以便能够移动到完成状态。这两种情况下的Operations在从队列中删除之前仍然有机会执行Operations.completionBlock。 注意1：对于队列中的所有operations，只要Operation.finished = YES，就会移除队列； 注意2：-cancelAllOperations不会直接 将Operations从队列中删除，但对于未执行的Operations，队列仍然尝试执行Operations，然后识别Operations.cancelled=YES并将Operations.finished 改为YES ！ Operations.finished=YES 时就是它从队列移除的时候，所以最终，队列中的所有Operations 还是被移除；只不过是-cancelAllOperations间接 导致的！ 属性 属性描述 operations 当前操作队列中所有未完成的Operations。该数组包含多个NSOperation对象，其顺序与它们被添加到队列的顺序相同；这个顺序不一定反映执行这些Operations的顺序。数组可能包含正在执行或等待执行的Operations，还可能包含在数组最初被检索时正在执行但随后已经完成的Operations。 operationCount 操作队列中当前的并发数； 2.1.3、管理与配置操作队列 属性 属性描述 qualityOfService 服务级别影响Operation访问系统资源(如CPU时间、网络资源、磁盘资源等)的优先级；服务质量较高的Operation优先于系统资源，因此可以更快地执行任务。对于自己创建的队列，默认值是NSOperationQualityOfServiceBackground。对于主线程方法返回的队列，默认值是NSOperationQualityOfServiceUserInteractive，无法更改。 maxConcurrentOperationCount 队列可以同时执行的最大数量；设置该值不会影响当前正在执行的Operation。系统推荐NSOperationQueueDefaultMaxConcurrentOperationCount是根据当前系统条件动态确定的最大操作数。 name 队列名称，方便调试或分析代码。默认值是一个包含队列内存地址的字符串。 underlyingQueue 用于执行Operation的分派队列dispatch_queue_t，默认值为 nil。可以将该变量设置为现有的dispatch_queue，以便将排队操作与提交到该dispatch_queue的块穿插在一起；只有在队列中没有Operation时才应该设置此属性的值，当operationCount!=0时设置该变量会引发NSInvalidArgumentException。该dispatch_queue不能是主队列dispatch_get_main_queue，dispatch_queue的优先级覆盖操作队列优先级；如果OS_OBJECT_IS_OBJC是 YES，此属性将自动保留其分配的队列。 2.1.4、操作队列暂停执行 属性suspended：可读可写的布尔值，指示队列是否在主动调度要执行的Operation。默认值为 NO，会启动队列中准备执行的Operation；将该值设为YES可挂起操作队列中的任何排队Operation，但已经执行的Operation将继续执行。挂起的操作队列可以继续添加Operation，但在将此属性更改为NO之前，这些Operation不会计划执行。 属性suspended在操作队列的作用类似于GCD中的dispatch_suspend()函数，并不会立即暂停dispatch_queue中正在执行的任务，而是在当前任务执行完成后，暂停后续的任务执行。 3、操作队列NSOperationQueue与分派队列dispatch_queue_t 我们在开篇时提出：NSOperation与 NSOperationQueue 是苹果提供的一套面向对象的基于GCD封装的多线程解决方案。那么苹果为什么要封装GCD？使用NSOperationQueue的优势是什么？ 3.1、NSOperation 与 dispatch_block_t 通过上文的学习，我们已经感受到 NSOperation很像 GCD 中的dispatch_block_t。那么相比于dispatch_block_t，使用NSOperation的优势如下: NSOperation 有生命周期，执行之后不能再次执行；而 dispatch_block_t 可以被多次调用； NSOperation添加completionBlock, 在任务完成后调用。相对于 GCD 代码更简洁；类似于 GCD 的dispatch_block_notify()函数 NSOperation之间可以设置依赖关系，-addDependency:; 设置NSOperation的优先级；类似dispatch_block_t的qos 方便的设置 NSOperation 取消操作；类似dispatch_block_cancel() 使用 KVO 对NSOperation状态的监听: isExcuting, isFinished, isCancelled。 3.2、NSOperationQueue 与 dispatch_queue_t 相比于分派队列dispatch_queue_t，使用操作队列NSOperationQueue 的优势如下: 对操作队列当前并发数的监控operationCount； 对操作队列最大并发数的设置 maxConcurrentOperationCount； 可以调用-cancelAllOperations方法取消操作队列中尚未执行的操作；GCD 中并没有提供取消分派队列dispatch_queue_t中任务的函数； 有时候我们很希望知道当前执行的操作队列是谁，我们可以使用currentQueue获取到当前的操作队列。但是 GCD 中分派队列dispatch_queue_t是按照层级结构来组织的，无法单用某个队列对象来描述“当前队列”，dispatch_get_current_queue()函数可能返回与预期不一致的结果，而且误用dispatch_get_current_queue()可能导致死锁，所以GCD中dispatch_get_current_queue()在 iOS 6 已被废弃。 参考文章： 示例Demo NSOperation概述 NSOperation相关学习笔记 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/OC之GCD.html":{"url":"iOS开发/杂记/OC之GCD.html","title":"GCD","keywords":"","body":"GCD Dispatch : Execute code concurrently on multicore hardware by submitting work to dispatch queues managed by the system. 1、GCD 概述 1.1、什么是 GCD？ GCD 全称 Grand Central Dispath ，是基于 C 语言的 API，支持分派队列执行任务。使用分派队列 dispath_queue 可以同步或者异步执行代码，以及串行或者并发的执行任务。与 NSOperationQueue 一样，dispath_queue 也比线程更易于使用，执行异步或者并发任务更高效。 我们日常开发所使用的 GCD 的 API 全部为包含在 libdispatch 库中的 C 语言函数。 1.2、为什么使用 GCD？ 应用程序中编写的线程管理用的代码要在系统级实现。 无论我们如何努力编写管理线程的代码，在性能方面也不可能胜过系统级所实现 GCD。GCD 是 iOS 和 OS X 的核心 XNU 内核所实现的；因此，使用 GCD 比使用 pthreads 和 NSThread 这些一般的多线程编程 API 效率更高。 1.3、GCD 内存管理 GCD 对象被称为 dispatch_object， 像 Cocoa 对象一样是引用计数的。因此，如果我们使用 ARC，dispatch_object将被保留并自动释放，就像任何其它 Objective-C 对象一样。当使用 MRC 时，需要使用dispatch_retain() 和 dispatch_release() 函数来保留和释放dispatch_object对象，不能使用 Core Foundation 框架的 -retain/-release方法。 思考：在 GCD 中是 dispatch_object 是什么？在 ARC 下，系统如何实现了dispatch_retain() 和 dispatch_release()函数的功能？ 1.4、dispatch_object 为了后文讲解，我们不妨先去 GCD源码 看下 dispatch_object 的内部结构： typedef union { struct dispatch_object_s *_do; struct dispatch_continuation_s *_dc; struct dispatch_queue_s *_dq;//队列 struct dispatch_queue_attr_s *_dqa; struct dispatch_group_s *_dg;//组 struct dispatch_source_s *_ds; struct dispatch_source_attr_s *_dsa; struct dispatch_semaphore_s *_dsema;//信号量 struct dispatch_data_s *_ddata; struct dispatch_io_s *_dchannel; struct dispatch_operation_s *_doperation; struct dispatch_disk_s *_ddisk; } dispatch_object_t __attribute__((transparent_union)); 可以看到 dispatch_object_t 的声明：使用关键字 union 表明dispatch_object_t 是一个联合 类型的数据结构；可以表示dispatch_queue、dispatch_group等 联合 是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被声明为“联合”的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。 2、分派队列 Dispatch Queues GCD 提供并管理 FIFO 队列，应用程序可以将任务以 Block 对象的形式提交给这些队列，提交给分派队列的任务在线程池（由系统完全管理）中执行。 2.1、什么是队列？ 队列是一种特殊的线性表，采用先进先出(FIFO)的规则，即 新任务总是被插入到队列的末尾，而读取任务总是从队列的头部开始读取。任务读取完毕，则从队列中移除该任务。 dispatch_queue 按 FIFO 顺序处理dispatch_block；该队列有两种类型：并发和串行队列。 串行队列（Serial Dispatch Queue）：每次只有一个任务被执行，一个任务执行完毕后，再执行下一个任务（只开辟一条线程）； 为了避免多线程下的资源竞争问题，一般使用串行队列，同一时间这个队列只有一个线程来访问这个共享资源； 并发队列（Concurrent Dispatch Queue）：可以让多个任务并发（同时）执行（可以开辟多条线程，并且同时执行任务） 并发队列 + 同步执行： 同步执行只能在当前线程中执行任务，不具备开辟新线程的能力。所以只会在一条线程里面同步执行这些任务，一个任务执行完毕后，再执行下一个任务。 并发队列 + 异步执行：异步开辟多条线程，同一时间在不同线程有许多的任务被执行。 注意：并发队列 的并发功能只有在异步函数 dispatch_async() 下才有效。 两者都符合先进先出(FIFO) 的原则，主要区别是：开辟线程数量可能不同 。 一条线程上可以有多个队列dispatch_queue，一个队列的任务也可能分别在多个线程执行 。 2.2、 dispatch_queue 我们已经大致了解了什么是队列！那么在GCD中的dispatch_queue到底是什么呢？ /// dispatch_queue_t 是一个结构指针，指向结构体 dispatch_queue_s typedef struct dispatch_queue_s *dispatch_queue_t; /* dq_serialnum 队列编号，跳过 0， 从 1 开始 * 1 主队列 3 不使用 * 2 管理队列：用来管理 GCD 内部的任务 ，比如下文介绍的定时器 * 4 ~ 11 是全局队列 */ struct dispatch_queue_s { const struct dispatch_queue_vtable_s *do_vtable; struct dispatch_queue_s *volatile do_next; unsigned int do_ref_cnt; unsigned int do_xref_cnt; unsigned int do_suspend_cnt; struct dispatch_queue_s *do_targetq;//目标队列 void *do_ctxt; void *do_finalizer; uint32_t volatile dq_running; uint32_t dq_width; //队列处理的任务并发数，1 代表着是串行队列 struct dispatch_object_s *volatile dq_items_tail; struct dispatch_object_s *volatile dq_items_head; unsigned long dq_serialnum;//队列序列号 dispatch_queue_t dq_specific_q; char dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE]; // 唯一标识 char _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; // for static queues only }; 2.2.1、main_queue 与 global_queue GCD 中两个特殊的队列：主队列 与 全局并发队列 //获取主队列：与主线程关联的串行队列 dispatch_queue_t dispatch_get_main_queue(void){ return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q); } //声明主队列 _dispatch_main_q struct dispatch_queue_s _dispatch_main_q; //主队列：结构体成员的赋值 struct dispatch_queue_s _dispatch_main_q = { #if !DISPATCH_USE_RESOLVERS .do_vtable = &_dispatch_queue_vtable, //通过 do_targetq 可以看出主队列拥有最高优先级 .do_targetq = &_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], #endif .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK, .dq_label = \"com.apple.main-thread\", .dq_running = 1, .dq_width = 1,//一次只能处理一个任务 .dq_serialnum = 1, }; /* 获取全局并发队列 * @param identifier 队列优先级 * @param flags 每当有任务提交到该队列时，为免线程过载，系统是否新开一个线程处理 * flags=0 代表不需要新开线程； flags=2 需要新开线程； * @note 常量 DISPATCH_QUEUE_OVERCOMMIT = 0x2ull */ dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags){ if (flags & ~DISPATCH_QUEUE_OVERCOMMIT) { return NULL; // flags!=0 或者 flags!=2 ,返回 NULL } //从队列池中获取指定的队列 return _dispatch_get_root_queue(priority, flags & DISPATCH_QUEUE_OVERCOMMIT); } 主队列 main_queue：由系统自动创建，并与应用程序的主线程相关联； 全局并发队列 global_queue：系统提供的队列池_dispatch_root_queues[] 中有 8 个队列，由两个入参获取其中一个队列。 dispatch_queue 有四个优先级，执行 dispatch_queue 中任务的线程 将 以该队列的优先级 作为线程的优先级。在向 global_queue 添加任务时，应设置好优先级；但是通过 XNU 内核用于 global_queue 的线程并不能保证实时性，因此执行优先级只是大致的判断。 队列优先级 值描述 DISPATCH_QUEUE_PRIORITY_HIGH 最高优先级 DISPATCH_QUEUE_PRIORITY_DEFAULT 默认优先级 DISPATCH_QUEUE_PRIORITY_LOW 低优先级 DISPATCH_QUEUE_PRIORITY_BACKGROUND 后台 2.2.2、创建 dispatch_queue_t /* 创建一个串行队列或者并发队列 * @param label 唯一标识，用于调试工具、示例、堆栈快照和崩溃报告 * 推荐使用反向dns命名如 \"com.demo.gcd.task\"。可以为空。 * @param attr 队列类型：如串行队列、并发队列 */ dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr); /* 获取队列的唯一标识 * @param queue 指定的队列 */ const char * dispatch_queue_get_label(dispatch_queue_t _Nullable queue){ return queue->dq_label; } 队列类型 值描述 DISPATCH_QUEUE_SERIAL 串行队列，队列中的任务按先进先出的顺序连续执行 DISPATCH_QUEUE_SERIAL_INACTIVE 不活跃状态的串行队列；该队列调用之前，必须使用dispatch_activate()函数激活队列(仅支持ios 10.0及以后的系统) DISPATCH_QUEUE_CONCURRENT 并发队列；虽然它们同时执行任务，但可以使用 dispatch_barrier() 在队列中创建同步点 DISPATCH_QUEUE_CONCURRENT_INACTIVE 不活跃的并发队列；该队列调用之前，必须使用dispatch_activate()函数激活队列(仅支持ios 10.0及以后的系统) 例子： //创建一个并发队列 dispatch_queue_t testQueue = dispatch_queue_create(\"com.demo.gcd.taskA\", DISPATCH_QUEUE_CONCURRENT); //获取该队列的唯一标识 const char *lable = dispatch_queue_get_label(testQueue); NSLog(@\"lable = %s\",lable);//打印：com.demo.gcd.taskA 思考： global_queue有执行的优先级，那么通过dispatch_queue_create()函数创建的队列肯定也有优先级，优先级是什么？串行队列与并发队列的优先级是否相同？我们能否获取创建队列的优先级？我们能否改变队列的优先级？ 2.2.3、目标队列 .do_targetq 目标队列 do_targetq 可以更改dispatch_queue 优先级，还能够创建队列的层次体系等！那么 do_targetq 是什么？我们来探究 dispatch_queue_create() 函数源码： /* 创建一个队列，该函数主要执行了三个功能 * 1、配置唯一标识，并拷贝至新队列 * 2、分配内存并初始化队列，该队列是串行队列 * 3、对于并发队列，需要额外设置 dq_width 、do_targetq */ dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr){ dispatch_queue_t dq; /**************** 唯一标识 *****************/ size_t label_len; if (!label) {//如果 label 为null，则设置为空字符串 label = \"\"; } label_len = strlen(label);//字符标签长度 if (label_len dq_label, label); if (fastpath(!attr)){ return dq;//返回串行队列 } /*************** 配置并发队列 ****************/ if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)){ dq->dq_width = UINT32_MAX;//设置并发数 dq->do_targetq = _dispatch_get_root_queue(0, false);//设置目标队列 } else { dispatch_debug_assert(!attr, \"Invalid attribute\"); } return dq; } 其中 _dispatch_queue_init() 函数初始化队列dispatch_queue，我们再去看下这个函数的源码： /* 初始化一个队列 * 并发数 dq_width=1 ，是个串行队列 * do_targetq 表明是默认优先级 */ static inline void _dispatch_queue_init(dispatch_queue_t dq){ dq->do_vtable = &_dispatch_queue_vtable; dq->do_next = DISPATCH_OBJECT_LISTLESS; dq->do_ref_cnt = 1; dq->do_xref_cnt = 1; dq->do_targetq = _dispatch_get_root_queue(0, true);//0 是 DISPATCH_QUEUE_PRIORITY_DEFAULT 默认优先级 dq->dq_running = 0; dq->dq_width = 1;//默认并发数为 1 dq->dq_serialnum = dispatch_atomic_inc(&_dispatch_queue_serial_numbers) - 1; } 上述create() 函数与init()函数的 do_targetq都交由_dispatch_get_root_queue()设置 /* 根据优先级 priority 与 overcommit ，从队列池中取出一个队列 * @param overcommit 每当有任务提交到该队列时，为免线程过载，系统是否新开一个线程处理。 */ static inline dispatch_queue_t _dispatch_get_root_queue(long priority, bool overcommit){ if (overcommit) switch (priority) { case DISPATCH_QUEUE_PRIORITY_LOW: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_DEFAULT: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_HIGH: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_BACKGROUND: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY]; } switch (priority) { case DISPATCH_QUEUE_PRIORITY_LOW: return &_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_DEFAULT: return &_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_HIGH: return &_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_BACKGROUND: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY]; default: return NULL; } } 根据入参(0, true)与(0, false)，找到函数执行的 case 为： case DISPATCH_QUEUE_PRIORITY_DEFAULT: return &_dispatch_root_queues[ DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]; case DISPATCH_QUEUE_PRIORITY_DEFAULT: return &_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]; 此时，我们明白：dispatch_queue_create() 函数创建的队列不管是串行队列，还是并发队列，优先级都是默认优先级DISPATCH_QUEUE_PRIORITY_DEFAULT 。 根据四个优先级 和 布尔值overcommit，队列池 _dispatch_root_queues[] 中有 8 个队列；这里简单展示一个队列 struct dispatch_queue_s _dispatch_root_queues[] = { [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = { .do_vtable = &_dispatch_queue_root_vtable, .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT, .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK, .do_ctxt = &_dispatch_root_queue_contexts[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], .dq_label = \"com.apple.root.default-overcommit-priority\", .dq_running = 2, .dq_width = UINT32_MAX, .dq_serialnum = 7, } } GCD 提供一个函数用于更改成员变量do_targetq ： /* 更改队列的目标队列 -> 更改队列优先级 * @param object 要修改的对象,不能为空； * @param queue 对象的新目标队列，不能为空。 * @note 该函数不仅可以设置优先级，还能够创建队列的层次体系； * 当我们需要不同队列中的任务同步执行时，可以创建一个串行队列 queue_A ，然后将这些队列的 do_targetq 指向 queue_A */ void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue); 2.2.4、dispatch_queue 小结： GCD 中的队列获取方式有三种： 获取主队列：系统创建，串行队列；.dq_running = 1 获取全局队列：系统提供，并发队列；.dq_running = 2 创建一个队列：可以是串行队列、也可以是并发队列；.dq_running = 0 在上文代码，可以发现dispatch_queue的 .dq_running，不同的获取方式，这个值是不同的， .dq_running值有什么用嘛？我们在下文使用时再来总结！ 2.3、dispatch_queue 的挂起与恢复 某些时候，可能需要暂停 dispatch_queue 中任务的执行，可以使用下述函数： /* 挂起指定的 dispatch_object * @note 全局队列不受影响 * @note 正在执行的 dispatch_block 不受影响，追加到 dispatch_queue 中尚未执行的任务停止执行 */ void dispatch_suspend(dispatch_object_t dou){ if (slowpath(dou._do->do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) { return; } //do_suspend_cnt = do_suspend_cnt + DISPATCH_OBJECT_SUSPEND_INTERVAL (void)dispatch_atomic_add2o(dou._do, do_suspend_cnt,DISPATCH_OBJECT_SUSPEND_INTERVAL); _dispatch_retain(dou._do); } /* 恢复指定的 dispatch_object * @note 全局队列不受影响 */ void dispatch_resume(dispatch_object_t dou){ if (slowpath(dou._do->do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) { return; } unsigned int suspend_cnt = dispatch_atomic_sub2o(dou._do, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_INTERVAL) + DISPATCH_OBJECT_SUSPEND_INTERVAL; if (fastpath(suspend_cnt > DISPATCH_OBJECT_SUSPEND_INTERVAL)) { return _dispatch_release(dou._do); } if (fastpath(suspend_cnt == DISPATCH_OBJECT_SUSPEND_INTERVAL)) { return _dispatch_resume_slow(dou); } DISPATCH_CLIENT_CRASH(\"Over-resume of an object\"); } 挂起/继续 函数对已经执行的任务没有影响。挂起后，追加到dispatch_queue 中但尚未执行的任务在此之后停止。而恢复则使得这些处理能够继续执行。 2.4、队列的性能问题 不论使用dispatch_queue_create()函数创建并发队列或者使用dispatch_get_global_queue()获取并发队列，在使用dispatch_async()函数执行任务时，都可以并发处理多个任务，但并发执行的任务数量取决于当前系统的状态。iOS 或者 OS X 基于dispatch_queue中的任务数量、CPU 核数以及 CPU 负荷等当前系统的状态来决定并发队列中并发执行的任务数量。iOS 和 OS X 的核心XNU 内核决定应当使用的线程数，并且只开辟所需的线程执行处理。当任务执行结束，应当执行的任务减少时，XNU 内核会结束不再需要的线程。XNU 内核使用并发队列便可完美的管理并执行多个处理任务的线程。 我们已经知道，一个串行队列需要开辟一条线程来处理队里中的任务；假如短时间内创建多个串行队列，就需要系统开辟多个线程去处理对应的串行队列中的任务。而此时就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。而对于并发队列来说，不管生成多少个并发队列，由于 XNU 内核只使用有效管理的线程，因此不会发生串行队列的那些问题。 我们分别测试下大量串行队列处理任务 与 大量并发队列处理任务的性能消耗: 串行队列的性能消耗 - (void)dispatch_serial_morequeue_Method{ dispatch_apply(1000, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) { dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ NSLog(@\"开始执行task%zu === %@\",index,NSThread.currentThread); [NSThread sleepForTimeInterval:13];//模拟耗时任务 NSLog(@\"结束执行task%zu=== %@\",index,NSThread.currentThread); }); }); } /* 部分关键打印数据 11:05:46 开始执行task511 === {number = 511, name = (null)} 11:05:46 开始执行task483 === {number = 512, name = (null)} 11:05:46 开始执行task512 === {number = 513, name = (null)} 11:05:46 开始执行task507 === {number = 514, name = (null)} */ 我们利用 dispatch_apply() 函数并发迭代了1000次，创建了 1000 条串行队列，每条串行队列都要执行一个耗时任务。理论上来说，系统需要创建 1000 条线程来处理这 1000 个串行队列中的任务，但是实际又如何呢？ 从打印数据可以看到：XNU 内核 极尽所能 的开辟了 500 多条线程来处理 1000个耗时任务！这500多条处理任务的线程，对于系统是一个不小的负担。 并发队列的性能消耗 - (void)dispatch_concurrent_morequeue_Method{ dispatch_apply(1000, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) { dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@\"开始执行task%zu === %@\",index,NSThread.currentThread); [NSThread sleepForTimeInterval:13];//模拟耗时任务 NSLog(@\"结束执行task%zu=== %@\",index,NSThread.currentThread); }); }); } /* 部分关键打印数据 11:08:42 开始执行task60 === {number = 63, name = (null)} 11:08:42 开始执行task61 === {number = 62, name = (null)} 11:08:42 开始执行task62 === {number = 64, name = (null)} 11:08:42 开始执行task64 === {number = 65, name = (null)} 11:08:42 开始执行task63 === {number = 66, name = (null)} */ 从打印数据可以看到：针对并发队列，XNU 内核仅仅开辟 60 多条线程来处理 1000个耗时任务，相对于比起串行队列的500多条线程，其对系统性能的消耗要远远优于串行队列。 3、什么是任务？ 任务也称为作业的逻辑单元，可以由进程或者线程完成，在 GCD 中是在 dispatch_block 或者 dispatch_function 中执行的； typedef void (^dispatch_block_t)(void); typedef void (*dispatch_function_t)(void *_Nullable); 3.1、任务封装在 dispatch_function中执行 我们在这里仅展示使用dispatch_async_f ()函数执行任务dispatch_function： /* @param queue 添加任务到指定的分派队列，不能为空 * @param context 传递一个任意类型的参数至dispatch_function_t work * 此处 void * 为C语言的不确定类型，类似于Objective-C 中的 id 类型。 * @param dispatch_function_t work 是一个函数指针，指向应用程序定义的函数; * 在这个函数中处理耗时操作，如读写数据、下载文件等； * typedef void (*dispatch_function_t)(void *_Nullable); */ void dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); 简单使用： //在函数指针指向的函数里处理耗时任务 void dispatch_async_function_test(void *_Nullable context){ id object = (__bridge id)context; NSLog(@\"开始处理 ： %@ == %@\",object,NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束处理 ： %@ == %@\",object,NSThread.currentThread); } - (void)dispatch_async_Method{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_SERIAL); dispatch_async_f(queue, @\"这是一个任意类型的参数\", dispatch_async_function_test); } /* 打印数据 * 09:48:25 开始处理 ： 这是一个任意类型的参数 == * 09:48:28 结束处理 ： 这是一个任意类型的参数 == */ 打印表明，dispatch_async_f() 函数将函数指针dispatch_function_t work指向的函数交给分派队里 queue 处理，将第二个参数void *_Nullable context传递给函数指针指向的函数。 3.2、任务封装在dispatch_block中执行 GCD 为 dispatch_block 提供多个函数： /* 创建一个 dispatch_block * @param flags DISPATCH_BLOCK_DETACHED * @param block 封装任务 * @return 返回 dispatch_block_t 或者 NULL */ dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block); /* 执行一个分派块 * @param flags DISPATCH_BLOCK_DETACHED * @param block 封装的分派块 * @note 因为不是在 dispatch_queue 中执行，所以堵塞线程 */ void dispatch_block_perform(dispatch_block_flags_t flags,DISPATCH_NOESCAPE dispatch_block_t block); /* 堵塞当前线程，直到等待的 dispatch_block 完成或者等到指定的截止时间，线程才会接着向下执行； * @param block 等待执行完毕的任务块 * @param timeout 等待的截止时间 * @return 截止时间内完成返回 0，否则返回一个非 0 值 */ long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout); /* 当 dispatch_block 执行完成时， dispatch_queue 调用 notification_block * @param block 被监听的任务块 * @param queue 分派队列 * @param notification_block 任务执行完毕时，需要进行的操作； * 类似 NSOperation.completionBlock * @note 不会堵塞当前线程 */ void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block); /* 取消尚未执行的 dispatch_block，但不影响已经在执行的 dispatch_block * 类似于 [NSThread cancel] 或者 [NSOperation cancel] */ void dispatch_block_cancel(dispatch_block_t block); 关于dispatch_block_flags_t 简单使用 - (void)dispatch_block_Method{ //创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); //创建一个任务 dispatch_block_t taskA = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^{ NSLog(@\"开始执行taskA === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行taskA === %@\",NSThread.currentThread); }); dispatch_block_t taskB = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^{ NSLog(@\"开始执行taskB === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行taskB === %@\",NSThread.currentThread); }); dispatch_block_t taskC = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^{ NSLog(@\"开始执行taskC === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行taskC === %@\",NSThread.currentThread); }); dispatch_async(queue, taskA); NSLog(@\"执行 dispatch_block_wait() \"); //阻塞线程，等待任务A 完成，截止时间 6 秒 long value = dispatch_block_wait(taskA, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC))); NSLog(@\"dispatch_block_wait === %ld\",value); if (value == 0){ NSLog(@\"执行成功\"); dispatch_block_cancel(taskB); }else{ NSLog(@\"执行超时\"); dispatch_async(queue, taskC); } dispatch_async(queue, taskB); } /* 打印数据 15:18:11 -------- 开始处理 -------- 15:18:11 执行 dispatch_block_wait() 15:18:11 开始执行taskA === {number = 6, name = (null)} 15:18:14 结束执行taskA === {number = 6, name = (null)} 15:18:14 dispatch_block_wait === 0 15:18:14 执行成功 15:18:14 -------- 结束处理 -------- */ 观察上述打印： dispatch_block_wait() 函数会堵塞当前线程的执行，直到等待的调度块完成，线程才会接着向下执行； dispatch_block_cancel() 函数取消了taskB ,所以taskB不再执行。 不论 dispatch_block_t 或者 NSOperation ，取消的任务都不会再被执行 3.3、任务的执行：同步执行与异步执行 执行任务有两种方式：同步执行dispatch_sync()和异步执行dispatch_async(): /* @param queue 提交任务块的队列，系统将保留该队列，直到块运行完成为止；不能为空。 * @param block 提交给 queue 的块，参数不能为空； * 下述函数代表调用者执行 Block_copy() 和 Block_release() */ //同步执行 void dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block); void dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); void dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block); void dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); //异步执行 void dispatch_async(dispatch_queue_t queue, dispatch_block_t block); void dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); void dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); 主要区别：是否阻塞当前线程，以及是否具备开辟新线程的能力。 同步执行 异步执行 同步添加任务到指定的队列中 异步添加任务到指定队列 在添加的任务执行结束之前，会阻塞当前线程，直到队列中的任务完成之后再继续执行 它不会阻塞当前的线程，可以继续执行任务 只能在当前线程中执行任务，不具备开启新线程的能力 可以在新的线程中执行任务，具备开启新线程的能力 注意：异步执行虽然可以开辟新线程，但是并不一定开启新线程，这跟任务所指定的队列类型有关。 思考 : dispatch_async() 函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？ dispatch_sync() 函数如何实现，为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？ 4、队列 + 任务 我们在上文介绍了分派队列dispatch_queue：串行队列、并发队列、主队列；又介绍了任务块dispatch_block_t 或者任务函数 dispatch_function_t 可以同步执行也可以异步执行。那么将任务追加到队列里都有哪几种分类呢？它们如何处理？需要注意的问题有哪些呢？ 我们不妨来一一探究下： 4.1、异步执行 + 并发队列 - (void)asyncTask_cocurrentQueue_Method{ //创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task0\", DISPATCH_QUEUE_CONCURRENT); //将一个耗时任务A（异步）添加到并发队列 queue 里处理 dispatch_async(queue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); //追加一个耗时任务B（异步）添加到 并发队列 queue 里处理 dispatch_async(queue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } /* 打印数据 10:49:28 -------- 开始处理 -------- 10:49:28 ------- 此处为taskA与taskB分界线 ------- 10:49:28 开始执行：taskA ======= {number = 3, name = (null)} 10:49:28 -------- 结束处理 -------- 10:49:28 开始执行：taskB ======= {number = 4, name = (null)} 10:49:31 结束执行：taskA ------- {number = 3, name = (null)} 10:49:31 结束执行：taskB ------- {number = 4, name = (null)} */ 观察打印数据： 程序的执行并没有按顺序执行，开始处理 与结束处理同时被打印，taskA与 taskB 同时执行，taskB 并没有等待 taskA 执行完毕再去执行。这说明：dispatch_async()异步添加任务到指定的队列中，它不会阻塞当前的线程，可以继续执行任务； 代码的执行在不同的线程中。也就是说：dispatch_sync()可以在新的线程中执行任务，具备开启多条新线程的能力； 4.2、异步执行 + 串行队列 - (void)asyncTask_serialQueue_Method{ //创建一个串行队列 dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task1\", DISPATCH_QUEUE_SERIAL); //将一个耗时任务A（异步）添加到串行队列 queue 里处理 dispatch_async(queue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); //追加一个耗时任务B（异步）添加到 串行队列 queue 里处理 dispatch_async(queue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } /* 打印数据 10:24:25 -------- 开始处理 -------- 10:24:25 ------- 此处为taskA与taskB分界线 ------- 10:24:25 开始执行：taskA ======= {number = 3, name = (null)} 10:24:25 -------- 结束处理 -------- 10:24:28 结束执行：taskA ------- {number = 3, name = (null)} 10:24:28 开始执行：taskB ======= {number = 3, name = (null)} 10:24:31 结束执行：taskB ------- {number = 3, name = (null)} */ 观察打印数据： 程序的执行并没有按顺序执行，开始处理 与 结束处理 同时被打印，这说明：dispatch_async()异步添加任务到指定的队列中，它不会阻塞当前的线程，可以继续执行任务； taskB 等待taskA执行完毕再去执行，taskA与taskB处理任务的线程是同一线程。这说明：异步执行具备开启新线程的能力；但是串行队列只开启一个线程，串行队列中的多个任务，每次只有一个任务被执行，任务一个接一个按顺序执行。 4.3、异步执行 + 主队列 - (void)asyncTask_mainQueue_Method{ //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //将一个耗时任务A（异步）添加到串行队列 queue 里处理 dispatch_async(mainQueue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); //追加一个耗时任务B（异步）添加到 串行队列 queue 里处理 dispatch_async(mainQueue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } /* 打印数据 10:36:51 -------- 开始处理 -------- 10:36:51 ------- 此处为taskA与taskB分界线 ------- 10:36:51 -------- 结束处理 -------- 10:36:51 开始执行：taskA ======= {number = 1, name = main} 10:36:54 结束执行：taskA ------- {number = 1, name = main} 10:36:54 开始执行：taskB ======= {number = 1, name = main} 10:36:57 结束执行：taskB ------- {number = 1, name = main} */ 观察打印数据： 程序的执行并没有按顺序执行，开始处理与结束处理同时被打印，这说明：dispatch_async()异步添加任务到指定的队列中，它不会阻塞当前的线程，可以继续执行任务； taskB等待taskA执行完毕再去执行，taskA与taskB处理任务的线程是同一线程，这再次说明了主队列就是串行队列的本质；串行队列中的多个任务，每次只有一个任务被执行，任务一个接一个按顺序执行。 4.4、同步执行 + 并发队列 - (void)syncTask_cocurrentQueue_Method{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task4\", DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); dispatch_sync(queue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } /* 打印数据 10:58:46 -------- 开始处理 -------- 10:58:46 开始执行：taskA ======= {number = 1, name = main} 10:58:49 结束执行：taskA ------- {number = 1, name = main} 10:58:49 ------- 此处为taskA与taskB分界线 ------- 10:58:49 开始执行：taskB ======= {number = 1, name = main} 10:58:52 结束执行：taskB ------- {number = 1, name = main} 10:58:52 -------- 结束处理 -------- */ 观察打印数据： 程序的执行按顺序执行，只有前面的代码执行完毕，后面的代码才会接着执行。也就是说：dispatch_sync() 同步添加任务到指定的队列中，在添加的任务执行结束之前，会阻塞当前线程，直到队列里面的任务完成之后再继续执行； 代码的执行都在主线程，也就是说：dispatch_sync()只能在当前线程（上下文所处线程）中执行任务，不具备开启新线程的能力； taskB等待 taskA 执行完毕再去执行，这说明并发队列实际上并没有并发执行。因为 dispatch_sync()不具备开启新线程的能力，也就不存在并发； 4.5、同步执行 + 串行队列 - (void)syncTask_serialQueue_Method{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task5\", DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); dispatch_sync(queue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } /* 打印数据 11:10:47 -------- 开始处理 -------- 11:10:47 开始执行：taskA ======= {number = 1, name = main} 11:10:50 结束执行：taskA ------- {number = 1, name = main} 11:10:50 ------- 此处为taskA与taskB分界线 ------- 11:10:50 开始执行：taskB ======= {number = 1, name = main} 11:10:53 结束执行：taskB ------- {number = 1, name = main} 11:10:53 -------- 结束处理 -------- */ 观察打印数据： 程序的执行按顺序执行，只有前面的代码执行完毕，后面的代码才会接着执行。也就是说：dispatch_sync()同步添加任务到指定的队列中，在添加的任务执行结束之前，会阻塞当前线程，直到队列里面的任务完成之后再继续执行； 通过对当前线程的观察，可以了解到代码的执行都在主线程，也就是说：dispatch_sync()只能在当前线程（上下文所处线程）中执行任务，不具备开启新线程的能力； 4.6、同步执行 + 主队列 队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。读取任务完毕，则从队列中移除该任务 - (void)syncTask_mainQueue_Method{ dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_sync(mainQueue, ^{ NSLog(@\"开始执行：taskA ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskA ------- %@\",NSThread.currentThread); }); NSLog(@\"------- 此处为taskA与taskB分界线 -------\"); dispatch_sync(mainQueue, ^{ NSLog(@\"开始执行：taskB ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：taskB ------- %@\",NSThread.currentThread); }); } 运行程序可以看到：在 Xcode 9 上线程死锁：Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0) 在上面截图中，出错栈中的dispatch_sync_wait()这个函数在wait什么？为什么会陷入wait无法离开？我们来分析上述代码： 我们使用dispatch_sync()函数向主队列mainQueue中同步添加了一个耗时任务； 因为主队列 mainQueue 是一个串行队列，每次只有一个任务被执行，一个任务执行完毕后，再执行下一个任务。 任务 taskA 被函数 dispatch_sync() 添加至在队列mainQueue的末尾，taskA 只有在队列 mainQueue 前面的任务执行完毕才会执行；因为队列是一种特殊的线性表，采用 FIFO 原则。 dispatch_sync()函数会阻塞当前线程的执行，直到队列mainQueue 里面的任务完成之后再继续向下执行； 这时问题来了，主队列 mainQueue 被 taskA 堵塞，只有 taskA处理完毕才会执行后面的代码；taskA 被添加至队列 mainQueue的末尾，只有 mainQueue的任务处理完才会处理 taskA；这不就两方在互相等待 dispatch_sync_wait()嘛？这也就造成了GCD死锁！ 4.7、执行队列任务的小结 区别 并发队列 串行队列 主队列 异步执行（异步添加任务到指定队列，不会堵塞当前线程） 可以开辟多条新线程；并发执行多个任务 只开辟一条新线程；在新开辟的线程中串行执行多个任务 没有开辟新线程； 在当前线程中串行执行多个任务 同步执行（同步添加任务到指定队列，堵塞当前线程，不能开辟新线程） 在当前线程中串行执行多个任务 在当前线程中串行执行多个任务 GCD死锁 5、信号量dispatch_semaphore dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式。但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）；而 dispatch_semaphore 能保存发送的信号。 /* 创建一个信号量 * @param value 如果 0 ，则该函数不执行任何操作，返回 0 * 如果 value=0，当前线程会和 NSCondition 一样休眠，等待其它线程发送信号唤醒此线程去执行后续任务 * @param timeout 截止时间；此时即使 value 值不大于 0 ，也会接着向下执行， * DISPATCH_TIME_NOW 立即发生的时间，表示忽略信号量，直接运行 * DISPATCH_TIME_FOREVER表示无穷大的时间，表示会一直等待信号量为正数，才会继续运行 * @return 如果该信号量的 value>0 ，则不执行任何操作，直接返回 0, * 如果 value=0，在截止时间之内收到信号，则唤醒该线程，并返回 0 ； * 超过截止时间，唤醒该线程并返回非 0 值， */ long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); /* 发送一个信号 * @param dsema 指定的信号量，如果该信号量的 value>0 ，则该函数不执行任何操作，返回 0 * 如果 value=0，则 value++，发送信号，唤醒休眠中的线程，返回 0 */ long dispatch_semaphore_signal(dispatch_semaphore_t dsema); 例子： NSOperationQueue 可以控制任务的最大并发数量，利用dispatch_semaphore_t 同样可以控制 dispatch_queue中任务的最大并发数量。 - (void)dispatch_semaphoreMethod{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.maxCONCURRENT\", DISPATCH_QUEUE_CONCURRENT); dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);//此处 2 表示线程并发数 dispatch_async(queue, ^{ for (int i = 0; i {number = 3, name = (null)} 20:24:14 开始执行 task0 == single : 0----- {number = 4, name = (null)} 20:24:16 结束执行 task0 == single : 1----- {number = 4, name = (null)} 20:24:16 开始执行 task2 == single : 0----- {number = 5, name = (null)} 20:24:17 结束执行 task1 == single : 1----- {number = 3, name = (null)} 20:24:17 开始执行 task3 == single : 0----- {number = 4, name = (null)} 20:24:18 开始执行 task4 == single : 0----- {number = 3, name = (null)} 20:24:18 结束执行 task2 == single : 1----- {number = 5, name = (null)} 20:24:20 开始执行 task5 == single : 0----- {number = 5, name = (null)} 20:24:20 结束执行 task4 == single : 1----- {number = 3, name = (null)} 20:24:20 结束执行 task3 == single : 0----- {number = 4, name = (null)} 20:24:23 结束执行 task5 == single : 0----- {number = 5, name = (null)} */ 打印数据表明：同时执行任务的线程有两条。 因为dispatch_semaphore_create() 创建的 dispatch_semaphore_t ，初值为 2 。 在将任务添加至 dispatch_queue 之前执行 dispatch_semaphore_wait() 函数，减少一个信号；在任务执行结束之后，调用 dispatch_semaphore_signal() 函数，增加一个信号。 当执行 task1 时，dispatch_semaphore 信号已经减少为0；此时 dispatch_semaphore_wait() 方法无法再减少信号继续执行，只能堵塞当前线程，导致 task2 无法开始； 开始处理 2s 之后 task0 执行完毕，调用 dispatch_semaphore_signal() 函数增加一个信号，此时执行 wait 的临界区唤醒线程执行后续代码，开始执行task2,dispatch_semaphore 信号再次减为0； 开始处理3s 之后 task1 执行完毕，调用 dispatch_semaphore_signal()函数增加一个信号，此时执行 wait 的临界区唤醒线程执行后续代码，开始执行task3，dispatch_semaphore信号再次减为0； 后续的任务以此类推 ... 直至所有任务执行完毕。 由此可知：dispatch_semaphore_wait()与dispatch_semaphore_signal() 互相对应； 看起来像 NSLock 的-lock 和 -unlock，区别在于有信号量这个参数，-lock、-unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 value，则可以有value 个线程同时访问被保护的临界区。 6、栅栏dispatch_barrier GCD 提供了在 dispatch_queue 中设置同步点的 API ，但是对于下述情况，设置同步点是毫无意义的： 对于串行队列，不论同步执行或者异步执行，都只会在一条线程 按顺序处理多个任务； 对于同步执行并发队列，会堵塞当前线程，不能开辟新线程；在当前线程下按顺序处理队列的任务; 获取的 全局并发队列，API 不会设置同步点 。 /* 设置 barrier：就好比在一条直线上添加了一个间隔点 * 针对队列 queue 的任务，系统会先执行 barrier 之前所有的任务； * 执行完毕之后，执行 barrier 点的 代码块 * barrier 点的代码块执行完毕，执行 barrier 点之后的任务 * 设置 barrier 的两种方式： * 同步设置 barrier： 会堵塞当前线程；barrier 代码块在当前线程执行； * 异步设置 barrier：不会堵塞当前线程；barrier 代码块开辟新线程执行； * @param queue 设置 barrier 的队列 * @param block barrier 点需要执行的代码 */ //同步设置 barrier void dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block); void dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); //异步设置 barrier void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); void dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); 6.1、同步栅栏 + 异步执行 - (void)dispatch_barrierSync_async_Method{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@\"开始执行taskA === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:1];//模拟耗时任务 NSLog(@\"结束执行taskA === %@\",NSThread.currentThread); }); dispatch_async(queue, ^{ NSLog(@\"开始执行taskB === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行taskB === %@\",NSThread.currentThread); }); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), queue, ^{ NSLog(@\"开始执行taskC === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行taskC === %@\",NSThread.currentThread); }); NSLog(@\"开始栅栏\"); dispatch_barrier_sync(queue, ^{ NSLog(@\"开始执行taskD === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行taskD === %@\",NSThread.currentThread); }); NSLog(@\"结束栅栏\"); dispatch_async(queue, ^{ NSLog(@\"开始执行taskE === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:4];//模拟耗时任务 NSLog(@\"结束执行taskE === %@\",NSThread.currentThread); }); } /* 打印数据 10:01:07 -------- 开始处理 -------- 10:01:07 开始栅栏 10:01:07 开始执行taskB === {number = 5, name = (null)} 10:01:07 开始执行taskA === {number = 4, name = (null)} 10:01:08 结束执行taskA === {number = 4, name = (null)} 10:01:10 结束执行taskB === {number = 5, name = (null)} 10:01:10 开始执行taskD === {number = 1, name = main} 10:01:12 结束执行taskD === {number = 1, name = main} 10:01:12 结束栅栏 10:01:12 -------- 结束处理 -------- 10:01:12 开始执行taskE === {number = 5, name = (null)} 10:01:13 开始执行taskC === {number = 6, name = (null)} 10:01:15 结束执行taskC === {number = 6, name = (null)} 10:01:16 结束执行taskE === {number = 5, name = (null)} */ 使用dispatch_async() 函数向并发队列添加 3 个耗时任务taskA、taskB、taskE异步执行；taskC 延迟执行；taskD使用dispatch_barrier_sync()函数同步执行。 观察打印数据： 由于 dispatch_async()函数异步执行任务，会开辟新的线程，不会堵塞当前线程；所以taskA、taskB同时开始执行，dispatch_after() 与开始栅栏处代码也同时执行； taskA、taskB 都执行完毕之后才执行开始执行taskD；taskD执行完毕之后，才会接着执行taskE；也就是说：dispatch_barrier_sync()函数会堵塞当前线程，直到目标队列中在它前面的的任务执行完毕，才会接着执行它的任务；它的任务执行完毕，代码才会接着向下执行； dispatch_barrier_sync() 函数与dispatch_sync() 函数类似，执行代码块的线程都是当前线程（上下文所处的线程），并没有开辟新的线程； 6.2、异步栅栏 + 异步执行 - (void)dispatch_barrierAsync_async_Method{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@\"开始执行taskA === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:1];//模拟耗时任务 NSLog(@\"结束执行taskA === %@\",NSThread.currentThread); }); dispatch_async(queue, ^{ NSLog(@\"开始执行taskB === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行taskB === %@\",NSThread.currentThread); }); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6 * NSEC_PER_SEC)), queue, ^{ NSLog(@\"开始执行taskC === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行taskC === %@\",NSThread.currentThread); }); NSLog(@\"开始栅栏\"); dispatch_barrier_async(queue, ^{ NSLog(@\"开始执行taskD === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"结束执行taskD === %@\",NSThread.currentThread); }); NSLog(@\"结束栅栏\"); dispatch_async(queue, ^{ NSLog(@\"开始执行taskE === %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:4];//模拟耗时任务 NSLog(@\"结束执行taskE === %@\",NSThread.currentThread); }); } /* 打印数据 10:38:49 -------- 开始处理 -------- 10:38:49 开始栅栏 10:38:49 开始执行taskA === {number = 4, name = (null)} 10:38:49 开始执行taskB === {number = 5, name = (null)} 10:38:49 结束栅栏 10:38:49 -------- 结束处理 -------- 10:38:50 结束执行taskA === {number = 4, name = (null)} 10:38:52 结束执行taskB === {number = 5, name = (null)} 10:38:52 开始执行taskD === {number = 5, name = (null)} 10:38:54 结束执行taskD === {number = 5, name = (null)} 10:38:54 开始执行taskE === {number = 5, name = (null)} 10:38:55 开始执行taskC === {number = 4, name = (null)} 10:38:57 结束执行taskC === {number = 4, name = (null)} 10:38:58 结束执行taskE === {number = 5, name = (null)} */ 观察打印数据： 由于 dispatch_async() 函数异步执行任务，会开辟新的线程，不会堵塞当前线程；所以taskA、taskB 同时执行，dispatch_after()与开始栅栏处代码也同时执行； 开始栅栏 与 结束栅栏 同时执行，也就是说：dispatch_barrier_async() 函数不会堵塞当前线程； taskA、taskB 都执行完毕之后才执行开始执行taskD；taskD执行完毕之后，才会接着执行taskE；也就是说：dispatch_barrier_async() 函数会堵塞它的目标队列中的任务执行。首先执行队列前面的任务，接着执行它的任务；它的任务执行完毕，代码才会接着向下执行； dispatch_barrier_async() 函数与 dispatch_async() 函数类似，开辟新的线程执行代码块； 思考： 我们通过对 taskC 的执行时机可以看到，dispatch_barrier_sync() 函数或者 dispatch_barrier_async() 函数对位于它前面的代码taskC 并没有堵塞到，想一想这是为什么？开篇时我们说dispatch_barrier() 可以在队列中创建同步点，那么这个同步点位于何处？如何实现的同步点？ 7、任务组dispatch_group 在我们日常开发中，经常会出现这样的需求：需要在追加到dispatch_queue中的多个任务执行完毕之后，去处理某件事情。比如：下载一个大的文件，分块下载，全部下载完成后再合成一个文件；再比如：同时下载多个图片，监听全部下载完后的动作等等很多场景。 如果使用串行队列，将想执行的处理追加到该串行队列中并在最后追加结束处理即可；但在使用并发队列时，源代码就会变得很复杂。可以使用 dispatch_barrier 在dispatch_queue 中设置同步点，在同步点来善后。 GCD 为我们提供了解决方案 dispatch_group 。那么什么是dispatch_group？怎么使用 dispatch_group？dispatch_group是怎么实现的？ 我们先来看一下官方提供的dispatch_groupAPI： dispatch_group_t dispatch_group_create(void); void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); /* 监听当前 group 中任务全部处理完毕，发送通知 * 不会堵塞当前线程 */ void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); /* 堵塞当前线程，直到 group 中的任务执行完毕，当前线程才会接着向下执行； */ long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); /* enter() 、 leave() 与 dispatch_async() 组合使用，效果等同于 dispatch_group_async() 函数 * 用法与 dispatch_semaphore 类似 */ void dispatch_group_enter(dispatch_group_t group); void dispatch_group_leave(dispatch_group_t group); 7.1、dispatch_group_create () 创建的是什么东西？ 在 GCD源码 可以看到dispatch_group_create () 的内部实现 dispatch_group_t dispatch_group_create(void){ return (dispatch_group_t)dispatch_semaphore_create(LONG_MAX); } dispatch_group_t 本质是一个值为 LONG_MAX 的信号量dispatch_semaphore_t。 7.2、dispatch_group 处理任务 a、 使用dispatch_group_async() 函数 /* @param group 任务组 * @param queue 分派队列 * @param block 处理的任务 */ void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 例子: - (void)dispatchGroupMethod{ dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); dispatch_apply(3, queue, ^(size_t index) { dispatch_group_async(group, queue, ^{ NSLog(@\"开始执行：task%zu ======= %@\",index,NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：task%zu ------- %@\",index,NSThread.currentThread); }); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\"****** 所有任务结束 ****** %@\",NSThread.currentThread); }); dispatch_group_async(group, queue, ^{ NSLog(@\"开始执行：task3 ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：task3 ------- %@\",NSThread.currentThread); }); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"将要执行：task4 ======= %@\",NSThread.currentThread); dispatch_group_async(group, queue, ^{ NSLog(@\"开始执行：task4 ======= %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行：task4 ------- %@\",NSThread.currentThread); }); }); } /* 打印数据 20:58:21 -------- 开始处理 -------- 20:58:21 -------- 结束处理 -------- 20:58:21 开始执行：task3 ======= {number = 6, name = (null)} 20:58:21 开始执行：task2 ======= {number = 5, name = (null)} 20:58:21 开始执行：task1 ======= {number = 4, name = (null)} 20:58:21 开始执行：task0 ======= {number = 3, name = (null)} 20:58:24 结束执行：task2 ------- {number = 5, name = (null)} 20:58:24 结束执行：task3 ------- {number = 6, name = (null)} 20:58:24 结束执行：task1 ------- {number = 4, name = (null)} 20:58:24 结束执行：task0 ------- {number = 3, name = (null)} 20:58:24 ****** 所有任务结束 ****** {number = 1, name = main} 20:58:31 将要执行：task4 ======= {number = 1, name = main} 20:58:31 开始执行：task4 ======= {number = 7, name = (null)} 20:58:34 结束执行：task4 ------- {number = 7, name = (null)} */ 在上述程序中，向并发队列添加 5 个耗时任务异步执行；其中task4在 10s 之后才添加至并发队列 dispatch_queue 中；使用dispatch_group_notify() 函数监听dispatch_group 任务完成时的回调。 观察打印数据： 开始处理\\结束处理同时打印，说明 dispatch_group_async()函数异步执行，不会堵塞当前线程； task0、task1、task2、task3 同时开始执行；dispatch_group_notify()函数监听到这四个任务都执行完毕后，触发该函数的第三个参数 dispatch_block 中的代码在第二个参数dispatch_queue中执行 task4 在开始处理 10s 后才开始执行，这个任务并没有被dispatch_group_notify() 函数监听到！ b、使用dispatch_group_enter()与dispatch_group_leave() 函数处理任务 dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_SERIAL); dispatch_group_t group = dispatch_group_create(); dispatch_group_enter(group);//标志着一个任务追加到 group dispatch_async(queue, ^{ [NSThread sleepForTimeInterval:3]; dispatch_group_leave(group);//标志着一个任务离开了 group }); 使用上述两种方法处理任务，效果完全一样。 8、其他 API 8.1、 dispatch_time_t /* @param when 表示从什么时间开始; DISPATCH_TIME_NOW 表示从现在开始 * @param delta 表示具体的时间长度，单位是纳秒； * 不能直接传 int 或 float, 需要写成 (int64_t)3 * NSEC_PER_SEC。 */ dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta); 普及一下关键字: 缩写 全拼 汉译 MSEC millisecond 毫秒 NSEC nanoseconds 纳秒 USEC microsecond 微秒 SEC second 秒 PER prep 每一 关于一些时间的宏： 宏 值 含义 NSEC_PER_SEC 1000000000ull 每秒有10亿纳秒 NSEC_PER_MSEC 1000000ull 每毫秒有100万纳秒 USEC_PER_SEC 1000000ull 每秒有100万微秒 NSEC_PER_USEC 1000ull 每微秒有1000纳秒 //从当前时间开始，10秒之后 dispatch_time_t tim1 = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10.0 * NSEC_PER_SEC)); //从当前时间开始，10毫秒之后 dispatch_time_t time2 = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10.0 * NSEC_PER_MSEC)); //从当前时间开始，10微秒之后 dispatch_time_t time3 = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10.0 * NSEC_PER_USEC)); 8.2、延迟执行dispatch_after() /* 在指定的时间执行任务；不会堵塞当前线程的执行 * @param when 将任务添加到队列中的时间（不是在指定时间之后开始处理任务） * 这个时间并不精准，只是大致延迟 * @param queue 处理任务的队列，不能为空 * @param block 要处理的任务，不能为空 */ void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work); 8.3、快速迭代：dispatch_apply() dispatch_apply() 函数是 dispatch_sync()函数和dispatch_group 关联的API。该函数按指定的次数将指定的任务追加到指定的 dispatch_queue 中，并等待全部处理结束。 /* 快速迭代，类似 for 循环 * @param iterations 执行的迭代次数 * @param queue 处理任务的队列，不能为空 * @param void (^block)(size_t) 当前处理的任务，size_t 是当前索引 * @note 可以利用并发队列，同时开辟多个线程处理多个任务 * 同步执行任务，等待队列的全部任务执行结束，才会接着向下执行； */ void dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t)); void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *_Nullable context, void (*work)(void *_Nullable, size_t)); 注意：由于 dispatch_apply() 是同步执行，所以目标队列不能是主队列，否则会造成线程死锁。 8.4、dispatch_once_t /* GCD 提供 dispatch_once_t 保证在应用程序执行中只执行一次; * 常用于创建单例 * @note 堵塞当前线程，直到 block 执行完毕 * @note 如果在一个线程调用 dispatch_once() 函数时，另外的线程调用此处代码， * 则调用线程等待，不往下执行，直到首次调用的线程返回。 */ typedef intptr_t dispatch_once_t; void dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block); 资源帮助： 示例demo 苹果官方文档 GCD源码 参考文章： 深入理解GCD iOS多线程：『GCD』详尽总结 iOS调度队列 GCD 之任务操作 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/OC之锁.html":{"url":"iOS开发/杂记/OC之锁.html","title":"锁","keywords":"","body":"OC之锁 前言：多线程下的 数据竞争 问题 使用并发编程以更高效率处理任务的同时，也带来了一些问题：如对共享内存的读写操作。程序中多个线程的执行顺序是不确定的，不同的执行顺序执行同一段代码得到不同的结果，这会导致并发程序中的bug难以检测和修复。 例子：多次执行该段代码，得到的打印数据可能不同，最终结果也不符合预计！ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); __block int length = 0; dispatch_apply(6, queue, ^(size_t index) { dispatch_async(queue, ^{ NSLog(@\"length === %d -- %@\",++length,NSThread.currentThread); [NSThread sleepForTimeInterval:2];//模拟耗时任务 NSLog(@\"length --- %d == %@\",--length,NSThread.currentThread); }); }); 多条线程同时访问一个变量，至少一条线程修改该变量，这种情况就叫竞态 。开启 Xcode 线程竞态检测工具 Thread Sanitizer 可以检测出这类问题： iOS 使用同步机制解决多线程下的竞态，如 锁 或者 条件。条件：使线程处于休眠状态，满足条件唤醒休眠的线程，条件变量通常用锁来实现。锁实行互斥策略，避免共享数据被多个线程同时访问；使用不当可能引发死锁、活锁、资源匮乏等问题，导致程序中断： 死锁：多个线程互相阻塞，每个线程都等待其他线程释放锁，导致所有线程都处于等待状态。如 GCD 的 dispatch_sync() 函数使用不当，容易造成队列的循环等待。 活锁：任务或者线程没有被阻塞，由于某些条件没有满足，导致一直重复尝试、失败，尝试、失败…如 NSConditionLock 的条件无法得到满足。 资源匮乏：一些线程占用共享资源的时间过长，导致其它线程无法正常访问该资源。活锁也是资源匮乏的一种形式。 1、互斥锁 互斥锁通过将代码切片成一个个临界区，防止多条线程同时对某个资源进行读写。 1.1、@synchronized 锁 @synchronized 发挥了和锁一样的作用：它避免了多个线程同时执行同一段代码。对比NSLock创建锁、加锁、解锁，在某些情况下@synchronized 会更方便、更易读。 - (void)synchronizedMethod{ dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@\"taskA_1 --- %@\",NSThread.currentThread); NSLog(@\"taskA_2 === %@\",[self getTheString]); NSLog(@\"taskA_3 --- %@\",NSThread.currentThread); }); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@\"taskB_1 --- %@\",NSThread.currentThread); NSLog(@\"taskB_2 === %@\",[self getTheString]); NSLog(@\"taskB_3 --- %@\",NSThread.currentThread); }); } - (NSString *)getTheString{ @synchronized (self){ NSLog(@\"currentThread == %@\",NSThread.currentThread); [NSThread sleepForTimeInterval:2]; return @\"*****************************\"; } } /* 打印数据： 10:23:26 taskB_1 --- {number = 5, name = (null)} 10:23:26 taskA_1 --- {number = 4, name = (null)} 10:23:26 currentThread == {number = 4, name = (null)} 10:23:28 taskA_2 === ***************************** 10:23:28 currentThread == {number = 5, name = (null)} 10:23:28 taskA_3 --- {number = 4, name = (null)} 10:23:30 taskB_2 === ***************************** 10:23:30 taskB_3 --- {number = 5, name = (null)} */ 1.2、NSLock 锁 Cocoa 的 NSLock 是最基本的锁，使用 POSIX 线程实现其功能。 //锁的通用协议 @protocol NSLocking /* 加锁操作，此时如果已经在其它线程上锁，则此操作会堵塞当前线程，等待其它线程解锁； * 如果没有在其它线程上锁，则立即上锁，并向下执行。 * @note 死锁：同一条线程，如果多次上同一把锁，会堵塞线程导致无法解锁，造成线程死锁。 * 除非使用递归锁：NSRecursiveLock */ - (void)lock; /* 解锁操作 */ - (void)unlock; @end //NSLock在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK。 @interface NSLock : NSObject /* 试图加锁，不会阻塞线程；无论能否加锁，都立即执行后续代码 * @return 加锁成功返回 YES； * NSLock 对象在其它线程被锁定，该操作失败，则返回 NO */ - (BOOL)tryLock; /* 堵塞当前线程，在截止时间内一直尝试上锁 * @param limit 截止时间 * @return 在截止时间内成功加锁，返回 YES * 到截止时间，依旧被其它线程锁定，返回 NO */ - (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name; @end 1.3、pthread_mutex_t pthread_mutex_t 是为Unix/Linux 平台提供的一套锁：除了实现互斥锁，还可以创建递归锁、读写锁、条件锁等。 /* 类似于 NSLocking 的 -lock 方法 * 加锁操作，此时如果 pthread_mutex_t 已经上锁，则堵塞当前线程，等待解锁， * 如果 pthread_mutex_t 没有上锁，则立即上锁，并向下执行 */ int pthread_mutex_lock(pthread_mutex_t *); /* 类似于 NSLock 的 -tryLock 方法 * 试图加锁，不会阻塞线程；无论能否加锁，都立即执行后续代码 * @return 如果 pthread_mutex_t 被其它线程上锁，或者已经被释放，加锁失败，返回非 0 值： * 加锁成功返回 0 */ int pthread_mutex_trylock(pthread_mutex_t *); /* 解锁 */ int pthread_mutex_unlock(pthread_mutex_t *); /* 释放锁 * @note pthread_mutex 由 C 函数创建，编译器不负责释放，需要程序员在合适的时机释放 */ int pthread_mutex_destroy(pthread_mutex_t *); 例子：引入头文件#include，利用pthread_mutex_t实现一个互斥锁： - (void)pthread_mutex_LockMethod{ dispatch_group_t group = dispatch_group_create(); //静态创建一个互斥锁 __block pthread_mutex_t pthreadLock = PTHREAD_MUTEX_INITIALIZER; __block int length = 0; dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ pthread_mutex_lock(&pthreadLock); length ++; [NSThread sleepForTimeInterval:2]; pthread_mutex_unlock(&pthreadLock); }); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ if (pthread_mutex_trylock(&pthreadLock) == 0){ [NSThread sleepForTimeInterval:2]; pthread_mutex_unlock(&pthreadLock); }else{ NSLog(@\"加锁失败 %@\",NSThread.currentThread); } }); //使用 dispatch_group 监听任务全部完成后手动释放 pthread_mutex dispatch_group_notify(group, dispatch_get_main_queue(), ^{ pthread_mutex_destroy(&pthreadLock); }); } 使用互斥锁需要注意的几点： 互斥锁的加锁和解锁操作要消耗时间。因此互斥锁够用即可，每个互斥锁保护的区域尽量大。 互斥锁本质是串行。如果多条线程频繁使用同一互斥锁，则线程的大部分时间就会在等待，这对性能是有害的。如果互斥锁保护的数据包含彼此无关的片段，将这些片段拆分到不同的互斥锁保护。这样，任意时刻等待互斥锁的线程减少，线程等待时间减少。所以，互斥锁应该足够多(到有意义的地步)，每个互斥锁保护的区域则应尽量的少。 2、递归锁 Warning : You should not use this class to implement a recursive lock. Calling the lock method twice on the same thread will lock up your thread permanently. Use the NSRecursiveLock class to implement recursive locks instead. 官方文档警告：在递归中建议使用NSRecursiveLock，使用 NSLock 造成递归死锁。 递归锁在同一个线程可以重复上锁，不会导致死锁。 2.1、递归锁 NSRecursiveLock 使用 NSRecursiveLock 处理递归代码： - (void)recursiveLockMethod{ NSMutableArray *array = [NSMutableArray array]; NSRecursiveLock *recursiveLock = [[NSRecursiveLock alloc] init]; static void (^recursiveTestBlock)(int length); recursiveTestBlock = ^(int length){ NSLog(@\"开始加锁 === length ：%d -- %@\",length,NSThread.currentThread); [recursiveLock lock]; if (length > 0){ [array addObject:@(length)]; [NSThread sleepForTimeInterval:2];//模拟耗时任务 recursiveTestBlock(--length); } [recursiveLock unlock]; NSLog(@\"已经解锁 --- length ：%d == %@\",length,NSThread.currentThread); }; [NSThread detachNewThreadWithBlock:^{ recursiveTestBlock(3); }]; [NSThread detachNewThreadWithBlock:^{ [recursiveLock lock]; NSLog(@\"array ------ %@\",array); [recursiveLock unlock]; }]; } /* 打印数据： 11:54:38 开始加锁 === length ：3 -- {number = 7, name = (null)} 11:54:40 开始加锁 === length ：2 -- {number = 7, name = (null)} 11:54:42 开始加锁 === length ：1 -- {number = 7, name = (null)} 11:54:44 开始加锁 === length ：0 -- {number = 7, name = (null)} 11:54:44 已经解锁 --- length ：0 == {number = 7, name = (null)} 11:54:44 已经解锁 --- length ：0 == {number = 7, name = (null)} 11:54:44 已经解锁 --- length ：1 == {number = 7, name = (null)} 11:54:44 已经解锁 --- length ：2 == {number = 7, name = (null)} 11:54:44 array ------ (3,2,1) */ 在一条线程中任务是按顺序执行的，不存在资源竞争问题；可以使用NSRecursiveLock 在一条线程中重复加锁。NSRecursiveLock会记录上锁和解锁的次数，当二者平衡时才会释放锁，其它线程才能获取该锁。 2.2、pthread_mutex_t 实现递归锁 2.2.1、互斥锁属性pthread_mutexattr_t //互斥锁属性 typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t; /* 互斥锁属性的初始化 * 该结构体的属性都是默认值；需要调用不同的函数设置其属性 */ int pthread_mutexattr_init(pthread_mutexattr_t *) /* 销毁互斥锁属性 */ int pthread_mutexattr_destroy(pthread_mutexattr_t *) /* 设置互斥锁的类型 * @return 如果设置成功，返回 0 ；否则返回错误码。 */ int pthread_mutexattr_settype(pthread_mutexattr_t *, int) /* 获取互斥锁的类型 * @return 如果获取成功，返回 0 ；否则返回错误码。 */ int pthread_mutexattr_gettype(const pthread_mutexattr_t * __restrict,int * __restrict) 互斥锁 pthread_mutex_t 的几种类型： PTHREAD_PROCESS_SHARED： 跨进程共享； 每个进程的地址空间是独立的，位于一个进程的普通内存区域中的对象是无法被其它进程所访问的； 能满足这一要求的内存区域是共享内存，因而互斥锁要在进程的共享内存区域内创建。 PTHREAD_PROCESS_PRIVATE ： 进程私有 PTHREAD_MUTEX_TIMED_NP 普通锁，保证了资源分配的公平性； 当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。 解锁一个由别的线程锁定的互斥锁将会返回一个错误代码。 解锁已经被解锁的互斥锁也将会返回一个错误代码。 PTHREAD_MUTEX_NORMAL 与 PTHREAD_MUTEX_DEFAULT ：不会自动检测死锁，不会返回错误代码，避免使用 PTHREAD_MUTEX_ADAPTIVE_NP ： 适应锁，仅等待解锁后重新竞争 PTHREAD_MUTEX_ERRORCHECK 与 PTHREAD_MUTEX_ERRORCHECK_NP ：检错锁：自动检测死锁。 如果一个线程试图对一个互斥锁重复锁定，返回 EDEADLK，保证多次加锁时不会出现最简单情况下的死锁。 PTHREAD_MUTEX_RECURSIVE 与 PTHREAD_MUTEX_RECURSIVE_NP ：递归锁： 在一个线程重复上锁，不会引起死锁；进程私有； 一个线程对递归锁重复上锁必须由这个线程来重复相同数量的解锁，这样才能解开这个互斥锁，然后 别的线程才能得到这个互斥锁。 例子：利用pthread_mutex_t实现递归锁的效果 与 NSRecursiveLock一样： - (void)pthread_mutex_RecursiveLockMethod{ __block pthread_mutex_t pthreadLock; pthread_mutexattr_t pthreadMutexattr; pthread_mutexattr_init(&pthreadMutexattr);//锁属性的初始化 pthread_mutexattr_settype(&pthreadMutexattr, PTHREAD_MUTEX_RECURSIVE);//设置为递归锁 pthread_mutex_init(&pthreadLock, &pthreadMutexattr);//锁的初始化 static void (^recursiveTestBlock)(int length); recursiveTestBlock = ^(int length){ NSLog(@\"开始加锁 === length ：%d -- %@\",length,NSThread.currentThread); pthread_mutex_lock(&pthreadLock);//上锁 if (length > 0){ [NSThread sleepForTimeInterval:2]; recursiveTestBlock(--length); } pthread_mutex_unlock(&pthreadLock);//解锁 NSLog(@\"已经解锁 --- length ：%d == %@\",length,NSThread.currentThread); }; [NSThread detachNewThreadWithBlock:^{ recursiveTestBlock(3); }]; } 3、条件锁 条件锁：当某些条件不满足时线程进入休眠；满足条件时，唤醒休眠线程继续执行。 3.1、条件锁 NSConditionLock NSConditionLock 确保只有满足特定条件时，线程才能获取该锁。 //实现 NSLocking 协议 @interface NSConditionLock : NSObject /* 初始化条件锁 * @param condition 加锁满足的条件 */ - (instancetype)initWithCondition:(NSInteger)condition; // 获取当前的条件 @property (readonly) NSInteger condition; /* 试图加锁，不会阻塞当前线程的执行。 * @param condition 加锁满足的条件 * 满足该条件，且没有在其它线程加锁，才能加锁成功 * @return 加锁成功返回 YES，否则返回 NO */ - (BOOL)tryLock; - (BOOL)tryLockWhenCondition:(NSInteger)condition; /* 加锁操作，阻塞当前线程 * @param condition 加锁满足的条件 * 满足该条件，且没有在其它线程加锁，则加锁成功，程序向下执行； * 如果不满足该条件，或者在其它线程上锁，则堵塞线程，一直等待 */ - (void)lockWhenCondition:(NSInteger)condition; /* 加锁操作，会堵塞当前线程 * @param limit 加锁的截止时间 * 在截止时间之前，堵塞当前线程，一直尝试加锁。 * @return 加锁成功返回 YES ，否则返回 NO */ - (BOOL)lockBeforeDate:(NSDate *)limit; /* 加锁操作，会堵塞当前线程 * @param condition 加锁满足的条件， * @param limit 加锁的截止时间 * @note 在截止时间 limit 之前，堵塞当前线程，一直尝试加锁。 * 如果满足条件，并且没有在其它线程上锁，则加锁成功，立即返回 YES； * 在其它线程上锁，超过截止时间，则加锁失败，返回 NO； * 如果不满足条件，在到达截止时间之前，会一直尝试，等待可能变化的条件； * 在到达截止时间也不满足，则加锁失败，返回 NO； * @return 加锁成功返回 YES ，否则返回 NO */ - (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; /* 解锁操作 * @param condition 重置锁的条件 */ - (void)unlockWithCondition:(NSInteger)condition; @end 3.2、条件锁 NSCondition NSCondition 实现了一个线程等待信号而休眠时，可以被另外一个线程唤醒的功能。其对象实现了锁和线程检查器的功能： 锁：保护共享数据； 线程检查器：判断线程是否休眠，收到信号唤醒休眠线程。 //实现 NSLocking 协议 @interface NSCondition : NSObject /* 使线程处于休眠状态，只有收到信号，才会唤醒线程 * @note 一条线程处于休眠，则之前 -lock 操作的锁也被休眠， * 只有该条线程再次活跃，加锁才有效； */ - (void)wait; /* 使线程处于休眠状态 * @param limit 休眠的截止时间 * 如果在截止时间之前收到了信号就唤醒线程，返回 YES * 如果到了截止时间也没收到信号，也会唤醒线程，返回 NO */ - (BOOL)waitUntilDate:(NSDate *)limit; /* 发送一个信号量，唤醒一个休眠线程 * 唤醒多条线程就得多次调用；如果没有线程休眠，则这个方法不起作用； */ - (void)signal; /* 唤醒所有休眠线程 * @note 如果这些线程在休眠之前 -lock， 在收到广播之后并非同时唤醒的； * 按先后顺序，一条条线程依次唤醒并解锁 */ - (void)broadcast; @end 3.3、利用pthread_mutex_t实现条件锁 条件变量 pthread_cond_t 包括两个动作：一条线程因条件变量不满足 而休眠；另一条线程使条件成立 发出信号唤醒休眠线程。为了防止竞争，条件变量总和互斥锁结合使用。 /* 初始化一个条件变量 * @note 可以直接静态创建一个条件变量： PTHREAD_COND_INITIALIZER * @return 初始化成功，返回 0； 否则返回非 0 */ int pthread_cond_init(pthread_cond_t* cond, pthread_condattr_t *cond_attr); /* 销毁一个条件变量 * @return 销毁成功，返回 0； 否则返回非 0 */ int pthread_cond_destroy(pthread_cond_t* cond); /* 休眠当前线程 * @param pthread_cond_t 条件变量 * @param pthread_mutex_t 互斥锁 * @return 收到信号，返回 0 ，唤醒线程继续执行 * @note 该函数唤醒休眠线程后，并不意味满足下述执行的条件，必须重新检查条件；最好的测试方法是循环调用： * while (条件){ * pthread_cond_wait(&pthreadCondition, &condMutexLock); * } * // 和条件关联的某些代码 */ int pthread_cond_wait(pthread_cond_t * __restrict,pthread_mutex_t * __restrict); /* 休眠当前线程到截止时间 * @param pthread_cond_t 条件变量 * @param pthread_mutex_t 互斥锁 * @param timespec 截止时间 * @return 如果在截止时间内收到信号，返回 0 ，唤醒线程继续执行； * 如果到截止时间还没有信号，返回 ETIMEOUT ，唤醒线程继续执行； */ int pthread_cond_timedwait(pthread_cond_t * __restrict, pthread_mutex_t * __restrict,const struct timespec * _Nullable __restrict) /* 发送一个信号，唤醒一条处于休眠的线程； * @note 存在多条休眠线程时按入队顺序唤醒其中一条 * @return 发送信号成功，返回 0 ；否则返回非 0 值 */ int pthread_cond_signal(pthread_cond_t* cond); /* 广播某信号，唤醒所有相关的处于休眠的线程； * @return 广播成功，返回 0 ；否则返回非 0 值 */ int pthread_cond_broadcast(pthread_cond_t* cond); 例子： 条件锁的使用（用法与NSCondition大同小异） - (void)pthread_mutex_ConditionMethod{ __block pthread_mutex_t condMutexLock; __block pthread_cond_t pthreadCondition;//条件变量 pthread_mutex_init(&condMutexLock, NULL);//初始化一个互斥锁 pthread_cond_init(&pthreadCondition, NULL);//初始化一个条件变量 NSMutableArray *array = [[NSMutableArray alloc] init]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@\"开始加锁 ： taskA === %@\",NSThread.currentThread); pthread_mutex_lock(&condMutexLock); //wait() 接到 signal 后，并不意味着条件的值一定发生了变化，必须重新检查条件的值。最好的测试方法是循环调用： while ([array containsObject:@5] == NO){ NSLog(@\"执行wait： taskA === %@\",NSThread.currentThread); struct timespec abstime; struct timeval now; long timeout_s = 5; // 等待 1s gettimeofday(&now, NULL); long nsec = now.tv_usec * 1000 + timeout_s * 1000000; abstime.tv_sec = now.tv_sec + nsec / 1000000000 + timeout_s; abstime.tv_nsec = nsec % 1000000000; if (pthread_cond_timedwait(&pthreadCondition, &condMutexLock, &abstime) == 0){ NSLog(@\"接signal： taskA === %@\",NSThread.currentThread); }else{ NSLog(@\"taskA ---- 指定时间内也没有收到 信号\"); } } pthread_mutex_unlock(&condMutexLock);//解锁 NSLog(@\"已经解锁 ： taskA === %@\",NSThread.currentThread); }); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@\"开始加锁 ： taskB === %@\",NSThread.currentThread); pthread_mutex_lock(&condMutexLock);//上锁 [array addObject:@5]; pthread_cond_signal(&pthreadCondition); NSLog(@\"发送信号 ： taskB === %@\",NSThread.currentThread); pthread_mutex_unlock(&condMutexLock);//解锁 NSLog(@\"已经解锁 ： taskB === %@\",NSThread.currentThread); }); } 4、信号量dispatch_semaphore 信号量也称数据操作锁，本身不具备数据交换功能，通过控制其它通信资源来实现线程间通信。信号量在此过程中负责数据操作的互斥、同步等功能。 dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式。但 NSCondition 只能发送信号，不能保存：如果没有线程在等待，则发送的信号会失效；而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t类型的信号量。 /* 创建一个信号量 * @param value 如果 0 ，则该函数不执行任何操作，返回 0 * 如果 value=0，当前线程会和 NSCondition 一样休眠，等待其它线程发送信号唤醒此线程去执行后续任务 * @param timeout 截止时间；此时即使 value 值不大于 0 ，也会接着向下执行， * DISPATCH_TIME_NOW 立即发生的时间，表示忽略信号量，直接运行 * DISPATCH_TIME_FOREVER表示无穷大的时间，表示会一直等待信号量为正数，才会继续运行 * @return 如果该信号量的 value>0 ，则不执行任何操作，直接返回 0, * 如果 value=0，在截止时间之内收到信号，则唤醒该线程，并返回 0 ； * 超过截止时间，唤醒该线程并返回非 0 值， */ long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); /* 发送一个信号 * @param dsema 指定的信号量，如果该信号量的 value>0 ，则该函数不执行任何操作，返回 0 * 如果 value=0，则 value++，发送信号，唤醒休眠中的线程，返回 0 */ long dispatch_semaphore_signal(dispatch_semaphore_t dsema); 例子： dispatch_semaphore控制线程的最大并发数 - (void)dispatch_semaphoreMethod{ dispatch_queue_t queue = dispatch_queue_create(\"com.demo.task\", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_apply(6, queue, ^(size_t i) { long single = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_group_async(group, queue, ^{ NSLog(@\"开始执行第 %zu 次任务 == single : %ld----- %@\",i,single,NSThread.currentThread); [NSThread sleepForTimeInterval:(i % 2 == 0 ? 2 : 3)];//模拟耗时任务 long value = dispatch_semaphore_signal(semaphore);// 当线程任务执行完成之后，发送一个信号，增加信号量。 NSLog(@\"结束执行第 %zu 次任务 == single : %ld----- %@\",i,value,NSThread.currentThread); }); }); //既控制了线程数量，也在执行任务完成之后得到了通知。 dispatch_group_notify(group, queue, ^{ NSLog(@\"任务结束 ------ %@\",NSThread.currentThread); }); } 5、读写锁 对于实时性较高的应用如订票系统，使用互斥锁时，多条线程无法同时读取某个数据，并发性能较低。此时读写锁可以提高读取效率。 读写锁把对共享资源的访问者划分成读者和写者，在任一时刻允许多条线程读取数据，提高并发度；同时在某个线程修改数据期间保护该数据，以免被其它线程的读取、修改操作干扰。 写者：只需修改共享资源，具有排它性，同一时刻只有一条线程在写； 读者：只能读取共享资源；多条线程可以同时读取； 当之前（读操作之前）所有写操作完成之后，才能进行读操作； 利用 dispatch_barrier_async() 函数在队列中设置同步点，可以分别执行读取、写入，达到读写锁的效果。但没有 pthread_rwlock_t 好用。 读写锁pthread_rwlock_t /* 初始化一个读写锁 * @return 初始化成功，返回 0； 否则返回非 0 */ int pthread_rwlock_init(pthread_rwlock_t * __restrict, const pthread_rwlockattr_t * _Nullable __restrict); /* 销毁指定读写锁 * @return 销毁成功，返回 0； 否则返回非 0 */ int pthread_rwlock_destroy(pthread_rwlock_t * ); /* 写入操作上锁，会堵塞线程 * @note 当该锁已经在其它线程执行 “写入操作上锁”，则会堵塞当前线程，等待其它线程完成写入操作； * @return 上锁成功，返回 0 ；否则返回非 0 值 */ int pthread_rwlock_wrlock(pthread_rwlock_t *); /* 写入操作尝试上锁，不会堵塞当前线程 * @return 当该锁已经在其它线程执行“写入操作上锁”，上锁失败，立即返回非 0 值 * 成功上锁返回 0； */ int pthread_rwlock_trywrlock(pthread_rwlock_t *); /* 读取操作上锁，会堵塞线程 * @note 当该锁已经在其它线程执行“写入操作上锁”，则会堵塞当前线程，等待其它线程解除 wrlock； * 直到之前的 wrlock 都已解锁，该函数返回 0 ，代码接着执行 * @note 即使该锁已经在其它线程执行“读取操作上锁”，也不会影响该操作 * 多条处于 rdlock 锁定的线程，可以同时访问某一资源 * @return 成功上锁返回 0；否则返回非 0 值 */ int pthread_rwlock_rdlock(pthread_rwlock_t *); /* 读取操作尝试上锁，不会堵塞线程 * @note1 当该锁已经在其它线程执行“写入操作上锁”，上锁失败，立即返回非 0 值； * @note2 即使该锁已经在其它线程执行 rdlock，也不会影响此处的 tryrdlock，依旧可以上锁成功 * @return 成功上锁返回 0；否则返回非 0 值 */ int pthread_rwlock_tryrdlock(pthread_rwlock_t *); /* 解除读锁、解除写锁 * @return 成功解除返回 0；否则返回非 0 值 */ int pthread_rwlock_unlock(pthread_rwlock_t *); 例子：同时多次写入与读取： - (void)pthread_rwlock_Method{ __block pthread_rwlock_t rwlock; pthread_rwlock_init(&rwlock, NULL);//初始化一个读写锁 NSMutableArray *array = [NSMutableArray array]; dispatch_queue_t queue = dispatch_queue_create(\"com.demo.barrier\", DISPATCH_QUEUE_CONCURRENT); //写任务：写锁锁定 dispatch_block_t writeTask = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^{ pthread_rwlock_wrlock(&rwlock); NSInteger index = array.count; NSLog(@\"开始执行writeTask:%ld === %@\",index,NSThread.currentThread); [array addObject:@(index)]; [NSThread sleepForTimeInterval:3];//模拟耗时任务 NSLog(@\"结束执行writeTask:%ld === %@\",index,NSThread.currentThread); pthread_rwlock_unlock(&rwlock); }); NSLog(@\"开始执行写入操作\"); for (int i = 0; i 6、执行一次的操作 /* GCD 提供 dispatch_once_t 保证在应用程序执行中只执行一次; * 常用于创建单例 * @note 堵塞当前线程，直到 block 执行完毕 * @note 如果在一个线程调用 dispatch_once() 函数时，另外的线程调用此处代码， * 则调用线程等待，不往下执行，直到首次调用的线程返回； * 此时 dispatch_once_t 被标记执行，Block 不再被执行，跳过往下执行。 */ typedef intptr_t dispatch_once_t; void dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block); /* C语言提供 pthread_once_t 保证在应用程序执行中只执行一次; 常用于创建单例 * @param pthread_once_t 控制变量，使用宏 PTHREAD_ONCE_INIT 静态地初始化该变量； * @param void(* _Nonnull)(void) 函数指针 * @note 堵塞当前线程，直到函数执行完毕 * @note 如果在一个线程调用 pthread_once() 函数时，另外的线程调用此处代码， * 则调用线程等待，不往下执行，直到首次调用的线程返回； * 此时 pthread_once_t 被标记执行，跳过该函数，往下执行。 */ int pthread_once(pthread_once_t *, void (* _Nonnull)(void)); pthread_once_t 的实现效果和 dispatch_once_t 一样。使用 pthread_once_t 创建一个单例： void pthread_once_Function(void) { static id shareInstance; shareInstance = [[NSObject alloc] init]; } - (void)pthread_once_Method{ pthread_once_t once = PTHREAD_ONCE_INIT; pthread_once(&once, &pthread_once_Function); } 7、属性修饰词 atomic/nonatomic atomic/nonatomic 用来决定编译器生成的getter 和 setter 是否为原子操作； 7.1、atomic 声明一个属性默认为 atomic，系统会保证在其自动生成的 getter/setter 方法中的操作是完整的，不受其他线程的影响。如线程5在执行 getter 方法时，线程6执行了 setter 方法，此时 线程5 依然会得到一个完整无损的对象。 //声明一个atomic修饰的属性 @property (atomic ,copy) NSString *testStrig; //setter 方法的内部实现 - (void)setTestStrig:(NSString *)testStrig{ {lock} if (![_testStrig isEqualToString:testStrig]){ _testStrig = testStrig; } {unlock} } atomic 不是线程安全的，如果有另一条线程同时在调 [testStrig release] ，程序可能 crash ，因为 -release 不受 getter/setter 操作的限制。也就是说，这个属性只是读/写安全的，但并不是线程安全的，因为其它线程还能执行读写之外的其他操作。线程安全需要开发者自己来保证。 atomic nonatomic 默认修饰符 不是默认的 读写速度慢，性能差 速度更快，提高性能 读写安全，线程不安全 读写不安全，线程不安全 demo 参考文章： iOS 常见知识点（三）：Lock C语言互斥锁pthread_mutex_t iOS 中常见的几种锁 pthread_cond_wait()用法分析 pthread_rwlock_t读写锁函数说明 ios atomic nonatomic区别 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/杂记/OC的深拷贝与浅拷贝.html":{"url":"iOS开发/杂记/OC的深拷贝与浅拷贝.html","title":"OC的深拷贝与浅拷贝","keywords":"","body":"OC的深拷贝与浅拷贝 Objective-C 对象是通过指向该对象内存地址的指针，以间接方式访问的。 指针赋值： MRC 下仅仅将一个新的指针指向该内存地址，并没有获取该内存的所有权，引用计数不变； ARC 下由于默认使用 strong 修饰，因此将一个新的指针指向该内存地址，获取该内存的所有权，引用计数+1； 对于实现了 NSCopying 与 NSMutableCopying 协议的对象来说，指针赋值并非简单的赋值，还有额外的操作： 浅拷贝：类似于ARC下的指针赋值，将一个新指针指向该内存地址； 深拷贝：将一个新指针指向新的内存对象，该内存的数据与被复制的数据相同！如果改变原内存数据，新对象不会随着改变！ 1、非容器类与容器类 1.1、非容器类 NSString 系统类 NSString 实现了 NSCopying 与 NSMutableCopying 协议 1.1.1、不可变对象 NSString { NSString *string = [[NSString alloc] initWithString:@\"String\"]; NSString *string_1 = string; NSString *string_2 = [string copy]; NSString *string_3 = [string mutableCopy]; NSLog(@\"string : %@\",logString(string)); NSLog(@\"string_1 : %@\",logString(string_1)); NSLog(@\"string_2 : %@\",logString(string_2)); NSLog(@\"string_3 : %@\",logString(string_3)); } /** 打印日志 string : String 0x1070701a8 | rCount :-1 | __NSCFConstantString string_1 : String 0x1070701a8 | rCount :-1 | __NSCFConstantString string_2 : String 0x1070701a8 | rCount :-1 | __NSCFConstantString string_3 : String 0x600003f381e0 | rCount :1 | __NSCFString */ 1.1.2、可变对象 NSMutableString { NSMutableString *mString = [[NSMutableString alloc] initWithString:@\"Mutable String\"]; NSString *mString_1 = mString; NSString *mString_2 = [mString copy]; NSString *mString_3 = [mString mutableCopy]; NSLog(@\"mString : %@\",logString(mString)); NSLog(@\"mString_1 : %@\",logString(mString_1)); NSLog(@\"mString_2 : %@\",logString(mString_2)); NSLog(@\"mString_3 : %@\",logString(mString_3)); } /** 打印日志 mString : Mutable String 0x600003f10840 | rCount :1 | __NSCFString mString_1 : Mutable String 0x600003f10840 | rCount :1 | __NSCFString mString_2 : Mutable String 0x60000316d420 | rCount :1 | __NSCFString mString_3 : Mutable String 0x600003f12160 | rCount :1 | __NSCFString */ 操作 非容器类 NSString NSMutableString copy 类似于ARC下的指针赋值 深拷贝，得到一个可变对象 mutableCopy 深拷贝，得到一个可变对象 深拷贝，得到一个可变对象 1.2、容器类 NSArray、NSDictionary 1.2.1、容器类 NSArray { NSString *string = @\"String\"; NSMutableString *mString = [[NSMutableString alloc] initWithString:@\"Mutable String\"]; NSLog(@\"string : %@\",logString(string)); NSLog(@\"mString : %@\",logString(mString)); NSArray *array = [[NSArray alloc] initWithObjects:string,mString, nil]; NSMutableArray *mArray = [[NSMutableArray alloc] initWithObjects:string,mString, nil]; mString.string = @\"Mutable String_2\"; NSLog(@\"mString : %@\",logString(mString)); NSArray *array_1 = array; NSArray *array_2 = [array copy]; NSArray *array_3 = [array mutableCopy]; NSLog(@\"array : %@\",logArray(array)); NSLog(@\"array_1 : %@\",logArray(array_1)); NSLog(@\"array_2 : %@\",logArray(array_2)); NSLog(@\"array_3 : %@\",logArray(array_3)); printf(\"\\n \\n\"); NSMutableArray *mArray_1 = mArray; NSMutableArray *mArray_2 = [mArray copy]; NSMutableArray *mArray_3 = [mArray mutableCopy]; NSLog(@\"mArray : %@\",logArray(mArray)); NSLog(@\"mArray_1 : %@\",logArray(mArray_1)); NSLog(@\"mArray_2 : %@\",logArray(mArray_2)); NSLog(@\"mArray_3 : %@\",logArray(mArray_3)); } /** 打印日志： string : String 0x10aa001a8 | rCount :-1 | __NSCFConstantString mString : Mutable String 0x600002c4e550 | rCount :1 | __NSCFString mString : Mutable String_2 0x600002c4e550 | rCount :3 | __NSCFString array : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x6000022485e0 | rCount :2 | __NSArrayI array_1 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x6000022485e0 | rCount :2 | __NSArrayI array_2 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x6000022485e0 | rCount :2 | __NSArrayI array_3 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x600002c463d0 | rCount :1 | __NSArrayM mArray : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x600002c44000 | rCount :1 | __NSArrayM mArray_1 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x600002c44000 | rCount :1 | __NSArrayM mArray_2 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x6000022408c0 | rCount :1 | __NSArrayI mArray_3 : String ：0x10aa001a8 Mutable String_2 ：0x600002c4e550 0x600002c78ff0 | rCount :1 | __NSArrayM */ 1.2.2、容器类NSDictionary { NSString *string = @\"String\"; NSMutableString *mString = [[NSMutableString alloc] initWithString:@\"Mutable String\"]; NSLog(@\"string : %@\",logString(string)); NSLog(@\"mString : %@\",logString(mString)); NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:string,@\"NSString\",mString,@\"NSMutableString\", nil]; NSMutableDictionary *mDict = [[NSMutableDictionary alloc] initWithObjectsAndKeys:string,@\"NSString\",mString,@\"NSMutableString\", nil]; NSDictionary *dict_1 = dict; NSDictionary *dict_2 = [dict copy]; NSDictionary *dict_3 = [dict mutableCopy]; NSLog(@\"dict : %@\",logDictionary(dict)); NSLog(@\"dict_1 : %@\",logDictionary(dict_1)); NSLog(@\"dict_2 : %@\",logDictionary(dict_2)); NSLog(@\"dict_3 : %@\",logDictionary(dict_3)); printf(\"\\n \\n\"); NSMutableDictionary *mDict_1 = mDict; NSMutableDictionary *mDict_2 = [mDict copy]; NSMutableDictionary *mDict_3 = [mDict mutableCopy]; NSLog(@\"mDict : %@\",logDictionary(mDict)); NSLog(@\"mDict_1 : %@\",logDictionary(mDict_1)); NSLog(@\"mDict_2 : %@\",logDictionary(mDict_2)); NSLog(@\"mDict_3 : %@\",logDictionary(mDict_3)); } /** 打印日志 string : String 0x10fba11a8 | rCount :-1 | __NSCFConstantString mString : Mutable String 0x600003859f20 | rCount :1 | __NSCFString dict : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600002360700 | rCount :2 | __NSDictionaryI dict_1 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600002360700 | rCount :2 | __NSDictionaryI dict_2 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600002360700 | rCount :2 | __NSDictionaryI dict_3 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600003611da0 | rCount :1 | __NSDictionaryM mDict : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600003611600 | rCount :1 | __NSDictionaryM mDict_1 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600003611600 | rCount :1 | __NSDictionaryM mDict_2 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600003650860 | rCount :1 | __NSFrozenDictionaryM mDict_3 : NSString String ：0x10fba11a8 NSMutableString Mutable String ：0x600003859f20 0x600003650800 | rCount :1 | __NSDictionaryM */ 操作 NSArray、NSDictionary NSMutableArray、NSMutableDictionary 容器中元素 copy 浅拷贝，类似于ARC下的指针赋值 深拷贝，得到一个不可变对象 浅拷贝 mutableCopy 深拷贝，得到一个可变对象 深拷贝，得到一个可变对象 浅拷贝 2、NSString 类型的属性修饰符 什么时候使用 copy 修饰 NSString 类型的属性？什么时候使用 strong 修饰 NSString 类型的属性？ @property (nonatomic ,strong) NSString *sString; @property (nonatomic ,copy) NSString *cString; 2.1、赋值NSMutableString常量 { NSMutableString *mString = [[NSMutableString alloc] initWithString:@\"Mutable String\"]; self.sString = mString; self.cString = mString; NSLog(@\"mString : %@ : %p : %p : %ld\",mString,mString,&mString,mString.retainCount); NSLog(@\"sString : %@ : %p : %p : %ld\",self.sString,self.sString,&_sString,_sString.retainCount); NSLog(@\"cString : %@ : %p : %p : %ld\",self.cString,self.cString,&_cString,_cString.retainCount); mString.string = @\"Mutable String_1\"; NSLog(@\"mString : %@ : %p : %p : %ld\",mString,mString,&mString,mString.retainCount); NSLog(@\"sString : %@ : %p : %p : %ld\",self.sString,self.sString,&_sString,_sString.retainCount); NSLog(@\"cString : %@ : %p : %p : %ld\",self.cString,self.cString,&_cString,_cString.retainCount); mString = [[NSMutableString alloc] initWithString:@\"Mutable String_2\"]; NSLog(@\"mString : %@ : %p : %p : %ld\",mString,mString,&mString,mString.retainCount); NSLog(@\"sString : %@ : %p : %p : %ld\",self.sString,self.sString,&_sString,_sString.retainCount); NSLog(@\"cString : %@ : %p : %p : %ld\",self.cString,self.cString,&_cString,_cString.retainCount); } /** 打印日志 mString : Mutable String : 0x600002f19650 : 0x7ffee5f1a138 : 2 sString : Mutable String : 0x600002f19650 : 0x7fad5cf0d800 : 2 cString : Mutable String : 0x600002135d40 : 0x7fad5cf0d808 : 1 mString : Mutable String_1 : 0x600002f19650 : 0x7ffee5f1a138 : 2 sString : Mutable String_1 : 0x600002f19650 : 0x7fad5cf0d800 : 2 cString : Mutable String : 0x600002135d40 : 0x7fad5cf0d808 : 1 mString : Mutable String_2 : 0x600002f0c1b0 : 0x7ffee5f1a138 : 1 sString : Mutable String_1 : 0x600002f19650 : 0x7fad5cf0d800 : 2 cString : Mutable String : 0x600002135d40 : 0x7fad5cf0d808 : 1 */ 将 NSMutableString *mString 赋值给上述属性 cString 与 sString： copy 修饰的变量cString属于深拷贝，使用新的指针指向新的内存地址，新的内存地址存储的数据与被赋值的数据相同; strong 修饰的变量sString属于浅拷贝，使用新的指针指向被赋值变量的内存地址，类似于 retain 操作，引用计数 +1； 改变 mString.string 的值： 由于变量cString属于深拷贝，不被 mString 的操作影响; strong 修饰的变量仍然指向 mString 的内存，因此该变量的字符串也被改变; 将 mString 指向别处： 由于变量cString属于深拷贝，不被 mString 的操作影响； strong 修饰的变量仍然指向原有内存，值不改变； 2.2、赋值NSString常量 { NSString *string = @\"Hello Word!\"; self.sString = string; self.cString = string; NSLog(@\"string : %@ : %p : %p : %ld\",string,string,&string,string.retainCount); NSLog(@\"sString : %@ : %p : %p : %ld\",self.sString,self.sString,&_sString,_sString.retainCount); NSLog(@\"cString : %@ : %p : %p : %ld\",self.cString,self.cString,&_cString,_cString.retainCount); string = @\"hehe\"; NSLog(@\"string : %@ : %p : %p : %ld\",string,string,&string,string.retainCount); NSLog(@\"sString : %@ : %p : %p : %ld\",self.sString,self.sString,&_sString,_sString.retainCount); NSLog(@\"cString : %@ : %p : %p : %ld\",self.cString,self.cString,&_cString,_cString.retainCount); } /** 打印日志 string : Hello Word! : 0x109ce5608 : 0x7ffee5f1a130 : -1 sString : Hello Word! : 0x109ce5608 : 0x7fad5cf0d800 : -1 cString : Hello Word! : 0x109ce5608 : 0x7fad5cf0d808 : -1 string : hehe : 0x109ce5648 : 0x7ffee5f1a130 : -1 sString : Hello Word! : 0x109ce5608 : 0x7fad5cf0d800 : -1 cString : Hello Word! : 0x109ce5608 : 0x7fad5cf0d808 : -1 */ 将 NSString *string 赋值给上述属性 cString 与 sString：都是浅拷贝，类似于 retain 操作，引用计数 +1； 改变变量 string 的值，即将指针 string 指向别的内存地址；此时变量cString 与sString 指向原有内存，值不改变； 结论： 如果不希望属性变量 string 的值随着 NSMutableString 变化，就用copy来修饰string属性; 如果需要属性变量 string 的值随着 NSMutableString 变化而改变，就用strong来修饰string。 Demo Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"其它/sdk_cocoapods.html":{"url":"其它/sdk_cocoapods.html","title":"iOS 使用 cocoapods 创建组件化库","keywords":"","body":"iOS 使用 cocoapods 创建组件化库 1、创建组件库 使用 cocoapods 创建组件化库 YLServices ： MacBook-Air Desktop % pod lib create YLServices 需要回答一些问题： What platform do you want to use?? [ iOS / macOS ] > iOS What language do you want to use?? [ Swift / ObjC ] > ObjC Would you like to include a demo application with your library? [ Yes / No ] > Yes Which testing frameworks will you use? [ Specta / Kiwi / None ] > Specta Would you like to do view based testing? [ Yes / No ] > Yes What is your class prefix? > YL Running pod install on your new library. Analyzing dependencies Downloading dependencies Installing Expecta (1.0.6) Installing Expecta+Snapshots (3.1.1) Installing FBSnapshotTestCase (2.1.4) Installing Specta (1.0.7) Installing YLServices (0.1.0) Generating Pods project Integrating client project [!] Please close any current Xcode sessions and use `YLServices.xcworkspace` for this project from now on. Pod installation complete! There are 5 dependencies from the Podfile and 5 total pods installed. Ace! you're ready to go! We will start you off by opening your project in Xcode open 'YLServices/Example/YLServices.xcworkspace' To learn more about the template see `https://github.com/CocoaPods/pod-template.git`. To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. MacBook-Air Desktop % 至此，已经在本地创建了组件化库！ 2、配置文件 .podspec 组件库的配置文件 YLServices.podspec ! 如果需要依赖三方库，需要配置 s.dependency s.dependency 'AFNetworking', '4.0.1' s.dependency 'SDWebImage', '4.3.3' s.dependency 'Bugly', '2.5.0' 如果模块间需要相互引用，同样需要配置 s.dependency， 如：组件库 YLRouter 需要引用 YLServices //********1、修改 YLRouter.podspec 文件 s.dependency 'YLServices' //********2、修改 YLRouter Podfile 文件 pod 'YLServices', :path => '../../YLServices' 配置 Git 仓库的主页与地址 /// 必须配置主页地址 s.homepage = 'https://github.com/name/YLServices' /// 必须配置 Git 仓库地址 s.source = { :git => 'https://github.com/name/YLServices.git', :tag => s.version.to_s } 3、在组件库添加文件 添加类 创建 PeopleModel 类添加至指定目录： 执行 pod install ,将 PeopleModel 更新至 pods 组件库中 MacBook-Air ~ % cd /Users/long/Desktop/YLServices/Example MacBook-Air Example % pod install 添加资源文件 添加资源到指定目录，如图片、json、bundle文件等: 注意：必须在配置文件 YLServices.podspec 设置资源路径，否则无法读取资源！ s.resource_bundles = { # 添加所有类型文件 'YLServices' => ['YLServices/Assets/*'], # 指定添加 png 图片 'YLServices' => ['YLServices/Assets/*.png'], # 指定添加 bundle 类型文件 'YLServices' => ['YLServices/Assets/*.bundle'] } 然后执行 pod install ,更新组件库 MacBook-Air Example % pod install 4、组件库上传至远程 Git 仓库 MacBook-Air YLServices % git add . MacBook-Air YLServices % git commit -m'init' MacBook-Air YLServices % git push 打 tag /// 新建tag git tag 1.0.0 /// 推送tag到远程 git push origin 1.0.0 验证 podspec 文件 ///只验证一个本地仓库 MacBook-Air YLServices % pod lib /// 同时验证本地仓库和远程仓库 MacBook-Air YLServices % pod spec lint MacBook-Air YLServices % pod spec lint -> YLServices (0.0.1) - WARN | url: The URL (https://github.com/774792381@qq.com/YLServices) is not reachable. - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git clone https://github.com/774792381@qq.com/YLServices.git /var/folders/s5/127zrd4j7kl4llwhcl4cz3_40000gn/T/d20210106-20600-1a4bg2o --template= --single-branch --depth 1 --branch 0.0.1 Cloning into '/var/folders/s5/127zrd4j7kl4llwhcl4cz3_40000gn/T/d20210106-20600-1a4bg2o'... fatal: unable to access 'https://github.com/774792381@qq.com/YLServices.git/': The requested URL returned error: 400 ) during validation. Analyzed 1 podspec. [!] The spec did not pass validation, due to 1 error and 1 warning. 5、在工程中使用组件库 YLServices 新建工程 Demo，创建 Podfile 文件 MacBook-Air Demo % pod init 在 Podfile 文件中添加： pod 'YLServices', :git => 'https://github.com/name/YLServices',:tag => '0.0.1' 此时，就可以在 Demo 工程中使用 YLServices 组件库 了！！ 参考文章 YLServices 示例 iOS 组件化方案 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/内存优化.html":{"url":"iOS开发/杂记/内存优化.html","title":"一些内存优化","keywords":"","body":"一次内存优化 Out Of Memory Killer 机制 : 为了防止当系统物理内存不够用的时候系统崩溃，而选择一个占用内存最高的程序，把它 Kill 掉！ 在 iOS 操作系统中， RAM 内存（运行内存）是一种稀缺资源：随着用户打开的 App 越来越多，后台 App 占用的内存也越来越多，迟早会出现资源耗尽的窘境。当被占用的内存达到某个临界值时，iOS 系统将按照优先级逐个 Kill App，以维护系统的流畅和稳定。 当 iOS 系统清理前台正在运行的 App，会出现前台 App 闪退的现象，也就是通常所说的 OOM 。 为避免 App 发生 OOM， 在上线前需要针对内存做一些优化处理！本文记录笔者使用 Xcode Tools -> Instruments -> Leaks -> Allocations 所做的一些优化点！ 关于 Allocations 的简单说明 Allocations 用来检测 APP 内存分配和使用情况等。其界面分为两个部分：上半部分的内存走势图，与下半部分的内存分类！在下图中，默认展示所有内存 All Heap & Anonymous VM 的占用情况；将勾选中下半部分的哪个内存分类，上半部分的内存走势图就显示哪个部分！ All Heap & Anonymous VM ：全部内存 All Heap Allocations ： 堆内存，程序真实的内存分配情况 All Anonymous VM ：系统为程序分配的虚拟内存，当程序有需要的时候，能够及时为程序提供足够的内存空间，而不会现用现创建; 列名 含义 Graph 是否需要绘制出来（在mark 1可以看到） Category 内存分类，如 CF 对象、OC 对象、或一块原始的内存 Persistent 没有释放的对象内存大小 #Persistent 没有释放的对象个数 #Transient 已经释放的对象个数 Total Bytes Persistent Bytes + Transient Bytes #Total #Transient + #Persistent Persistent/Total Bytes 当前还活跃在RAM的内存占比 1、关于图片的优化 1.1、图片内存怎么算 磁盘上的图片和最终渲染出来的图片，所占用的内存大小不同的 ！ 平常使用的 .jpg、 .png 图片，需要经过一系列复杂的处理，才能最终渲染到屏幕。在本文，暂且不谈渲染流程，笔者关心的是最终渲染到屏幕的图片占用了多大的内存空间！ 众所周知，电子屏幕上的每个像素点均由红、绿、蓝三种颜色组件构成；而大多数情况下，还有第四个组件“透明度”；最终可以从每个像素中得到四个单独的值。在 iOS 中每个像素占用 4 byte ，可以通过以下公式快速计算 RAM 中的图片大小： RAM 中图片大小 = image.size.width * image.size.height * image.scale * 4 根据该公式可知：渲染到屏幕的图片 size 越大，占用的内存必然越高！ 1.2、关于 VM: ImageIO_PNG_Data 的优化点 根据 Persistent排序，发现类别 VM: ImageIO_PNG_Data 占用的内存最多，如下图所示： 点击进入 VM: ImageIO_PNG_Data 目录下，发现多个对象占用 12 M 内存！ 分析上图，是由于图片的读写操作引发的！根据对象的生成时间，判断出是加载了一张 @2x.png 图片引起的！针对大图的加载，通常做法是调用下述方法： + (nullable UIImage *)imageWithContentsOfFile:(NSString *)path; 但该方法仅仅保障不会缓存，但对大尺寸图片的加载，会引发 VM: ImageIO_PNG_Data 所占内存的激增！使用 Allocations 找出项目中同类型问题的一些大图： 解决思路：在 UI 同事 认为清晰度不受影响的前提下，笔者使用了一倍图，替代了上述的大图！之后监控发现，平均 RAM 内存减少了 50 M 左右！ 1.3、关于 VM: IOSurface 中 __csiCompressImageProviderCopyIOSurfaceWithOptions 的优化点 在某个业务场景中，出现了代码 __csiCompressImageProviderCopyIOSurfaceWithOptions 相关的 8.88 MiB 内存增长 针对 VM: IOSurface 目录下 __csiCompressImageProviderCopyIOSurfaceWithOptions 的内存增长，是由于调用下述方法加载图片引发的： /// 可以针对图片做缓存，方便下一次加载 + (nullable UIImage *)imageNamed:(NSString *)name; 找到具体的代码如下: /// 相关代码 UIImageView *whiteBoradImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"image_1\"]]; 分析图片 image_1.zize = {2048,1136} ，换为一倍图后，内存由 8.88 MiB 降到 2.2 MiB ！ size 比较大的图片的一些建议： 1、尽量将大图统一放置于一个 .bundle 文件夹中，不要放置于 Assets.xcassets 中； 2、尽量使用 -imageWithContentsOfFile: 方法替代 -imageNamed: 方法； 1.4、 VM: CG raster data 中 CGDataProviderCreateWithCopyOfData 的优化点 经过前面的一系列优化，现在发现 VM: CG raster data 位居榜首，进入该目录： 可以看到 CGDataProviderCreateWithCopyOfData 是由于某些业务代码引起的: 通过调试发现， UIGraphicsBeginImageContextWithOptions() 的入参 size = {1249,702} ，也就是由于给定的 size 过大导致的！针对该业务做一些优化处理！ 2、 VM: ZMDrawingView (CALayer) 优化 除了加载图片，引发内存激增之外，别的操作也可能引发内存激增！ VM: ZMDrawingView (CALayer) 13.42 MiB QuartzCore CA::Render::Shmem::new_shmem(unsigned long) QuartzCore 是图形绘制的底层框架， UIView 的 -drawRect: 方法最终由 QuartzCore 实现！分析找到该内存的具体代码： /// 关键代码 - (void)drawRect:(CGRect)rect { /// 备注： _image.size = {1249,702} [_image drawAtPoint:CGPointZero]; } 由于绘制大图导致了一个大块内存！尝试优化该块业务！ 参考文章： Allocations分析内存分配 iOS内存分析上-图片加载内存分析 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/内存泄露.html":{"url":"iOS开发/杂记/内存泄露.html","title":"一些内存泄漏","keywords":"","body":"一些典型的内存泄漏 野指针：指向一块被释放内存的指针；开启僵尸对象调试野指针，在对象释放时，使用一个内置的Zombie对象，替代原来被释放的对象；无论向该对象发送什么消息，都会触发异常，抛出调试信息； 在监测内存泄露时，需要关闭 调试僵尸对象 的选项，，否则 Intruments 会监测到大量 NSZombie 对象； 笔者在优化项目时，发现了一些比较典型的内存泄漏原因，在此记录一下！ CNCopyCurrentNetworkInfo() 引发的内存泄漏 项目中某个业务，会尝试获取 Wifi 的名称（非必须选项），导致下述的内存泄漏！ 1.39 KB 2.1% 13 main 1.39 KB 2.1% 13 __73+[KDeviceAccessManager requestAccessForAudioAndVideoCompletionHandler:]_block_invoke 1.39 KB 2.1% 13 __42-[ZMkGotoClassroom requestClassroomAccess]_block_invoke 1.39 KB 2.1% 13 +[NetWorkTool checkNetWorkStatusWithEnterClassBlock:] 1.39 KB 2.1% 13 +[NetWorkTool beginCheckNetWorkWithEnterClassBlock:] 1.39 KB 2.1% 13 -[NetWorkStatusView initWithEnterBlock:] 1.39 KB 2.1% 13 -[NetWorkStatusView loadCurrentNetInfo] 1.39 KB 2.1% 13 -[NetWorkStatusView loadWifiName] CaptiveNetwork __CNCopyCurrentNetworkInfo 分析日志，是由于 CNCopyCurrentNetworkInfo() 函数导致的内存泄漏，但是这个函数不是系统提供的嘛？怎么会出现内存泄漏了呢？ 去 苹果官网问题反馈 也能发现有人提出相同的问题： 再来看一下 CNCopyCurrentNetworkInfo() 的官方解释： /** @discussion 应用至少满足下述一个条件时，函数才会返回有效的网卡信息： * 1、应用如果使用 CoreLocation API，则必须拥有用户访问位置的授权 * 2、应用使用 NEHotspotConfiguration API 来配置当前的 Wi-Fi 网络 * 3、正处于启用状态的 VPN 应用 * 4、应用开启 NEDNSSettingsManager 配置 * * @note 1、iOS 12.0 以上必须有\"com.apple.developer.networking.wifi-info\"授权 * @note 2、iOS 13.0 及以上的系统，如果不满足上述至少一条要求，该函数返回 NULL * @note 3、如果遇到错误，返回NULL；必须释放返回值； */ CFDictionaryRef __nullable CNCopyCurrentNetworkInfo(CFStringRef interfaceName) API_DEPRECATED_WITH_REPLACEMENT(\"[NEHotspotNetwork fetchCurrentWithCompletionHandler:]\", ios(4.1, API_TO_BE_DEPRECATED), macCatalyst(14.0, API_TO_BE_DEPRECATED)) 笔者猜测：在 iOS 13.0 以上的系统，当项目不满足上述4个条件任一一个时，该函数内部仍然执行了逻辑功能，仅仅是最后给我们返回了 NULL ；这就导致原本返回的 NetworkInfo 被这个函数内部劫持了，而苹果又没去释放 NetworkInfo ，而开发者没办法拿到也不能去释放，所以导致了内存泄漏！ 开发者唯一能做的，仅仅是首先判断上述 4 个条件，确定自己是否有权限获取 Wifi 信息，如果没有就不要去调用这个函数！ - (NSString *)loadWifiName{ if (@available(iOS 13.0,*)) { /// 注：在 iOS 13 以上的设备，如果没有权限获取网卡信息，即使返回 NULL。苹果也留了个扯淡的内存泄漏 /// 此处判断下用户是否开启定位权限（前提是你没有在开发者网站配置 NEHotspotConfiguration 或者 NEDNSSettingsManager，否则大可不必在此判断） if (CLLocationManager.locationServicesEnabled) { /// 定位权限 if ( !(CLLocationManager.authorizationStatus == kCLAuthorizationStatusAuthorizedAlways || CLLocationManager.authorizationStatus == kCLAuthorizationStatusAuthorizedWhenInUse) ) { return nil; } } } /// 所有支持的网卡列表 NSArray *interfaceNames = CFBridgingRelease(CNCopySupportedInterfaces()); NSDictionary *SSIDInfo; for (NSString *interfaceName in interfaceNames) { /// 拿到有效网卡的信息（SSID，BSSID） SSIDInfo = CFBridgingRelease(CNCopyCurrentNetworkInfo((__bridge CFStringRef)interfaceName)); BOOL isNotEmpty = (SSIDInfo.count > 0); if (isNotEmpty) { break; } } NSString *SSID = SSIDInfo[@\"SSID\"]; return SSID; } Main.storyboard 操作不当导致的循环引用 使用 Xocde 创建一个 App 时默认会创建一个 Main.storyboard，并且在 info.plist 设置映射关系！ 如果不使用 Main.storyboard，而是在 AppDelegate 中使用代码创建 window，此时一定要将 info.plist 的映射关系删除，否则会引发内存泄露！ NSURLSession 使用不当导致的内存泄露 创建 NSURLSession 实例，如果使用不当可能造成内存泄漏 { NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://itunes.apple.com/lookup?id=1164001330\"]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { }]; [dataTask resume]; } The session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you don’t invalidate the session, your app leaks memory until the app terminates. NSURLSession 实例是不会主动释放的，除非开发者使它无效；否则将会导致内存泄露。 /// 修改后的程序 { NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://itunes.apple.com/lookup?id=1164001330\"]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { [session finishTasksAndInvalidate]; /// 使 session 无效 }]; [dataTask resume]; } 由于 AFNetworking 通过调用 NSURLSession 实现网络通信，因此在使用该库时也要注意相关问题，最好的办法就是创建一个单例类供全局使用！ 使用 Core Foundation 疏忽造成的内存泄露 ARC is only for NSObject ! （ARC 内存管理技术只对 OC 对象负责） /// 下述代码导致内存泄漏 ABAddressBookRef addresBook = ABAddressBookCreateWithOptions(NULL, NULL); ABAddressBookRegisterExternalChangeCallback(addresBook, addressBookChanged, (__bridge void *)(self)); 泄露的原因是 ABAddressBookRef 没有调用 CFRelease() 释放内存。 注意：针对 C 对象或是 CG 开头的对象，需要开发者负责其创建于释放！ 参考文章 苹果官网问题反馈 记 iOS13 CNCopyCurrentNetworkInfo一个哭笑不得的内存泄漏bug Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/OC之处理错误.html":{"url":"iOS开发/杂记/OC之处理错误.html","title":"一些错误处理机制","keywords":"","body":"OC之处理错误 运行时错误是指在运行程序时出现的错误，它不同于其他类型的错误（如语法错误、链接错误，这些错误是在执行程序前出现的）。 常见的运行时错误类型有以下几种： 逻辑错误：错误原因是代码没有正确实现相应的程序逻辑。只有当运行程序时没有获得预期的输出结果，这类错误才会显现出来。 语义错误：错误原因是不正确地使用程序语句 用户输入错误：由非法的用户输入信息导致的错误 这些错误如果不及时处理，就会导致各种不利情况，如程序异常终止，不正确操作等。Foundation 框架提供了几类用于处理错误的API： 错误对象 (NSError) 错误异常 (NSException) 断言 (Assert) 1、错误对象 NSError 程序运行时总是会发生各种各样的错误，比如网络请求失败、文件无法打开，文档无法解析等，在 Foundation 框架中提供了 NSError 来对错误信息（有关错误情况的信息，包括域，域特定的错误代码和特定于应用程序的信息）进行封装。我们可以使用 NSError 对象，封装多种错误信息以及实现一些自定义行为。 1.1、分析 NSError 的 属性 属性 类型 属性描述 domain NSErrorDomain 错误域 code NSInteger 标识了error的ID.在相同domain中的每个error都有一个唯一的值 userInfo NSDictionary 包含了错误的额外信息 localizedDescription NSString 错误的描述，可能包含 failure reason localizedFailureReason NSString 错误原因的解释 localizedRecoverySuggestion NSString 描述了用户如何操作以修复错误 localizedRecoveryOptions NSArray 一个字符串数组，内容是提供给用户操作的按钮的标题，与 recovery suggestion 配合使用 recoveryAttempter id 一个实现了NSErrorRecoveryAttempting协议的实例，与 recovery options 配合使用，可以让系统根据用户选择点击的按钮，执行相应的修复方法，但只能在 Cocoa 框架中使用 helpAnchor NSString 用于 Cocoa 框架中，NSAlert类执行方法+ alertWithError:时，展示的错误提示框中help anchor button的标题。 通过它的两个实例化方法，可以了解到我们要实例化一个 error ，需要传入三个参数：domain、code、userInfo。其中，domain不能为空，code 与 userInfo 可以为空。 1.1.1、错误域(domain) 错误域是一种用于根据系统、子系统和框架等组织错误编码的机制。使用错误域可以识别检测错误的子系统、框架等。错误域还有助于避免编码名称出现冲突，因为不同错误域中的错误编码可以拥有相同的名称。 Foundation 框架声明了以下4中主要的错误域： 错误域 值描述 NSCocoaErrorDomain Cocoa Frameworks（其中包括 Foundation 框架和其它 Objective-C 框架）的错误编码 NSURLErrorDomain URL加载错误码 NSStreamSOCKSErrorDomain NSError报告SOCKS错误时使用的错误域 NSStreamSocketSSLErrorDomain NSError报告SSL错误时使用的错误域 NSPOSIXErrorDomain 源自遵守 POSIX 标准的 Unix 的错误编码 NSOSStatusErrorDomain Apple OS Core Services 和 Carbon framework的错误编码 NSMachErrorDomain OS 内核错误编码 除了以上几种主要的错误域外，还有框架、类分组和单个类错误域。在创建和初始化 NSError 对象时，使用 NSError 类还可以创建自定义的错误域。如 AFNetworking 框架中自定义的错误域： AFNetworking的错误域 值描述 AFURLRequestSerializationErrorDomain 请求序列化错误域 AFURLResponseSerializationErrorDomain 响应序列化错误域 ... ... 当然，我们也可以为自己的类系或者框架自定义错误域 FOUNDATION_EXPORT NSErrorDomain const NSCustomErrorDomain; NSString * const NSCustomErrorDomain = @\"这是一个自定义的错误域\"; 1.1.2、用户信息字典(userInfo) 用户信息字典：其中含有代码和域之外的错误信息，该字典含有的信息类型包括错误的本地化信息和对支持对象的引用。 NSError类定义了一系列常用的用户信息字典值，使用这些键可以为用户信息字典创建键值对。下面表中展出了这些键： 键 值描述 NSUnderlyingErrorKey 基础实现代码中出现的错误 NSLocalizedDescriptionKey 代表错误的本地化字符串 NSLocalizedFailureReasonErrorKey 描述错误原因的本地化字符串 NSLocalizedRecoverySuggestionErrorKey 恢复错误的本地化建议 NSLocalizedRecoveryOptionsErrorKey 含有用于显示 Alert 的按钮的本地化标题的NSArray实例 NSRecoveryAttempterErrorKey 遵守 NSRecoveryAttempting 协议的对象 NSHelpAnchorErrorKey 表示帮助按钮的帮助信息的本地化字符串 NSStringEncodingErrorKey 含有字符串编码值得 NSNumber 的对象 NSFilePathErrorKey 错误的文件路径 NSURLErrorKey NSURL 对象 NSURLErrorFailingURLString 含有导致加载数据失败的URL的NSURL对象 NSURLErrorFailingURLStringErrorKey 导致加载数据失败的URL的字符串 NSURLErrorFailingURLPeerTrustErrorKey 表示SSL握手失败状态的 SecTrustRef对象 1.2、使用一个NSError实例 1.2.1、自定义一个NSError 实例 NSDictionary *dict = @{NSLocalizedDescriptionKey:@\"文件不能被写入\", NSLocalizedRecoverySuggestionErrorKey:@\"你要再次写入嘛？\", NSLocalizedRecoveryOptionsErrorKey:@[@\"取消\",@\"确定\",@\"想会\"], NSURLErrorFailingURLErrorKey:[NSURL URLWithString:@\"https://www.baidu.com\"], NSUnderlyingErrorKey:@\"基础实现代码中出现的错误\", NSLocalizedFailureReasonErrorKey:@\"描述错误原因的本地化字符串\", }; NSError *error = [NSError errorWithDomain:NSCustomErrorDomain code:11111 userInfo:dict]; 现在，我们利用用户信息字典的一些键定义了一个 userInfo ，并且使用前文提到的 NSCustomErrorDomain 错误域 ，实例化了一个 error 对象， 为了更直观的观看它的内部信息，我们重写下它的 description 方法: - (NSString *)description { return [NSString stringWithFormat:@\"%@\", [self dictionaryRepresentation]]; } - (NSDictionary *)dictionaryRepresentation { NSMutableDictionary *mutableDict = [NSMutableDictionary dictionary]; unsigned int count = 0; Ivar *iavrList = class_copyIvarList(self.class, &count); for (int i = 0; i 现在我们看它的打印信息： { \"_code\" = 11111; \"_domain\" = \"这是一个自定义的错误域\"; \"_userInfo\" = { NSErrorFailingURLKey = \"https://www.baidu.com\"; NSLocalizedDescription = \"文件不能被写入\"; NSLocalizedFailureReason = \"描述错误原因的本地化字符串\"; NSLocalizedRecoveryOptions = ( \"取消\", \"确定\", \"想会\" ); NSLocalizedRecoverySuggestion = \"你要再次写入嘛？\"; NSUnderlyingError = \"基础实现代码中出现的错误\"; }; } 通过它的打印信息，确实可以看到，NSError 主要有三个属性：code、domain、userInfo，其余的属性，其实都是根据userInfo的一些键取出的值。 1.2.2、实例化一个文件路径error： NSError *error; [NSString stringWithContentsOfFile:@\"123\" encoding:NSUTF8StringEncoding error:&error]; 我们看下打印信息： { \"_code\" = 258; \"_domain\" = NSCocoaErrorDomain;//Foundation 的错误域 \"_userInfo\" = { NSFilePath = \"123\";//错误的文件路径 NSUnderlyingError = \"Error Domain=NSPOSIXErrorDomain Code=2 \\\"No such file or directory\\\"\";//基础实现代码中出现的错误:源自遵守 POSIX 标准的 Unix 的错误编码 }; } 1.2.3 为何使用双指针指向error ？ + (nullable id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; 实际开发中我们遇到了很多使用双指针指向 error 的例子，那么为什么要使用双指针呢？ 1.3、错误恢复 NSError 类提供了错误修复机制。非正式协议 NSErrorRecoveryAttempting 提供了2个执行错误修复操作的方法。才用该协议的对象必须实现该协议的两个修复方法之一。支持错误恢复的NSError 对象的用户信息目录中必须至少含有下列 3 个条目： NSRecoveryAttempterErrorKey 尝试恢复对象 NSLocalizedRecoveryOptionsErrorKey 恢复选项 NSLocalizedRecoverySuggestionErrorKey 恢复建议的本地化字符串 注意：只能在 Cocoa 框架中使用错误恢复功能 1.3.1、在 Mac App 中使用NSAlert 展示错误弹出框 根据前文 2.1 中自定义的 error， NSAlert *alert = [NSAlert alertWithError:error]; NSModalResponse modalResponse = [alert runModal]; switch (modalResponse) { case NSModalResponseOK: { NSLog(@\"NSModalResponseOK\"); } break; case NSModalResponseStop: { NSLog(@\"NSModalResponseStop\"); } break; case NSModalResponseContinue: { NSLog(@\"NSModalResponseContinue\"); } break; default: NSLog(@\"default --- %ld\",modalResponse); break; } 代码运行后的弹出框： 可以看到： NSLocalizedDescriptionKey 对应标题部分 NSLocalizedRecoverySuggestionErrorKey 对应信息部分 NSLocalizedRecoveryOptionsErrorKey 给出的修复错误的选项（数组中的元素顺序在弹出框按钮位置从右到左展示） 现在我们分别点击 取消 、确定 、想会 三个按钮得到的打印信息如下： default --- 1000 //取消 default --- 1001 //确定 default --- 1002//想会 我们可以根据 modalResponse 做出一些修复措施。 1.3.2、当然，我们也可以在 iOS 封装 error 弹出框： ///通过 Categoty 给 UIAlertController 增加一个实例化的类方法 @implementation UIAlertController (HandleError) + (instancetype)showError:(NSError *)error ActionHandler:(void (^)(NSString *buttonTitle))handler { UIAlertController *alertController = [UIAlertController alertControllerWithTitle:error.localizedDescription message:error.localizedRecoverySuggestion preferredStyle:UIAlertControllerStyleAlert]; [error.localizedRecoveryOptions enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { UIAlertAction *action = [UIAlertAction actionWithTitle:obj style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) { handler(obj); }]; [alertController addAction:action]; }]; return alertController; } @end 还记得我们在 2.1 中实例化的 error嘛？现在我们在 iOS 中弹出 alertController UIAlertController *alertController = [UIAlertController showError:error ActionHandler:^(NSString *buttonTitle) { NSLog(@\"buttonTitle === %@\",buttonTitle); }]; [self presentViewController:alertController animated:YES completion:nil]; 现在我们分别点击 取消 、确定 、想会 三个按钮得到的打印信息如下： buttonTitle === 取消 buttonTitle === 确定 buttonTitle === 想会 我们可以根据获取的修复键值，做出一些修复 错误回应对象 Application Kit 提供了多个 API 和机制，使用它们可以回应封装在 NSError 对象中的错误。NSResponder 类定义了一个错误回应对象链条，使用该链条可以在层次结构中向上传递事件和行动消息。该类含有多个方法，使用这些方法可以在相关 NSError 对象中显示信息，然后将错误信息转发给下一条回应对象。该层次结构中的每个对象都能够以适当的方式处理错误，还可以向错误添加额外的相关信息。 2、NSException NSException 一个表示中断程序执行正常流程的特殊条件的对象，使用它实现异常处理。 异常是中断正常程序执行流程的特殊情况。每个应用程序都会因为不同的原因而中断程序 例如，一个应用程序可能会将保存在写保护目录中的文件解释为异常。从这个意义上说，这个例外相当于一个错误。另一个应用程序可能会将用户的按键（例如Control+C）解释为一个异常：表示应该中止长时间运行的进程。 2.1、NSException 的属性 属性 类型 属性描述 name NSExceptionName 异常的名称,用于唯一标识接收者的字符串 reason NSString 异常的起因 userInfo NSDictionary 含有用户对异常自定义信息的目录 callStackReturnAddresses NSArray 调用堆栈返回地址 callStackSymbols NSArray 调用堆栈的符号集 2.1.1 NSExceptionName 常规异常 异常名称 描述 NSGenericException 普通异常 NSMallocException 内存异常(已弃用，目前未使用) NSRangeException 当尝试访问超出某些数据的范围时引发的异常（如数组、字符串） NSInvalidArgumentException 当向方法传送非法常数时引发的异常 NSInternalInconsistencyException 当内部断言失败（如使用NSAssert函数）并表明代码出现了意外情况时引发的异常 NSDestinationInvalidException 因内部断言失败引发的分布式对象异常 NSObjectInaccessibleException 当远程对象被不该访问它的线程访问时引发的异常 NSObjectNotAvailableException 因对象还没有发布，所以远程NSConnection对象拒绝向它发送消息而引发的分布式对象异常 NSPortTimeoutException 在发送或者接收操作过程中，端口过期引发的异常 NSInvalidSendPortException NSConnection对象的发送端口变得不合法引发的异常 NSInvalidReceivePortException NSConnection对象的接收端口变得不合法引发的异常 NSPortSendException 当向端口发送消息时出现的 NSPort常规错误 NSPortReceiveException 当向端口接收消息时出现的 NSPort 常规错误 当然，我们也可以为自己的类系或者框架自定义异常名称 FOUNDATION_EXPORT NSExceptionName const NSCustomException; NSString * const NSCustomException = @\"这是一个自定义的异常\"; 2.2、创建一个 NSException 实例 NSException *exception = [NSException exceptionWithName:NSCustomException reason:@\"why exception\" userInfo:@{@\"ExceptionSuggest\":@\"Kill App\"}]; NSLog(@\"exception == \\n %@\",exception); 打印exception { name = \"这是一个自定义的异常\"; reason = \"why exception\"; userInfo = { ExceptionSuggest = \"Kill App\"; }; } 这时程序正常运行，为何没有异常终止呢？ 我们看到有个 - (void)raise;方法，我们没有调用，我们调用 raise 方法，再次运行程序，可以发现程序异常终止了： Terminating app due to uncaught exception '这是一个自定义的异常', reason: 'why exception' *** First throw call stack: ( 0 CoreFoundation 0x000000011235612b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000011149df41 objc_exception_throw + 48 2 CoreFoundation 0x0000000112356079 -[NSException raise] + 9 3 objective_c_language 0x000000010e573ba4 -[AssertTableViewController creatNSException] + 356 4 objective_c_language 0x000000010e57320c -[AssertTableViewController tableView:didSelectRowAtIndexPath:] + 364 5 UIKit 0x0000000112bf3839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 6 UIKit 0x0000000112bf3a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 7 UIKit 0x0000000112abcd59 _runAfterCACommitDeferredBlocks + 318 8 UIKit 0x0000000112aabbb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 9 UIKit 0x0000000112adb0e0 _afterCACommitHandler + 137 10 CoreFoundation 0x00000001122f8c07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 11 CoreFoundation 0x00000001122f8b5e __CFRunLoopDoObservers + 430 12 CoreFoundation 0x00000001122dd124 __CFRunLoopRun + 1572 13 CoreFoundation 0x00000001122dc889 CFRunLoopRunSpecific + 409 14 GraphicsServices 0x0000000116cc99c6 GSEventRunModal + 62 15 UIKit 0x0000000112ab15d6 UIApplicationMain + 159 16 objective_c_language 0x000000010e609aef main + 111 17 libdyld.dylib 0x00000001155edd81 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException 那么，我们能让我们的程序不异常终止嘛？我们这时该如何做呢？ 2.3、捕获异常 NSUncaughtExceptionHandler 因为某个NSException 导致程序 Crash 的，只有拿到这个NSException ，获取它的reason 、name 、callStackSymbols 信息，才能确定出问题的程序位置。Apple 提供了 NSSetUncaughtExceptionHandler()函数去获取NSException的异常，注册即可捕获异常信息： typedef void NSUncaughtExceptionHandler(NSException *exception); //指向顶级错误处理函数的指针，我们可以在程序终止之前执行最后一次记录 FOUNDATION_EXPORT NSUncaughtExceptionHandler * _Nullable NSGetUncaughtExceptionHandler(void); //设置顶层错误处理函数，我们可以在程序终止之前执行最后一次记录,我们常用这个C 函数来收集 App 的崩溃信息 FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * _Nullable); 我们在程序启动时加上一个异常捕获监听，然后处理程序崩溃时的回调动作，核心代码如下： @implementation AppDelegate //获取app信息 NSString * const appInfo(void) { NSString *appInfo = [NSString stringWithFormat:@\"App : %@ %@(%@)\\nDevice : %@\\niOS Version : %@ %@\\n\", [[NSBundle mainBundle] objectForInfoDictionaryKey:@\"CFBundleDisplayName\"], [[NSBundle mainBundle] objectForInfoDictionaryKey:@\"CFBundleShortVersionString\"], [[NSBundle mainBundle] objectForInfoDictionaryKey:@\"CFBundleVersion\"], [UIDevice currentDevice].model, [UIDevice currentDevice].systemName, [UIDevice currentDevice].systemVersion ]; return appInfo; } ///获取日志文件路径 NSString * const errorLogPath(void){ return [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"errorLog\"]; } ///获取异常崩溃信息 void UncaughtExceptionHandler(NSException *exception){ NSArray *callStack = [exception callStackSymbols];//异常的堆栈信息 NSString *reason = [exception reason];//异常原因 NSString *name = [exception name];//异常名称 NSString *content = [NSString stringWithFormat:@\"========异常错误报告========\\nappinfo:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",appInfo(),name,reason,[callStack componentsJoinedByString:@\"\\n\"]]; NSLog(@\"content -------- %@\",content); //将错误日志保存到本地，在合适的时机上传至业务服务器 NSMutableArray *array = [NSMutableArray arrayWithContentsOfFile:errorLogPath()]; [array insertObject:content atIndex:0]; [array writeToFile:errorLogPath() atomically:YES]; } - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler); return YES; } @end 2.4、Single 异常/中断 用于处理内存访问错误、内存重复释放等错误，这些错误发送的Single，我们称之为 Single 异常。对这些异常采用上文的NSSetUncaughtExceptionHandler()函数处理是无效的，我们需要利用 UNIX标准的 Single 机制，注册 Single 等信号发生时的处理函数，在该函数中，我们可以输出堆栈信息、版本信息。 核心代码如下所示： void MySingleHandle(int single) { NSMutableString *string = [[NSMutableString alloc] init]; [string appendString:@\"Stack:\\n\"]; void *callstack[128]; int i ,frames = backtrace(callstack,128); char ** str = backtrace_symbols(callstack, frames); for (i = 0; i 其中：函数int backtrace(void**,int) 与 函数 char** backtrace_symbols(void* const*,int)在 execinfo.h文件声明 2.5、Crash 分析 上文我们讲述了如何收集异常信息。我们收集崩溃日志的最终目的是分析和解决崩溃，找出崩溃原因，积累经验，提升产品质量。 我们来分析一份标准的iOS崩溃日志，该日志由：进程信息、基本信息、异常信息、线程回溯、线程状态、动态库等几部分组成。 // ------------ 1、进程信息 ------------ Incident Identifier: 8CB6514E-4F90-B66F-4BF7F5DF703E CrashReporter Key: 69bc374aa65c7f951d99872940cece2c0 Hardware Model: iPhone9,1 Process: QQ [13549] Path: /private/var/containers/Bundle/Application/E5603EE4-DD98-4C09-ACC3-DCE3D820D2E7/qq.app/qq Identifier: com.qq.iphoneclient Version: 10.1.30.300 (10.1.30) Code Type: ARM-64 (Native) Role: Non UI Parent Process: launchd [1] Coalition: com.qq.iphoneclient [4218] // ------------ 2、基本信息 ------------ Date/Time: 2018-08-20 21:09:43.2632 +0800 Launch Time: 2018-08-20 21:09:34.3936 +0800 OS Version: iPhone OS 11.3.3 (14G60) Report Version: 104 // ------------ 3、异常信息 ------------ Exception Type: EXC_CRASH (SIGKILL) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d Triggered by Thread: 0 Filtered syslog: None found Last Exception Backtrace: 0 CoreFoundation 0x1836e2fe0 __exceptionPreprocess + 124 1 libobjc.A.dylib 0x182144538 objc_exception_throw + 55 2 CoreFoundation 0x1836e2f28 +[NSException raise:format:] + 115 3 Foundation 0x18410ee78 -[NSThread start] + 127 4 WeChat 0x1026e89b4 0x100014000 + 40716724 5 WeChat 0x1025c14a4 0x100014000 + 39507108 6 UIKit 0x18993aec8 -[UISearchDisplayController setActive:animated:] + 511 ... // ------------ 4、线程回溯 ------------ Thread 0 name: Dispatch queue: com.apple.main-thread // ------------ 5、堆栈信息 ------------ Thread 0 Crashed: 0 libsystem_malloc.dylib 0x0000000182713d74 szone_size + 192 1 libsystem_malloc.dylib 0x0000000182713a94 free + 120 2 CoreFoundation 0x00000001835ca0d4 -[__NSDictionaryI dealloc] + 180 3 CoreText 0x000000018636e6f8 -[CTFeatureSetting dealloc] + 44 4 CoreFoundation 0x00000001836d29ac common_removeAllObjects + 156 5 CoreFoundation 0x00000001835c69f0 -[__NSArrayM dealloc] + 28 6 CoreFoundation 0x0000000183719174 __CFBasicHashDrain + 284 7 CoreFoundation 0x0000000183692c28 _CFRelease + 216 ... Thread 1: 0 libsystem_kernel.dylib 0x00000001826dce1c __psynch_cvwait + 8 1 libsystem_pthread.dylib 0x00000001827a4814 _pthread_cond_wait + 640 2 Matrix 0x00000001051765b0 0x105110000 + 419248 ... // ------------ 6、线程状态 ------------ Thread 0 crashed with ARM Thread State (64-bit): x0: 0x0000000000000000 x1: 0x0000000000000000 x2: 0x0000000000000000 x3: 0x0000000127534067 x4: 0x0000000182137b07 x5: 0x000000016fde6b30 x6: 0x000000000000006e x7: 0xffffffffffffffec x8: 0x0000000008000000 x9: 0x0000000004000000 x10: 0x000000000000000b x11: 0x000000000000000b x12: 0x0000000000000010 x13: 0x000000018392dc0e x14: 0x00000000ffffffeb x15: 0x0000000000000000 ... // ------------ 7、动态库信息 ------------ Binary Images: 0x104964000 - 0x104997fff dyld arm64 /usr/lib/dyld 0x1049ec000 - 0x104cc7fff TXLiteAVSDK_Smart_No_VOD arm64 /var/containers/Bundle/Application/E67E2E70-AEFB-49C2-8006-BBBE48F858E0/qq.app/Frameworks/TXLiteAVSDK_Smart_No_VOD.framework/TXLiteAVSDK_Smart_No_VOD 0x105110000 - 0x1051e3fff Matrix arm64 /var/containers/Bundle/Application/E67E2E70-AEFB-49C2-8006-BBBE48F858E0/qq.app/Frameworks/Matrix.framework/Matrix 0x1059d4000 - 0x105a4bfff GPUImage arm64 /var/containers/Bundle/Application/E67E2E70-AEFB-49C2-8006-BBBE48F858E0/qq.app/Frameworks/GPUImage.framework/GPUImage ... 2.5.1、进程信息 我们在上文的崩溃信息，可以看到相关崩溃进程信息： Incident Identifier：Crash 的唯一标识符 CrashReporter Key：映射到设备的唯一 key ，如果多个 Crash 拥有相同的 key，说明这系列 Crash 只发生在一个或者少数几个设备上。 Hardware Model：设备类型。如果很多 Crash log 都来自相同的设备，说明该应用在特定的设备上存在问题。 Process：应用的名称，里面的数字(QQ [13549])是 Crash 时的 PID。 Path：应用在手机上的路径 Identifier：应用的 Bundle ID Version： 应用的版本号 Code Type：代码类型 Role：在停止的生活task_role被分配的进程。 Parent Process： Coalition： 2.5.2、基本信息 崩溃设备基本信息，包含闪退发生的日期与时间、设备的iOS版本等 Date/Time：Crash 发生的时间 Launch Time ：App 启动的时间 OS Version ： iOS版本，如iPhone OS 10.3.3 (14G60)，10.3.3是系统版本，14G60是 Build 号，每个系统版本可能对应多个 Build 号。 Report Version 2.5.3、异常信息 Crash 时异常类型、异常码和抛出异常的线程等信息。 Exception Type ：异常类型 Exception Subtype ：可读的Exception Codes的名称 Exception Codes ：异常码 Termination Signal ： Termination Reason ：当进程被终止时的原因及信息 Terminating Process ： Triggered by Thread ：异常发生的线程 2.5.4、 常见异常码Exception Codes code 含义 0x8badf00d watchDog超时，意为“ate bad food” 0xdead10cc 死循环 0xdeadfall 用户强制退出，意为“dead fall” 0xbaaaaaad 用户按住 Home 键和音量键，获取当前内存状态，不代表崩溃 0xbad22222 VoIP 应用被 iOS 干掉 0xc00010ff 因为太烫了被干掉，意为“coll off” 0xdead10cc 在后台时仍然占据系统资源（比如通信录）被干掉，意为“dead lock” 2.5.5、 常见异常类型Exception Type 异常类型Exception Type，我们经常遇到的 SEGV(Segmentation Violation ，段错误)，表明内存操作不当，比如访问一个没有权限的内存地址： Single 含义 EXC_BAD_ACCESS SIGSEGV 内存使用错误，例如：1、访问无效内存地址，比如访问Zombie对象；2、尝试往只读区域写数据；3、解引用空指针；4、使用未初始化的指针；5、栈溢出；6、再次调用已经被释放的对象 EXC_CRASH SIGABRT 收到Abort信号，可能自身调用absort()或者收到外部发来的信号；比如NSDictionary传入nil产生的crash SIGBUS 总线错误，与SIGSEGV不同的是：SIGSEGV访问的是无效地址（虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（如地址对齐问题） SIGILL 尝试执行非法指令，可能不被识别或者没有权限 SIGFPE floating point error，数学计算问题，比如除零操作 SIGPIPE 管道另一端没有进程接手数据 SIGTERM 程序结束信号，与SIGKILL不同的是：该信号可以被堵塞和处理。通常用来要求程序自己正常退出。 2.5.6、线程回溯 线程回溯，提供应用中所有线程的回溯日志 2.5.7、堆栈信息 分析 Crash 最重要的信息，可以帮助我们快速定位 Crash位置与原因，这些信息都保存在 .dSYM 文件中。格式为：frame 号 + 库名 + 函数调用地址 + 函数地址起始行数 + 执行到的行数。 我们以上述日志为例来分析： Frame 库名 函数调用地址 函数地址起始行数 执行到的行数 0 libsystem_malloc.dylib 0x0000000182713d74 szone_size + 192 1 libsystem_malloc.dylib 0x0000000182713a94 free + 120 2 CoreFoundation 0x00000001835ca0d4 -[__NSDictionaryI dealloc] + 180 3 CoreText 0x000000018636e6f8 -[CTFeatureSetting dealloc] + 44 2.5.8、线程状态 Crash 时寄存器中的值，一般可忽略 2.5.9、动态库信息 包括动态库名称、UUID、模块起始地址、模块结束地址、指令集种类、安装路径等信息，在符号化时需要用到 2.6、NSAssertionHandler @interface NSAssertionHandler : NSObject { @private void *_reserved; } //返回与当前线程关联的对象；如果没有与当前线程相关联的NSAssertionHandler，此方法将创建一个并将其分配给该线程 @property (class, readonly, strong) NSAssertionHandler *currentHandler; //使用 NSLog 记录一条错误消息，其中包含失败方法的名称，对象的类名称，源文件的名称和行号 - (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(nullable NSString *)format,... ; //使用 NSLog 记录包含函数名称，文件名称和行号的错误消息 - (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(nullable NSString *)format,... ; @end 我们看到 NSException.h 文件里还有个 NSAssertionHandler 类，继承 NSObject ，那么它是干什么用的呢？NSAssertionHandler会自动创建对象来处理错误的断言 我们来看看 NSException.h 中的一段 NSAssert 函数的宏定义： #define NSAssert(condition, desc, ...) \\ do { \\ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \\ if (__builtin_expect(!(condition), 0)) { \\ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \\ __assert_file__ = __assert_file__ ? __assert_file__ : @\"\"; \\ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \\ object:self file:__assert_file__ \\ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \\ } \\ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \\ } while(0) Foundation 框架的断言函数 NSAssert 是在 Objective-C 代码中启用断言创建操作的宏。每个断言宏都会对条件求值，如果得到的值为假，就会向 NSAssertionHandler 实例发送一个描述失败情况的字符串(并且可能在该字符串中添加printf风格的参数)。NSAssertionHandler 是一个 Foundation 框架类，用于处理获得假值的断言，而且每个程序线程都拥有本身的 NSAssertionHandler 对象。因此，当Foundation 框架断言宏的求值为假时，就会将错误情况描述发送给当前线程的 NSAssertionHandler 对象，该对象会记录错误，并抛出使程序终止的异常(确切的说是一个 NSInternalInconsistencyException 实例)。NSAssertionHandler 实例通常不是以编程方式创建的，而是由断言函数创建的。 也就是说，NSAssertionHandler实例是自动创建的，用于处理错误断言。如果 NSAssert和NSCAssert条件为假，会向 NSAssertionHandler 实例发送一个表示错误的字符串。每个线程都有它自己的NSAssertionHandler实例。 我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。 3、断言 Assert 断言是一种在代码中检查某个情况存在的语句。断言用于验证运行时的假设，如果假设不成立，就应该终止程序。通过编译器指令可以禁用断言，因此只应使用断言检查编程和语义错误，不能使用它检查非法用户输入信息等错误。 在代码中添加断言语句，是检测和纠正 bug 的最高效、最快捷的途径。断言语句还可以描述程序的逻辑，因而可以提高程序的可维护性 每个断言都含有一个布尔表达式，执行断言操作后该表达式应获得真值。如果该表达式没有获得真值，系统就会抛出错误。通过验证该表达式的结果，断言可以确认你对程序行为的假设，增强你对程序的信息 3.1、什么是断言？ 前面说了那么多断言的概念，那么在 Objective-C 语言中到底什么是断言呢？断言就是对NSAssert 等函数的使用，断言就是 宏定义， 3.1.1 断言函数 Foundation 框架提供的断言函数： 断言函数 描述 NSAssert 如果对指定条件的求值为NO（假），就为Objective-C方法生成断言。其参数包括条件表达式和描述错误的格式化字符串（不带有格式限定符） NSAssert1 与 NSAssert 函数类似，其参数包括条件表达式、格式化字符串（带有一个格式限定符）和一个将会被插入格式化字符串中的参数 NSAssert2、NSAssert3、NSAssert4、NSAssert5 与NSAssert 函数类似，它们的参数包括条件表达式、格式化字符串（带有2、3、4、5个格式限定符）和2、3、4、5个将会被插入格式化字符串中的参数 NSParameterAssert 为 Objective-C 函数的参数生成断言。其参数是函数参数的条件表达式 NSCAssert 如果对指定条件的求值为NO（假），就为Objective-C函数生成断言。其参数包括条件表达式和描述错误的格式化字符串（不带有格式限定符） NSCAssert1 与 NSCAssert函数类似，其参数包括条件表达式、格式化字符串（带有一个格式限定符）和一个将会被插入格式化字符串中的参数 NSCAssert2、NSCAssert3、NSCAssert4、NSCAssert5 与 NSCAssert 函数类似，它们的参数包括条件表达式、格式化字符串（带有2、3、4、5个格式限定符）和2、3、4、5个将会被插入格式化字符串中的参数 NSCParameterAssert 为 Objective-C 函数的参数生成断言。其参数是函数参数的条件表达式 可以看到，总共有两种类型的断言函数：NSAssert与 NSCAssert，那么它俩到底有何区别呢？现在我们去看下它们的定义 3.1.2 断言宏 我们来看看NSAssert函数内部实现： #define NSAssert(condition, desc, ...) \\ do { \\ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \\ if (__builtin_expect(!(condition), 0)) { \\ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \\ __assert_file__ = __assert_file__ ? __assert_file__ : @\"\"; \\ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \\ object:self file:__assert_file__ \\ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \\ } \\ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \\ } while(0) 我们再来看看NSCAssert函数内部实现： #define NSCAssert(condition, desc, ...) \\ do { \\ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \\ if (__builtin_expect(!(condition), 0)) { \\ NSString *__assert_fn__ = [NSString stringWithUTF8String:__PRETTY_FUNCTION__]; \\ __assert_fn__ = __assert_fn__ ? __assert_fn__ : @\"\"; \\ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \\ __assert_file__ = __assert_file__ ? __assert_file__ : @\"\"; \\ [[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ \\ file:__assert_file__ \\ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \\ } \\ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \\ } while(0) 从它们的宏定义看出：NSAssert 宏函数只能在Objective-C方法中使用，_cmd和 self与运行时有关。NSCAssert宏函数只能在C函数中使用 Foundation 框架的断言函数是在 Objective-C 代码中启用断言创建操作的宏。每个断言宏都会对条件求值，如果得到的值为假，就会向NSAssertionHandler 实例发送一个描述失败情况的字符串(并且可能在该字符串中添加printf风格的参数)。NSAssertionHandler 是一个Foundation 框架类，用于处理获得假值的断言，而且每个程序线程都拥有本身的 NSAssertionHandler对象。因此，当Foundation框架断言宏的求值为假时，就会将错误情况描述发送给当前线程的 NSAssertionHandler 对象，该对象会记录错误，并抛出使程序终止的异常(确切的说是一个 NSInternalInconsistencyException 实例)。NSAssertionHandler 实例通常不是以编程方式创建的，而是由断言函数创建的。 现在我们弄清了NSAssert与 NSCAssert 两对函数的区别，那么NSAssert与 NSParameterAssert 有何区别呢？NSCAssert 与 NSCParameterAssert又有何区别呢？ 3.1.3 NSAssert 与 NSParameterAssert 的区别 NSAssert 用于条件断言；而 NSParameterAssert用于方法内部参数是否存在的断言 3.2、可使用断言的情况 内部不变：对程序行为的假设。该假设通畅由代码中的注释指明，但* 也可以将之记录到程序文档中并在运行程序时使用断言进行验证。 控制流不变：对控制流的假设，明确表明控制流的范围。 先决条件：在调用方法前必须为真的条件。 后置条件：调用方法后必须为真的条件 类不变：对于所有类实例来说，必须为真的条件 3.2.1、下面看一个通过断言表达内部不变的例子： - (void)assertMethod:(NSInteger)value { if (value > 0) { } else { //值必须非正数 NSAssert((value 如果该条件没有得到满足，程序就会抛出相应的异常： Assertion failure in -[AssertTableViewController assertMethod:], AssertTableViewController.m:72 Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'value 是无效的，它必须是非正数' *** First throw call stack: ( 0 CoreFoundation 0x00000001134f812b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000011263ff41 objc_exception_throw + 48 2 CoreFoundation 0x00000001134fd2f2 +[NSException raise:format:arguments:] + 98 3 Foundation 0x000000010f1fcd69 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 193 4 objective_c_language 0x000000010d54b5f2 -[AssertTableViewController assertMethod:] + 290 5 objective_c_language 0x000000010d54b444 -[AssertTableViewController tableView:didSelectRowAtIndexPath:] + 148 6 UIKit 0x00000001103c8839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 7 UIKit 0x00000001103c8a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 8 UIKit 0x0000000110291d59 _runAfterCACommitDeferredBlocks + 318 9 UIKit 0x0000000110280bb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 10 UIKit 0x00000001102b00e0 _afterCACommitHandler + 137 11 CoreFoundation 0x000000011349ac07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 12 CoreFoundation 0x000000011349ab5e __CFRunLoopDoObservers + 430 13 CoreFoundation 0x000000011347f124 __CFRunLoopRun + 1572 14 CoreFoundation 0x000000011347e889 CFRunLoopRunSpecific + 409 15 GraphicsServices 0x0000000115c139c6 GSEventRunModal + 62 16 UIKit 0x00000001102865d6 UIApplicationMain + 159 17 objective_c_language 0x000000010d5e0f4f main + 111 18 libdyld.dylib 0x0000000114537d81 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException //NSInternalInconsistencyException 是当内部断言失败（如使用NSAssert函数）并表明代码出现了意外情况时引发的异常 3.2.2、使用NSParameterAssert函数检查方法的参数值 - (void)readFile:(NSString *)filePath { //文件路径不能为空 NSParameterAssert(filePath != nil); } Assertion failure in -[AssertTableViewController readFile:], AssertTableViewController.m:77 Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid parameter not satisfying: filePath != nil' *** First throw call stack: ( 0 CoreFoundation 0x000000010ce1612b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000010bf5df41 objc_exception_throw + 48 2 CoreFoundation 0x000000010ce1b2f2 +[NSException raise:format:arguments:] + 98 3 Foundation 0x0000000108b1ad69 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 193 4 objective_c_language 0x0000000106e695c9 -[AssertTableViewController readFile:] + 297 5 objective_c_language 0x0000000106e6931d -[AssertTableViewController tableView:didSelectRowAtIndexPath:] + 205 6 UIKit 0x0000000109ce6839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 7 UIKit 0x0000000109ce6a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 8 UIKit 0x0000000109bafd59 _runAfterCACommitDeferredBlocks + 318 9 UIKit 0x0000000109b9ebb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 10 UIKit 0x0000000109bce0e0 _afterCACommitHandler + 137 11 CoreFoundation 0x000000010cdb8c07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 12 CoreFoundation 0x000000010cdb8b5e __CFRunLoopDoObservers + 430 13 CoreFoundation 0x000000010cd9d124 __CFRunLoopRun + 1572 14 CoreFoundation 0x000000010cd9c889 CFRunLoopRunSpecific + 409 15 GraphicsServices 0x000000010f5319c6 GSEventRunModal + 62 16 UIKit 0x0000000109ba45d6 UIApplicationMain + 159 17 objective_c_language 0x0000000106efef2f main + 111 18 libdyld.dylib 0x000000010de55d81 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException 4、异常处理 Objective-C 提供了在程序运行期间处理异常情况的机制。异常情况可能是无法恢复的编程错误，也可能是无法恢复的运行时错误，如未实现的方法编程错误和超出范围的集合访问运行时错误。编译器指令 @try、@catch()、@throw和@finally为异常处理提供了运行时系统支持，而 NSException 类可以封装异常的信息。 捕获异常时，一定要注意将@try块内所创立的对象清理干净，否则会造成内存泄露 当出现异常时，程序控制流程会切换到局部异常处理程序。程序栈框架在异常出现的时间点和异常被捕获并处理的时间点之间的内容也会被取出。因此，不是以 ARC 管理的资源，可能没有以适当方式清除。尤其是，Foundation框架API不是异常安全的，因此在异常处理域中使用这些API并且程序抛出异常时，他们可能会泄露内存或含有损坏的内容。因而，原则上当出现异常时，不应尝试进行恢复，应迅速退出程序。 @try { //可能抛出异常的代码 } @catch(NSException *exception) { //处理异常的代码 } @finally { //释放资源的代码 } @try、@catch()和@finally指令构成了一种控制结构，可以将这种控制结构应用于异常处理逻辑的代码。@try指令可以定义可能抛出异常的语句块（也称为异常处理域）。@catch()指令可以定义用于处理其前面的@try语句块中异常的语句块。@catch()指令的参数是局部抛出的异常对象，通常为NSException对象。@finally可以在@try语句块后面定义一个语句块，不论程序是否抛出异常该语句块都会被立即执行。@finally语句块通常被用于执行与其对相应的@try语句块和@catch()语句块的清楚行动（释放资源等） 现在，我们写一个数组越界的异常程序： - (void)handleExceptionArray { NSArray *array = @[@\"1\"]; NSLog(@\"array[2] --- %@\",array[2]); } 这时，我们运行程序，肯定异常终止： Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSSingleObjectArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 0]' *** First throw call stack: ( 0 CoreFoundation 0x000000010b9d112b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000010ab18f41 objc_exception_throw + 48 2 CoreFoundation 0x000000010ba1140f -[__NSSingleObjectArrayI objectAtIndex:] + 111 3 objective_c_language 0x0000000105a2422a -[AssertTableViewController handleExceptionArray] + 122 4 objective_c_language 0x0000000105a23d17 -[AssertTableViewController tableView:didSelectRowAtIndexPath:] + 311 5 UIKit 0x00000001088a1839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 6 UIKit 0x00000001088a1a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 7 UIKit 0x000000010876ad59 _runAfterCACommitDeferredBlocks + 318 8 UIKit 0x0000000108759bb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 9 UIKit 0x00000001087890e0 _afterCACommitHandler + 137 10 CoreFoundation 0x000000010b973c07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 11 CoreFoundation 0x000000010b973b5e __CFRunLoopDoObservers + 430 12 CoreFoundation 0x000000010b958124 __CFRunLoopRun + 1572 13 CoreFoundation 0x000000010b957889 CFRunLoopRunSpecific + 409 14 GraphicsServices 0x000000010e0ec9c6 GSEventRunModal + 62 15 UIKit 0x000000010875f5d6 UIApplicationMain + 159 16 objective_c_language 0x0000000105ab9e5f main + 111 17 libdyld.dylib 0x000000010ca10d81 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException 通过控制台，我们可以看到：Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSSingleObjectArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 0]'也就是数组越界了，导致程序闪退。 然后，我们使用@try、@catch()和@finally指令处理一下这段代码： - (void)handleExceptionArray { NSArray *array = @[@\"1\"]; @try { NSLog(@\"array[2] --- %@\",array[2]); } @catch(NSException *exception) { NSLog(@\"exception == \\n %@\",[self dictionaryRepresentationWithError:exception]); } @finally { } } 这时候运行程序，就不会再异常终止了，我们打印了捕获的异常，可以看到异常的名称、起因等 { name = NSRangeException;//当尝试访问超出某些数据的范围时引发的异常 reason = \"*** -[__NSSingleObjectArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 0]\"; userInfo = \"\"; } 那么，前面提到的@throw又有什么用呢？我们在适当的位置写上这句代码: @catch(NSException *exception) { NSLog(@\"exception == \\n %@\",[self dictionaryRepresentationWithError:exception]); @throw ; } 运行程序后，又再次异常终止： { name = NSRangeException; reason = \"*** -[__NSSingleObjectArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 0]\"; userInfo = \"\"; } Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSSingleObjectArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 0]' *** First throw call stack: ( 0 CoreFoundation 0x000000010a56a12b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x00000001096b9f41 objc_exception_throw + 48 2 CoreFoundation 0x000000010a5aa40f -[__NSSingleObjectArrayI objectAtIndex:] + 111 3 objective_c_language 0x0000000104506fca -[AssertTableViewController handleExceptionArray] + 122 4 objective_c_language 0x0000000104506ab7 -[AssertTableViewController tableView:didSelectRowAtIndexPath:] + 311 5 UIKit 0x0000000107442839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 6 UIKit 0x0000000107442a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 7 UIKit 0x000000010730bd59 _runAfterCACommitDeferredBlocks + 318 8 UIKit 0x00000001072fabb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 9 UIKit 0x000000010732a0e0 _afterCACommitHandler + 137 10 CoreFoundation 0x000000010a50cc07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 11 CoreFoundation 0x000000010a50cb5e __CFRunLoopDoObservers + 430 12 CoreFoundation 0x000000010a4f1124 __CFRunLoopRun + 1572 13 CoreFoundation 0x000000010a4f0889 CFRunLoopRunSpecific + 409 14 GraphicsServices 0x000000010cc5c9c6 GSEventRunModal + 62 15 UIKit 0x00000001073005d6 UIApplicationMain + 159 16 objective_c_language 0x000000010459cd8f main + 111 17 libdyld.dylib 0x000000010b587d81 start + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException 通过控制台，我们可以分析：@catch()确实捕捉到了异常，但是又给抛出了。 使用@throw指令可以抛出异常，默认为 NSException 对象，但我们也可以抛出其它类型的对象。 5、系统适配 在 iOS 13 中部分方法属性不允许使用 -valueForKey:、-setValue:forKey: 来获取或者设置私有属性，具体表现为在运行时会直接崩溃，并提示以下崩溃信息： Terminating app due to uncaught exception 'NSGenericException', reason: 'Access to UISearchBar's _searchField ivar is prohibited. This is an application bug' // 崩溃 api UITextField *textField = [searchBar valueForKey:@\"_searchField\"]; // 替代方案 1，使用 iOS 13 的新属性 searchTextField searchBar.searchTextField // 崩溃 api [searchBar setValue:@\"取消\" forKey:@\"_cancelButtonText\"]; Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"iOS开发/杂记/刘海屏适配.html":{"url":"iOS开发/杂记/刘海屏适配.html","title":"刘海屏适配","keywords":"","body":"判断是否是刘海屏 判断是否是刘海屏 /* iPhone8 Plus UIEdgeInsets: {20, 0, 0, 0} * iPhone8 UIEdgeInsets: {20, 0, 0, 0} * iPhone XR UIEdgeInsets: {44, 0, 34, 0} * iPhone XS UIEdgeInsets: {44, 0, 34, 0} * iPhone XS Max UIEdgeInsets: {44, 0, 34, 0} */ BOOL isIPhoneNotchScreen(void) { if (__IPHONE_OS_VERSION_MAX_ALLOWED 0 ? YES : NO; } 获取导航栏高度 CGFloat getNavigationBarHeight(void) { if (__IPHONE_OS_VERSION_MAX_ALLOWED 获取tabBar高度 CGFloat getTabBarHeight(void) { if (__IPHONE_OS_VERSION_MAX_ALLOWED Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"iOS开发/杂记/获取WIFI信息.html":{"url":"iOS开发/杂记/获取WIFI信息.html","title":"获取WIFI信息","keywords":"","body":"获取WIFI信息 苹果开发者中心，相应项目的 Access WiFi Information 选项 Access WiFi Information Entitlement 要使用此功能，与iOS 12或更高版本链接的应用必须启用Xcode中的Access WiFi Information功能。有关更多信息，请参见。与iOS 12或更高版本链接时，总是在没有权利的情况下调用此函数。Access WiFi Information EntitlementNULL iOS13获取Wi-Fi信息步骤 1、首先开启定位权限 2、Xcode开启WIFi权限 1.39 KB 2.1% 13 main 1.39 KB 2.1% 13 __73+[ZMKDeviceAccessManager requestAccessForAudioAndVideoCompletionHandler:]_block_invoke 1.39 KB 2.1% 13 __42-[ZMkGotoClassroom requestClassroomAccess]_block_invoke 1.39 KB 2.1% 13 +[ZMNetWorkTool checkNetWorkStatusWithEnterClassBlock:] 1.39 KB 2.1% 13 +[ZMNetWorkTool beginCheckNetWorkWithEnterClassBlock:] 1.39 KB 2.1% 13 -[ZMNetWorkStatusView initWithEnterBlock:] 1.39 KB 2.1% 13 -[ZMNetWorkStatusView loadCurrentNetInfo] 1.39 KB 2.1% 13 -[ZMNetWorkStatusView loadWifiName] CaptiveNetwork __CNCopyCurrentNetworkInfo - (NSString *)loadWifiName{ /// 所有支持的网卡列表 NSArray *interfaceNames = CFBridgingRelease(CNCopySupportedInterfaces()); NSDictionary *SSIDInfo; for (NSString *interfaceName in interfaceNames) { /// 拿到有效网卡的信息（SSID，BSSID） SSIDInfo = CFBridgingRelease(CNCopyCurrentNetworkInfo((__bridge CFStringRef)interfaceName)); BOOL isNotEmpty = (SSIDInfo.count > 0); if (isNotEmpty) { break; } } NSString *SSID = SSIDInfo[@\"SSID\"]; return SSID; } /** CNCopyCurrentNetworkInfo() 获取的网卡信息 { BSSID = \"44:6b:2a:1d:45:f1\"; SSIDDATA = \"office\"; SSID = \"office\"; } */ /** @discussion 应用至少满足下述一个条件时，函数才会返回有效的网卡信息： * 1、应用如果使用 CoreLocation API，则必须拥有用户访问位置的授权 * 2、应用使用 NEHotspotConfiguration API 来配置当前的 Wi-Fi 网络 * 3、正处于启用状态的 VPN 应用 * 4、应用开启 NEDNSSettingsManager 配置 * * @note 1、iOS 12.0 以上必须有\"com.apple.developer.networking.wifi-info\"授权 * @note 2、iOS 13.0 及更早的系统，如果不满足上述至少一条要求，该函数返回 NULL * @note 3、如果遇到错误，返回NULL；必须释放返回值； */ CFDictionaryRef __nullable CNCopyCurrentNetworkInfo(CFStringRef interfaceName) API_DEPRECATED_WITH_REPLACEMENT(\"[NEHotspotNetwork fetchCurrentWithCompletionHandler:]\", ios(4.1, API_TO_BE_DEPRECATED), macCatalyst(14.0, API_TO_BE_DEPRECATED)) #import /// NEHotspotNetwork 提供了获取当前 Wi-Fi 网络SSID和BSSID的类方法 API_AVAILABLE(ios(9.0), watchos(7.0), macCatalyst(14.0)) API_UNAVAILABLE(macos, tvos) @interface NEHotspotNetwork : NSObject /// Wi-Fi网络的SSID @property (readonly) NSString * SSID API_AVAILABLE(ios(9.0), watchos(7.0), macCatalyst(14.0)) API_UNAVAILABLE(macos, tvos); /// Wi-Fi网络的 BSSID @property (readonly) NSString * BSSID API_AVAILABLE(ios(9.0), watchos(7.0), macCatalyst(14.0)) API_UNAVAILABLE(macos, tvos); /** @discussion 应用至少满足下述一个条件时，才会获取当前Wi-Fi网络的SSID和BSSID * 1、应用如果使用 CoreLocation API，则必须拥有用户访问位置的授权 * 2、应用使用 NEHotspotConfiguration API 来配置当前的 Wi-Fi 网络 * 3、正处于启用状态的 VPN 应用 * 4、应用开启 NEDNSSettingsManager 配置 * * @note 1、如果不满足上述至少一条要求，该方法返回 nil * @note 2、如果没有\"com.apple.developer.networking.wifi-info\"授权，该方法返回 nil * @note 3、该方法异步执行 */ + (void)fetchCurrentWithCompletionHandler:(void (^)(NEHotspotNetwork * __nullable currentNetwork))completionHandler API_AVAILABLE(ios(14.0), watchos(7.0), macCatalyst(14.0)) API_UNAVAILABLE(macos, tvos); @end 参考文章： 记 iOS13 CNCopyCurrentNetworkInfo一个哭笑不得的内存泄漏bug CNCopyCurrentNetworkInfo() bug Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"语言篇/C++学习入门篇.html":{"url":"语言篇/C++学习入门篇.html","title":"C++学习入门篇","keywords":"","body":"C++ 学习入门篇 C++ 是 C 的超集，在 C 语言的基础上发展而来，因此 C 语言更加高效！ C++ 是一门面向对象的编程语言！ 1、基础篇 1.1、基本数据类型 C 基本数据类型： 基本类型 ：整型、浮点型、字符型 ； 构造类型 ：数组、结构、枚举、联合； 指针类型 ； 空类型 ； C++ 具有 C 语言的所有基本数据类型，并且多了一个布尔类型：bool:true、false; 1.2、新的初始化方法 C 语言提供的初始化方法 ： /// 复制初始化 int a = 10; C++ 语言提供的初始化方法 ： /// 复制初始化 int a = 10; /// 直接初始化 int a(10); 1.3、随用随定义 C 语言所有变量定义都必须位于函数体最前面 ： { int a = 10; int b = 20; a = a + 3; b = b + a; } C++ 中所有变量随用随定义 ： { int a = 10; a = a + 3; int b = 20; b = b + a; } 1.4、输入输出流 C 语言的 I/O 方式 : 输入过程 : 输入设备 -> 输入流 -> scanf -> 变量； 输出过程 : 变量 -> printf -> 输出流 -> 输出设备 ； C++ 语言的 I/O 方式 ： 输入过程 : 输入设备 -> 输入流 -> cin -> 变量 ； 输出过程 : 变量 -> cout -> 输出流 -> 输出设备 ; /// 输出语法： cout > x; cin >> x >> y; 与 C 语言相比，C++ 的cin与cout的便利： 不用关注占位符； 不用关注数据类型； 不容易出现问题； 1.5、命名空间namespace 命名空间namespace是 C++ 新引入的一个机制，主要是为了解决多个模块间命名冲突的问题，就像现实生活中两个人重名一个道理。 /// 使用命名空间 std using namespace std; C++ 需要用不同的名字区分不同的命名空间！通过不同的命名空间，可以区分具有相同名字的变量，可以区分具有相同名字的函数！ /// 定义命名空间 namespace YLProject { int chapter; void test(); } namespace WLProject { int chapter; void test(); } void demoTest(void) { YLProject::chapter = 10; WLProject::chapter = 20; YLProject::test(); WLProject::test(); } 2、特性篇 2.1、指针 VS 引用 引用即 变量的别名！ 引用不能单独存在，必须有对应的变量名！ 针对别名的操作就是对其本身的操作！ 基本数据类型的引用 { int a = 10; int &b = a; b = 3; } 结构体类型的引用 { Coordinate c1; Coordinate &c2 = c1; c2.latitude = 9.234; c1.longitude = 4.243256; } 指针类型的引用 指针类型的引用：类型 *&指针别名 = 指针； { int m = 90; int *p = &m; int *&q = p; *p = 80; *q = 70; } 引用作函数参数 /// C 语言交换两个变量的值 void quoteFuncCTest(int *a, int *b) { int c = 0; c = *a; *a = *b; *b = c; } /// C++ 使用引用交换两个变量的值 void quoteFuncTest(int &a, int &b) { int c = a; a = b; b = c; } ///测试代码段 { int k1(78),k2(87); quoteFuncCTest(&k1, &k2); quoteFuncTest(k1, k2); } 2.2、#define VS const 与#define相比，const修饰的变量是由类型的！在编译阶段，编译器可以检查const修饰的变量的类型错误，而不会去检查 #define 修饰的变量的类型错误！ 存储类别说明符 const 指明被修饰的变量为只读类型，用于防止变量值被篡改！ 一般而言，声明的一个变量既具有读权限、又具有写权限！ 而使用 const 修饰的变量，仅仅具有读权限！ 为数据安全考虑，编译器允许声明一个只读权限的变量指向一个具有读写权限的变量；而不会允许一个具有读写权限的变量指向一个只读权限的变量！ const与 基本数据类型 { int a = 3;/// 变量 const int b = 5;/// 常量 } 变量名 存储地址 存储内容 a &a 3 b &b 5 const 与 指针类型 const修饰指针要特别注意，共有两种形式： 一种是用来限定指向空间的值不能修改； 另一种是限定指针不可更改。 { int a = 5, b = 10, c = 15; const int *p = &a; /// int const *p = &a; 两种写法完全等价，const 修饰的都是 *p，此时不能通过 *p 来赋值 p = &b; /// 正确，const 修饰的是 *p， *p = 1; // ❌ const 修饰的是 *p，因此 *p 不能修改 int *const k = &b; /// const 修饰 k，此时不能通过 k 来赋值 k = &c; // ❌ 此时 const 修饰 k *k = 100; /// 正确 /// 不能通过指针 m 来修改值，也不能将指针 m 指向它处！ int const *const m = &b; ///完全等价于 const int *const m = &b; } const 与 函数 const修饰函数参数，对参数起限定作用，防止其在函数内部被修改。所限定的函数参数可以是普通变量，也可以是指针变量。 int sum(const int a,const int b) { return a + b; } int max(const int &a,const int &b) { if (a > b) return a; return b; } const 与 引用 { int a = 5; const int &y = a; a = 10; /// 正确 y = 20; /// ❌ } const 小结 const int x = 3; x = 5; /// ❌ int x = 3; const int y = x; y = 5; /// ❌ int x = 3, z = 4; int *const y = &x; y = &z; /// ❌ const int x = 3; const int &y = x; y = 5; /// ❌ /// 注意：变量 x 具有读写权限，指针 y 只具有读权限，允许使用权限小的变量接收权限大的变量 int x = 3; const int *y = &x; *y = 5; /// ❌ /// 注意：变量 x 具有写权限，指针 y 只具有读写权限，不允许使用权限大的变量接收权限小的变量 const int x = 3; int *y = &x; /// ❌ 2.3、函数特性 2.3.1、函数参数默认值 函数参数默认值需要记住两条规则： 有默认值的参数必须在参数列表的最右端； 无实参则用默认值，否则实参覆盖默认值； void func(int a, int b = 10, int c = 15); /// 有默认值的参数必须在参数列表的最右端 void func(int a = 5, int b, int c); /// ❌ void func(int a, int b = 10, int c = 15) { /// 无实参则用默认值，否则实参覆盖默认值 cout 注意：函数默认值建议写在声明处，所有的编译器都可以通过；如果在函数定义处写默认值，部分编译器可能不通过！ 2.3.2、函数重载 函数重载需要满足下述条件： 在相同作用域下； 用同一函数名定义的多个函数； 参数个数和参数类型不同； int max(int a, int b); /// max_int_int int max(int a, int b, int c); /// max_int_int_int double max(double a, double b); /// max_double_double double max(double a, double b, double c); /// max_double_double_double 思考：编译器如何识别重载的函数呢？ 答：编译器会将函数编译为函数名称 + 参数的样子，来区别重载的函数；调用时，编译器根据入参的类型与个数，调用不同的函数！ 2.3.3、内联函数 调用普通函数的五大步骤： 1、调用func()； 2、跳转函数 func()的入口； 3、执行函数 func()； 4、回到主函数的调用处 ； 5、结束func()的调用； 与普通函数相比，在定义上，区别不大！但在调用上，内联函数更加的高效：在编译时将函数体代码和实参代替函数调用语句，少了跳转函数入口、回到主要函数的步骤！ 某些时候，执行函数 func()的消耗时间并不长，但是执行 ②、④ 两个步骤消耗了比较长的时间！此时使用内敛函数，更加高效！使用关键字inline声明一个内联函数！ /// 内敛函数仅是一种编译方式 inline int max(int a, int b){ if (a > b) return a; return b; } 思考: 为什么不把所有的函数声明为内联函数呢？ 内联函数是建议性的，由编译器决定； 逻辑简单，调用频繁的函数建议使用内联函数； 递归函数无法使用内联方式； 2.4、内存管理 内存的本质就是一种由操作系统掌管的内存资源；开发者被允许向系统申请内存资源，同时被要求使用完毕后归还这部分内存资源！ 在 C 语言中使用 void *malloc(size_t size) 函数申请内存资源，使用 void free(void *p)函数归还内存资源； 而 C++ 中使用运算符new申请内存资源，使用运算符delete归还内存资源； { /// 内存的申请与释放 int *p = new int(20); if (p != NULL) { cout 注意：申请内存需要判断是否申请成功；释放内存，需要将指针指向NULL； Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C++学习封装篇.html":{"url":"语言篇/C++学习封装篇.html","title":"C++学习封装篇","keywords":"","body":"C++ 学习封装篇 1、类与对象 类是用户定义的数据类型规范，它详细的描述了如何表示信息以及可对数据执行的操作。 对象是根据类规范创建的实体，就像简单变量是根据类型描述创建的实体一样。 1.1、类的定义 与 实例化对象 1.1.1、 使用关键字 class 定义一个 People 类 class People { }; 1.1.2、数据的封装 C++ 作为一门面向对象的语言，通过 封装 将数据成员与成员函数封装在一个类中；通过 class 定义的类公布其接口。 /// 使用关键字 class 定义一个类 class People { /// 公有成员 public: std::String name; float height; void eat(std::String food); /// 受保护 protected: int age; /// 私有成员 private: float weight; }; 可以使用 访问限定符 public | protected | private 选择暴露或者隐藏某些类的信息！在类中，访问限定符可以使用一个、也可以使用多个！ public： 公有的；可以在外部访问，读写； protected： 受保护的；被修饰的成员不能在外部被访问；只能在类定义内部读写； private： 私有的；被修饰的成员不能在外部被访问；只能在类定义内部读写； 1.1.3、分别在栈中与堆中实例化 People 对象 { /// 栈中实例化对象 People zhangSan; People peos[10]; /// 堆中实例化对象 People *liSi = new People(); People *rens = new People[10]; /// 对象的成员访问 cout height eat(); delete liSi; liSi = NULL; } if (rens != NULL){ cout height 1.2、类内定义与类外定义 成员函数的函数体写在类的定义体之内、还是外面，是有区别的： 类内定义：函数体写在类的定义体之内； 类外定义：函数体写在类的定义体之外；类外定义的函数可以重载； 一般而言，将类的声明与实现分为两个文件： 同文件类外定义：类的定义、与成员函数的实现，都在一个文件中！ 分文件类外定义：类定义在 People.hpp 文件，而成员函数的实现，主要在 People.cpp 文件中！ /// 类外定义的格式 void People::eat(std::String food) { cout 不得不提：对于类内定义的函数体，编译器会优先使用 inline 的方式来编译这些函数；但对于复杂的函数，还是会编译为普通的函数！ 1.3、对象指针 对象指针指向一块堆内存（第一个成员的地址） 堆中内存 ：运算符 new 与函数 malloc() 的区别 : new 会调用默认构造函数; malloc() 仅仅开辟内存，不会初始化这段内存的数据； { ///对象指针 peo 指向一块堆内存 People *liSi = new People; /// new 一个类后面，不加 () 则调用默认构造函数 if (liSi != NULL){ cout name 1.4、this 指针 this 指针就是指向自身数据的指针！ 说的通俗点， this 指针指向其类实例对象的起始地址！ 参数与数据成员同名怎么办？ class People { public: /// 参数与数据成员同名怎么办？ setHeight(float height) { /// 注意：此时编译器无法识别两个 height 的含义 /// 导致无法达到预期的赋值结果 height = height; } private: float height; }; 上述代码中 参数与数据成员同名 ,导致赋值失败！碰见这种情况，我们应该使用this 指针指向自身的数据成员！ class People { public: setHeight(float height) { /// this 指针一般写在容易混淆的地方 this -> height = height; } private: float height; }; 成员函数如何访问到对应的数据成员？ 实例对象的变量存储在栈区或者堆区，而编译的类的二进制文件存储在代码区！当一个类创建多个对象时： 编译器是如何区分哪个对象调用了成员函数 setHeight() 呢？ 编译器是如何在成员函数 setHeight() 中为对应的对象赋值，而没有产生混乱呢？ class People { public: setHeight(T *this, float height) { /// 编译器自动的为每个成员函数的参数列表添加了一个 this 指针！ this -> height = height; } private: float height; }; 编译器自动的为每个成员函数的参数列表添加了一个 this 指针！因此当不同对象调用同一个成员函数时，不会混淆调用者！ this 指针添加到成员员函数的位置！ 添加到第一个位置？最后一个位置？ 打印自身 class People { public: setHeight(float height) { this -> height = height; } /// 通过引用的方式，打印自身 People &printfPeople(){ return *this; } /// 通过指针的方式，打印自身 People *printfPeople(){ return this; } private: float height; }; this 指针总结： this 指针无需用户定义，是编译器自动产生的！ 同一个类的多个对象的this 指针，指向其实例的内存地址！ 当成员函数的参数或临时变量与数据成员同名时，可以使用 this 指针区分同名的数据成员； this 指针也是指针类型，在 64 位编译器下占用 8 个字节的内存！ 2、构造函数与析构函数 内存分区 解释 栈区 int a = 5; int *p = NULL; 堆区 int *q = new int[10]; 全局区 存储全局变量及静态变量 常量区 String str = \"Hello\" 代码区 存储编译之后的二进制代码 2.1、构造函数 构造函数的规则和特点： 构造函数在对象实例化时被自动调用 构造函数与类名同名； 构造函数没有返回值； 构造函数可以有多个重载形式（遵循重载函数的规则）； 构造函数的参数列表，可以有默认值； 实例化一个对象时，仅仅用到一个构造函数； 当用户没有定义构造函数时，编译器自动生成一个构造函数； 2.1.1、无参构造函数 构造函数内部为一些成员变量赋值 class People { People(){ name = \"人类\"; } private: String name; } 2.1.2、有参构造函数 class People { People(String name); private: String name; } People::People(String name){ this -> name = name; } 2.1.3、重载构造函数 class People { People(); People(String name); People(int age, String name = \"狗蛋\"); /// 构造函数也可以有默认参数 public: String name; private: int age; } People::People(){ name = \"人类\"; age = 0; } People::People(String name){ this -> name = name; age = 0; } People::People(int age, String name){ this -> name = name; this -> age = age; } 2.1.4、默认构造函数 在实例化对象时，如果不使用任何参数，则调用的是默认构造函数！ 当构造函数没有参数时，被称为默认构造函数； 当构造函数有参数，但每个参数都有默认值时，也被称为默认构造函数； class People { People(); People(String name = \"狗蛋\"); public: String name; } People::People(){ name = \"人类\"; } People::People(String name){ this -> name = name; } 2.1.5、构造函数初始化列表 推荐使用初始化列表来完成对数据成员的初始化操作！ class People { People():name(\"狗蛋\"),age(10); public: String name; private: int age; } 初始化列表特性： 初始化列表先于构造函数执行； 初始化列表只能用于构造函数； 初始化列表可以同时初始化多个数据成员； 初始化列表存在的必要性 class People { People(){ species = \"人类\"}; /// ❌ const修饰，不能修改 People():species(\"人类\"); ///可以通过初始化列表完成 const 常量的修改 public: const String species; } 2.1.6、拷贝构造函数 定义格式： 类名(const 类名& 变量名) ! class People { People(const People &peo){}; public: }; 拷贝构造函数特性： 如果没有自定义的拷贝构造函数，则系统自动生成一个默认的拷贝构造函数； 当采用直接初始化或复制初始化实例化对象时，系统自动调用拷贝构造函数； 拷贝构造函数的参数时确定的，不能重载； 浅拷贝 class People { public: People(){ this -> age = 10; this -> name = new string(\"堆中申请内存\"); }; /// 浅拷贝 People(const People &peo){ this -> age = peo.age;/// 没毛病 /// 指针 name 指向同一块内存 /// name 时通过 new 运算符申请的块内存，需要在 析构函数 中释放该块内存 /// 两个对象释放同一块内存，会造成内存的过度释放，引起程序崩溃 this -> name = peo.name; }; ~People(){ delete name; } int age; string *name; }; string 的浅拷贝是让两个不同的指针指向同一块空间，而这在析构的时候会出现将一块空间释放两次，程序会崩溃! 因此需要进行深拷贝，即第二个指针开辟和第一个指针一样大小空间，然后将内容复制过去。 深拷贝 class People { public: People(){ this -> age = 10; this -> name = new string(\"堆中申请内存\"); }; People(const People_YL &peo){ this -> age = peo.age; this -> name = new string((*peo.name)); /// 深拷贝 }; ~People(){ delete name; } int age; string *name; }; 2.2、析构函数 对象的生命历程： 申请内存 -> 初始化列表 -> 构造函数 -> 参与运算 -> 析构函数 -> 释放内存！ 申请的内存，最终要归还 如果没有自定义析构函数，则系统自动生成； 析构函数在对象被销毁时，系统自动调用！ 析构函数没有返回值；不允许添加任何参数，也就不会重载！ 析构函数的唯一作用就是释放资源！ 定义格式：~类名() ！ class People { People():species(\"人类\"); ///可以通过初始化列表完成 const 常量的修改 ~People(){}; public: const String species; } 2.2.1、析构函数存在的必要性 class People { People(){ name = new char[20]}; ~People(){ delete []name; }; /// 释放掉堆中内存 public: char *name; } 3、对象数组 实例化对象数组时 每一个对象的构造函数都会被执行； 内存既可以从堆上分配、也可以从栈上分配； 销毁对象数组时 每一个对象的析构函数都会被执行； 堆中实例化的数组，需要手动销毁释放内存； 栈中实例化的数组，系统自动回收内存； class Coordinate { public: Coordinate():longitude(0.0),latitude(0.0){}; double longitude; double latitude; }; ///测试代码段 { Coordinate coor[3];///栈上实例化一个对象数组 coor[0].longitude = 9.12; coor[0].latitude = 105.72; Coordinate *p = new Coordinate[3];///堆上实例化一个对象数组 if (p != NULL) { p[0].longitude = 21.567; p[0].latitude = 56.32543; delete []p; p = NULL; } } 4、对象成员 对象成员：一个对象成为另一个类的数据成员！ 实例化一个对象 A 的时候，如果对象 A 有对象成员 B 、C，那么先执行对象成员 B 、C 的构造函数，再执行 A 的构造函数；销毁对象 A 时，先执行 A 的析构函数，再执行对象成员 C 、B 的析构函数！ class Coordinate { public: Coordinate():x(0.0),y(0.0){}; /// 默认构造函数 Coordinate(double _x, double _y):x(_x),y(_y){}; /// 带有参数的构造函数 double x; double y; }; class Line { public: Line():start(10,20), end(40, 50){}; /// 默认构造函数 Line(double sx, double sy, double ex, double ey):start(sx,sy), end(ex, ey){}; /// 带有参数的构造函数 Coordinate start; Coordinate end; }; ///测试代码段 { Line a1; ///栈上实例化一个对象 /// 先实例化成员 start 、接着实例化成员 end， 最后实例化 Line 对象 /// 释放内存时：先销毁 Line 对象 、接着销毁 end， 最后销毁 start } 4.1、对象成员指针 对象成员指针：对象指针成为另一个类的数据成员！ class Line { public: Line():start(NULL), end(NULL){}; /// 默认构造函数 Line(double sx, double sy, double ex, double ey){ start = new Coordinate(sx, sy); end = new Coordinate(ex, ey); }; /// 带有参数的构造函数 ~Line(){ delete start; start = NULL; delete end; end = NULL; }; Coordinate *start; Coordinate *end; }; 类 Line 中仅有两个成员指针，一个指针在 64 位电脑上占 8 个字节内存，sizeof(Line) 理论上应该占 16 个字节内存！ 4.2、常对象成员与常成员函数 常对象成员 ：const 可以修饰对象成员！ 例子：一条线段一旦构造完毕，就不能再修改它的起始终点位置！ class Coordinate { public: Coordinate():x(0.0),y(0.0){}; Coordinate(double _x, double _y):x(_x),y(_y){}; double x; double y; }; class Line { public: /// 使用构造函数初始化列表为被 const 修饰的数据成员赋值！ Line():start(10,20), end(40, 50){}; Line(double sx, double sy, double ex, double ey):start(sx,sy), end(ex, ey){}; const Coordinate start; const Coordinate end; }; 4.3、常成员函数 常成员函数 ：const 修饰成员函数！ 常成员函数本质是对 this 指针的修饰； 常成员函数中不能修改数据成员的值； class Coordinate { public: Coordinate():x(0.0),y(0.0){}; Coordinate(double _x, double _y):x(_x),y(_y){}; double x; double y; /// 声明的地方写上 const void changeX(double _x) const; }; /// 实现的地方也需要写上 const void Coordinate::changeX(double _x) const { /// error : Cannot assign to non-static data member within const member function 'changeX' this -> x = _x; } 为什么不能在常成员函数中修改数据成员的值？编译器将上述常成员函数编译为下述函数： void Coordinate::changeX(const Coordinate *this, double _x) { /// 通过常指针修改该指针指向的数据，是不被允许的！ this -> x = _x; /// this 指针此时仅具有读权限，没有写权限！ } 4.3.2、重载 常成员函数可以与普通同名函数互为重载 class Coordinate { public: /// 下述函数互为重载 void changeX(double _x); void changeX(double _x) const; }; 当与普通函数互为重载时，什么情况下调用普通函数？什么情况下调用常成员函数？ 普通对象调用普通成员函数； 常对象调用常成员函数； { Coordinate coor; coor.changeX(10);/// 调用普通成员函数 ///在互为重载时：常对象将调用常成员函数 const Coordinate coor1; coor1.changeX(10); } 4.4、常指针与常引用 常对象只能调用常成员函数，不能调用普通成员函数； 普通对象能够调用普通成员函数，也能调用常成员函数； 常指针和常引用都只能调用对象的常成员函数； 一个对象可以有多个常引用！ 5、字符串类 String 字符串库 #include String 的初始化方式 代码 注释 String str str 为空字符串 String str1 = \"A\" 字符串 str1 初始化为 \"A\" String str2(\"B\") 字符串str2 初始化为 \"B\" String str3(str2) 字符串str3 初始化为 str2 的一个副本 String str4(n,'B') 字符串str4 初始化为字符 'B' 的 n 个副本，即 BBB...BBBB String 的常用操作 代码 注释 str.empty() 判 str 是否为空，为空返回 true str.size() 返回 str 中字符的个数 str[n] 返回 str 中位置为 n 的字符（索引从 0 开始） str1 + str2 将两个字符串拼接为新串，返回新串的地址！ str1 = str2 将 str1 的内容替换为 str2 的副本 str1 == str2 判断 str1 与 str2 是否相等 String 的拼接 String str1 = \"Hello\"; String str2 = \"Word\"; String str3 = str1 + str2; String str4 = \"Hello\" + str2; String str5 = \"Hello\" + str2 + \"Word\"; String str6 = \"Hello\" + \"Word\"; /// ❌ 非法操作 注意 : 并不是所有的字符串都可以通过 + 连接的；双引号的字符串之间通过 + 连接，是不合法的！ 对象复制与对象赋值 深拷贝与浅拷贝 对象数组与对象指针 this 指针 const + 对象 -> 常对象 const + 函数 -> 常成员函数 const + 对象成员 -> 常对象成员 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C++学习继承篇.html":{"url":"语言篇/C++学习继承篇.html","title":"C++学习继承篇","keywords":"","body":"C++ 学习继承篇 1、什么是继承？ 继承是面向对象软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。 /// 基类 class People { public: int age; string firstName; void sleep(void); void eatFood(string food); }; /// 派生类 class Worker : public People{ public: void work(void); int salary; }; 被继承的类叫做基类也叫做父类，从其他类继承而来的类叫做派生类也叫做子类； 子类中不仅继承了父类中的数据成员，也继承了父类的成员函数； 1.1、内存中的对象 子类的实例化，内存中既包含父类的成员变量，又包含自己特有的成员变量 { Worker *p = new Worker(); if (p != NULL) { p -> firstName = \"狗蛋\"; p -> age = 10; p -> eatFood(\"面包\"); cout firstName age 创建时先调用父类的构造函数初始化一些数据，接着再调用自身的构造函数！ 销毁时先调用自身的析构函数释放一些内存，接着再调用父类的析构函数！ 2、继承方式 基类到派生类的关系： 公有继承 class subclass : public superclass 私有继承 class subclass : private superclass 保护继承 class subclass : protected superclass 2.1、公有继承 在公有继承中： 子类可以访问父类的 public 成员函数，读写父类的 public 数据成员； 子类可以在 内部 访问父类的 protected 成员函数，读写父类的 protected 数据成员； 子类无法访问父类的 private 成员函数，不能读写父类的 private 数据成员；父类的私有数据成员与成员函数，对于子类来说，是 不可见 的！ 父类的私有成员函数不能被子类继承并使用； 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 public 无法访问（不可见） protected 成员 public protected public 成员 public public 2.2、保护继承 对于访问限定符 protected： 其修饰的数据成员与成员函数，只能在类内部访问与读写；在外部是不被允许使用的！ 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 protected 无法访问（不可见） protected 成员 protected protected public 成员 protected protected 在保护继承中： 父类的公共成员函数与数据成员，将成为子类的受保护成员函数与数据成员！ 父类的受保护成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的私有成员函数与数据成员，对于子类来说是不可见的！ 2.3、私有继承 对于访问限定符 private： 其修饰的数据成员与成员函数，只能在类内部访问与读写；在外部与子类中是不可见的！ 基类成员访问属性 继承方式 派生类成员访问属性 private 成员 private 无法访问（不可见） protected 成员 private private public 成员 private private 在私有继承中： 父类的公共成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的受保护成员函数与数据成员，将成为子类的私有成员函数与数据成员！ 父类的私有成员函数与数据成员，对于子类来说是不可见的！ 3、覆盖与隐藏 继承关系中的 覆盖 与 隐藏： 隐藏：同名的成员变量、或者同名的成员函数 （父子关系、成员同名、隐藏） 覆盖: 3.1、隐藏 隐藏的特性主要体现在： 子类的实例对象只能访问自己的成员函数，而似乎无法访问父类的同名函数； 子类修改的是自己的数据成员，而不能直接修改父类的同名数据成员； /// 父类 class People { protected: string food; public: void eatFood(string food){ this -> food = food; }; }; /// 子类 class Worker : public People{ protected: /// 同名的数据成员 string food; public: /// 子类的函数隐藏了父类的同名函数 void eatFood(string food){ this -> food = food; this -> People_YL::food = food;// 读写同名的父类数据成员 }; }; 但实际上，父类的同名函数确实被子类继承，可以通过特殊手段来访问父类的同名函数 { Worker_YL *p = new Worker_YL; p -> eatFood(\"工人在食堂吃饭\"); /// 通过特殊手段来访问父类的同名函数 p -> People_YL::eatFood(\"人类需要吃饭\"); } 注意： 在继承关系中，同名但参数不同的函数，无法形成重载，只能以隐藏的形式出现！ 即使子类已经继承了父类的函数，但函数同名，就会将父类函数隐藏，即使参数不同，也无法形成重载！ /// 父类 class People { public: void eatFood(); }; /// 子类 class Worker : public People{ public: /// 子类的函数隐藏了父类的同名函数 void eatFood(string food); }; /// 测试代码 { Worker_YL *p = new Worker_YL; p -> eatFood(\"工人在食堂吃饭\"); p -> eatFood(); /// ❌ 不允许这种调用 p -> People_YL::eatFood(); /// 要想调用该函数，只能通过父类来调用 } 4、 基类与派生类的关系： Is'a 与 Has'a 4.1、 Is-a 关系 Is-a 概念：派生类的实例对象也是一个基类的实例对象 父类指针无法访问子类的成员变量与成员函数 调用父类指针销毁子类的实例对象，只会销毁父类的那一部分；子类独有的成员变量，不会被释放 父类指针 new 一个子类对象时，构造函数会先调用父类的构造函数，接着调用子类的构造函数！ 而 delete 仅仅调用的是父类的构造函数 ； class People { public: int age; void eatFood(); }; class Worker : public People{ public: int salary; void work(void); }; 测试代码段 /// Is-a 概念：派生类的实例对象也是一个基类的实例对象 { People *p = new Worker(); /// 先调用 People 的构造函数，接着调用 Worker 的构造函数 std::cout age salary work() 思考：在 Is-a 关系中如何通过父类指针释放子类内存？ 4.1.1、虚析构函数 虚析构函数：当存在继承关系时，使用父类指针指向堆中的子类对象，并且向通过父类指针释放子类的内存，这种情况下就需要虚析构函数来解决了！ 虚析构函数 virtual ~People(); 当父类的析构函数被声明为虚析构函数时，编译器也会默认将子类的析构函数编译为虚析构函数！ class People { public: int age; void eatFood(); virtual ~People(); /// 声明为虚析构函数 }; class Worker : public People{ public: int salary; void work(void); ~Worker();/// 编译器也会默认将其编译为虚析构函数 }; 此时通过父类指针指向堆中的子类对象，并且使用父类指针释放子类的内存，将会先调用子类的析构函数，接着调用父类的析构函数！ 4.1.2、测试 测试在公有继承中，Is-a 在函数传递中的表现！ 继承关系 class People { public: string name; People(){ this -> name = \"人类\"; cout name name = \"工人\"; cout 测试函数 /// test1 函数的传值是一个对象 peo /// 因此调用函数传值时，系统会现在栈上创建一个临时的对象，函数调用结束后，将栈上的缓存释放 void test1(People peo) { peo.logName(); } void test2(People &peo) { peo.logName(); } void test3(People *peo) { peo -> logName(); } 对比 test1() 函数 ， test2()与 test3()不会产生临时变量，效率更高！ 测试代码 { People p; Worker w; test1(p); test1(w); test2(p); test2(w); test3(p); test3(w); } 上述三个 test 函数， 当传递 People 对象时，打印的是 People 对象的实例变量； 当传递 Worker 对象时，打印的是 Worker 对象的实例变量； Has a : 包含关系！ 5、多继承与多重继承 5.1、多重继承 当 B 类从 A 类派生而来，C 类从 B 类派生而来，此时称为多重继承！ class People { public: string name; }; class Worker : public People{ }; class BenchWorker : public Worker{ }; 实例化一个 BenchWorker ，构造函数的执行顺序：People() -> Worker() -> BenchWorker() ! 释放一个 BenchWorker ，析构函数的执行顺序：~BenchWorker() -> ~Worker() -> ~People() ! 一个子类的对象，可以作为参数，传入父类的函数中！ 不管继承的关系有多少层，只要存在继承关系，子类与父类就存在 isa 的关系：PeasantWorker isa People ；PeasantWorker isa Worker！ 5.2、多继承 多继承： 一个子类继承多个父类 对父类的个数没有限制，继承方式可以是公共继承、保护继承、私有继承； 继承时，如果没有生命继承方式，默认为私有继承； /// 工人 class Worker : public People{ }; /// 农民 class Peasant : public People{ }; /// 农民工 : 默认私有继承 class PeasantWorker : public Peasant, public Worker { public: PeasantWorker(){ ///编译❌ Non-static member 'name' found in multiple base-class subobjects of type 'People': this -> name = \"农民工\"; }; }; 实例化一个 BenchWorker ，依次调用父类的构造函数（初始化列表中的顺序）！析构函数的执行顺序正好与构造函数的执行顺序相反！ PeasantWorker isa Worker PeasantWorker isa Peasant 5.3、多继承与多重继承的陷阱 菱形继承：既有多继承、又有多重继承！如下所示 类 A 人类 类B 类C 农名类 工人类 类D 农民工类 类 D 继承类B，类B继承类A；类 D 继承类C，类C继承类A！ 此时类 D 将含有类 A 中两份完全相同的数据，这是不被允许的； 如何解决数据冗余的问题呢？使用虚继承 virtual ！ 5.4、虚继承 virtual /// 工人 class Worker : virtual public People{ }; /// 农民 class Peasant : virtual public People{ }; /// 农民工 : 默认私有继承 class PeasantWorker : public Peasant, public Worker { }; 此时PeasantWorker类仅含有People类中一份数据！ Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C++学习多态篇.html":{"url":"语言篇/C++学习多态篇.html","title":"C++学习多态篇","keywords":"","body":"C++学习多态篇 多态：指相同对象收到不同消息或不同对象收到相同消息时产生不同的动作！ 1、虚函数 1.1、静态多态 静态多态也称为早绑定！ class People { public: void eat(); void eat(string food); }; { People p; p.eat();///编译器能够准确识别调用哪个函数 p.eat(\"食物\"); } 调用互为重载的函数，程序在编译的时期已经决定调用哪些函数；这种情况称为早绑定，也称为静态多态！ 1.2、动态多态 动态多态也称为晚绑定！ 产生多态的基础是继承关系；没有继承与封装，就没有多态！ 动态多态至少需要一个基类，一个派生类！ 动态多态的核心是 virtual 关键字，必须使用 virtual 才能建立多态关系！ class Shape { public: double calcArea(){ cout radius = radius; }; double calcArea(); private: double radius; }; double Circle::calcArea() { return M_PI * radius * radius; } class Rect : public Shape { public: Rect(double width, double height){ this -> width = width; this -> height = height; }; double calcArea(); private: double width; double height; }; double Rect::calcArea() { return width * height; } 上述的代码，我们做一个测试： { Shape *s1 = new Circle(10); Shape *s2 = new Rect(5,6); s1 -> calcArea(); s2 -> calcArea(); } 可以发现，调用的都是父类的成员函数，而非具体到某个子类的函数！也就是没有实现多态的功能！ 要想调用到某个子类的成员函数；需要使用 virtual 修饰父类的成员函数，使其成为虚函数！ 1.3、虚函数 使用 virtual 修饰成员函数，使其成为虚函数！ class Shape { public: virtual double calcArea(){ cout 此时，调用上述 1.2 的测试代码，将执行子类的相关函数！也就实现了动态多态！ 虚函数使用virtual 关键字定义，但使用 virtual 关键字时，并非全部是虚函数； 虚函数特性可以被继承，当子类定义的函数与父类中虚函数的声明相同时，该函数也是虚函数； 关于 virtual 在函数中的使用限制： 不能修饰普通函数； 不能修饰全局函数，否则产生编译错误； 不能修饰静态成员函数； 不能修饰内联函数，否则计算机会忽略 inline 关键字； 不能修饰构造函数； 1.4、虚析构函数 父类指针指向子类对象，使用父类指针调用 delete 销毁子类对象时，可能存在内存泄漏 ! 在上述例子中： { Shape *s1 = new Circle(10); if(s1 != NULL) { /// 父类指针调用 delete ，仅执行父类的析构函数； /// 子类的一些成员无法被释放，由此导致内存泄漏 delete s1; } } 解决方法：使用 virtual 修饰析构函数： class Shape { public: virtual ~Shape(); }; 注意： 只有虚析构函数，没有虚构造函数！ 虚析构函数避免了使用父类指针释放子类对象时造成内存泄漏！ 1.5、如何实现虚函数与虚析构函数？ 函数的本质就是一段二进制代码，而函数指针就是指向这段代码开头地址的指针！ 1.5.1、测试：证明虚函数表的存在 对象的大小：在类实例化出的对象中，数据成员总计占据的内存大小，不包含成员函数！ 对象的地址：通过一个类实例化一个对象后，该对象会在内存中占据一定的内存单元；第一个内存单元就是该对象的地址！ 对象成员的地址：每个数据成员所占据的地址；不同类型的数据成员占据不同的内存大小； 虚函数表指针： 一个有声明虚函数的类，具有一个隐藏的数据成员 虚函数表指针 vftable_pr ！ 测试1 C++ 中的一个类实例，如果没有一个数据成员，将会标记一个内存单元 class Shape { public: int width; }; { /// 测试代码 cout width) 测试2 (证明了虚函数表的存在) class Shape { public: int width; virtual double calcArea(); }; { /// 测试代码 cout width) 通过上述两个测试用例，发现有虚函数的 Shape 类，其指针并非是第一个成员变量的地址！中间差距 8 个字节的内存单元！ 这 8 个字节的内存单元，主要用于存储 虚函数表指针！ 1.5.2、虚函数表 一个有声明虚函数的类，具有一个隐藏的数据成员：虚函数表指针 vftable_pr ！ 虚函数表指针指向一个虚函数表，与类的定义同时出现！ 虚函数表指针 占据一个对象的前 8 个字节的内存单元！ 虚函数表占用一定的内存空间 该类只有一个虚函数表，所有该类的实例对象，共同使用一个虚函数表； 定义其子类时，一个子类也维护一个虚函数表； 父类与子类的两张虚函数表中的函数指针，可能指向同一个函数； 父类调用虚函数步骤： 1、通过虚函数表指针 vftable_pr 找到虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 3、根据函数地址，执行对应的虚函数； 子类调用父类的虚函数步骤（前提是子类没有同名函数）： 1、通过虚函数表指针 vftable_pr 找到自身的虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 3、该虚函数的入口地址，就是父类中的虚函数入口地址； 4、根据函数地址，执行对应的虚函数； 子类调用自身实现的虚函数步骤： 1、通过虚函数表指针 vftable_pr 找到自身的虚函数表； 2、在虚函数表中，通过地址偏移量，找到对应的虚函数入口地址； 4、根据函数地址，执行对应的虚函数； 1.5.3、虚析构函数 理论前提：执行完子类的析构函数之后，系统将会自动执行父类的析构函数； 1.5.4、多态中的覆盖与隐藏 隐藏：子类与父类出现同名函数；在子类中，父类的同名函数将被隐藏； 覆盖：在子类的虚函数表中，同名函数的地址被覆盖为子类函数的入口地址； 2、 纯虚函数 只有函数声明，没有函数定义的虚函数称为 纯虚函数！ class Shape { public: int width; /// 虚函数 virtual double calcArea() { return 0; } /// 纯虚函数：声明后面 + '= 0' virtual double funcArea() = 0; }; 2.1、虚函数表中的纯虚函数 2.2、抽象类 含有纯虚函数的类，称其为抽象类！ C++ 不允许抽象类实例化一个对象 抽象类的一个子类，也可以是抽象类 { Shape *p = new Shape(); /// erroe : Allocating an object of abstract class type 'Shape'! } 3、 接口类 接口类：仅含有纯虚函数的类，不含有其它的成员函数；不含有任何数据成员！ class Shape { public: virtual double calcArea() = 0; ///计算面积 virtual double calcPerimeter() = 0; ///计算周长 }; 上面 Shape 类不包含任何数据成员，仅有两个成员函数还都是纯虚函数！此时 Shape 类被称为接口类！ 接口类仅需要 .hpp 文件来声明，不需要 .cpp 文件来实现！ 接口类也是抽象类，因此不能使用接口类来实例化一个对象！ 一个类可以继承多个接口类，同时也可以继承非接口类； 接口类更多的是表达一种能力或者一个协议 ! 3.1、Objective-C 中的协议 Objective-C 中的协议类似于 C++ 的接口类，就是一堆方法的声明，但没有实现！ 一个 Objective-C 类可以遵循一个或多个协议，任何类只要遵循了协议就相当于拥有了这个协议中所有的方法声明。 协议可以定义在一个类的头文件上部，并直接应用在该类中（如作为delegate功能使用时）；也可单独定义到一个类中，作为多个不同类来遵循并实现的接口。 @protocol HumanProtocol @required - (void)name; - (void)age; @optional // ... @end 协议可以用于存储方法声明，可以将多个类中的公有方法抽取出来，让这些类遵守协议即可！ 4、运行时类型识别 RTTI 什么是 RTTI ？ 通过父类指针，识别其所指向对象的真实数据类型！ 运行时类型识别必须建立在虚函数的基础上，否则无需 RTTI 技术！ typeid 注意事项: typeid 返回一个 type_info 对象的引用； 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数；否则只能返回定义时的数据类型； 只能获取对象的实际类型； dynamic_cast 注意事项: 只能应用于指针和引用转换； 要转换的类型中必须包含虚函数； 转换成功返回子类的地址，失败则返回 NULL； 4.1、 RTTI 用例 定义一个接口类 class Flyable { public: /// 纯虚函数 virtual void takeOff() = 0; ///起飞 virtual void land() = 0; ///降落 }; 继承接口类 /// 飞机类 class Plane : public Flyable{ public: Plane(); ~Plane(); void carry(); virtual void takeOff(); virtual void land(); }; /// 鸟类 class Bird : public Flyable{ public: Bird(); ~Bird(); virtual void takeOff(); virtual void land(); void foraging(); }; 测试函数 void doSomething(Flyable *fly) { std::cout takeOff(); if (typeid(*fly) == typeid(Bird)) { /// 类型强制转换 /// 转换成功返回子类的地址，失败则返回 NULL Bird *niao = dynamic_cast(fly); niao -> foraging(); } if (typeid(*fly) == typeid(Plane)) { Plane *ji = dynamic_cast(fly); ji -> carry(); } fly -> land(); } void PolymorphismDemo(void) { /// 分别将 Bird 类与 Plane 类实例传入上述函数 Bird niao; doSomething(&niao); Plane *ji = new Plane(); doSomething(ji); std::cout 5、异常处理 异常：程序在运行过程中出现的错误！ 异常处理：对有可能发生异常的地方做出预见性的安排！ 常见异常： 数组下标越界； 除数为 0； 内存不足； 5.1、如何异常处理？ 在 C++ 中通常 throw 抛出异常， 使用 try...catch 语法结构尝试捕获并处理异常！ void func1() { try { func2(); } catch (string &value) { ///捕获异常 /// 发生异常时，可以在此处处理一些异常 std::cout try...catch 可以是一对一的关系，也可以是一对多的关系！ catch (...) { /// 省略号，表示可以捕获所有异常 } 多态与异常处理的关系 : 定义一个接口类 Exception ，处理不同场景的异常! Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C数组.html":{"url":"语言篇/C数组.html","title":"C语言数组","keywords":"","body":"C 数组 1、什么是数组（array）？ 数组(array)是由数据类型相同的一系列元素组成，这些元素按顺序存储。 如 10 个 char 类型的字符集合 或者 20 个 int类型的值集合，都可以称为数组。 数组有数组名，通过整数下标访问数组中单独的项或者元素(element)。 在 C 中，数组首元素的下标为 0，所以对于一个内含 n 个元素的数组，其最后一个元素的下标为 n - 1 。作为程序员，要确保正确使用下标，因为编译器和运行的程序都不会检查下标的有效性。 C 语言把数组看做 派生类型 ，因为数组是建立在其它类型的基础之上的。我们无法单独的声明一个数组，在声明一个数组时必须说明其他元素的类型，如 int 型的数组、float 型的数组或者其它类型的数组。所谓的其它类型也可以是数组类型，这时创建的数组为多维数组。 2、数组的声明 一维数组声明的一般形式为：type array[count]; type 为基本数据类型，如int类型、char类型等，表示数组内的元素的数据类型； array 为数组名；也是数组首元素的地址; count：方括号[]中的count 为这个数组内的元素个数，且 count 必须是正整数 ; 通过声明数组，告诉编译器数组内含多少个元素，和这些元素的类型，编译器根据这些信息分配内存空间，正确的创建数组。 普通变量可以使用的类型，数组元素都可以使用。如下面代码： float states[3]; 声明了 states 是一个内含 3 个元素的数组，每个元素都可以存储float 类型的值。数组的第一个元素是 states[0]，以此类推，直到 states[2]。 2.1、数组的下标 用于识别数组元素的数字被称为 下标 (subscript)、索引 (indice)或者 偏移量 (offset)。 数组的元素依次被存储在内存中相邻的位置。 注意：下标必须是整数，而且从0开始； 一个未初始化的数组，其存在是怎么样的呢？我们以刚才声明的数组为例，打印其结果： float states[3]; for (int i = 0; i 我们可以看到：内存地址间隔4个字节，为三个连续的地址，也就是说编译器已正确创建数组，但是其存储的值都是垃圾值； 2.2、数组的大小 数组的元素个数count 值必须大于 0，而且count 必须是整数; 声明count 为 0，这个数组没有存在的意义； count为负整数时编译器报错：'array' declared as an array with a negative size 3、数组的初始化 初始化数组，列表用 {} 括起来，元素之间用逗号 ，分割； 下面演示了一个简单的程序，打印每个月的天数: void arrayInitialize(void) { //初始化数组，列表用 {} 括起来，元素之间用 ，分割 int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; for (int i = 0; i 运行程序，分析打印结果： 1 月有 31天 2 月有 28天 3 月有 31天 4 月有 30天 5 月有 31天 6 月有 30天 7 月有 31天 8 月有 31天 9 月有 30天 10 月有 31天 11 月有 30天 12 月有 31天 3.1、使用数组时的一些陷阱 3.1.1、数组下标越界 在 C 标准中，使用越界下标的结果是未定义的。 假如我们不小心写错索引，索引值大于数组元素个数会发生什么情况？索引值为负，又会发生什么情况？我们通过一个例子来说明： /* days[100] 从内存地址方面来讲，就是days[0]元素的内存后第 100 个同样大小的内存，这块内存可能存储 int 型数据，也有可能存储 double 数据（占有的内存大于这块内存），充满了不确定性 */ days[100];//该数组元素不存在 days[-1];//程序并不报错 在 C 标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是数据被放置在已被其他数据占用的地方，运行结果很奇怪或者异常终止。 C 语言为何允许这种麻烦事发生呢？考虑到程序执行的效率问题，c 编译器不会检查数组的下标是否正确，这样子 C 程序可以执行的更快，编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。如果编译器必须在运行时添加额外的代码检查数组的每个下标值，这会降低程序的运行速度。 注意： C 语言保证在为数组分配内存空间时，指向数组后面的第一个位置的指针是有效指针，但是对这个内存位置存储的值未做任何保证。 3.1.2、数组元素类型错误 C 语言在检查类型匹配方面并不是太严格 假如我们在初始化数组时，将错误的数据类型赋值给元素，会发生什么呢？下面我们看一个例子： int mu[3] = {1 ,2.0 ,3}; for (int i = 0; i 我们声明了一个内部包含 3 个int类型元素的数组，并且初始化这个数组，但是第二个元素由于大意，错写为 浮点型，这时候我们的编译器并未报错；那么这个错误的元素类型，会发生什么呢？看下它的输出： mu[0]= 1 ,地址为:0x7ffeefbff444 mu[1]= 2 ,地址为:0x7ffeefbff448 mu[2]= 3 ,地址为:0x7ffeefbff44c 观察各个元素的值，可以看到索引为1 的元素，它的前面的值不受影响，正常显示，它的后面的值也不受影响，正常显示；但是这个索引为 1 的值，显示为 2 ，明显是个整型！这是为什么呢？ 相信大家都可以得出结论：因为我们声明的数组是个包含int 类型元素的数组，系统给这个数组分配了连续三个存储空间，每个存储空间有 4（ sizeof(int) ）个字节,这三个存储空间都是存储 int 类型的，所以 2.0 被系统强制转化为int 型 2 存储到内存；这从打印出的地址可以看出，打印的三个地址连续，每相邻地址间隔 sizeof(int) 个字节。 3.1.3、 变量的值与其类型不匹配 在这里，我们回顾一下在 C 基础数据类型里遇到的变量的值与其类型不匹配的问题： float a = 9; int b = 9.0; printf(\"a = %f , b = %d\\n\",a,b); //a = 9.000000 , b = 9 C 语言在检查类型匹配方面并不是太严格，把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这会导致部分数据丢失（C 编译器把浮点数转换整数时，会丢弃小数部分，而不进行四舍五入） 通过回顾，我们发现可以使用“编译器会把值转换成与变量匹配的类型”这个规则来解释数组元素类型错误时会发生什么了。 3.2、 数组初始化时元素个数异常 3.2.1 数组元素都没有初始化 数组元素都没有初始化，也就是只声明了数组，这个案例在前面已经讨论过，我们就不再过多叙述了； 3.2.2 数组元素未全部初始化 初始化列表中的项数应与数组的大小一致，如果不一致会怎样？我们还是以一个例子来讲起： int mu[3] = {1}; for (int i = 0; i 我们声明了一个内部包含 3 个 int 类型元素的数组，并且初始化这个数组为第一个元素赋值，但是第二个元素、第三个元素我们并未赋值，我们看下打印结果： mu[0]= 1 ,地址为:0x7ffeefbff444 mu[1]= 0 ,地址为:0x7ffeefbff448 mu[2]= 0 ,地址为:0x7ffeefbff44c 可以看到，内存地址依旧为三个连续的地址，但是第一个值为 1，其余值均为 0。也就是说：如果部分初始化数组，剩余的元素都会被初始化为0，如果不初始化数组，则内部存储的是垃圾值。 3.2.3 数组初始化的元素个数大于数组元素个数 如果初始化列表的项数多于数组元素个数，会出现什么呢？我们仍然写一个例子 //waring:Excess elements in array initializer float mun[3] = {1,2,3,4,5,6,7,8}; for (int i = 0; i 这时我们的编译器报警告：Excess elements in array initializer（数组初始化器中有多余元素）,既然没有报错，那么我们把这个数组的 8 个值全部打印出来看看： 元素 0 = 1.000000 元素 1 = 2.000000 元素 2 = 3.000000 元素 3 = 0.000000 元素 4 = -105654032.000000 元素 5 = -118816705213457147349000257536.000000 元素 6 = 0.000000 元素 7 = 0.000000 我们可以看到：前三个元素是有保证的，打印的是我们赋予的值；但是后面 5 个元素未做任何保证，都是垃圾值。也就是说：即使初始化列表的项数多于数组元素个数，编译器也只会给数组大小范围内的元素分配内控空间并存储，超出范围的未做任何保证，都是垃圾值。 3.3、自动计数 如果我们不确定数组元素个数怎么办呢？我们可以直接声明一个含有元素个数足够多的数组，这样即使我们使用再大的索引，也不怕数组越界，但是这样做，显然浪费了大量内存； C 已经给了我们解决办法：在初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小： float mun[] = {1,2,3}; 我们并未给出数组元素个数，并不知道数组的大小，我们使用 sizeof() 函数计算出数组的大小、数组的元素个数 3.4、 指定初始化器（Designated Initializer） C99 增加了一个新特性：指定初始化器(Designated Initializer)，利用该特性，可以初始化指定的数组元素。例如。只初始化数组的最后一个元素。 void designatedInitializerMethod(void) { int days[6] = {1,[3] = 22,45,[0] = 76}; for (int i = 0; i 对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为 0。但是上面这个程序明显比较复杂，days 是一个包含 6 个 int 型元素的数组，但是我们只初始化了第一个元素，第三个元素，第三个元素后面还跟了一个元素，那么这个数组各个元素的值是怎么样呢？我们看下打印结果： days[0]= 76 ,地址为:0x7ffeefbff460 days[1]= 0 ,地址为:0x7ffeefbff464 days[2]= 0 ,地址为:0x7ffeefbff468 days[3]= 22 ,地址为:0x7ffeefbff46c days[4]= 45 ,地址为:0x7ffeefbff470 days[5]= 0 ,地址为:0x7ffeefbff474 以上输出，揭示了指定初始化器的两个重要特性： 如果指定初始化器后面有更多的值，那么后面这些值将被用于指定元素后面的元素 如值 45，位于指定的第三个元素之后，那么它就是第四个元素的值 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化 如 days 里第 0 个元素，我们初始化为 1 ，但是之后又指定初始化为 76 ，那么它最后的值为 76 3.5、使用 const 声明数组 有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组，要创建这样的数组，应该使用 const 声明和初始化数组： const int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; //dates[2] = 3;//不允许，编译器报错：Read-only variable is not assignable 或者： int const days[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; //dates[2] = 3;//不允许，编译器报错：Read-only variable is not assignable 3.6、给数组元素赋值 声明数组后，可以借助数组下标给数组元素赋值 int days[6] = {1,[3] = 22,45,[0] = 76}; days[1] = 98; days[2] = 56; 注意：C 不允许在初始化以外使用花括号列表的形式赋值。 int days[6] = {1,[3] = 22,45,[0] = 76}; days = {1,2};//编译错误error : Expected expression 注意：C 不允许把数组作为一个单元赋给另一个数组。 int days[6] = {1,[3] = 22,45,[0] = 76}; int days2[6] = days; //编译错误error: Array initializer must be an initializer list or wide string literal 4、变长数组(VLA) 对于传统的 C 数组，必须使用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11 新增了变长数组，可以用变量表示数组的大小。这意味着变长数组的大小延迟到程序运行时才确定。 C99/C11 新增的变长数组，允许使用变量表示数组的维度。变长数组必须是自动存储类别，这意味着在函数中声明或者在函数形参中声明，都不能使用 static 或 extern 存储类别说明符，不能在初始化中声明它们。 注意：变长数组的 变 不是指修改已创建的数组大小，一旦创建了变长数组，它的大小保持不变。这里的 变 指的是：在创建数组时可以使用指定数组的维度 5、多维数组 多维数组：数组的数组 C 语言支持多维数组：数组的声明一般形式为： type name[size1][size2]...[sizeN]; 我们来声明一个 3 维数组：int dogs[3][3][5]; 我们声明了一个包含三个元素的数组 dogs，这个数组的每个元素是一个包含三个项的数组，每个项又是包含 5 个 int 型元素的数组；也就是说这个数组 dogs ，是个数组的数组； 在计算机内部：多维数组是按顺序存储的。从 dogs[0][0][0]--> dogs[0][0][4] --> ... dogs[0][2][4] --> .. dogs[2][2][4] 。 5.1、二维数组 我们以一个图表来讨论二维数组int pigs[4][5]: 主数组 pigs 有 4 个元素，每个元素是内含 5 个 int型数据的数组：pigs 的首元素pigs[0] 是一个内含 5 个 int型数据的数组；pigs[1]、pigs[2]、pigs[3] 都是如此。 如果 pigs[0] 是一个数组，那么它的首元素就是 pigs[0][0]，第二个元素是 pigs[0][1]，以此类推。 假如要访问三行三列的值，则使用 pigs[2][2]。 在计算机内部，这样的数组是按顺序存储的：从第一个内含 5 个int 型数据的数组开始，然后是第二个内含 5 个 int 型数据的数组，以此类推 我们给这个二维数组 pigs 初始化 void twoDimensionArray(void) { int pigs[4][5] = { {1,2,3,4,5}, {10,20,30,40}, {100,200,300,400,500,600}, {1000,2000,3000}, }; for (int i = 0; i 这个初始化用了四个数值列表，每个数值列表都用花括号括起来；第一个列表初始化数组的第一行（即上图中的第一行数据），第二个列表初始化数组的第二行（即上图中的第二行数据），以此类推 它的打印结果为： 1 2 3 4 5 0x7ffeefbff420 0x7ffeefbff424 0x7ffeefbff428 0x7ffeefbff42c 0x7ffeefbff430 10 20 30 40 0 0x7ffeefbff434 0x7ffeefbff438 0x7ffeefbff43c 0x7ffeefbff440 0x7ffeefbff444 100 200 300 400 500 0x7ffeefbff448 0x7ffeefbff44c 0x7ffeefbff450 0x7ffeefbff454 0x7ffeefbff458 1000 2000 3000 0 0 0x7ffeefbff45c 0x7ffeefbff460 0x7ffeefbff464 0x7ffeefbff468 0x7ffeefbff46c 数组元素的内存地址：从 pigs[0][0] -- > pigs[0][4] --> pigs[3][4] ，内存地址是连续排列的，间隔 4 个字节。 假如某一行没有全部初始化，则这一行的剩余元素默认初始化为 0 ; 假如某一行的数值个数超出数组大小，并不会影响其它行的初始化； 思考: 既然二维数组，内存地址是连续分布的，那么是否可以只使用一个花括号来表示所有的值？我们不妨来试试： void twoDimensionArray(void) { int pigs[4][5] = { 1,2,3,4,5, 10,20,30,40, 100,200,300,400,500,600, 1000,2000,3000, }; for (int i = 0; i 我们在第二行、第四行列表各少初始化一个元素，打印结果为最后两个元素为 0； 初始化时可以省略内部的花括号，只保留最外一层。但是这样做，必须保证初始化的数值个数是正确的 6、数组 与 指针 指针（pointer）是一个值为内存地址的变量。 因为计算机内部的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的形式表达。因此，使用指针的程序更有效率。尤其是，数组表示法其实是在变相的使用指针。 我们来举个例子: void arrayAndPointer(void) { //在我们的系统中，地址按字节编址，short 类型占 2 个字节，double 类型占 8 个字节 printf(\"sizeof(short) : %zd ;sizeof(double) : %zd \\n\",sizeof(short),sizeof(double)); //sizeof(short) : 2 ;sizeof(double) : 8 short dates[4];//声明了一个含有 4 个 short 类型元素的数组 short * pti;//声明了一个指向 short 类型值的指针 int index;//声明了一个 int 类型的变量 double bills[4];//声明了一个含有 4 个 double 类型元素的数组 double * ptf;//声明了一个指向 double 类型值的指针 pti = dates;//把数组地址赋给指针 ptf = bills;//把数组地址赋给指针 printf(\"%30s %15s \\n\",\"short\",\"double\"); for (index = 0 ; index 下面是该程序的输出： sizeof(short) : 2 ;sizeof(double) : 8 short double pointers + 0 : 0x7ffeefbff470 0x7ffeefbff450 array element + 0 : 0x7ffeefbff470 0x7ffeefbff450 pointers + 1 : 0x7ffeefbff472 0x7ffeefbff458 array element + 1 : 0x7ffeefbff472 0x7ffeefbff458 pointers + 2 : 0x7ffeefbff474 0x7ffeefbff460 array element + 2 : 0x7ffeefbff474 0x7ffeefbff460 pointers + 3 : 0x7ffeefbff476 0x7ffeefbff468 array element + 3 : 0x7ffeefbff476 0x7ffeefbff468 分析打印结果： 第一行表明了：在我们系统中，short 占 2 个字节，double 占 8 个字节； 第三、四行分别用指针表示法、数组表示法打印两个数组开始的地址：可以看到：第三行和第四行的结果分别对应相等； 第五行是指针加 1 后的地址，与第六行数组表示法下一个值得地址相等； 以此类推... 在 C 中，指针加 1 指的是增加一个存储单元（这个存储单元的大小依据变量的类型来确定）。对于数组而言，这意味着加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。这也是为什么必须声明指针所指向的对象类型的原因之一。只知道内存首地址是不够的，还需要知道这个变量占据多少的字节的存储空间。 dates + 2 == &dates[2]; //表示相同的地址 *(dates + 2) == dates[2]; //相同的值 数组与指针的关系十分密切，可以使用指针标识数组的元素。从本质上讲，同一个对象有两种表示法。C 语言标准在描述数组表示法时确实借助了指针，array[n] 的意思是 *(array + n)，即 到内存 array 的位置，然后再移动n 个单元，检索储存在那里的值 注意： * 的运算级别高于 + *(dates + 2) ;//数组 dates 索引为 2 的值 *dates + 2;//数组 dates 索引为 0 的值 再加上 2 6.1、指针的操作 C 提供了一些基本的指针操作；我们来看程序： void pointerOperation(void) { printf(\"sizeof(int) = %zd \\n\",sizeof(int)); // sizeof(int) = 4 (int 型占 4 个字节) /* 1、声明一个含有5个int 类型元素 的 数组 2、初始化每个元素的值 3、array 数组名，是数组首元素的地址 4、int 占四个字节，这个数组有五个 int 类型元素，占 20 个字节 */ int array[5] = {100,200,300,400,500};//声明一个整型数组，并初始化 printf(\"sizeof(array) = %zd \\n\",sizeof(array)); // sizeof(array) = 20 /* 1、声明三个 int* 类型的指针变量 2、由于未初始化，所以指针变量指向的地址，既指针变量的值不确定是随机值 */ int *p1 , *p2 , *p3;//声明指针变量 printf(\"p1 = %p , p2 = %p , p3 = %p \\n\",p1,p2,p3); //p1 = 0x2b00000028 , p2 = 0x280000003d , p3 = 0x3d00000024 /* 此时：p1 与 p2 的值 相差 8 个字节，2个 int 元素 指针 p1 指向内存地址的值 为100 ，既数组 array 的首位元素 100 ，是第0位元素的地址 指针 p2 指向内存地址的值 为300 ，既数组 array 的第2位元素 300，是第2位元素的地址 以上说明：说明数组元素的内存地址是连续的 指针变量 p1 的内存地址为 0x7fff5fbff638 指针变量 p2 的内存地址为 0x7fff5fbff630 为什么 p1 比 p2 的地址高呢? 因为栈空间是从 高地址 向 低地址 扩展的，先声明的 p1，那么 p1 的内存地址自然比 p2 的高 */ p1 = array;//数组名是数组首元素的地址 p2 = &array[2];//把一个地址赋给指针 printf(\"p1 = %p , *p1 = %d , &p1 = %p \\n\",p1,*p1,&p1); //p1 = 0x7fff5fbff640 , *p1 = 100 , &p1 = 0x7fff5fbff638 printf(\"p2 = %p , *p2 = %d , &p2 = %p \\n\",p2,*p2,&p2); //p2 = 0x7fff5fbff648 , *p2 = 300 , &p2 = 0x7fff5fbff630 /* 指针 p1 + 4 = 0x7fff5fbff640 + 4 * sizeof(int) = 0x7fff5fbff640 + 16 = 0x7fff5fbff650 指针减去一个整数：指针必须是减数，整数是被减数 */ p3 = p1 + 4;//指针加法 printf(\"p1 + 4 = %p , *(p1 + 4) = %d , &p3 = %p \\n\",p1 + 4,*(p1 + 4),&p3); //p1 + 4 = 0x7fff5fbff650 , *(p1 + 4) = 500 , &p3 = 0x7fff5fbff628 printf(\"p3 = %p , *p3 = %d , &p3 = %p \\n\",p3,*p3,&p3); //p3 = 0x7fff5fbff650 , *p3 = 500 , &p3 = 0x7fff5fbff628 /* 递增：让 该指针 移动至数组的下一个元素 此时：变量 p1 的内存地址 仍为 0x7fff5fbff638 注意：变量不会因为值发生变化就移动位置 */ p1 ++;//递增指针 printf(\"p1++ = %p , *(p1++) = %d , &p1 = %p \\n\",p1,*p1,&p1); //p1++ = 0x7fff5fbff644 , *(p1++) = 200 , &p1 = 0x7fff5fbff638 p2 --;//递减指针 printf(\"p2-- = %p , *(p2--) = %d , &p2 = %p \\n\",p2,*p2,&p2); //p2-- = 0x7fff5fbff644 , *(p2--) = 200 , &p2 = 0x7fff5fbff630 /* 两个指针相减:指针求差 （通常求差的两个指针分别是同一数组的不同元素） 通过求差，计算出两个元素之间的距离 */ printf(\"p3 - p2 = %td \\n\",p3 - p2); //p3 - p2 = 3 //指针减去整数 printf(\"p3 - 2 = %p \\n\",p3 - 2); //p3 - 2 = 0x7fff5fbff648 } 上面一段程序演示了指针变量的基本操作： 赋值: 可以把地址赋值给指针。例如：使用数组名、带地址运算符 & 的变量名、另一个指针进行赋值。 注意：地址应该与指针类型兼容；不能把 double 型的地址赋给指向int 的指针。 解引用: * 运算符给出指针指向地址上存储的值。 取址: 和所有变量一样，指针变量也有自己的地址 和 值。 指针与整数相加: 可以使用 + 运算符把指针与整数相加，或者整数与指针相加。整数和指针所指向类型的大小（以字节为单位）相乘，然后把乘积与指针的值相加 注意：在做加法时，编译器不会检查指针是否仍然指向数组元素，C 只能保证指向数组任意元素的指针 和 数组后面第一个位置的指针有效，如果超出了这个范围，则是未定义 递增指针: 指向数组元素的指针可以通过递增让该指针移动至数组的下一个元素。 指针减去一个整数: 可以使用 - 运算符从一个指针减去一个整数。 必须指针是减数，整数是被减数。如果相减的结果超出初始指针所指向的数组的范围，计算结果是未定义的。 递减指针: 指向数组元素的指针可以通过递减让该指针移动至数组的上一个元素。 指针求差: 可以计算两个指针的差值。求差的两个指针分别指向同一数组的不同元素，通过求差计算出两个元素之间的距离 比较: 使用关系运算符可以比较两个指针的值，前提是这两个指针都指向相同类型的对象。 6.2、指针 与 多维数组 指针与多维数组有什么关系呢？我们先来看一段程序： void twoDimensionArray(void) { int pigs[3][2] = {{1,3},{5,7},{2,4}}; printf(\"pigs = %p ; pigs + 1 = %p \\n\",pigs,pigs + 1);//二维数组 pigs 的地址与一维数组 pigs[0] 的地址相同，它们的地址都是各自数组首元素的地址，因此与 &pigs[0][0] 的地址相同 printf(\"pigs[0] = %p ; pigs[0] + 1 = %p \\n\",pigs[0],pigs[0] + 1); printf(\"*pigs = %p ; *pigs + 1 = %p \\n\",*pigs,*pigs + 1); printf(\"pigs[0][0] = %p \\n\",&pigs[0][0]); printf(\"pigs[0][0] = %d \\n\",pigs[0][0]); printf(\"*pigs[0] = %d \\n\",*pigs[0]); printf(\"**pigs = %d \\n\",**pigs); printf(\"pigs[2][1] = %d \\n\",pigs[2][1]); printf(\"*(*(pigs + 2) + 1) = %d \\n\",*(*(pigs + 2) + 1)); } /* ------------------------------- 打印结果 ------------------------------- pigs = 0x7ffeefbff470 ; pigs + 1 = 0x7ffeefbff478 pigs[0] = 0x7ffeefbff470 ; pigs[0] + 1 = 0x7ffeefbff474 *pigs = 0x7ffeefbff470 ; *pigs + 1 = 0x7ffeefbff474 pigs[0][0] = 0x7ffeefbff470 pigs[0][0] = 1 *pigs[0] = 1 **pigs = 1 pigs[2][1] = 4 *(*(pigs + 2) + 1) = 4 */ 我们先来分析一下这个二维数组的声明： int pigs[3][2] = {{1,3},{5,7},{2,4}}; 数组名pigs 是该数组首元素的地址，而该数组首元素又是一个内含两个int 型的数组，所以 pigs 是这个内含两个int 值数组的地址： 因为 pigs 是数组首元素的地址，所以 pigs 的值和 &pigs[0] 的值相同。而 pigs[0] 本身是一个内含两个整数的数组，所以 pigs[0]的值和 &pigs[0][0] 的值相同。pigs 是一个占用两个int 大小对象的地址，pigs[0] 是一个占用一个int 大小对象的地址。由于这个整数 和 内含两个整数的数组都开始于同一个地址，所以pigs 和 pigs[0] 的值相同。 我们知道，给指针或者地址加 1，其值会增加对应类型大小的数值。在这里，pigs 与 pigs[0] 不同，因为 pigs 指向的对象占用了 2 个int大小，而 pigs[0] 指向的对象占用了 1 个 int 大小。因此，pigs + 1 和 pigs[0] + 1 的值不同。 解引用一个指针，得到引用对象代表的值。因为 pigs 是该数组首元素pigs[0][0] 的地址，所以 *(pigs[0]) 表示存储在 pigs[0][0]上的值，* pigs表示存储在pigs[0]上的值。但是 pigs[0] 本身又是一个地址，该地址的值为 &pigs[0][0]。对两个表达式引用解引用运算符表明，**pigs 与 *&pigs[0][0]等价。简而言之，pigs[0][0] 是地址的地址，必须解引用两次才能获得原始值。 我们以一个图来演示数组地址、数组内容和指针的关系： 6.3、指向多维数组的指针 如何声明一个指针变量p 指向一个二维数组呢？ int *p[2]; 由于 [] 的优先级高，先与 p 结合，所以 p 是一个内含 2 个元素的数组，然后 * 表示 p 数组内含 2 个指针。也就是说；我们声明了 2 个指向 int 型的指针。 我们再来看看下一种声明： int (*p)[2]; 其中 * 先与 p 结合，声明的是一个指向数组（内含 2 个 int 型数据）的指针。 我们来看看下面一段程序： void twoDimensionArray(void) { int pigs[3][2] = {{1,3},{5,7},{2,4}}; int (* p) [2] = pigs; printf(\"p = %p ; p + 1 = %p \\n\",p,p + 1); printf(\"p[0] = %p ; p[0] + 1 = %p \\n\",p[0],p[0] + 1); printf(\"*p = %p ; *p + 1 = %p \\n\",*p,*p + 1); printf(\"p[0][0] = %p \\n\",&p[0][0]); printf(\"p[0][0] = %d \\n\",p[0][0]); printf(\"*p[0] = %d \\n\",*p[0]); printf(\"**p = %d \\n\",**p); printf(\"p[2][1] = %d \\n\",p[2][1]); printf(\"*(*(p + 2) + 1) = %d \\n\",*(*(p + 2) + 1)); } /* ------------------------------- 打印结果 ------------------------------- p = 0x7ffeefbff420 ; p + 1 = 0x7ffeefbff428 p[0] = 0x7ffeefbff420 ; p[0] + 1 = 0x7ffeefbff424 *p = 0x7ffeefbff420 ; *p + 1 = 0x7ffeefbff424 p[0][0] = 0x7ffeefbff420 p[0][0] = 1 *p[0] = 1 **p = 1 p[2][1] = 4 *(*(p + 2) + 1) = 4 */ 虽然，p 是一个指针不是一个数组，但也可以使用 p[2][1] 这种写法。可以使用数组表示法或者指针表示法表示一个数组元素，既可以使用数组名也可以使用指针名。 6.4、指针的兼容性 指针的赋值比较严格。我们可以使用把int 类型的值赋给 double 型变量，但是两个类型的指针不能这样做。 void pointerCompatibility (void) { int a = 3; double x; int *p1 = &a; double *q1 = &x; x = a;//我们可以把 int 型数据赋值给 double 型变量 q1 = p1;//waring：Incompatible pointer types assigning to 'double *' from 'int *' } 声明数组将分配存储数据的空间，声明指针只分配存储一个地址的空间 7、函数、数组 与 指针 编写一个处理基本数据类型（如 float）的函数时，要选择是传递float 类型的值还是传递指向float 的指针。我们的通常做法是直接传递值，只有程序需要在函数中改变该值时才会传递指针。 那么：编写一个处理数组的函数时，我们该如何做呢？ 7.1、声明数组形参： 首先我们需要明确：编写一个处理数组的函数时，这个函数必须知道数组何时开始、何时结束。显而易见，我们有多种方法满足它的两个要求。 7.1.1、数组形参中使用 数组名 与 数组大小 /*函数的声明：计算数组内所有元素之和 第一个参数告诉函数，该数组的首元素的指针和数据类型； 第二个参数告诉函数：该数组中元素的个数。 */ int sumFunction(int array[],int count); //函数的实现 int sumFunction(int array[],int count) { int toast = 0; for (int i = 0; i 下面我们来调用这个函数： int array[7] = {1,2,3,4,5,6,7}; printf(\"数组的所有元素之和为 ： %d \\n\",sumFunction(array, 7)); // 打印结果： 数组的所有元素之和为 ： 28 可以看到，这种方法满足我们的需求。 注意： 在第一行数组的初始化中array 占有 sizeof(int) * 7 个字节，表示整个数组的大小；在第二行作为形参中，array 占有 8 个字节（一个指针变量占得字节数），因为它并不是一个数组，而是一个指向数组首元素的地址。 7.1.2、 数组形参中使用 指针与 数组大小 在上文中因为数组名是该数组首元素的地址，所以我们可以直接使用一个指针来声明 /*函数的声明：计算数组内所有元素之和 第一个参数告诉函数，该数组的地址和数据类型； 第二个参数告诉函数：该数组中元素的个数。 */ int sumFunction(int *array,int count); //函数的实现 int sumFunction(int *array,int count) { int toast = 0; for (int i = 0; i 下面我们来调用这个函数： int array[7] = {1,2,3,4,5,6,7}; printf(\"数组的所有元素之和为 ： %d \\n\",sumFunction(array, 7)); // 打印结果： 数组的所有元素之和为 ： 28 可以看到，这种方法满足我们的需求，而且和 1.1 一样； 注意： int array[] 与 int *array 形式上都表示 array 是一个指向 int 的指针。但是，int array[] 只能用于声明形式参数。 由于函数原型可以省略参数名，所以以下等价： int sumFunction(int array[],int count); int sumFunction(int [],int); int sumFunction(int *array,int count); int sumFunction(int *,int); 思考一下： 除了使用数组首元素地址 和 数组元素个数这种表示法声明函数形参，我们还可以使用什么办法处理数组（告诉函数这个数组何时开始，何时结束）？ 7.1.3、 数组形参中使用 两个指针 我们可以传递两个指针，第一个指针指明数组的开始处，第二个指针指明数组的结束处： /*函数的声明：计算数组内所有元素之和 第一个参数 start 是一个指针，指向数组首元素 第二个参数 end 是一个指针，指向数组的结尾处 */ int sumFunction(int *start,int *end); /*数组的实现： 一元运算符 * 和 ++ 的优先级相同，但结合律从右往左，所以 start++ 先求值； 递增运算符使用后缀形式，意味着先把指针指向的值加到 toast 上，然后再递增指针 start 递增 1 相当于其值递增 int 类型的大小； end 指向数组最后一个元素的后面（ C 语言保证指向数组后面第一个位置的指针是有效指针，但是对于这个位置的值没有做任何保证，程序最好不要访问该位置） */ int sumFunction(int *start,int *end) { int toast = 0; while (start 下面我们来调用这个函数： int array[7] = {1,2,3,4,5,6,7}; printf(\"数组的所有元素之和为 ： %d \\n\",sumFunction(array, array + 7)); 可以看到，这种方法满足我们的需求，而且和 1.1 与 1.2 一样； 7.1.4、总结 从以上 3 种函数形参的最终结果来看，无论数组表示法 或者 指针表示法，都能打到我们的需求。 使用 数组表示法，可以更清晰的表达函数处理数组的意图；但是对于数组而言：最好传递指针，因为这样做，效率更高。你可以想象一下：假如传递的是数组，则必须在 栈区(stack) 分配足够的内存空间来存储该数组的副本，然后把数组的所有数据拷贝至新的数组中；而如果我们把数组的地址传递给函数，栈区 只需分配一小块的内存空间来存储该地址的副本，则函数直接处理原始数组效率更高。 思考： 编写一个处理数组的函数时传递指针安全嘛？ 7.2、形参安全 C 语言通常按值传递数据，传递的是原始数据的副本，不会意外修改原始数据，保证了数据的完整性。但是处理数组时我们为了效率问题传递的是指针，这时如果我们不需要修改数据，那么这份数据在函数中就存在被篡改的风险：如下面程序： /* 我们的本意是：计算数组中各个元素的和，不改变数组的原始数据 但是，以下函数虽然计算出了数组元素之和，但是却也改变了原始数据，违背我们的初衷 */ int sumFunction(int array[],int count) { int toast = 0; for (int i = 0; i 7.2.1、对形参使用 const 针对上文的思考，我们可以提高警惕避免错误，但是我们总有疏忽大意的时刻。ANSI C 提供了一种预防手段：如果函数的意图不是修改数组中的数据内容 ，那么在函数原型和函数定义中声明形参时应使用关键字const。再看下面程序： //函数声明 int sumFunction(const int array[],int count); //函数实现 int sumFunction(const int array[],int count) { int toast = 0; for (int i = 0; i 我们使用 const 告诉编译器：该函数不能修改 array 指向的数组的内容，这时在函数中再不小心改变数组数据，编译器就会捕获这个错误并生成一条错误信息。 这里我们需要明白：使用 const 并不是要求原始数组是常量，只是在该函数处将数组视为常量，不可更改。 一般而言：如果编写的函数需要修改数组，在声明形参时不使用 const；如果编写的函数不需要修改数组，在声明形参时最好使用 const。 7.3、 const 的其它内容 #define A 1 const int a = 1; 虽然我们可以使用#define 达到类似 const 的功能，但是显然 const 更加灵活。可以创建 const 数组、const 指针、指向 const 的指针。 7.3.1、 指向 const 的指针不能用于改变值 考虑下面代码： int array[7] = {1,2,3,4,5,6,7}; const int *p = array;//指针 p 指向数组 array 的首元素，使用 const 表明不能使用 p 来更改他所指向的值 *p = 10;//编译器error : Read-only variable is not assignable p[2] = 100;//编译器error : Read-only variable is not assignable array[2] = 100;//允许，因为 array 未被 const 限定 p ++;//允许指针 p 指向别处，递增指向 array[1] p = array2; //允许指针 p 指向别处，再次给指针 p 指向新的内存地址 无论使用指针表示法 或者 数组表示法，都不允许修改 p所指向数据的值，但是并不限定 array，因为他未被 const 限定。允许指针p 指向新的内存地址。 指向const 的指针一般用于数组的形参，表明该函数不会使用指针改变数据。 7.3.2、 使用 const 声明并初始化一个不能指向别处的指针 int array[7] = {1,2,3,4,5,6,7}; int array2[7] = {1,2,3,4,5,6,7}; int * const p = array;//指针 p 指向数组 array 的首元素，使用 const 表明不能使用 p 指向别处 *p = 10; p[2] = 100; p ++;//编译器error : Cannot assign to variable 'p' with const-qualified type 'int *const' p = array2;//编译器error : Cannot assign to variable 'p' with const-qualified type 'int *const' array[2] = 100;//允许，因为 array 未被 const 限定 可以使用指针来修改它所指向的值，但是不能让指针重新指向别处； 7.3.3、 既不能指向别处 又不能更改它所指向地址的值 的指针 int array[7] = {1,2,3,4,5,6,7}; int array2[7] = {1,2,3,4,5,6,7}; const int * const p = array;//指针 p 指向数组 array 的首元素，使用 const 表明不能使用 p 来更改他所指向的值 *p = 10;//编译器error : Read-only variable is not assignable p[2] = 100;//编译器error : Read-only variable is not assignable p ++;//编译器error : Cannot assign to variable 'p' with const-qualified type 'int *const' p = array2; array[2] = 100;//允许，因为 array 未被 const 限定 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C结构.html":{"url":"语言篇/C结构.html","title":"C语言结构","keywords":"","body":"C 结构 设计一个程序时，最重要的步骤之一是选择表示数据的方法；C 语言的基本数据类型 甚至是 数组 array 在许多情况都不够用。C 语言提供了派生类型 结构变量（structure variables）:它创造新的形势，提高我们表示数据的能力。 1、结构变量 例子，我们想要表示一部电影的各种信息：如名片、发行年份、导演、主演、片长、影片的种类、评级等。这时，简单变量甚至是数组都无法表示这个数据形式，我们可以使用结构： #define TSIZE 45//存储名片的数组大小 struct film { char title[TSIZE];//电影的片名 int rating;//电影的评分 }; 上述代码声明的结构有 2 部分：每个部分称为成员；使用结构需要掌握： 为结构建立一个格式或样式 声明一个适合该样式的变量 访问结构变量的各个部分 1.1、声明结构 结构声明：描述了一个结构的组织布局。 下述声明描述了一个由字符数组和 int 类型变量组成的结构： #define TSIZE 45//存储名片的数组大小 struct film { char title[TSIZE];//电影的片名 int rating;//电影的评分 }; 该声明并未创建实际的数据结构，仅仅是描述了该结构由什么组成： 关键字 struct：它表明跟在其后的是一个结构； 可选标记film：使用该标记引用该结构；如struct film piggod; 结构成员使用自己的声明来描述：如电影名称title是一个内含TSIZE个元素的char类型数组； 结构成员可以是任意一种 C 的数据类型，甚至可以是其它结构 结构体右花括号后的分号表明结构布局定义结束。 可以把这个声明置于所有函数外部，在该声明之后的所有函数都可以使用它；也可以将它放在一个函数内部定义，它的标记只限于该函数内部使用 #define TSIZE 45//存储名片的数组大小 //函数外部声明一个结构 struct film { char title[TSIZE];//电影的片名 int rating;//电影的评分 }; 1.2、定义结构 结构有两层含义： 结构布局：告诉编译器如何表示数据，但是编译器并没有为数据分配内存空间。 创建一个结构变量； void filmMain(void) { /* 编译器执行该行代码，创建了一个结构变量piggod， * 该变量的结构布局是 film； * 编译器使用 film 模板为该变量分配内存空间：一个内含 TSIZE 个元素的 char 数组和一个 int 型的变量 * 这些结构成员的存储空间与变量 piggod 结合在一起 */ struct film piggod; } 在结构变量的声明中，struct film所起的作用相当于一般声明中的 int 或 float。我们可以声明一个指向结构的指针： struct film piggod ,dogs , * clapton; 1.2.1、声明与定义结构 如果该结构模板 film 不打算多次使用，我们可以将声明结构和定义结构的过程组合为一个步骤 struct { char title[TSIZE];//电影的片名 int rating;//电影的评分 } piggod; 上述声明没有使用结构标记（结构标记是可选的），在定义结构时，并未初始化结构变量 1.2.2、初始化结构 与初始化数组类似，我们以类似的语法初始化结构： struct film piggod = { \"变形金刚\", 8 }; 使用一对花括号中括起来的初始化列表进行初始化，各初始化项用逗号分隔。 注意：如果初始化是一个静态存储期的结构，初始化列表的值必须是常量。如果是自动存储期，初始化列表的值可以不是常量。 1.2.3、访问结构成员 数组可以使用下标访问数组中的各个元素，那么如何访问结构中的成员呢？ a、点访问 (结构成员运算符) 我们可以通过结构成员运算符访问结构成员： piggod.title b、-> 访问 (间接成员运算符) 后文再讲。 1.2.4、结构的初始化器 结构的指定初始化器使用点运算符和成员名标识特定的元素： struct film cats = { .rating = 9 }; 可以按照任意顺序指定初始化器： struct film cats = { .rating = 9, .title = \"猫\" }; 与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。 1.3、结构的复合字面量 C99 的复合字面量特性可用于数组和结构：当需要一个临时结构值时，我们可以选择使用复合字面量。 语法：类型名放在圆括号中，后面紧跟一个用花括号括起来的初始化列表 //使用复合字面量为一个结构变量提供两个可替换的值 (struct film){\"dogs\",8}; 还可以把结构字面量作为函数的参数传递：字面量在所有函数外部，则具有静态存储期；在块中，则具有自动存储期。 1.4、嵌套结构 有时，需要在一个结构中包含另一个结构，即嵌套结构。如统计一个人的爱好：可能有电影、音乐等： struct music { char title[TSIZE];//音乐名字 char singer[TSIZE];//歌手 }; //爱好 hobby中嵌套另外的结构 struct hobby{ struct film movie; struct music song; }; 和一般声明类似，在结构声明中创建嵌套结构如下： struct hobby myHobby = { { \"变形金刚\", 8 }, { \"大象\", \"花伦\" } }; 访问嵌套结构中的成员，需要多次使用点运算符 /* 点运算符从左往右运算 * 先找到 myHobby，然后找到 myHobby 的 movie 成员； * 再找到 movie 的 title 成员 (myHobby.movie).title */ myHobby.movie.title; myHobby.song.singer; 注意：结构不能嵌套与本身类型相同的结构，但是可以含有指向同类型结构的指针。 1.5、匿名结构 匿名结构是一个没有名称的结构成员： struct hobby{ struct film movie; struct {//匿名结构 char muTitle[TSIZE];//音乐名字 char singer[TSIZE];//歌手 }; }; 上述结构 hobby 是一个嵌套结构，通过点运算符访问其成员： struct hobby myHobby = {{\"变形金刚\",8},{\"大象\",\"花伦\"}}; myHobby.movie.title; myHobby.muTitle; 在访问匿名结构中的成员时，将 muTitle看做hobby成员直接使用它。 1.6、结构指针 为何要使用指向结构的指针？ 类似于指向数组的指针比数组本身更容易操控（排序问题），指向结构的指针通常比结构本身更容易操控； 在早期的 C 实现中，结构不能作为参数传递给函数；可以传递结构指针； 相对于传递一个结构，传递指针显然效率更高； 某些用于表示数据的结构中包含指向其它结构的指针 1.6.1、声明与初始化结构指针 声明结构指针与其它指针声明一样： struct film *sky; 以上声明并没创建一个新的结构，但是指针 sky 可以指向任意现有的 film 类型的结构； sky = &piggod; 注意：与数组不同的是，结构变量名并不是结构的地址；获取结构变量地址需要在结构变量名前加 & 运算符 1.6.2、用结构指针访问成员 我们可以使用间接成员运算符 -> 访问结构成员： sky -> title; sky -> rating; 此处不能写成 sky.title ，因为 sky 不是结构; 1.7、向函数传递结构 函数的参数把值传递给函数，ANSI C 允许把结构作为参数使用；我们可以选择传递结构本身，或者传递指向结构的指针，甚至只传递结构的某一成员。 1.7.1、传递结构成员 只要结构成员是一个具有单个值的数据类型（int 、char、float），便可以把它作为参数传递给接受该特定类型的函数。 int sum(int a ,int b){ return a + b; } 如上述sum()函数，既不知道也不关心实参是否是结构成员，它只要求传入int类型； 如果需要在被调函数中修改主调函数中结构成员的信息，需要传递成员的地址： char * resertTitle(char * title) { title = NULL; return title; } 1.7.2、传递结构地址 void showMovie(const struct film * movie) { printf(\"电影 : %s 评分 : %d\",movie ->title,movie->rating); } 由于该函数不需要改变结构成员，所以使用一个指向const的指针。 1.7.3、传递结构 我们还是使用上述函数来展示： void showMovie(struct film movie) { printf(\"电影 : %s 评分 : %d\",movie.title,movie.rating); } 我们知道，在程序调用 showMovie() 函数时，编译器根据该函数实参创建了一个名为 movie 的自动结构变量，为实参的副本，存储在栈区。 也就是说，即使我们在该函数中修改movie 的成员信息，也是修改的副本信息，而非主调函数中结构成员的信息。 同时，如果结构占用内存过大，传递结构也对内存开销是一种浪费。 1.7.4、结构与结构指针的选择 如果我们需要编写一个处理结构的函数，那么传递结构作为参数，还是传递结构指针呢？这两者皆有优缺点： 优点 缺点 传递结构指针 执行效率高 无法保护数据（被调函数的某些操作可能影响原来结构中的数据），可以使用const限定符解决 传递结构 函数处理的是原始数据的副本，保护了原始数据；代码风格清晰 传递结构浪费时间和存储空间；对于大型数据结构，为了使用某几个成员信息而传递整个结构是一种极大的性能浪费 为了效率，我们一般使用结构指针作为函数参数，如果不需要修改原始数据，使用const限定符防止数据被以外篡改。 1.8、结构中的字符数组和字符指针 在前面的 struct film，笔者使用字符数组来存储字符串，字符串存储在结构内部。当然，也可以使用指向 char 的指针来代替字符数组，此时结构内存只存储该字符串的指针： struct film { char title[TSIZE];//字符串存储在结构内存 char *director;//结构内存只存储字符串指针 int rating; }; 我们来看以下语句： scanf(\"%s\",piggod.director); scanf() 函数将输入的字符串放入piggod.director地址上。如果piggod.director未初始化，则该字符串地址可能是任意值，因此程序执行该语句时可能把输入的字符串放在任意位置，这一操作可能导致程序崩溃。 使用结构存储字符串，字符串数组作为成员比较简单；而指向 char 的指针可能会犯错，导致严重问题。 1.9、结构、指针、malloc() 使用 malloc() 函数为结构变量分配内存并使用指针存储该地址，可以为字符串分配合适的存储空间 2、结构与数组 结构 数组 赋值 C 允许把一个结构赋值给另一个结构 不能把一个数组赋值给另一个数组 变量名 结构变量名并不是结构的地址 数组名是数组首元素的地址 struct film piggod = { \"变形金刚\", 8 }; /* 该语句将 piggod 的每个成员赋值给 cat 的相应成员 * 即使成员是数组，如title，也能完成赋值 */ struct film cat = piggod; 假如我们要收集多部电影的信息，我们可以使用数组来存储这多个电影结构。 2.1、声明结构数组 声明结构数组与声明其它类型的数组类似： //数组 filmList 中每个元素都是 struct film 类型的结构变量 struct film filmList[100]; 2.2、标识结构数组的成员 为了标识结构数组的成员，可以采用访问单独结构的规则：在结构名后面加一个点运算符，再在点运算符后面写上成员名。 filmList[0];//访问第 1 个位置的结构变量 filmList[1].rating;//访问第 2 个位置的结构变量的 rating 成员 filmList[3].title;//访问第 4 个位置的结构变量的 title 成员 filmList[5].title[7];//访问第 6 个位置的结构变量的 title 字符串的第 8个字符 2.3、函数中使用结构数组传参 我们需要计算结构数组中所有电影的平均评分，将结构数组作为实参换地给以下函数： float average(const struct film movies[],int count) { int total = 0; for (int i = 0; i 数组名movies是该数组的地址，movies[0]是数组中第1个结构变量，通过点运算符访问结构成员。 3、链式结构 学习计算机语言和学习音乐一样：首先学会使用工具，学习如何演奏音阶、如何使用锤子等；然后解决各种问题；接着，对于更高层次，工具是次要的，需要设计和创建一个项目。 我们已经学习了 C 语言的基本数据类型int、float等以及派生类型 数组、指针、结构等，我们可以使用这些基础类型与派生型解决一些常见的问题。 然而，对于复杂的问题，这些数据类型显然并不能完全处理我们遇到的问题。 针对上文的struct film，需要统计一个人一年看过的电影。我们如何存储这些数据呢？使用结构数组？或者使用malloc()动态分配内存？还是其他的形式？ 是否需要按字母排序？是否需要按评分排序？如何快速查找到一部电影？ 3.1、使用结构数组 我们不妨使用一个数组存储一年看过的电影，每部电影使用结构表示： #define TSIZE 45 //存储名片的数组大小 #define FMAX 5 //影片的最大数量 struct film { char title[TSIZE];//电影的片名 int rating;//电影的评分 }; char * s_gets(char str[], int lim); void filmMain1(void) { struct film movies[FMAX];//创建一个结构数组 int i = 0;//当前输入电影位置 /* 将用户输入的数据存储在数组中 * 数组已满(FMAX)、达到文件末尾(NULL)、或者按下Enter键('\\0')；输入终止 */ puts(\"输入第一部电影标题:\"); while (i :\"); scanf(\"%d\", &movies[i++].rating); while(getchar() != '\\n') continue; puts(\"输入下一个电影标题 (遇到空行停止):\"); } if (i == 0) printf(\"没有数据输入. \"); else printf (\"以下是电影列表:\\n\"); for (int j = 0; j 上述程序创建了一个结构数组，然后将输入的数据存储在数组中。 我们可以明显感觉到该程序的缺陷：首先，该程序浪费存储空间；大部分电影名不会超过 40 个字母，但是有些电影名超过 40 个字母；其次，只记录 5 部电影，限制太严格；限制小了无法满足用户需求，限制大了浪费内存。 总的来说，该程序的最大问题，就是 数据表示死板、不太灵活。可以在编译时确定所需内存量，使用malloc()函数分配需要的内存，这或许会灵活些。 3.2、链表 我们的需求是可以不确定的添加数据，而不是指定输入多少项、指定程序分配多大的空间。我们有两种方式使用malloc()函数分配内存： 一次性分配足够的内存，前面已经尝试过，太死板不灵活； 每次存储电影时使用malloc()分配一个内存，这时我们需要知道每个电影struct film的内存地址。 我们可以重新定义结构struct film，每个结构中包含指向 next的结构指针，当创建结构时，将该结构的地址存储在上一个结构中。 struct film { char title[TSIZE]; int rating; struct film * next; }; 结构不能嵌套与本身类型相同的结构，但是可以含有指向同类型结构的指针。这是定义链表的基础，链表中每一项都包含着指向下一项的信息。 3.2.1、链表定义 链表是一个能存储一系列项且可以对其进行所需操作的数据对象。 链表具有哪些属性？首先，链表应该能存储一系列的项；其次，链表类型应该提供一些操作。一般的链表包含以下操作： 初始化一个空链表； 在链表末尾添加一个新项； 确定链表是否为空； 确定链表是否为已满； 确定链表中的项数； 访问链表中的每一项执行某些操作，如显示该项； 在链表的任意位置插入一个项； 移除链表中的一个项； 在链表中检索一个项（不改变链表）； 用另一个项替换链表中的一个项； 在链表中搜索一个项 3.2.2、使用链表 我们已经简单了解链表，现在使用链表解决问题：由于代码过多，请点击查看 Demo 3.3、队列 队列是具有两个属性的链表： 第一，新项只能添加到链表的末尾； 第二，只能从链表的开头移除项。 队列是一种先进先出(FIFO)的数据形式。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"语言篇/C递归.html":{"url":"语言篇/C递归.html","title":"递归","keywords":"","body":"C 递归 C 允许函数调用自己，这种过程称为递归。 一般而言，可以使用循环的地方都可以使用递归。有时循环解决问题好，有时使用递归更好。递归方案简洁，但效率没有循环高。 1、简单示例 我们来看一个简单示例，了解递归是什么： void recursion(int n); int main(int argc, const char * argv[]) { recursion(1); return 0; } void recursion(int n) { printf(\"Level %d: n location %p\\n\", n, &n); // 打印语句1 if (n 在main()函数中调用recursion(1)，这次调用是第1级递归；然后recursion()调用自己，是第2级递归；依次类推... 我们运行该段程序，分析打印结果： Level 1: n location 0x7ffeefbff54c Level 2: n location 0x7ffeefbff52c Level 3: n location 0x7ffeefbff50c Level 4: n location 0x7ffeefbff4ec LEVEL 4: n location 0x7ffeefbff4ec LEVEL 3: n location 0x7ffeefbff50c LEVEL 2: n location 0x7ffeefbff52c LEVEL 1: n location 0x7ffeefbff54c 在每次递归中，变量n都属于本级递归私有。 执行第1级递归时，执行到if语句，判断为真，执行第2级递归；一直到 n = 4（第4级递归）时if语句，判断为假，recursion()不再调用自己，此时调用打印语句2，接着第4级递归执行完毕；返回第3级递归接着执行... 我们可以理解为一条函数链：func1() ->func2() ->func3() ->func4() ；func4()结束时，控制传回func3() ->func2() ->func1()。递归中func1() 、func2()、func3() 、func4() 都是相同的函数。 2、基本原理 每一级递归都有自己的变量，如上图所示；每级递归的变量n值不同、内存地址不同。上述示例经历了四次递归，程序创建了4个单独的变量。当程序最终返回第1级递归时，最初的n仍然是它的初值 1。 每次函数调用都会返回一次。当函数执行完毕，控制权被传回上一级递归。程序按顺序返回递归，不能从第 3 级递归跳到第1级递归。 递归函数中位于递归调用之前的语句，按被调用函数顺序执行代码。 递归函数中位于递归调用之后的语句，按被调用函数相反的顺序执行代码。 虽然每一级递归都有自己的变量，但是并没有拷贝函数的代码。除了每次递归创建变量以外，递归类似于循环语句。 递归必须有让递归调用停止的语句。如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。 3、尾递归 把递归调用置于函数末尾，即正好在return之前，这种形式的递归称为尾递归。 尾递归是最简单的递归形式，相当于循环语句。 我们分别使用循环和递归计算阶乘：(阶乘公式：n!=n*(n-1)!) 循环计算阶乘 //循环函数 long factorial(int n) { long ans; for (ans = 1; n > 1; n--) ans *= n; return ans; } { printf(\"循环计算阶乘： 10! = %ld \\n\",factorial(10)); //循环计算阶乘： 10! = 3628800 } 递归计算阶乘 /* 递归函数： * 虽然递归调用不是函数的最后一行， * 但是当 n > 0 时，它是该函数执行的最后一条语句， * 因此也是尾递归 */ long rfactorial(int n) { long ans; if (n > 0) ans= n * rfactorial(n-1); else ans = 1; return ans; } { printf(\"递归计算阶乘： 10! = %ld \\n\",rfactorial(10)); //递归计算阶乘： 10! = 3628800 } 阶乘公式n!=n*(n-1)!，这种特性适合使用递归求值。 上述两个方法求值结果都相同，那么我们到底应该使用哪个呢？一般而言，使用循环比较好： 首先，每次递归都会创建一组变量，又将新创建的变量放在栈中，递归使用的内存更多；递归调用的数量受限于内存空间 其次，每次函数调用都会花费一定的时间，即递归调用的速度比循环慢。 4、递归与倒序计算 既然递归在空间与时间上都比较复杂，为何还要使用递归？在某些问题上，使用递归更为简单：如倒序。 设计一个以二进制形式表示整数的算法：一般而言，对于整数n，其二进制的最后一位是 n%2，因此计算的第一位数字实际上是待输出的二进制数的最后一位。 这一规律提示我们，在递归函数的递归调用之前计算n%2，在递归调用之后打印结果。 这样，计算的第 1 个值正好是最后一个打印的值。 void to_binary(unsigned long n) { int r; r = n % 2; if (n >= 2) to_binary(n / 2); putchar(r == 0 ? '0' : '1'); return; } { printf(\"整数10转为二进制为 \"); to_binary(10); printf(\"\\n\"); } //整数10转为二进制为 1010 不用递归，我们还可以使用别的算法实现以二进制形式表示整数。 位移计算 将十进制转为二进制，要获得下一位数字，必须把原数除以 2；这类似于在十进制下将小数点左移一位。如果计算是偶数，那么二进制的下一位是 0；如果计算是奇数，那么二进制的下一位是 1。 #include #include char * itobs(int n, char * ps); int main(int argc, const char * argv[]) { char bin_str[CHAR_BIT * sizeof(int) + 1]; printf(\"整数10转为二进制为 %s \\n\",itobs(10,bin_str)); return 0; } char * itobs(int n, char * ps) { int i; const static int size = CHAR_BIT * sizeof(int); for (i = size - 1; i >= 0; i--, n >>= 1) ps[i] = (01 & n) + '0'; ps[size] = '\\0'; return ps; } 5、递归的优缺点 递归为某些编程问题提供了最简单的解决方案，缺点是一些递归算法会快速消耗计算机的内存资源；另外，递归不易于维护。 比如使用递归计算斐波那契数列F(n)=F(n-1)+F(n-2)： unsigned long fibonacci(unsigned n) { if (n > 2) return fibonacci(n - 1) + fibonacci(n - 2); else return 1; } 该函数使用了双递归。 函数在每一级递归调用两次，第1级递归创建变量n，然后调用两次，在第2级调用中分别创建2个变量n；在第3级调用中分别创建4个变量n... 每一级递归创建的变量时上一级的两倍，变量的数量呈指数爆炸增长，很快就会消耗掉计算机的大量内存，很可能导致程序崩溃。 因此在使用使用递归时要特别注意 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-13 11:05:13 "},"Git体系/Git常用命令.html":{"url":"Git体系/Git常用命令.html","title":"Git常用命令","keywords":"","body":"Git常用命令 仓库：每个项目都可以看作一个仓库！仓库管理 代码管理：单人项目、或者多人协作开发的项目； 进度管理：每提交一次代码，就产生一个时间节点；众多时间点形成一条时间线！ 1、配置 Git 1.1、管理工具 Git 的安装 /// Git 官网下载 git 或者使用 brew 下载 Git MacBook-Pro $ brew install git /// 查看 Git 版本号： MacBook-Pro $ git --version git version 2.30.1 (Apple Git-130) 1.2、查看 Git 的全局配置 MacBook-Pro $ git config --global --list user.email=123456@qq.com user.name=nickName core.excludesfile=/Users/.gitignore_global difftool.sourcetree.cmd=opendiff \"$LOCAL\" \"$REMOTE\" difftool.sourcetree.path= mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh \"$LOCAL\" \"$REMOTE\" -ancestor \"$BASE\" -merge \"$MERGED\" mergetool.sourcetree.trustexitcode=true commit.template=/Users/.stCommitMsg Git 的用户名 和 邮箱地址 是本地 Git 客户端的一个变量，当安装 Git 后首先要做的事情就是设置本地 用户名 和 邮箱地址 ，因为每次 Git 提交都会使用这个 用户名 和 邮箱地址 来记录提交信息！这些信息不会随着远程仓库的改变而变化！ 1.2.1、修改全局 Git 用户名和邮箱 /// 修改全局配置 MacBook-Pro $ git config --global user.name \"nickName2\" MacBook-Pro $ git config --global user.email \"123456789@qq.com\" 1.2.2、查看当前 Git 用户名和邮箱 /// 查看全局配置 MacBook-Pro $ git config user.name nickName2 MacBook-Pro $ git config user.email 123456789@qq.com 1.3、初始化本地 Git 仓库 MacBook-Pro $ cd /Users/Desktop/GitTest MacBook-Pro : GitTest $ git init hint: Using 'master' as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch hint: hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and hint: 'development'. The just-created branch can be renamed via this command: hint: hint: git branch -m Initialized empty Git repository in /Users/Desktop/GitTest/.git/ 1.3.1、指定仓库的用户名和邮箱 如果希望在不同的项目中使用不同的 用户名 和 邮箱地址 来提交，可以使用下面的方法单独设置 用户名 和 邮箱地址 ，如果不设置就会默认使用上面全局设置的 用户名 和 邮箱地址。 /// 到本地仓库下配置 MacBook-Pro $ cd /Users/Desktop/GitTest MacBook-Pro : GitTest $ git config user.name \"nickName3\" MacBook-Pro : GitTest $ git config user.email “654321@qq.com” /// 查看配置详情 MacBook-Pro : GitTest $ git config user.name nickName3 MacBook-Pro : GitTest $ git config user.email “654321@qq.com” 本地配置的用户名 和 邮箱地址 只是用来记录本地 Git 提交信息的一个标识，和远程仓库账号下的 用户名 或 邮箱地址 没有任何关系。 1.3.2、忽略项目中的某些文件 建立一个 .gitignore 文件，在文件中配置一些无需上传到远程 Git 仓库的内容： *~ *.DS_Store *xcuserdata* *gitconfig *.diff build/* product/* driveData/* *.xcuserstate project.xcworkspace xcuserdata UserInterfaceState.xcuserstate project.xcworkspace/ xcuserdata/ UserInterface.xcuserstate 2、文件操作 通常将本地 Git 仓库分为三个区： 本地代码区， 暂存区：使用 git add . 将写好的代码提交到暂存区，等待推到远程仓库去； 远程仓库：使用 git commit -m'' 命令将暂存区代码提交到远程仓库去； 2.1、查看项目状态 使用 git status 可以查看当前的项目状态！ 没有任何改动 MacBook-Pro:GitTest $ git status On branch name Your branch is up to date with 'origin/name'. nothing to commit, working tree clean 创建文件 test.md 后的状态 MacBook-Pro :GitTest $ touch test.md MacBook-Pro :GitTest $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) test.md nothing added to commit but untracked files present (use \"git add\" to track) 2.1.1、文件的添加 /// 使用命令工具添加某个文件 MacBook-Pro :GitTest $ git add test.md /// 添加仓库中的所有改动 MacBook-Pro :GitTest $ git add . 2.1.2、文件的删除 /// 使用命令工具删除某个文件 MacBook-Pro :GitTest $ git rm test.md /// 查看与上次提交的不同之处 MacBook-Pro :GitTest $ git diff 2.2、查看提交记录 2.2.1、查找本地过往提交记录 /// 查看全部提交 MacBook-Pro :GitTest $ git log /// 查看某个人的提交 MacBook-Pro :GitTest $ git log --author name 2.2.2、查看某个文件的提交记录 /// 查看某个文件的提交记录 MacBook-Pro :GitTest $ git log --pretty=oneline test.md 5f6e42605a5a26036452d336fd6f2677adc68bd0 (HEAD -> master) hello2 1acfff2f562645d0103c0e52783d6fc8ef59c8c1 hello 23983f57a6ee316290b6198fbca34a8689254ebb creat test.md 2.2.3、查看某次提交记录的详情 /// 查看某次提交记录的详情 MacBook-Pro:GitTest $ git show 1acfff2f562645d0103c0e52783d6fc8ef59c8c1 commit 1acfff2f562645d0103c0e52783d6fc8ef59c8c1 Author: nickName3 Date: Fri Oct 29 09:55:23 hello diff --git a/test.md b/test.md index e69de29..c1bf8ad 100644 --- a/test.md +++ b/test.md @@ -0,0 +1 @@ +Hello Word 2.2.4、查看某个文件的具体修改记录 /// 查看修改的具体详情 MacBook-Pro:GitTest $ git log -p home/test.md commit 5f6e42605a5a26036452d336fd6f2677adc68bd0 (HEAD -> master) Author: nickName3 Date: Fri Oct 29 09:56:00 2021 +0800 hello2 diff --git a/test.md b/test.md index c1bf8ad..e9d56ca 100644 --- a/test.md +++ b/test.md @@ -1 +1,3 @@ Hello Word + +Hello Word2 commit 1acfff2f562645d0103c0e52783d6fc8ef59c8c1 Author: nickName3 Date: Fri Oct 29 09:55:23 2021 +0800 hello diff --git a/test.md b/test.md 2.3、文件还原 2.3.1、回退某个文件到上一次提交记录 /// 将某个文件还原到上一次提交的状态 MacBook-Pro:GitTest $ git checkout -- home/test.md 2.3.2、整个项目回退到某个版本 /// 回退到上一版本：一个 ^ 代表一个版本，回到到前两次版本 ^^ MacBook-Pro:GitTest $ git reset --hard HEAD^ /// 回退到指定版本： 使用 commit ID 寻找某一版本 MacBook-Pro:GitTest $ git reset --hard ff3e0742bfae4303 2.3.3、某一文件回退到某个版本 可能在某些时候，你并不希望将整个版本回退到某个版本，而仅仅希望对某个文件做回退操作！ /// 查看版本提交记录 MacBook-Pro:GitTest $ git log commit 23983f57a6ee316290b6198fbca34a8689254ebb (HEAD -> master) Author: nickName3 Date: Fri Oct 29 09:53:47 creat test.md /// 将指定文件回退到指定版本 MacBook-Pro:GitTest $ git checkout 1acfff2f562645d0103c0e52783d6fc8ef59c8c1 -- test.md 2.4、文件追踪 文件追踪：如果将代码加入到暂存区，Git 就会实现对这个文件的追踪，就无法进行还原操作！ /// 先将修改的文件加入暂存区 MacBook-Pro:GitTest $ git add test.md /// 此时无法将某个文件还原到上一次提交的状态 MacBook-Pro:GitTest $ git checkout -- home/test.md /// 也即是说：Git 对该文件实现了追踪，不允许回到原来状态 2.4.1、撤销文件追踪 某些时候，我们不希望 Git 追踪暂存区的代码，这时候可以撤销追踪 /// 撤销对文件 test.md 的追踪 MacBook-Pro:GitTest $ git reset HEAD home/test.md 2.5、为每一个版本打标签 tag /// 列出所有标签 MacBook-Pro:GitTest $ git tag /// 新建tag MacBook-Pro:GitTest $ git tag V1.0.0 /// 推送tag到远程 MacBook-Pro:GitTest $ git push origin V1.0.0 /// 本地删除某个标签 MacBook-Pro:GitTest $ git tag -d V1.0.0 /// 远程删除 tag MacBook-Pro:GitTest $ git push origin :refs/tags/V1.0.0 3、分支 分支：需要完成某项工作时，从主线中脱离出来的一条支线；由支线完成单独的功能，最终再将支线合并到主线上！ 3.1、创建分支 /// 新建一个本地分支 MacBook-Pro:GitTest $ git checkout -b L2 /// 把新建的本地分支push到远程服务器 MacBook-Pro:GitTest $ git push origin L2:L2 /// 新建本地分支，并切换到远程分支 MacBook-Pro:GitTest $ git checkout -b local/2 origin/0.0.2 /// 拉取远程分支到本地 MacBook-Pro:GitTest $ git fetch 注意：创建一个本地分支时，将当前分支拷贝至新创建的分支，此时也会将当前分支的 git commit 的文件拷贝至新的分支！ 3.2、查看分支 /// 查看本地分支 MacBook-Pro:GitTest $ git branch ///查看远程分支 MacBook-Pro:GitTest $ git branch -r /// 查看所有分支 MacBook-Pro:GitTest $ git branch -a 3.2.1、切换分支 /// 切换本地分支 MacBook-Pro:GitTest $ git checkout master 3.3、删除分支 注意：不能删除当前分支！ -d 删除某个分支 -D 强制删除某个分支 如果某个分支有 git commit 操作 ，也是不能删除的！ /// 删除本地分支 MacBook-Pro:GitTest $ git branch -D L3 /// 删除远程分支 MacBook-Pro:GitTest $ git push origin --delete L4 3.4、合并分支 切换到分支 L1，然后将分支 L2 的改变合并到 L1 ！ MacBook-Pro:GitTest $ git checkout L1 Switched to branch 'L1' MacBook-Pro:GitTest $ git merge L2 Merge made by the 'recursive' strategy. 3.4.1、合并冲突 当在不同的分支修改同一处代码时，将这两个分支合并，就可能碰到合并冲突！ >>>>>> L1 (传入分支的更改) 解决方案一：忽略其他分支的修改 当遇到合并冲突时，其中一个解决方案是忽略其它分支的修改，保留当前分支！ MacBook-Pro:GitTest $ git merge --abort 解决方案二：手动解决冲突 删除 等特殊符号，代码视情况保存！修改完代码后将新的代码提交 git commit! 3.4.2、合并某次提交 将历史上某次提交合并到指定分支! /// 查找需要合并的commit记录 MacBook-Pro:GitTest $ git log /// 将 8a645bf5 提交合并到当前分支 MacBook-Pro:GitTest $ git cherry-pick 8a645bf5 3.5、查看版本路线 /// 查看当前分支的所有提交记录 MacBook-Pro:GitTest $ git log /// 查看提交记录的简要信息 MacBook-Pro:GitTest $ git log --oneline /// 查看当前版本路线 MacBook-Pro:GitTest $ git log --oneline --graph * 196b56b2 (HEAD -> L1, origin/L1) 提交摘要信息 * 15c8da07 (origin/master, origin/HEAD, master) Merge branch 'L1' into 'master' |\\ | * 1f0f75ec 提交摘要信息 |\\| 3.6、其它操作 拉取远程分支 ///拉取远程某个分支 MacBook-Pro:GitTest $ git clone -b 分支名 git仓库 4、pull 命令 ///将与本地当前分支同名的远程分支 拉取到 本地当前分支上 MacBook-Pro:GitTest $ git pull /// 将远程指定分支 拉取到 本地当前分支上 MacBook-Pro:GitTest $ git pull origin /// 将远程指定分支 拉取到 本地指定分支上 MacBook-Pro:GitTest $ git pull origin : 4.1、回退到 pull 之前 /// 查看提交记录 MacBook-Pro:GitTest $ git reflog /// 回退到某一版本 MacBook-Pro:GitTest $ git reset --hard 70973042 5、push 命令 /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 MacBook-Pro:GitTest $ git push /// 将本地当前分支 推送到 远程指定分支上 MacBook-Pro:GitTest $ git push origin : /// 将本地当前分支 推送到 与本地当前分支同名的远程分支上 MacBook-Pro:GitTest $ git push origin 5.1、回退到本地某个版本 /// 查看历史提交 MacBook-Pro:GitTest $ git log commit 12caba23700c057a (HEAD -> branch, origin/branch) 代码1 commit 4d4d5ad55045ddbc (HEAD -> branch, origin/branch) 代码2 commit ff3e0742bfae4303 (HEAD -> branch, origin/branch) 代码3 /// 本地回退到代码 3 MacBook-Pro:GitTest $ git reset --hard ff3e0742bfae4303 HEAD is now at 4d4d5ad5 代码3 /// 强制同步远程仓库的分支 MacBook-Pro:GitTest $ git push origin branch -f 6、Pull Request Github 的 Pull Request 功能，简写为 PR；适用于多人合作的项目！ 6.1、什么是 Pull Request Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。 Pull Request 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码。 注意：GitHub 的代码贡献，是请求别人 pull 你的代码，而不是请求别人接受你的 push。因为对应的 git 操作必须是 pull 而不能是 push，所以叫 pull request 而不是 push request。 6.2、 Pull Request 的流程 第一步，在 Git 仓库创建自己的分支！ 第二步，在修改后的分支上，按下 New pull request 按钮。 这时，会进入一个新页面，有 Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。 第三步，填写说明，帮助别人理解你的提交，然后按下 create pull request 按钮即可。 PR 创建提交后，管理者就要决定是否接受该 PR。 参考文章 Pull Request 的命令行管理 git: 为什么 pull request 不叫 push request ? Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"Git体系/Github和SSH密钥.html":{"url":"Git体系/Github和SSH密钥.html","title":"Github和SSH密钥","keywords":"","body":"Github和SSH密钥 SSH 密钥允许本地计算机和 Git 远程仓库之间建立安全连接。 我们在使用 Git 管控项目时，需要一个安全的通信通道来共享信息。可以使用 用户名与密码 的认证方式，但每次输入密码，太过麻烦；还可以使用 SSH 协议向 Git 远程服务器进行身份验证。 有关SSH协议如何工作的更详细说明，建议阅读教程 DigitalOcean 。 1、SSH密钥的类型 Git 支持RSA、DSA、ECDSA和ED25519密钥。它们的区别在于签名算法，其中一些具有其他优势。 本文重点关注ED25519和RSA等。 1.1、RSA 密钥 RSA密钥是最常见的密钥，经典且可靠，兼容 OpenSSH 6.5 之前的服务器版本。 RSA 密钥最小为1024位，默认为 2048；如果希望生成更强的RSA密钥对，需要使用 -b 指定位值。 /// -t rsa 表示使用 RSA 算法 /// -b 指定 RSA 密钥为 4096 位;默认 2048 位 /// 使用 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码 MacBook ~ % ssh-keygen -o -t rsa -b 4096 -C 123456@github.com SSH 私钥密钥的旧的默认密码编码不安全。从 OpenSSH 6.5 版开始，应该使用该 -o 选项以 ssh-keygen ，更安全的格式对 RSA 私钥进行编码。 但 RSA 密钥性能不够理想；所以建议使用 ED25519， ED25519 的安全性在 RSA 2048 与 RSA 4096 之间，且性能在数十倍以上。 1.2、ED25519 密钥 ED25519 密钥是在 OpenSSH 6.5 中引入的，如果GitLab服务器不兼容 ED25519 键，可以使用RSA 密钥！ ED25519 密钥加密解密很快，生成时间短而且安全性更高！ 所以现在建议使用ED25519 密钥！ 注意： 一对密钥只对应一个 Git 服务：一对密钥通吃各 Git 服务不太安全。 2、ED25519 的使用 2.1、ED25519 的制作 在Linux 或 macOS上打开终端，生成新的 ED25519 SSH 密钥对: //生成一个新的ED25519 SSH密钥对 MacBook ~ % ssh-keygen -t ed25519 -C 123456@qq.com Generating public/private ed25519 key pair. Enter file in which to save the key (/Users/long/.ssh/id_ed25519): /Users/long/.ssh/Test Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/long/.ssh/Test. Your public key has been saved in /Users/long/.ssh/Test.pub. The key fingerprint is: SHA256:FC2Qz4gvekNv8m4BcvptmI+oPKA8eqrZdhNTp/7Hkb8 123456@qq.com The key's randomart image is: +--[ED25519 256]--+ | .o.. | | . ... | | . +.. | | . + o.+ | | + + oS . | |. . = + o | |+ + X . . o | |o*+.X.B o . | |O*=o.@+... E. | +----[SHA256]-----+ 注意： passphrase 是给私钥添加一个 解锁口令！私钥必须要有 passphrase：如果私钥文件遗失，没有 passphrase 也无法解锁，只能暴力破解；所以不要偷懒，passphrase 一定要设置。 此时，已经将密匙对保存在本地！我们可以去查看并获取密匙： /// 进入ssh默认路径 MacBook ~ % cd ~/.ssh /// 查看该文件夹下的文件 MacBook .ssh % ls Test Test.pub known_hosts /// 打印公匙 Test.pub MacBook .ssh % cat Test.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTEL7FM0x60p5/S3M6IaBLkyi3OroA 123456@github.com /// 或者直接将 Test.pub 复制到剪贴板 MacBook % pbcopy 我们需要将 ED25519 的公匙复制到剪贴板，并添加到 Git 仓库！ 2.2、添加 ED25519 的公匙到 Git 远程仓库 在 Git 远程仓库中，通过点击 个人中心 -> Settings -> SSH and GPG Keys ，然后添加！ 注意： 手动复制的 ED25519 公匙，请确保以 ssh-ed25519 开头并以电子邮件结尾。 2.3、测试是否正确设置 SSH 密钥 要测试是否正确添加了SSH密钥，可以在终端中运行以下命令（自己的服务器，替换 github.com 的域名）： 2.3.1 、Permission denied (publickey) ssh -T git@github.com git@github.com: Permission denied (publickey). ///权限被拒，添加失败 如果设置正确，应该受到类似于下述的 欢迎消息： Welcome to github, @123456! 如果未出现欢迎消息，可以替换 -T 为-vvvT 来运行 SSH 的详细模式，以了解错误的位置： ssh -vvvT git@github.com 不过一般情况下，可以使用下述两个操作，将 SSH 密钥添加到高效缓存中： /// 首先进入 ssh 文件夹 MacBook ~ % ~ % cd ~/.ssh /// 然后将 ，将 SSH 密钥添加到高效缓存中 MacBook .ssh ~ % ssh-agent -s MacBook .ssh ~ % ssh-add ~/.ssh/Test 2.3.2 、but GitHub does not provide shell access. MacBook :.ssh $ ssh -T git@github.com Hi K! You've successfully authenticated, but GitHub does not provide shell access. 查看该 Git 仓库提交方式： MacBook $ git remote -v origin https://github.com/xxx/x (fetch) origin https://github.com/xxx/x (push) 发现不是 ssh 方式，需要改为 ssh 方式 MacBook $ git remote set-url origin git@github.xxx/ix.git MacBook $ git remote -v /// 再次查看 origin git@github.com:xxx/x.git (fetch) origin git@github.com:xxx/x.git (push) 参考文章： github配置ssh key过程中为什么需要ssh-add这一步呢？ 使用 Ed25519 算法生成你的 SSH 密钥 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"Gitbook指导/":{"url":"Gitbook指导/","title":"GitBook 使用教程","keywords":"","body":"GitBook 是使用 GitHub / Git 和 Markdown（或 AsciiDoc ）构建漂亮书籍的命令行工具（和 Node.js 库）。 GitBook 创建和托管图书，可以将您的内容作为网站（可定制和可扩展）或电子书（PDF ，ePub 或 Mobi ）输出。 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"Gitbook指导/gitbook教程.html":{"url":"Gitbook指导/gitbook教程.html","title":"GitBook 安装","keywords":"","body":"gitbook 使用教程 下载 gitbook /// gitbook 是个本地命令行工具 /// 通过 npm 安装 gitbook npm install gitbook-cli -g /// 查看 gitbook 信息、验证安装 gitbook -V /// 列出可以下载的 gitbook 版本 gitbook ls-remote /// 列出本地的 gitbook 版本 gitbook ls /// 卸载对应的 gitbook 版本 gitbook uninstall 3.2.3 /// 安装对应的 gitbook gitbook fetch 标签/版本号 /// 更新到 gitbook 的最新版本 gitbook update /// 帮助 gitbook help 使用 gitbook创建电子书 初始化一个电子书 /// 初始化一个书籍 MacBook-Pro:book $ gitbook init gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件: SUMMARY.md 是默认概括文件，主要是根据该文件内容生成相应的目录结构； README.md 是默认首页文件，用于电子书的简介/前言； gitbook init 报错 MacBook-Pro:book $ gitbook init warn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 问题原因：node.js 版本过高； 解决办法：卸载高版本 node.js ，重新安装稍低版本的 node.js MacBook-Pro:$ node -v v16.6.1 /// 卸载高版本 node MacBook-Pro $ brew uninstall node 去官网下载一个稳定的版本 MacBook-Pro $ node -v v14.17.5 MacBook-Pro $ npm -v 6.14.14 MacBook-Pro $ npm install --global vue-cli 本地预览电子书 启动本地服务，程序无报错则可以在 本地浏览器 预览电子书效果 MacBook-Pro:book $ gitbook serve 制作静态网页 MacBook-Pro:book $ gitbook build 制作 PDF 格式 MacBook-Pro:book $ gitbook pdf MacBook-Pro:book $ gitbook epub MacBook-Pro:book $ gitbook mobi 生成 PDF 格式需要下载 ebook-convert，并链接环境变量 sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 查看目录 MacBook-Pro:booktest $ tree . ├── README.md ├── SUMMARY.md ├── _book │ ├── assets │ │ └── 图1.png │ ├── gitbook │ │ ├── fonts │ │ │ └── fontawesome │ │ │ ├── FontAwesome.otf │ │ │ ├── fontawesome-webfont.eot │ │ │ ├── fontawesome-webfont.svg │ │ │ ├── fontawesome-webfont.ttf │ │ │ ├── fontawesome-webfont.woff │ │ │ └── fontawesome-webfont.woff2 │ │ ├── gitbook-plugin-fontsettings │ │ │ ├── fontsettings.js │ │ │ └── website.css │ │ ├── gitbook-plugin-highlight │ │ │ ├── ebook.css │ │ │ └── website.css │ │ ├── gitbook-plugin-livereload │ │ │ └── plugin.js │ │ ├── gitbook-plugin-lunr │ │ │ ├── lunr.min.js │ │ │ └── search-lunr.js │ │ ├── gitbook-plugin-search │ │ │ ├── lunr.min.js │ │ │ ├── search-engine.js │ │ │ ├── search.css │ │ │ └── search.js │ │ ├── gitbook-plugin-sharing │ │ │ └── buttons.js │ │ ├── gitbook.js │ │ ├── images │ │ │ ├── apple-touch-icon-precomposed-152.png │ │ │ └── favicon.ico │ │ ├── style.css │ │ └── theme.js │ ├── index.html │ └── search_index.json ├── assets │ └── 图1.png ├── book.pdf ├── 篇1.md ├── 篇2.md └── 篇3.md 13 directories, 38 files 配置文件 book.json book.json 是配置文件,用于个性化调整 gitbook 的相关配置！如定义电子书的标题，封面，作者等信息。虽然是手动创建但一般是必选的！ author: 书籍的作者 title: 书籍的标题 description: 书籍的简要描述 language: 支持语言 \"language\": \"zh-hans\", isbn: 国际标准书号 \"isbn\": \"978-0-13-601970-1\", direction: 阅读顺序，支持从右到左(rtl)或从左到右(ltr)；默认值取决于语言值； gitbook: 指定 gitbook 版本； root: 包含所有图书文件的根文件夹的路径， book.json 文件除外； plugins : 添加新插件之后需要运行 gitbook install 来安装新的插件 { \"author\": \"苏莫离\", \"title\": \"初次配置 GitBook 教程\", \"description\": \"初次配置 GitBook 教程，记录一些使用步骤！\", \"isbn\": \"书籍的国际标准书号\", \"language\": \"zh-hans\", \"direction\" : \"ltr\", \"gitbook\": \"3.2.3\", \"root\" : \"./docs\", \"pdf.pageNumbers\" : true, \"pdf.fontSize\" : 12 , \"pdf.fontFamily\" : \"Arial\", \"pdf.paperSize\" : \"a4\", \"pdf.margin.top\" : 10, \"pdf.margin.left\" : 10, \"pdf.margin.bottom\" : 10, \"pdf.margin.right\" : 10, \"plugins\": [ \"highlight\", \"search\", \"sharing\", \"font-settings\", \"livereload\", \"collapsible-menu\", \"anchor-navigation-ex\", \"tbfed-pagefooter\", \"disqus\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": true, /// 是否自定插入标题索引 \"showGoTop\": false }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &SuMoli\", \"modify_label\": \"修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"disqus\": { \"shortName\": \"gitbookuse\" } } } 插入图片 修改一些默认配置 使用 Gitbook 进行项目输出的时候，我们会发现生成 Table of Contents 、 Introduction 等字样！此时需要修改 Gitbook 的预模版 一般情况下 Gitbook 的安装文件会在我们的 Users 目录下的 .gitbook 目录中 其 .gitbook/versions 目录下会有对应的版本号文件夹 修改对应版本号文件夹下的指定文件 ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_i18n/en.json ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_layouts/website/summary.html ~/.gitbook/version/3.2.3/node_modules/gitbook-plugin-theme-default/_layouts/layouts.html 修改某些占位符！ 其它配置 要提供封面，需要将 cover.jpg 文件放在书本的根目录下。添加一个 cover_small.jpg 将指定一个较小版本的封面。封面应为 JPEG 文件。 好的封面应该遵守以下准则： cover.jpg 的尺寸为 1800x2360 像素，cover_small.jpg 为 200x262 没有边界 清晰可见的书名 任何重要的文字应该在小版本中可见 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "},"Gitbook指导/gitbook语法.html":{"url":"Gitbook指导/gitbook语法.html","title":"GitBook 使用","keywords":"","body":" __Gitbook 语法__ 标题 要创建标题，请在标题之前加 1-6 个 #，使用 # 的多少决定字体的大小 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 锚点 跳转到锚点 跳转到锚点 [跳转到本文标题](#title) //需要给标题添加id， 跳转到简介界面 跳转到简介界面 [跳转到简介界面](README.md) 跳转到百度 跳转到百度 [跳转到百度](http://www.baidu.com \"百度\") // 鼠标移入显现title属性 图片 ![图片](assets/图1.png) /// 不支持大小写修改 /// 支持大小写修改 字体 这是蓝色字体 这是蓝色字体 文字居中 文字居中 引用1 引用2 引用3 > 引用1 >> 引用2 >>> 引用3 序号 科目 成绩 1 语文 123 2 数学 134 3 英语 145 Copyright 苏沫离 all right reserved，powered by Gitbook修订时间： 2019-11-06 10:34:17 "}}