### 操作系统基础篇

![操作系统的演进历史](https://upload-images.jianshu.io/upload_images/7112462-2c9d9b07adb7f441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



多道程序设计：是指计算机内存中同时存放多个程序，并且这些程序互不干扰；
* 早起 _批处理系统_ 一次只能处理一个任务；
* 多道程序设计使得 _批处理系统_ 可以一次处理多个任务；
* 多道程序在计算机的管理程序之下相互穿插运行；
* 因此，对多道程序的管理是操作系统的重要功能；


![操作系统管理](https://upload-images.jianshu.io/upload_images/7112462-7072f83ee2d04a10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1、操作系统概览

##### 1.1、什么是操作系统？为什么使用操作系统？

> 操作系统是管理硬件、提供用户交互的软件系统！

操作系统是管理计算机硬件和软件资源的 _计算机程序_；通过管理配置内存、决定资源供需顺序、控制输入输出设备等方法管理硬件资源！同时，操作系统也提供了让用户和系统交互的操作界面！

操作系统的种类是多种多样的，不局限于计算机；从手机到超级计算机，都有操作系统的存在（`Android`、`iOS`、`Windows`、`Linux`、`MacOS`）！在不同的设备，操作系统可以简单也可以复杂，向用户呈现多种操作手段（手机的触控操作）！

###### 为什么使用操作系统？
* 我们不可能直接的操作计算机硬件（如告诉 CPU 计算 `1 + 1`）
* 设备种类繁多复杂，需要操作系统为用户提供了统一的界面，屏蔽不同设备的差异；
* 操作系统的简易性使得更多的人可以使用计算机；

##### 1.2、操作系统的基本功能

###### 计算机的硬件资源

* 处理器资源（CPU 资源）
* 存储器资源（内存、硬盘）
* IO 设备资源（打印机等）
* 文件资源

######  基本功能一：操作系统统一管理着计算机资源

* 如用户需要操作某个文件，并不是直接操作该文件的地址，而是通过操作系统来访问！
* 如存储器资源，在用户读取数据或者写入数据，并不是直接控制存储器的设备读写，而是通过操作系统去管理和读写的！
* 如处理器资源，也不是直接告诉 CPU 需要计算的内容，而是由操作系统来翻译需要做的任务！


######  基本功能二：用户无需面向硬件接口编程
* 操作系统的 IO 设备管理软件，提供读写接口；
* 文件管理软件，提供操作文件的接口；
* 操作系统实现了对计算机资源的抽象；通过管理软件来实现抽象！管理软件屏蔽了硬件设备，向上向用户提供了逻辑设备，使得每个用户都使用相同的逻辑！

######  基本功能三：操作系统提供了用户和计算机之间的接口
* 图像窗口形式
* 命令形式
* 系统调用形式

![用户层次](https://upload-images.jianshu.io/upload_images/7112462-68f165fdfbe173c0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### 1.3、操作系统的相关概念


![操作系统相关概念](https://upload-images.jianshu.io/upload_images/7112462-f82c91c80952dc08.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 2、进程管理之进程实体


##### 2.1、为什么需要进程

在没有操作系统的年代，计算机只能运行一个程序，计算机资源属于当前运行的程序；有了操作系统之后，引入了多道设计的概念，通过合理的隔离资源、运行环境，提升资源利用率！

* 进程是系统进行资源分配和调度的基本单位；
* 进程作为独立运行的载体，保障程序正常执行；（多个进程可能有多个程序使用一个共同的人设备、如存储器、CPU）
* 进程的存在使得操作系统资源的利用率大幅度提升；

##### 2.2、进程的实体：主存中的进程形态

在主存中，进程也是一段连续存储的空间（进程控制块）：

进程控制块元素 | 细节
-|-
标识符 | 唯一标记一个进程，用于区别其它进程（如进程 ID 就是唯一标识符）
状态 | 标记进程的状态，如运行态、阻塞态
程序计数器 | 进程即将被执行的下一条指令的地址
内存指针 | 程序代码、进程数据相关指针；可能有多个内存指针分别指向程序的逻辑代码；
上下文数据 | 进程执行时处理器存储的数据
IO 状态信息 | 被进程 IO 操作所占用的文件列表
记账信息 | 存储进程使用处理器的时间、时钟数总和等；
优先级| 
...|...

进程的实体由四种概念：进程标识符、处理机状态、进程调度信息、进程控制信息 构成；


###### 进程控制块 PCB

* 用于描述和控制进程运行的通用数据结构；
* 用于记录进程当前状态和控制进程运行的全部信息；
* PCB 是进程能够独立运行的基本单位；每个进程都依赖于进程控制块，被操作系统调度；
* PCB 是操作系统进行调度经常会被读取的信息；
* PCB 是常驻内存的，存放在系统专门开辟的 PCB 区域内；

##### 2.3、进程与线程

* 进程 `Process`：是系统进行资源分配和调度的基本单位；
* 线程 `Thread` ：是操作系统进行运行调度的最小单位；
* 一个进程可以有多个线程；
* 操作系统对进程的调度，实质上是对进程里面线程的调度；
* 线程包含在进程之中，是进程中实际运行工作的单位；
* 一个进程可以并发多个线程，每个线程执行不同的任务；
* 进程中的线程共享进程资源；


对比 | 进程 | 线程 
-|-|-
资源 | 资源分配的基本单位 | 不拥有资源
调度 | 独立调度的基本单位 | 独立调度的最小单位
系统开销 | 进程系统开销大（管理线程、分配资源） | 线程系统开销小
通信 | 进程 IPC | 读写同一进程数据通信


#### 3、进程管理之五状态模型

进程在系统中是有多个状态的，主要有 _就绪_ 、 _阻塞_ 、_执行_ 、 _创建_ 、_终止_ 五个状态！

就绪状态：
* 当进程被分配到除 CPU 以外所有必要的资源后处于就绪状态；
* 此时只要再获得 CPU 的使用权，就可以立即执行；
* 其它资源（包括进程控制块，堆空间、栈空间等内存，）都准备好、只差 CPU 资源的状态为就绪状态；
* 在一个系统中多个处于就绪状态的进程通常排成一个队列（__就绪队列__）；

执行状态：
* 进程获得 CPU ，其程序正在执行的状态；
* 在单处理机中，在某个时刻只能有一个进程处于执行状态；


阻塞状态：
* 进程由于某些原因从而放弃 CPU 的状态称为阻塞状态
* 如进程需要获取某个设备，而对应的设备没有就绪导致进程无法继续执行；
* 如某个进程需要使用打印机，而打印机属于外围的 IO 设备、速度比较慢，进程在请求使用打印机后可能没有立刻得到反馈，这时候进程无法进行下一步工作，由于打印机的未就绪而处于阻塞状态；
* 阻塞队列：在操作系统中可能有一个或者多个阻塞进程；

创建状态：分配 PCB -> 插入就绪队列
* 创建进程时拥有 PCB ，但其它资源尚未就绪的状态称为创建状态；
* 操作系统提供了 `fork()` 函数接口供程序员手动创建进程；

终止状态；系统清理 -> 归还 PCB
* 进程结束由系统清理或者归还 PCB 的状态称为终止状态；


![进程五状态](https://upload-images.jianshu.io/upload_images/7112462-ded2983ed281321f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



* 就绪 -> 执行状态：当就绪状态的进程发生 进程调度 时，就可以变为执行状态；
* 执行 -> 就绪状态：当执行状态的进程 CPU 资源（时间片）用完时，又会切换为 就绪状态，插入到就绪队列中去；时间片资源指分配给某个进程执行的 CPU 时间段；
* 执行 -> 阻塞状态：进程发生 IO 请求时，可能变为阻塞状态；
* 阻塞 -> 就绪状态： 当 IO 完成时，进程由阻塞状态切换为就绪；


#### 4、进程管理之进程同步

##### 4.1、为什么需要进程间同步？

###### `question 1`：生产者-消费者问题

有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费；生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有 n 个可缓冲区的缓冲池；生产者进程需要将所生产的产品放到一个缓冲区中，消费者进程可以从缓冲区取走产品消费。

![生产者-消费者模型](https://upload-images.jianshu.io/upload_images/7112462-5ec178376903b8bb.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


在现实的宏观生活中，上述的生产者-消费者模型没有任何问题，但是针对计算机的微观世界而言，是有一些问题的！

* 单从生产者程序或者消费者程序去看是没有任何问题的；
* 但如果两者并发执行时，可能出错！

![生产者与消费者的数据竞态](https://upload-images.jianshu.io/upload_images/7112462-9fe73238bdb5eebe.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


###### `question 2`：哲学家进餐问题

有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌子，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子，只有两支筷子都被拿到的时候才能进餐，进餐完毕后放下筷子左右思考！


![哲学家进餐问题](https://upload-images.jianshu.io/upload_images/7112462-3ccac054481ce414.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


上述两个模型的根源问题是彼此之间没有互相通信，如果生产者通知消费者我已经完成了一件生产、或者哲学家向旁边的哲学家说我要进餐了你们别拿我的筷子！因此需要进程间的同步！

进程间的同步可以对竞争资源在多进程间进行使用次序的协调；使得并发执行的多个进程之间可以有效使用资源和相互合作！

##### 4.2、进程同步的原则

__临界资源__ ：指一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其它进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源！

为了对临界资源更好的约束，提出了四条原则
* 空闲让进：如果临界资源没有被占用、操作系统应该允许某个进程使用该临界资源；
* 忙则等待：如果已经有进程占用临界资源，此时应该防止别的进程使用该资源；使请求进程等待该临界资源的释放；
* 有限等待：在忙则等待的基础上，如果临界资源被占用，需要保证在有限等待时间内别的等待进程能够使用到资源，以避免外部等待进程僵死；
* 让权等待：当外部进程等待时，等待进程需要让出 CPU（进程从执行状态转为阻塞状态），保证 CPU 可以高效利用；


进程间同步的方法有：消息队列、共享存储、信号量。

##### 4.3、线程同步

进程中的线程共享进程资源，当进程中的多线程并发的访问进程的资源时，可能发生数据竞态的问题；所以进程内多线程也需要同步！

线程同步的方法有：
* 互斥量：
* 读写锁：应对多读少写、少读多写的情况使用；
* 自旋锁：
* 条件变量：


#### 5、Linux 的进程管理

##### 5.1、Linux 进程的相关概念

###### 进程的类型

* 前台进程：具有终端、可以和用户交互的进程；
* 后台进程：基本上不和用户交互，优先级比前台进程低；
* 守护进程：一种特殊的后台进程；很多守护进程在系统启动引导的时候启动，一直运行直到系统关闭；如进程名字以 `d` 结尾的一般都是守护进程：`crond` 、`httpd` 、`sshd` 、`mysqld` ！

###### 进程的标记

* 进程 ID ：进程的唯一标记，每个进程拥有不同的 ID；是一个非负整数，最大值由操作系统限定；
* ID 为 0 的进程为 idle 进程，是系统创建的第一个进程；
* ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化； init 进程 是所有用户进程的祖先进程；


```
/// 进程 ID 相关的关系：父子关系
进程A调用 fork() 函数创建进程B；
进程B调用 fork() 函数创建进程C；
进程A是进程B的父进程，进程B是进程A的子进程；

/// 进程的父子关系可以通过 pstree 命令来查看
MacBook-Pro:~ $ pstree
-+= 00001 root /sbin/launchd
 |--= 00064 root /usr/sbin/syslogd
 |--= 00065 root /usr/libexec/UserEventAgent (System)
 |-+= 00073 root /usr/sbin/systemstats --daemon
 |-+= 00075 root /usr/libexec/configd
 |--= 00077 root endpointsecurityd
 |--= 00081 root /usr/libexec/remoted
 |--= 00083 root /usr/libexec/logd
 |--= 00097 root /usr/libexec/kernelmanagerd
 |--= 00098 root /usr/libexec/diskarbitrationd
 |--= 00101 root /usr/libexec/coreduetd
```


进程的状态标记 | 状态说明
-|-
`R` | `TASK_RUNNING` 进程处于运行状态
`S` | `TASK_INTERUPTIBLE` 进程处于睡眠状态
`D` | `TASK_UNINTERUPTIBLE` 进程处于 IO 等待的睡眠状态
`T` | `TASK_STOPPED` 进程处于暂停状态
`Z` | `TASK_DEAD / EXIT_ZOMBIE` 进程处于退出状态，或僵尸进程


##### 5.2、操作 Linux 进程的相关命令

* `ps` 命令：查看当前进程的相关信息；配合 `aux` 参数或 `ef` 参数和 `grep` 命令检索特定进程； 　 　
* `top` 命令：查看一些使用内存等
* `kill` 命令：发送特定信号给进程，`kill -l` 可以查看操作系统支持的信号；只有 `kill 9 -0000` 可以无条件终止进程，其它信号进程有权忽略；


```
MacBook-Pro:~ $ ps
  PID TTY           TIME CMD
21187 ttys001    0:00.01 -bash
```


#### 6、作业管理之进程调度

##### 6.1、进程调度概述

进程调度指计算机通过决策决定哪个就绪进程可以获得 CPU 使用权！
* 保存旧进程的运行信息，请出旧进程（收拾包袱）
* 选择新进程，准备运行环境并分配 CPU （新进驻）

![进程五状态](https://upload-images.jianshu.io/upload_images/7112462-ded2983ed281321f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


* 就绪队列的排队机制：为了提高进程的效率，事先将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程；
* 选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将 CPU 资源分配给它； 
* 新老进程的上下文切换机制：如果需要把新的进程调度到 CPU 中，需要将旧的 CPU 中的进程备份出来，将新的进程切换到 CPU 中去；保存当前进程的上下文信息，装入被委派执行进程的运行上下文；


![新老进程的上下文切换](https://upload-images.jianshu.io/upload_images/7112462-6431001acd124f48.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如果程序调度时，老进程还没有执行完会怎样呢？进程调度分为非抢占式调度、抢占式调度！

* 非抢占式调度：处理器一旦分配给某个进程，就让该进程一直使用下去；调度器不以任何原因抢占正在被使用的处理器；直到进程完成工作或因为 IO 阻塞才会让出处理器；
* 抢占式调度：允许调度程序以一定的策略暂停当前运行的进程；保存好旧进程的上下文信息，分配处理器给新进程；

对比 | 抢占式调度 | 非抢占式调度
-|-|-
系统开销 | 频繁切换、开销大 | 切换次数少、开销小
公平性 | 相对公平 | 不公平
应用 | 通用系统 | 专用系统

##### 6.2、进程调度算法

* 先来先服务算法：在就绪队列，按先来先服务原则，优先取出先进入队列的就绪进程；
* 短进程优先调度算法：调度程序优先选择就绪队列中估计运行时间最短的进程；不利于长作业进程的执行；
* 高优先权优先调度算法：进程附带优先权，调度程序优先选择权重高的进程；使得紧迫的任务可以优先处理；（前台进程高于后台进程，是因为前台进程与用户交互，需要保证用户的体验，不卡顿！）
* 时间片轮转调度算法：按照先来先服务的原则排列就绪进程；每次从队列头部取出待执行进程，分配一个时间片，时间片用完后不管进程是否执行完、都会将进程重新插入队列尾部，然后取出第二个队列；是相对公平的调度算法，但不保证及时响应用户；




#### 7、作业管理之死锁



死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象；若无外力作用，它们都将无法推进下去。此时称操作系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程！

##### 7.1、死锁的产生原因

死锁的产生是由于竞争资源、进程调度顺序不当导致的！

竞争资源：
* 共享资源数量不满足各个进程需求；
* 各个进程之间发生资源竞争导致死锁；
* 自身占用资源不释放，而一直在等待请求的资源被释放；

![进程调度顺序不当导致死锁](https://upload-images.jianshu.io/upload_images/7112462-71fcf4ae58a667a2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

假设进程 1 申请传真机为步骤 A、进程 2 申请打印机为步骤 B、进程 2 申请传真机为步骤 C、进程 1 申请打印机为步骤 D！
按照 `A -> B -> C -> D` 的顺序调度，就会引起进程死锁；如果将进程调度顺序改为 `A -> D -> B -> C` 就不存在死锁的情况！

##### 7.2、死锁产生的四个必要条件

死锁的产生，必然同时满足以下四个条件，仅满足其中的某几个是不会产生死锁的！

* 互斥条件：进程对资源的使用具有 _排它性_ ；某个资源仅能由一个进程使用，其它进程需要使用只能等待；
* 请求保持条件：进程至少保持一个资源，又提出了新的资源请求；但新资源被占用，导致请求被堵塞；同时被阻塞的进程又不释放自己保持的资源；
* 不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺；获得的资源只能由进程自身释放；
* 环路等待条件：发生死锁时，必然存在进程-资源环形链；


##### 7.3、预防死锁的方法

破坏死锁产生的四个必要条件中的某一个或者某几个，就能有效预防死锁的产生！
* 摒弃 _请求保持条件_ ：系统规定进程在运行之前，一次性申请所有需要的资源；在进程运行中，不会再去申请资源；
* 破坏 _不可剥夺条件_ ：当一个进程请求新的资源得不到满足时，必须释放其自身占有的资源；进程运行时占有的资源可以被释放，意味着可以被剥夺；
* 破坏 _环路等待条件_ ： 可用资源线性排序，申请必须按照需要递增申请；线性申请不再形成环路，从而摒弃了环路等待条件；

##### 7.4、银行家算法

银行家算法是一个可操作的著名的避免死锁的算法、以银行借贷系统分配策略为基础的算法！

银行家算法的策略基础：
* 假设客户申请的贷款是有限的，每次申请需声明最大资金量；
* 银行家在能够满足贷款时，都应该给用户贷款；
* 客户在使用完贷款后，能过及时归还贷款；


![银行家算法](https://upload-images.jianshu.io/upload_images/7112462-0edd4c6570fc9488.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如上图所示，有初始状态的 _所需资源表_、_已分配资源表_；所需资源表减去已分配资源表得到的 _还需分配资源表_；还有 _可分配资源表_ ！
* 所需资源表：`P1` 需要 `0` 个 `A` 资源、 `6` 个 `B` 资源、 `5` 个 `C` 资源、 `6` 个 `D` 资源；
* 已分配资源表：`P1` 已经拥有 `0` 个 `A` 资源、 `0` 个 `B` 资源、 `1` 个 `C` 资源、 `4` 个 `D` 资源；
* 还需分配资源表：`P1` 还需要 `0` 个 `A` 资源、 `6` 个 `B` 资源、 `4` 个 `C` 资源、 `2` 个 `D` 资源；
* 经过与  _可分配资源表_  对比后，发现不能满足 `P1` 、`P3` 、`P4` 的需求，仅仅能满足 `P2` 的需求；
* 因此先满足 `P2` ，执行完 `P2` 后   `P2` 归还资源；
* 此时  _可分配资源表_  又可以分配资源给  `P1` 、`P3` 、`P4`  ！


#### 8、存储管理之内存分配与回收

早期的计算机编程并不需要过多的存储管理；随着计算机和程序越来越复杂，存储管理称为一件必要的事情！
* 确保计算机有足够的内存来处理数据；
* 确保程序可以从可用内存中获取一部分内存使用；
* 确保程序可以归还使用后的内存以供其他程序使用！

##### 8.1、内存分配的过程

单一连续分配：
* 最简单的内存分配方式；
* 只能在单用户、单进程的操作系统中使用；
* 将主存分为系统区、用户区；
* 系统区指的是内存给操作系统所使用；
* 用户区指的是所有的用户区内存都给用户区程序所使用；


固定分区分配：
* 支持多道程序的最简单存储分配方式；
* 将内存空间划分为若干个固定大小的区域；
* 每个分区只提供给一个程序使用，互不干扰；

动态分区分配：
* 根据进程实际需要、动态分配内存空间；
* 涉及到相关数据结构（如动态分区空闲表数据结构、动态分区空闲链数据结构等）、分配算法；

假设主存中有若个分区，并且一些分区已经使用、一些分配还没有使用；这时候就需要一个数据结构来存储某个分区是否已使用！

![动态分区空闲表数据结构](https://upload-images.jianshu.io/upload_images/7112462-c14a4030021718fe.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![动态分区空闲链](https://upload-images.jianshu.io/upload_images/7112462-8b55502bf91a6f54.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


动态分区分配算法：

* 首次适应算法（FF 算法）：
* 最佳适应算法（BF 算法）；将空闲区链表按照容量大小进行排序；在每一次需要分配时遍历链表找到最佳合适空闲区；
* 快速使用算法（QF 算法）；要求有多个空闲区链表；每个链表存储一种容量的空闲区；



![首次适应算法](https://upload-images.jianshu.io/upload_images/7112462-fbff272c3da4b17e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![最佳适应算法](https://upload-images.jianshu.io/upload_images/7112462-5062057447201008.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### 8.2、内存回收的过程

![内存回收的过程](https://upload-images.jianshu.io/upload_images/7112462-cbd39198b7b04493.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


内存回收过程分为四种情况：
* 情况1：需要回收的区域和空闲区连接在一起，并且位于空闲区后面；
* 回收1：不需要新建空闲链表节点；只需要把空闲区 1 的容量增大为包括回收区的空闲区即可；
* 情况2：需要回收的区域和空闲区连接在一起，并且位于空闲区前面；
* 回收2：将回收区和空闲区合并为一个新的节点，然后使用回收区的地址作为新的节点地址；
* 情况3：需要回收的区域和空闲区连接在一起，并且位于空闲区中间；
* 回收3：将空闲区1、回收区、空闲区2 合并为一个新的节点，然后使用空闲区1的地址作为新的节点地址；
* 情况4： 需要回收的区域和空闲区没有连接在一起，单一的回收区；
* 回收4：为回收区创建新的节点，然后将新的节点插入到相应的空闲区链表中即可；



#### 9、存储管理之段页式存储管理

操作系统是如何管理进程的内存空间呢？

##### 9.1、页式存储管理

前文提到的 _字与字块_ 是相对于物理设备的定义，而此处的 __页面__ 则是相对于逻辑空间的定义！

* 将进程逻辑空间 _等分_ 为若干个大小的页面；
* 相应的把物理内存空间分成与页面大小一样的物理块；
* 以页面为单位把进程空间装进物理内存中分散的物理块；
* 页面大小应该适中，过大难以分配，过小则内存碎片过多；
* 页面大小通常是 `512B ～ 8 K` ；

![页式存储管理](https://upload-images.jianshu.io/upload_images/7112462-c6824551c561405f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


通过页式存储管理，可以把进程的逻辑空间的每个页面放到内存的物理块中去！但是又如何知道进程的某个页面具体被分配到哪一个字块中去呢？这时候就需要了解 __页表__ 的概念！

![页表](https://upload-images.jianshu.io/upload_images/7112462-12c8cee6410b0286.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


__页表__ ：
* 页表是一个记录进程逻辑空间与物理空间的映射表；
* 在页式存储管理中，_地址_ 分为 _页号_ 与 _页内偏移_；


在现代计算机系统中，可以支持非常大的逻辑地址空间（`2^32 ~ 2^64`）；这样就会导致页表就变得非常大，要占用非常大的内存空间。如具有 32 位逻辑地址空间的分页系统，规定页面大小为 `4 KB` ，则在每个进程页表中的页表项可达  `1 M (2^20)` 个，如果每个页表项占用   `1 Byte`，则每个进程仅仅页表就要占用  `1 MB` 的内存空间！

```
32 位系统进程的寻址空间位 2^32 = 4 G
4 G / 4KB = 2^20
```

使用多级页表可以解决页表占用高的问题！

![二级页表](https://upload-images.jianshu.io/upload_images/7112462-e45b897932d4bed2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


* 首先，多级页表有一个根页表；
* 根页表的每个字块都指向内存的一片地址空间，这歌地址空间存储一个二级页表；
* 假设每个二级页表有 1024 项，每一项指向的字块才是进程实际使用的内存；
* 一个根页表可以指向二级页表，这样子大大的减少的进程的页表所占用的内存空间；
* 在运行时，只需要把根页表加载到内存中即可；如果调用某个字块，发现二级页表不在内存空间；此时只需要把二级页表加载到内存中，做到按需加载，节省内存空间；


页式存储管理仍然有一个问题：假如有一段连续的逻辑分布在多个页面中，将大大降低执行效率！此时提出了段式存储管理！ 

##### 9.2、段式存储管理

* 将进程逻辑空间 _非等分地_ 划分为若干段；
* 段的长度由进程的连续逻辑长度决定；
* 如进程的逻辑有 主函数 `MAIN` 、字程序段  `X`、字函数 `Y` 等，此时按照每个函数的逻辑长度分配逻辑空间；
* 段表：段式存储管理也需要一个表来保存逻辑空间到物理空间的映射关系；

![段表](https://upload-images.jianshu.io/upload_images/7112462-4235bf754faaebc8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


不管是段式存储管理、或者页式存储管理，都离散地管理了进程的逻辑空间；不同之处在于：
*  页是物理单位（从物理的角度划分），段是逻辑单位（从进程的逻辑划分）；
* 分页是为了合理的利用空间；分段是为了满足用户需求；
* 页大小由硬件固定；段长可动态变化；
* 页表信息是一维的，段表信息是二维的；段表中每一段的长度不同，因此需要把段的基址和长度都记录起来，所以段表信息是二维的！


##### 9.3、段页式存储管理

分页可以有效提高内存利用率（虽然存在页内碎片），而分段可以更好的满足用户需求（因为逻辑是用户写的）；将两者结合，形成了段页式存储管理！

* 先将逻辑空间按段式管理分成若干段；
* 再把段内空间按页式管理分成若干页；
* 页地址分为页号和页内偏移；
* 段地址分为段号和段内偏移；
* 段页地址：段号、段内页号、页内地址

段号 | 段内页号 | 页内地址
-|-|-
指定进程逻辑空间的具体哪一段 | 段里面具体的某一页 | 某一页的具体哪个字



![段页式存储管理](https://upload-images.jianshu.io/upload_images/7112462-d25fbb719b20598b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
