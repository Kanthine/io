# 依赖倒置原则

依赖倒置原则 `Dependency Inversion Principle` 简写为 DIP，遵循三层含义：
* 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
* 抽象不行该依赖其细节；
* 细节应该依赖其抽象；

什么是高层模块、低层模块？每一个逻辑的实现都是由其原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块！

什么是抽象、细节？抽象指的是接口或者抽象类，不能直接被实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类就是细节类！


依赖倒置原则的具体表现为：
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系通过接口或者抽象产生；
* 接口或者抽象类不依赖于实现类；
* 实现类依赖接口或者抽象类；

# 1、反面案例

> 依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性！

## 1.1、系统的稳定性

如下述代码所示，有一个司机类、一个宝马车类：
* 宝马车有一个启动方法；
* 司机有一个开动宝马车的方法；

```
class DIP_B_BMW: NSObject {
    func run() {
        print("开动宝马汽车")
    }
}

class DIP_B_Driver: NSObject {
    func drive(car: DIP_B_BMW) {
        car.run()
    }
}

{
    /// 此时，司机可以正常开动宝马车
    let drive = DIP_B_Driver()
    drive.drive(car: DIP_B_BMW())
}
```

我们常说 “为难时刻见真情”，在编程中 __变更才显真功夫__！业务需求变更永无止境，技术前进就永无止境，在发生变更时才发觉我们的设计或程序是否是低耦合！

如果现在要求司机开奥迪车，又该怎么实现呢？司机没有开动奥迪车的方法！一个司机竟然只能开一种车型，这简直是对现实世界规则的践踏。在上述代码中，司机与宝马车是一种高耦合的关系，其结果就是系统的可维护性大大降低、可读性降低，两个相似的类需要阅读两个文件，试问你愿意嘛？

什么是稳定性？健壮的才是稳定的，这里只是增加了一个车型，就需要修改司机类，这是不正常的，是易变的！被依赖者的变更需要让依赖者承担修改成本，这样的依赖关系谁肯承担？

一个稳定性较高的程序设计，在周围环境频繁变化的时候，依然可以做到 _我自岿然不动_ ！

## 1.2、什么是并行开发的风险？

并行开发最大的风险就是风险扩散，本来只是一段程序的错误或者异常，逐步波及到一个功能、一个模块，甚至最后坏了整个项目。

在一个大型开发团队中，各人负责不同的功能模块，甲负责汽车类的建造、乙负责司机类的建造。在甲没有完工的情况下，乙是不能编译代码的，因为缺少汽车类编译器根本不通过！在这种不使用依赖倒置原则的设计中，所有的开发工作都是单线程的，甲做完、乙再做...， 在现代的大型项目中完全不能胜任！

# 2、引入依赖倒置原则

首先设计接口类，规定一些基本功能

```
/// 汽车接口
protocol DIP_Car {
    /// 负责跑
    func run()
}

/// 司机接口
protocol DIP_Driver {
    /// 通过遵循接口 DIP_Car ，实现了抽象之间的依赖
    func drive(car: DIP_Car)
}
```

接口仅仅是一个抽象化的概念，是对一类事物的最抽象描述，具体的实现由相应的细节类完成：

```
class DIP_Driver_C1: DIP_Driver {
    /// 司机的主要职责就是驾驶汽车
    func drive(car: DIP_Car) {
        car.run()
    }
}

class DIP_BMW: DIP_Car {
    func run() {
        print("宝马车在奔跑")
    }
}

class DIP_SGMW: DIP_Car {
    func run() {
        print("五菱神车在超车")
    }
}
```

最后在业务场景中，贯彻“抽象不应该依赖其细节”；

```
func DIP_Scene_Test() {
    let drive = DIP_Driver_C1()
    
    /// 将变更的风险降到最低： 同一个司机，可以无缝切换不同的车型
    drive.drive(car: DIP_BMW())
    drive.drive(car: DIP_SGMW())
}
```

两个类之间有依赖关系，只要制定出两者之间的接口，就可以独立开发了；而且项目之间的单元测试也可以独立的运行！而 __测试驱动开发__ `Test-Driven Development` 就是依赖倒置原则的最高应用！

在一个大的开发团队中，在甲没有完工的情况下，乙完全可以通过接口 Mock 一个抽象类，测试司机类的功能！从这一点看，两个相互依赖的对象可以分别进行开发，孤立的进行单元测试，进而保证并行开发的效率和质量！TDD 的精髓正在于此。

# 3、依赖的几种写法

依赖是可以传递的，A 对象依赖 B，B 对象依赖 C， C对象依赖 D ... 依赖无止境！只要做到 __抽象依赖__，即使是多层的依赖传递，也无所谓畏惧！

对象依赖的传递有三种方式：
* 构造函数注入
* setter 依赖注入
* 接口注入

## 3.1、构造函数传递依赖对象

```
protocol DIP_Car {
    func run()
}

protocol DIP_Driver {
    func drive()
}

/// 通过构造函数将依赖注入
class DIP_Driver_C1: DIP_Driver {
    var car: DIP_Car
    init(car: DIP_Car) {
        self.car = car
    }
    
    func drive() {
        car.run()
    }
}
```

## 3.2、Setter 方法传递依赖对象


```
protocol DIP_Car {
    func run()
}

protocol DIP_Driver {
    void setCar(car: DIP_Car)
    func drive()
}

class DIP_Driver_C1: DIP_Driver {
    var car: DIP_Car
    
    void setCar(car: DIP_Car) {
        self.car = car
    }

    func drive() {
        car.run()
    }
}
```

## 3.3、接口声明依赖注入

```
protocol DIP_Car {
    func run()
}

protocol DIP_Driver {
    /// 接口声明依赖注入
    func drive(car: DIP_Car)
}
```

# 4、总结

依赖倒置原则的本质就是通过抽象使各个类或者模块实现彼此独立，不互相影响，实现模块间的耦合！在项目中使用依赖倒置原则需遵循以下几个规则：

* 每个类尽量有接口或者抽象类，或者接口与抽象类都具备；
 这是基本要求，接口或者抽象类都是属于抽象类的，有了抽象才可能依赖倒置；
* 变量的声明类型尽量是接口或者抽象类
* 任何类都不应该从具体类派生；
* 尽量不要覆写基类的方法；
 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的基础是抽象，覆写了抽象方法，会对依赖的稳定性产生一定的影响；
* 结合里氏替换原则使用；


