# 里氏替换原则

## 1、引言

在面向对象的语言中，继承是必不可少的，它具有如下优点：
* 代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；
* 提高代码重用性
* 子类可以形似父类，但又异于父类；
* 提高代码的可扩展性；实现父类的方法就可以为所欲为了；
* 提高产品或项目的开放性；

万事万物有优点，自然也有其缺点：
* 继承具有侵入性；只要继承，就必须拥有父类的所有属性和方法；
* 降低代码的灵活性；子类必须拥有父类的属性和方法，让子类的自由世界多了些约束；
* 增强了耦合性；当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的情况下，这种修改很容易带来糟糕的结果 -- 大量的代码需要重构！

## 2、里氏替换原则

如何让继承的优势发挥到最大，同时又减少它的弊端呢？解决方法是引入 __里氏替换原则__(`Liskov Substritution Principle`，简称 LSP)
* 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常；
* 使用者可能感知不到使用的是父类还是子类；
* 但是反过来就不行了，有子类出现的地方，父类未必能适应；

里氏替换原则为良好的继承定义了一个规范：
* 子类必须完全实现父类的方法；
* 子类可以拥有自己的个性；
* 覆盖或者实现父类的方法时，输入参数可以被放大；
* 覆盖或者实现父类的方法时，输出结果可以被缩小；

### 2.1、子类必须完全实现父类的方法

我们在做系统设计时，经常会定义一个接口或者抽象类，然后编码实现，调用类则直接传入接口或者抽象类！

使用一个射击游戏来举例说明里氏替换原则的实现：


* 枪：负责射出子弹；如何射击在其具体的子类中定义，如手枪单发射程比较近，步枪威力大，射程远，机枪用于扫射；

```
/// 枪支抽象类，仅仅定义了射击行为；没有做任何实事
class LSP_AbstractGun: NSObject {
    func shoot() {
        
    }
}

class LSP_Handgun: LSP_AbstractGun {
    override func shoot() {
        print("手枪射击")
    }
}

class LSP_Rifle: LSP_AbstractGun {
    override func shoot() {
        print("步枪射击")
    }
}

class LSP_MachineGun: LSP_AbstractGun {
    override func shoot() {
        print("机枪射击")
    }
}
```

* 士兵 `Solider` ：被授予一支枪，拿着枪杀敌；具体使用什么枪，只有调用的时候才知道

```
/// 士兵类
class LSP_Solider: NSObject {
    var gun : LSP_AbstractGun?
    
    /// 1、授枪
    func giveGun(gun: LSP_AbstractGun) {
        self.gun = gun
    }
    
    /// 2、杀敌
    func killEnemy() {
        guard let gun = self.gun else {
            print("士兵没有获取枪支")
            return
        }
        print("士兵杀敌")
        gun.shoot()
    }
}
```

* 场景：士兵使用什么枪，在使用场景中临时决定

```
{
    let guns: [LSP_AbstractGun] = [ /// 枪械库
        LSP_Handgun(),
        LSP_Rifle(),
        LSP_Rifle_AK(),
        LSP_Rifle_AUG(),
        LSP_MachineGun(),
    ]
    
    for gun:LSP_AbstractGun in guns {
        
        /// 士兵 tom 可能感知不到使用的是哪个型号的枪（子类）被传入
        let tom : LSP_Solider = LSP_Solider.init(name: "Tom")
        tom.giveGun(gun: gun)
        tom.killEnemy()
    }
    
    let john: LSP_Solider_Sniper = LSP_Solider_Sniper.init(name: "John")
    john.giveGun(gun: LSP_Rifle_AUG())
    john.killEnemy()
}
/** 日志打印: 
士兵开始杀敌
手枪射击

士兵开始杀敌
步枪射击

士兵开始杀敌
AK47步枪射击

士兵开始杀敌
AUG步枪射击

士兵开始杀敌
机枪射击
*/
```

__注意__：在类中调用其它类时，务必使用父类或接口；如果不能使用父类或接口，则说明类的设计违背了 LSP 原则！

试想一下：如果有一把玩具枪，该如何定义呢？
* 可以继承 `AbstractGun` ，使玩具枪作为一个子类存在
* 但玩具枪不能射击；

```
class LSP_Toygun: LSP_AbstractGun {
    func shoot() {
        print("玩具枪、不杀敌")
    }
}
```

如果在战场上将这样一把枪传到了士兵手中，士兵无法射出子弹，该有多大的愤怒？在这种情况下，业务调用类已经出现了问题，正常的业务逻辑已经不能运行，那该怎么办呢？
* 可以在士兵  `Solider`  中在授枪时增加判断，如果是玩具枪，则拒绝接受；
 这个方案可以解燃眉之急，但试想一下，如果后期枪支的型号增加到成千上万，难道我们要去判断几万种枪能否杀敌？那还不被业务方给骂死？
* 将玩具枪 `Toygun` 脱离出 `AbstractGun`  的继承、建立一个独立的父类；
    * 但玩具枪和枪，都具有相似的外形、射击时都会发出枪声；这些相同的代码如何处理？
    * 可以与  `AbstractGun` 建立关联委托关系，将外观、声音等相似特征交给  `AbstractGun`  处理
    * 然后两个基类下的子类自由延展、互不影响；

> 如果子类不能完整的实现父类的方法、或者父类的某些方法在子类中已经发生畸变，则建议断开继承关系；采用依赖、聚集、组合等关系替代！


### 2.2、子类可以拥有自己的个性

子类可以拥有自己的行为和外观，也就是属性和方法。
* 里氏替换原则可以正着用，但不能反过来用；
* 父类出现的地方，子类可以胜任；子类出现的地方，父类却不一定能胜任；

例如：狙击枪继承了步枪，但它也有自己的特征

```
class LSP_Rifle_AUG: LSP_Rifle {
    func zoomout() {
        print("通过望远镜观察敌人")
    }
    override func shoot() {
        print("AUG步枪射击")
    }
}
```

有狙击手、就有狙击手！

```
class LSP_Solider_Sniper: LSP_Solider {
    override func killEnemy() {
        guard let gun = self.gun else {
            print("士兵没有获取枪支")
            return
        }
        if gun.isKind(of: LSP_Rifle_AUG.self) {
            let gun : LSP_Rifle_AUG = gun as! LSP_Rifle_AUG
            print("狙击手杀敌")
            gun.zoomout()
            gun.shoot()
        } else {
            print("狙击手没有使用狙击枪杀敌")
            gun.shoot()
        }

    }
}
```

此时，系统直接调用子类  `Sniper` ：
* 因为狙击手是依赖于狙击枪的，换了枪的型号会严重影响狙击手的杀敌效率；所以直接将指定型号的狙击枪传了进来！
* 如果传入枪的父类（其它型号），则抛出异常；
* 从里氏替换原则来看，__子类出现的地方，父类未必可以出现__；


### 2.3、 覆盖或者实现父类的方法时，输入参数可以被放大

> 子类方法中的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松！

方法中的输入参数称之为前置条件：根据 _契约优先_ 的原则，先定义 API 接口，然后再各自实现！

里氏替换原则也要求制定一个契约（父类或者接口），这种设计也叫做 __契约设计__：
* 契约制定了，也就同时制定了前置条件和后置条件；
* 前置条件就是你要让我执行，就必要满足我的条件；
* 后置条件就是我执行完毕需要反馈，标准是什么

```
@implementation Rifle

- (NSArray *)getAllKeys:(NSDictionary *)dictionary {
    return dictionary.allKeys;
}

@end

@implementation Rifle_AUG

- (NSArray *)getAllKeys:(NSMutableDictionary *)dictionary {
    return dictionary.allKeys;
}

@end
```

在上面例子中，子类 `Rifle_AUG` 和父类  `Rifle` 调用相同名称的方法，但传入的参数又不相同（重载）！

```
{
    NSDictionary *dict = @{@"key":@"value"};
    Rifle *gun = [[Rifle alloc] init];
    [gun getAllKeys:dict];
}
```

根据里氏替换原则，父类出现的地方，子类就可以出现

```
{
    NSDictionary *dict = @{@"key":@"value"};
    Rifle_AUG *gun = [[Rifle_AUG alloc] init];
    [gun getAllKeys:dict];
}
```

子类 `Rifle_AUG` 和父类  `Rifle` 的运行结果一样！
* 父类传入了 `NSDictionary` ,子类传入了 `NSMutableDictionary` ;
* __子类传入的参数的作用范围相对于父类的参数扩大了，子类替代父类，则子类的独有特性不被表现出来__；
* 这是正确的，如果想要子类的特性表现出来，就必须覆写父类方法；
* 如果父类的输入参数作用范围大于子类，那么父类存在的地方，子类未必可以存在；这会引起意料之外的逻辑混乱！

### 2.4、 覆盖或者实现父类的方法时，输出结果可以被缩小

里氏替换原则要求：子类的返回值作用范围必须小于或者等于父类的返回值作用范围！

```
@implementation Rifle

- (NSMutableDictionary *)getGunInfo {
    return _dictionary;
}

@end

@implementation Rifle_AUG

- (NSDictionary *)getGunInfo {
    return _dictionary;
}

@end
```


```
{
    Rifle *gun = [[Rifle alloc] init];
    [gun getGunInfo];

    /// 根据里氏替换原则，父类出现的地方，子类就可以出现
    Rifle_AUG *gun = [[Rifle_AUG alloc] init];
    [gun getGunInfo];
}
```

## 3、总结

采用里氏替换原则的目的，就是增强程序的健壮性，版本升级时，可以保持非常好的兼容性。即使增加子类，原有的子类可以正常运行。

在实际项目中，每个子类对应不同的业务，使用父类作为参数，传递不同的子类完成不同的业务逻辑！

采用里氏替换原则，尽量避免子类的个性，一旦子类出现了个性，子类与父类的关系就很难调和：
* 把父类当子类使用，子类的个性被抹杀，委屈了子类；
* 把子类作为一个独立的业务使用，则会让代码的耦合关系变得扑朔迷离，缺乏类替换的标准！
