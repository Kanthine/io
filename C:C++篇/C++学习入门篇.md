# C++ 学习入门篇

C++ 是 C 的超集，在 C 语言的基础上发展而来，因此 C 语言更加高效！

C++ 是一门面向对象的编程语言！

# 1、基础篇

## 1.1、基本数据类型

C  基本数据类型：

*基本类型 ：整型、浮点型、字符型 ；
*构造类型 ：数组、结构、枚举、联合；
*指针类型 ；
*空类型 ；

C++ 具有 C  语言的所有基本数据类型，并且多了一个布尔类型：`bool`:`true`、`false`;

## 1.2、新的初始化方法

C 语言提供的初始化方法 ：

```
/// 复制初始化
int a = 10;
```

C++ 语言提供的初始化方法 ：

```
/// 复制初始化
int a = 10;

/// 直接初始化 
int a(10);
```

## 1.3、随用随定义

C 语言所有变量定义都必须位于函数体最前面 ：

```
{
    int a = 10;
    int b = 20;

    a = a + 3;
    b = b + a;
}
```

C++ 中所有变量随用随定义 ：

```
{
    int a = 10;
    a = a + 3;

    int b = 20;
    b = b + a;
}
```

## 1.4、输入输出流

C 语言的 I/O 方式 :
* 输入过程 : `输入设备 -> 输入流 -> scanf -> 变量`； 
* 输出过程 : `变量 -> printf -> 输出流 -> 输出设备` ；

C++ 语言的 I/O 方式 ： 
* 输入过程 : `输入设备 -> 输入流 -> cin -> 变量` ；
* 输出过程 : `变量 -> cout -> 输出流 -> 输出设备` ;

```
/// 输出语法：
cout << x << endl;
cout << "x + y = " << x + y << endl;
int a = 256;
cout << oct << a << endl; ///  八进制 oct
cout << dec << a << endl; ///  十进制 dec
cout << hex << a << endl; /// 十六进制 hex

/// 输入语法:
cin >> x; 
cin >> x >> y; 
```

与 C 语言相比，C++ 的`cin`与`cout`的便利：
*不用关注占位符；
*不用关注数据类型；
*不容易出现问题；

## 1.5、命名空间`namespace`

命名空间`namespace`是 C++ 新引入的一个机制，主要是为了解决多个模块间命名冲突的问题，就像现实生活中两个人重名一个道理。

```
/// 使用命名空间 std
using namespace std;
```

C++ 需要用不同的名字区分不同的命名空间！通过不同的命名空间，可以区分具有相同名字的变量，可以区分具有相同名字的函数！

```
/// 定义命名空间
namespace YLProject {
    int chapter;
    void test();
}

namespace WLProject {
    int chapter;
    void test();
}

void demoTest(void) {
    YLProject::chapter = 10;
    WLProject::chapter = 20;

    YLProject::test();
    WLProject::test();
}
```

# 2、特性篇

## 2.1、指针 VS 引用

> 引用即 变量的别名！

引用不能单独存在，必须有对应的变量名！

__针对别名的操作就是对其本身的操作！__

###### 基本数据类型的引用

```
{
    int a = 10;
    int &b = a;
    b = 3;
}
```

###### 结构体类型的引用

```
{
    Coordinate c1;
    Coordinate &c2 = c1;
    c2.latitude = 9.234;
    c1.longitude = 4.243256;   
}
```

###### 指针类型的引用

指针类型的引用：类型 *&指针别名 = 指针；

```
{
    int m = 90;
    int *p = &m;
    int *&q = p;
    *p = 80;
    *q = 70;
}
```

###### 引用作函数参数

```
/// C 语言交换两个变量的值
void quoteFuncCTest(int *a, int *b) {
    int c = 0;
    c = *a;
    *a = *b;
    *b = c;
}

/// C++ 使用引用交换两个变量的值
void quoteFuncTest(int &a, int &b) {
    int c = a;
    a = b;
    b = c;
}

///测试代码段
{
    int k1(78),k2(87);
    quoteFuncCTest(&k1, &k2);
    quoteFuncTest(k1, k2);
}
```

## 2.2、`#define` VS `const`

与`#define`相比，`const`修饰的变量是由类型的！在编译阶段，编译器可以检查`const`修饰的变量的类型错误，而不会去检查  `#define`  修饰的变量的类型错误！

> 存储类别说明符 `const` 指明被修饰的变量为只读类型，用于防止变量值被篡改！

一般而言，声明的一个变量既具有_读权限_、又具有_写权限_！ 而使用  `const`  修饰的变量，仅仅具有_读权限_！

为数据安全考虑，编译器允许声明一个只读权限的变量指向一个具有读写权限的变量；而不会允许一个具有读写权限的变量指向一个只读权限的变量！

###### `const`与 基本数据类型

```
{
    int a = 3;/// 变量
    const int b = 5;/// 常量
}
```

变量名|存储地址|存储内容

-|-|-
`a`|`&a`|`3`
`b`|`&b`|`5`

###### `const` 与 指针类型

`const`修饰指针要特别注意，共有两种形式：
*一种是用来限定指向空间的值不能修改；
*另一种是限定指针不可更改。

```
{
    int a = 5, b = 10, c = 15;
    const int *p = &a; /// int const *p = &a; 两种写法完全等价，const 修饰的都是 *p，此时不能通过 *p 来赋值
    p = &b; /// 正确，const 修饰的是 *p，
    *p = 1; // ❌ const 修饰的是 *p，因此 *p 不能修改

    int *const k = &b; /// const 修饰 k，此时不能通过 k 来赋值
    k = &c; // ❌ 此时 const 修饰 k
    *k = 100; /// 正确

    /// 不能通过指针 m 来修改值，也不能将指针 m 指向它处！
    int const *const m = &b; ///完全等价于  const int *const m = &b;
}
```

###### `const` 与 函数

`const`修饰函数参数，对参数起限定作用，防止其在函数内部被修改。所限定的函数参数可以是普通变量，也可以是指针变量。

```
int sum(const int a,const int b) {
    return a + b;
}

int max(const int &a,const int &b) {
    if (a > b) return a;
    return b;
}
```

###### `const` 与 引用

```
{
    int a = 5;  const int &y = a;
    a = 10; /// 正确
    y = 20; /// ❌
}
```

###### `const` 小结

```
const int x = 3; x = 5; /// ❌ 
int x = 3; const int y = x; y = 5; /// ❌ 
int x = 3, z = 4; int *const y = &x; y = &z; /// ❌ 
const int x = 3; const int &y = x; y = 5; /// ❌ 

/// 注意：变量 x 具有读写权限，指针 y 只具有读权限，允许使用权限小的变量接收权限大的变量
int x = 3; const int *y = &x; *y = 5; /// ❌

/// 注意：变量 x 具有写权限，指针 y 只具有读写权限，不允许使用权限大的变量接收权限小的变量
const int x = 3; int *y = &x; /// ❌ 
```

## 2.3、函数特性

### 2.3.1、函数参数默认值

函数参数默认值需要记住两条规则：
*_有默认值的参数必须在参数列表的最右端_；
*_无实参则用默认值，否则实参覆盖默认值_；

```
void func(int a, int b = 10, int c = 15);

/// 有默认值的参数必须在参数列表的最右端
void func(int a = 5, int b, int c); /// ❌
void func(int a, int b = 10, int c = 15) {
    /// 无实参则用默认值，否则实参覆盖默认值
    cout << a << b << c << endl;
}

/// 测试代码段
{
    func(10);
    func(10,100);
    func(10,100,1000);
}
```

__注意__：函数默认值建议写在声明处，所有的编译器都可以通过；如果在函数定义处写默认值，部分编译器可能不通过！

### 2.3.2、函数重载

函数重载需要满足下述条件：

*在相同作用域下；

*用同一函数名定义的多个函数；

*参数个数和参数类型不同；

```
int max(int a, int b); /// max_int_int
int max(int a, int b, int c);  /// max_int_int_int
double max(double a, double b); /// max_double_double
double max(double a, double b, double c); /// max_double_double_double
```

__思考__：编译器如何识别重载的函数呢？

答：编译器会将函数编译为_函数名称 + 参数_的样子，来区别重载的函数；调用时，编译器根据入参的类型与个数，调用不同的函数！

### 2.3.3、内联函数

调用普通函数的五大步骤：

*1、调用`func()`；
*2、跳转函数  `func()`的入口；
*3、执行函数  `func()`；
*4、回到主函数的调用处 ；
*5、结束`func()`的调用；

与普通函数相比，在定义上，区别不大！但在调用上，内联函数更加的高效：在编译时将函数体代码和实参代替函数调用语句，少了跳转函数入口、回到主要函数的步骤！

某些时候，执行函数  `func()`的消耗时间并不长，但是执行 ②、④ 两个步骤消耗了比较长的时间！此时使用内敛函数，更加高效！使用关键字`inline`声明一个内联函数！

```
/// 内敛函数仅是一种编译方式
inline int max(int a, int b){
    if (a > b) return a;
    return b;
}
```

_思考_: 为什么不把所有的函数声明为内联函数呢？
*内联函数是建议性的，由编译器决定；
*逻辑简单，调用频繁的函数建议使用内联函数；
*递归函数无法使用内联方式；

## 2.4、内存管理

内存的本质就是一种由操作系统掌管的内存资源；__开发者被允许向系统申请内存资源，同时被要求使用完毕后归还这部分内存资源__！

在 C 语言中使用 `void *malloc(size_t size)` 函数申请内存资源，使用 `void free(void *p)`函数归还内存资源； 

而 C++ 中使用运算符`new`申请内存资源，使用运算符`delete`归还内存资源；

```
{
    /// 内存的申请与释放
    int *p = new int(20);
    if (p != NULL) {
        cout << *p << endl;
        delete p;
        p = NULL;
    }

    /// 如何申请和释放 块内存 呢？
    int *array = new int[1000]; /// 申请一块连续的内存
    if (array == NULL) { ///内存分配失败
        /// 注意： 申请内存一定能申请成功嘛？
        /// 系统可能没有足够的内存资源，导致申请内存失败
    } else {
        delete []array; /// 释放一块内存
        array = NULL;/// 注意：释放之后，将指针指向 NULL
        /// 否则， 指针仍指向该块内存，不小心再次调用时，可能发生无法预知的风险！
    }
}
```

__注意__：申请内存需要判断是否申请成功；释放内存，需要将指针指向`NULL`；
